# Версионирование

Большинство библиотек в `tramvai` репозитории объединены в общее версионирование.

Все актуальные версии библиотек хранятся в релизных тегах, в `package.json` используются версии - заглушки `0.0.0-stub`.

Версионирование `tramvai` библиотек придерживается [semver](https://semver.org/lang/ru/). Для версий, которые начинаются с нуля (`0.x.x`), мажорной (`major`) считается вторая цифра в версии, а минорной (`minor`) считается третья цифра - `0.major.minor`. Таким образом, при `BREAKING CHANGE` коммите, пакет версии `1.0.0` поднимется до `2.0.0`, а пакет версии `0.1.0` поднимется до `0.2.0`.

Версии библиотек обновляются согласно [conventional commits](https://www.conventionalcommits.org/en/v1.0.0/)

## Сквозное версионирование

Большинство библиотек в `tramvai` репозитории объединены в сквозное версионирование - это `core` пакеты, трамвай модули и токены, все что входит в скоупы `@tramvai` и `@tramvai-tinkoff`. Релиз и публикация этих библиотек происходит одновременно, даже если изменения затронули только один пакет из списка.
Такой подход вы можете увидеть у [Angular](https://angular.io/guide/releases), и с некоторыми ограничениями, в монорепозиториях использующих [Lerna](https://github.com/lerna/lerna#fixedlocked-mode-default)

Основной плюс unified версионирования - гарантируется совместимость между пакетами одной версии.

Раньше у пользователя был только один способ поднять версию фреймворка, не потеряв совместимость между пакетами - устанавливать все пакеты до их latest версии.
Сейчас, можно указать общую целевую версию для каждой `tramvai` библиотеки, либо использовать команду `tramvai update`.

Один из минусов подхода - любое обновление пакета из списка unified, требует поднять версии и опубликовать все эти пакеты из списка, что значительно замедляет CI.

## Хранение версий в релизных тегах

Одна из причин для хранения версии в релизных тегах - protected ветка `master`, в которую мы не можем автоматически внести изменения после релиза и обновления версий пакетов.

Хранение версий в релизных тегах само по себе не дает преимуществ, и у нас используется вместе со stub версиями пакетов в исходных `package.json` файлах.
 
Допустим, у нас был пакет с зависимостями:

```json
{ 
  "name": "@tramvai/foo", 
  "version": "0.1.0", 
  "dependencies": { 
    "@tramvai/bar": "^1.1.0", 
    "@tramvai/baz": "^2.0.0" 
  } 
}
```

Раньше, каждый крупный Merge Request сопровождался конфликтами, если в master ветке обновлялась версии пакетов, а затронутые библиотеки в MR содержали изменения в dependencies.

Теперь, наш пакет выглядит так:
```json
{ 
  "name": "@tramvai/foo", 
  "version": "0.0.0-stub", 
  "dependencies": { 
    "@tramvai/bar": "0.0.0-stub", 
    "@tramvai/baz": "0.0.0-stub" 
  } 
}
```

Версия `0.0.0-stub` никогда не вызовет конфликтов слияния, а вычисление реальных версий происходит только в CI - при создании нового релизного тега и публикации, внутри библиотеки `pvm`.
