---
id: command-line-runner
title: Цепочка действий
---

При обработке запроса клиента нам необходимо выполнить стандартный список действий, такие как получение роута, получение нужных данных для клиента, рендеринг приложения и ответа клиенту. При этом, у нас модульная система, когда модули не знают о друг друге, но их надо как то связать.

Для решение этой проблемы был разработан `commandLineRunner`, который содержит в себе фиксированный список шагов, в которые модули могут добавлять необходимые задачи через провайдеры. Выполнение всех шагов происходит последовательно, но при этом задачи, зарегистрированные на каждый отдельный шаг, выполняются параллельно.

## Пример использования

Мы зарегистрировали новый провайдер, который вызовется, когда `commandLineRunner` дойдет до токена `commandLineListTokens.generatePage` и выполнится функция `render`:

```tsx
import { provide } from '@tramvai/core';
@Module({
  providers: [
    provide({
      provide: commandLineListTokens.generatePage,
      useFactory: ({ responseManager }) => {
        return function render() {
          responseManager.setBody(ReactDOM.renderToString(<App />));
        };
      },
      deps: {
        responseManager: RESPONSE_MANAGER_TOKEN,
      },
      multi: true,
    }),
  ],
})
export class RenderModule {}
```

## Блоки действий

В трамвае предустановлены некоторое количество базовых действий, которые выполняются в определенные этапы работы приложения. На основе этих этапов строится работа базовых модулей трамвая и можно добавлять действия кастомными модулям.

### Инициализация (init)

При старте tramvai запускается цепочка действий в которой можно инициализировать асинхронные сервисы (если это необходимо) и добавить базовый функционал. Эти действия выполняются только один раз и не доступны провайдерам, которым нужен пользовательский контекст.

![init command](/img/commands/command-line-init.jpg)

### Обработка запросов клиента (customer)

Для каждого клиента мы запускаем список действий в котором доступен пользовательский контекст и данные. Для каждого клиента, мы создаем свой di контекст в котором будут жить реализации только пока мы обрабатываем запрос клиента.

![customer command](/img/commands/customer-command.drawio.svg)

### SPA-переходы (spa)

При SPA-переходах в браузере роутинг запускает список действий

![spa command](/img/commands/command-line-spa.jpg)

### Завершение работы (close)

Перед завершением работы приложения, запускается этот список действий

![close command](/img/commands/command-line-close.jpg)

## Токены

### init

Инициализация асинхронных сервисов

_Для чего_: Если вам нужно асинхронно проинициализировать глобальные синглтоны

### listen

Подписка на глобальные события приложением

_Для чего_: Если вам нужно подписаться на глобальные события или порт

### customer_start

Стартовый токен в цепочке обработки клиентского запроса. Необходимо для инициализации специальных асинхронных конструкторов.

На этом этапе не советуется делать каких-либо долгих асинхронных задач, так как ожидаются только синхронные действия.

_Для чего_: Для инициализации асинхронных сервисов для каждого клиента

### resolve_user_deps

Главная цель этого этапа узнать всю необходимую информацию о странице и клиенте которого мы сейчас обрабатываем.

Так как у нас все действия внутри одного этапа выполняются параллельно, то именно в этом этапе эффективно и быстро можно запросить всю необходимую информацию, к примеру одновременно с запросом данных о странице, можно узнать о состоянии авторизации клиента, получить аналитическую информацию о клиенте и подобные действия.

_Для чего_: Для запроса любой глобальной информации о клиенте и странице

### resolve_page_deps

На этом этапы мы уже знаем о клиенте, о том, какая эта страница. Но, мы не запросили необходимые данные для страницы. К примеру: запросить ресурсы из админки, получить список регионов, загрузить необходимые блоки страницы. И всю ту информацию, которая необходима будет при генерации страницы.

В этом этапе не стоит делать долгие асинхронные действия и предполагается кэширование либо вынос в `resolveUserDeps` для достижения максимальной скорости ответа клиентам.

На этом этапе выполняются [action](concepts/action.md) и возможно они вам лучше подойдут, так как есть множество дополнительного функционала

_Для чего_: Для получение информации необходимой для отрисовки страницы

### generate_page

На этом этапе мы уже знаем текущий роут, какой клиент и все действия для страницы уже были загружены. И на этом этапе мы по информации из прошлых этапов генерируем html страницу и отдаем клиенту

_Для чего_: это больше внутренний этап и его не стоит использовать в обычных кейсах. Так как могут появится [race condition](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%B3%D0%BE%D0%BD%D0%BA%D0%B8) с рендером приложения

### clear

Этот этап вызовется уже после того, как мы ответили клиенту, но некоторым модулям или библиотекам необходимо удалить данные о клиенте

_Для чего_: Метод нужен, если вам нужно выполнить действия, после успешного ответа пользователю

### spa_transition

Задачи, зарегистрированные на этом этапе, выполняются при SPA-переходах в приложении

_Для чего_: Для обновления meta информации на текущей странице

### close

Перед закрытием приложения, некоторым модулям может быть необходимо выполнить специальные действия, к примеру закрыть соединения, отправить данные и подобные активности. Для того, что бы не дублировать код отслеживания закрытия приложения в каждом модуле, был сделан этот этап.

_Для чего_: Если вам нужно выполнить действия, перед закрытием приложения. например закрыть соединения, отправить логи и так далее

## Кастомизация

Приложение может переопределить стандартный список действий, например удалить не нужные или добавить новые.

Для этого необходимо в приложении или модуле определить провайдер, который перепишет базовый список

```tsx
import { provide } from '@tramvai/core';
[
  provide({
    provide: COMMAND_LINES_TOKEN,
    scope: 'singleton',
    useValue: customLines,
  }),
];
```

**_Предостережение_**: не стоит удалять этапы, так как из-за этого могут перестать корректно работать некоторые модули. В таком случае лучшим решением будет удалить модуль, который привязывается на не нужный этап.
