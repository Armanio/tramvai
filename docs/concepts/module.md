---
id: module
title: Модуль
---

Модули — это реализация какого-либо ограниченного функционала приложения с использованием DI системы и провайдеров.

## Жизненный цикл модулей

### Инициализация приложения

При создании приложения происходит обработка всех задекларированных [провайдеров](concepts/provider.md), которые попадут в общий [DI](concepts/di.md) контейнер.

### Обработка запросов клиента

Экземпляр модуля создается один раз на сервере (и используется для всех клиентов), после инициализации приложения, и один раз в браузере, после загрузки страницы и инициализации клиентской части. Эти инстансы содержат экземпляры классов, которые были переданы в `deps`, и будут переданы в конструктор модуля:

```tsx
import { Module } from '@tramvai/core';

@Module({
  providers: [],
  deps: {
    log: 'log',
  },
})
class TestModule {
  constructor({ log }) {
    log.info('TestModule created');
  }
}
```

## Пример модуля

Основной функционал модуля находится в списке `providers`. Каждый провайдер либо добавляет новый функционал, например делает доступным во всех остальных модулях констатное значение `New` под ключем `Token`:

```tsx
import { Module, provide } from '@tramvai/core';

@Module({
  providers: [
    provide({
      provide: 'Token',
      useValue: 'New',
    }),
  ],
})
class TestModule {}
```

Либо использует токены из других модулей, например добавление нового параметра окружения через токен `ENV_USED_TOKEN`, который обработает EnvModule:

```tsx
import { Module, provide } from '@tramvai/core';
import { ENV_USED_TOKEN } from '@tramvai/module-common';

@Module({
  providers: [
    provide({
      provide: ENV_USED_TOKEN,
      multi: true,
      useValue: [
        {
          key: 'ENV_VARIABLE',
          value: 'New',
          optional: true,
        },
      ],
    }),
  ],
})
class TestModule {}
```

## Импорт в модуле сторонних модулей

Модули могут внутри себя импортировать провайдеры сторонних модулей. Тем самым позволяя строить цепочку взаимосвязанных модулей.

Пример кода

```tsx
import { Module } from '@tramvai/core';
import { LogModule } from '@tramvai/module-log';

@Module({
  providers: [],
  imports: [LogModule],
})
class TestModule {}
```

В этом случае, при инициализации TestModule, предварительно произойдет инициализация провайдеров из модуля ModuleLogger и вложенных imports, если они присутствуют.

## Динамические модули

Конфигурировать модули можно двумя способами, причем оба способа можно использовать одновременно:

- передача параметров в `module`
- возврат параметров в статическом методе `forRoot`

Пример динамического модуля, в котором мы добавим в DI зависимости `metaGenerate` первым способом и `meta-list` вторым, причем одна из них зависит от другой:

```tsx
import { Module, provide } from '@tramvai/core';

@Module({
  providers: [
    provide({
      provide: 'metaGenerate',
      useClass: class MetaGenerate {},
      deps: {
        list: 'meta-list',
      },
    }),
  ],
})
export class SeoModule {
  static forRoot({ metaList }: { metaList?: string[] }) {
    if (metaList) {
      return {
        mainModule: SeoModule,
        providers: [
          provide({
            provide: 'meta-list',
            useValue: metaList,
          }),
        ],
      };
    }
  }
}
```

Статичный метод должен вернуть объект с интерфейсом:

```tsx
type staticModule = {
  mainModule: Module; // Ссылка на основной модуль, из которого мы вощьмем всю основную информацию
  providers: Provider[]; // Провайдеры которые будут добавлены в DI
};
```

Теперь этот модуль содержит статичный метод `forRoot` который к стандартному модулю `SeoModule` добавляет дополнительные `providers`. Без этой конструкции нам нужно было бы явно прописывать в приложении провайдеры. Все данные, которые были добавлены в `SeoModule` будут наследованы и расширены.

Теперь мы можем в приложении или в других модулях вызвать наш статичный метод. И результат выполнения `forRoot` будет добавлен в `DI`

```tsx
import { Module } from '@tramvai/core';
import { SeoModule } from './SeoModule';
import { metaFromConfig } from './metaFromConfig';

@Module({
  imports: [SeoModule.forRoot([metaFromConfig])],
})
export class ApplicationModule {}
```

При этом стоит учитывать, что `forRoot` конструкция должна только упрощать использование модуля и мы должны так же поддерживать работоспособность модуля через обычное конфигурирование `providers`

## Рекомендации для модулей

### Низкая связанность

Желательно модули строить так, что бы они не зависели прямо от других модулей. Связанность только должна происходить на основе интерфейсов и с возможностью замены. Иначе нельзя будет просто заменить модули и произвести рефакторинг

### Не большой размер

Чем больше модуль, тем больше кода он содержит внутри и тем больше потенциально он имеет связей и причин для изменений.

По этому причине модуль будет сложнее менять и будет больше шанс для поломки функционала при изменениях.

Желательно, что бы модули реализовывали какую-то не большую часть функциональности.

### Опциональные зависимости/конфигурирование

Модулем удобно пользоваться, если он не требует какое либо конфигурирование и по дефолту работает нормально. Но, если понятно, что для некоторых приложений и кейсов нужна будет дополнительная настройка поведения, то желательно использовать опциональные зависимости, которые смогут определить в приложении.

Стоит помечать опциональными зависимостями не критичный функционал, который не обязательно нужен модулю. Для того, чтобы можно было не реализовывать интерфейсы и выкинуть часть логики. К примеру, логирование

```tsx
// @todo пример опциональной зависимости
```

### Отладка модулей

Рекомендуется указывать в документации модуля уникальный идентификатор/namespace логгера, который используется в этом модуле. Пример идентификатора модуля для `@tramvai/module-server`:

```tsx
const log = logger('server'); // получаем экземпляр logger по токену LOGGER_TOKEN
```

## Дополнительные ссылки

- Про [DI контейнер](concepts/di.md)
- Про [провайдеры](concepts/provider.md)
