---
id: provider
title: Провайдер
---

Провайдер - это простой объект, который предоставляет реализацию для интерфейса (идентефикатора) конкретной зависимости. Реализацией может быть константное значение (строка, функция, symbol, экземпляр класса), фабрика или класс. Фабрика или класс инициализируются по запросу к соответствующему идентификатору. Можно регистрировать несколько провайдеров на один токен, при наличии параметра `multi`.

## Формат

```tsx
type Provider = {
  provide: Token | string; // идентификатор провайдера
  useValue?: any; // реализация идентификатора
  useFactory?: any; // реализация идентификатора
  useClass?: any; // реализация идентификатора
  deps?: Record<string, Token | string>; // список зависимостей которые необходимы провайдеру для работы
  multi?: boolean; // возможность зарегистрировать множество реализаций провайдеров, если true, при получении значения этого идентификатора, все зарегестрированные значения будут приходить в массиве
  scope?: 'request' | 'singleton'; // Если singleton, то контейнер зарегестрирует один экземпляр провайдера на все запросы клиента. Если request то будет создавать свой инстанс для каждого клиента и Request
};
```

## Разновидности провайдеров

### Class

При инициализации инстанса произойдет создание класса переданного в `useClass`, если были заданы `deps` то класс вызовется с объектом реализаций первым аргументом

```tsx
import { provide } from '@tramvai/core';
const provider = provide({
  provide: 'token',
  useClass: class ImplementClass {
    constructor({ logger }) {}
  },
  deps: {
    logger: 'logger',
  },
});
```

### Factory

При инициализации инстанса произойдет вызов функции переданной в `useFactory`, если были заданы `deps` то функция вызовется с объектом реализаций первым аргументом

```tsx
import { provide } from '@tramvai/core';
const provider = provide({
  provide: 'token',
  useFactory: ({ logger }) => new Implement(logger),
  deps: {
    logger: 'logger',
  },
});
```

### Value

Устанавливает значение провайдера теми данными, которые были переданы в параметре `useValue`, не будет производится дополнительная инициализация и нельзя использовать `deps`

```tsx
import { provide } from '@tramvai/core';
const provider = provide({
  provide: 'token',
  useValue: { appName: 'APP' },
});
```

## Multi провайдеры

Нам может понадобиться возможность регистрации для одного токена множества реализаций. Например, несколько действий для одного шага. Что бы это реализовать, нужно передать параметр `multi` в провайдер. В таком случае в di контейнере сохраняется массив провайдеров:

```tsx
import { provide } from '@tramvai/core';
const providers = [
  provide({
    provide: 'token',
    multi: true,
    useValue: { route: '/' },
  }),
  provide({
    provide: 'token',
    multi: true,
    useValue: { route: '/cards' },
  }),
];
```

## Зависимости (deps)

Нужны для указания зависимостей, которые нужны для работы провайдера. При создании провайдера будут созданы инстансы зависимостей, которые указаны в deps и переданы в провайдер первым аргументом. Ключами объекта deps будут являться реализации, которые попадут в провайдер. При этом, если не будет найден провайдер в глобальном DI, будет выброшена ошибка с уведомлением что текущий токен не найден.

### Формат

```tsx
type Provider = {
  deps: {
    [key: string]:
      | Token
      | {
          token: Token;
          optional?: boolean;
          multi?: boolean;
        };
  };
};
```

### Опциональные зависимости

Нам не всегда нужны обязательные зависимости для работы. И мы хотим пометить, что зависимость не обязательно для работы и не нужно кидать ошибку. Для этого можно передать параметр `optional` который отключит выброс ошибки при отсутствии зависимости. Вместо реализации зависимости провайдеру придет значение `null`.

```tsx
import { provide } from '@tramvai/core';
const provider = provide({
  provide: 'token',
  useClass: class A {
    constructor({ log }) {}
  },
  deps: {
    log: {
      token: 'log',
      optional: true,
    },
  } as const,
});
```

### Multi зависимости

Некоторые провайдеры являются мульти провайдерами и вместо одной реализации, нам придет массив реализаций. Для правильного вывода типов, мы должны передать параметр `multi: true`, применить `as const` для `deps` блока для корректного вывода типов через TS:

```tsx
import { provide } from '@tramvai/core';
const provider = provide({
  provide: 'token',
  useClass: class A {
    constructor({ commands }) {
      commands.forEach();
    }
  },
  deps: {
    commands: {
      token: 'commands',
      multi: true,
    },
  } as const,
});
```

### Circular dependency

DI не позволяет объявлять зависимости, которые находятся в зависимости у друг друга, например:

```tsx
import { provide } from '@tramvai/core';
const providers = [
  provide({
    provide: 'A',
    deps: {
      B: 'B',
    },
  }),
  provide({
    provide: 'B',
    deps: {
      A: 'A',
    },
  }),
];
```

В этом примере мы с не сможем коректно создать инстансы провайдеров и код выкинет ошибку.

Подобные провайдеры стоит пересмотреть и вынести общую часть в отдельный класс и провайдер и использовать совместно `A` и `B`

## Scope

> Опция влияет только на работу контейнера на сервере, на клиенте работает только один общий контейнер, в котором провайдеры с разным скопом хранятся вместе

Позволяет создавать синглтон инстансы которые будут общие между множеством клиентов. В стандартном поведение, каждый объявленный провайдер будет автоматически удаляться и пересоздаваться для каждого нового клиента. Этот функционал был сделан для того, чтобы у нас была возможность хранить, как и синглтоны, к примеру кэш, так и различные персонализированные данные. К примеру статус пользователя и персонализацию.

По дефолту все провайдеры имеют значение `Scope.REQUEST`, что означает, что значения провайдера будет создавать для каждого клиента. Исключение составляют провайдеры `useValue`, которые ведут себя как синглтон.

## Интерфейс

```tsx
import { provide } from '@tramvai/core';
const provider = provide({
  provide: 'Cache',
  useFactory: Cache,
  scope: Scope.SINGLETON,
});
```

В этом случае, провайдер `Cache` зарегистрируются как глобальный синглтон, так как был передан параметр `scope` и будет использоваться единый инстанс для всех пользователей.

## Токены (token)

Токены используются как идентификатор для провайдера в DI. По значению токена происходит регистрация провайдера и поиск реализации.

## Интерфейс

```tsx
type token = Token | string;
```

Токен может быть как строкой, так и специально созданным с помощью функции `createToken` в который можно передать интерфейс. При этом можно использовать одновременно и строку и createToken, главное то, что бы идентификатор был одинаковым

## createToken

```tsx
import { createToken } from '@tinkoff/dippy';
import { provide } from '@tramvai/core';

const loggerToken = createToken<Logger>('logger');

const provider = provide({
  provide: loggerToken,
  useClass: Logger,
});
```

Основное отличие заключается в том, что в createToken можно передать интерфейс реализации, который потом будет использоваться для проверки типов при получение зависимостей и создание провайдеров.
