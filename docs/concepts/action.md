---
id: action
title: Экшен
---

Экшены необходимы в приложении для локализации выполнения асинхронных действий, например сделать запрос, обновить данные в сторе и прочие действия, которые затрагивают IO или управление состоянием.

Подробное описание интерфейса [createAction](references/tramvai/create-action.md)

## Пример экшена

```tsx
import { createAction } from '@tramvai/core';

// создаем экшен
const actionFetchData = createAction({
  name: 'fetch-data',
  fn: (context, payload) => fetch(payload.url),
});

// вызываем экшен
context
  .executeAction(actionFetchData, { url: 'https://tinkoff.ru' })
  .then((data) => context.dispatch(loadData(data)));
```

## Глобальные экшены

Приложения могут добавить глобальные экшены в приложении, которые необходимы выполнить перед отрисовки страницы, в этих действиях обычно загружают информацию необходимую для отображении страницы, например информацию о депозитах. Перед рендерингом страницы различные типы экшенов собираются в единый список и выполняются параллельно.

Вкратце, экшен глобальный, если он добавлен через `createApp`, `createBundle`, или статическое свойство компонента - страницы, например `PageComponent.actions`. По умолчанию, глобальные экшены выполняются один раз, на сервере, и передают статус и результат выполнения экшена на клиент.

### Дедлайн выполнения

Серверы должны отвечать быстро, поэтому мы должны уменьшить количество кейсов, когда глобальные экшены вызывают задержку загрузки страницы, допустим если выйдет из строя какое либо API. Для этого на сервере присутствует ограничение по времени на выполнение глобальных экшенов и если это время проходит, то ожидание экшенов заканчивается и эти экшены должны будут выполниться на стороне клиента.

### Синхронизация экшенов между сервером и клиентом

Информация о всех успешно выполненных экшенах будут переданы клиенту, который на основе этой информации запустит выполнение глобальных экшенов. При этом, если экшен к примеру выпал за дедлайн или упал по ошибке, то произойдет повторное выполнение на стороне клиента

### Виды глобальных экшенов

#### Глобальные экшены для всего приложения

Для регистрации внутри приложения, мы должны передать массив экшенов в [createApp](references/tramvai/create-app.md), после этого все эти экшены будут выполняться для каждой страницы и любых бандлов:

##### Подключение

```tsx
createApp({
  name: 'myApp',
  actions: [loadDepositConfig],
});
```

Также можно зарегистрировать экшены в провайдерах:

```tsx
import { ACTIONS_LIST_TOKEN } from '@tramvai/core';
import { provide } from '@tramvai/core';

const provider = provide({
  provide: ACTIONS_LIST_TOKEN,
  multi: true,
  useValue: [loadDepositConfig],
});
```

#### Глобальные экшены для бандла

Для регистрации внутри бандла, мы должны передать в [createBundle](references/tramvai/create-bundle.md) список экшенов, которые будут после этого выполняться для всех страниц которые присутствуют и используются в бандле.

##### Подключение

```tsx
createBundle({
  name: 'bundle',
  actions: [loadDepositConfig],
});
```

#### Глобальные экшены привязанные к странице

Это самый низкий уровень добавление глобальных экшенов, для отдельного Page компонента мы можем привязать список экшенов, которые нужно выполнить перед рендерингом страницы.

##### Подключение

Для этого необходимо добавить статичное свойство для page компонента `actions` и передать список необходимых экшенов

```tsx
class PageComponent extends Copmponent {
  static actions = [loadDepositConfig];
}
```

## Ограничения

Не все экшены могут выполняться при любых обстоятельствах, у нас могут быть экшены которые должны выполняться только на сервере, другие только в браузере, так и имеющие какие любые другие ограничения. Для решения этой проблемы есть свойство `conditions`:

```tsx
createAction({
  name: 'fetch-data',
  fn: (context, payload) => fetch(payload.url),
  conditions: {
    requiredCoreRoles: ['client'],
    onlyBrowser: true,
  },
});
```

В примере выше мы создаем экшен, который будет выполняться только в браузере и только когда у нас будет роль пользователя у основного core API равная `client`.

### Добавление новых ограничений в приложение

Можно реализовать в приложении или модуле свои собственные ограничения. Для этого мы должны создать объект с интерфейсом:

```tsx
interface Condition {
  key: string;
  fn(checker: ActionConditionChecker): void;
}
```

- `key` - идентификатор ограничения
- `fn` - функция проверки, которая будет вызвана для каждого экшена

Функция получит в аргументе checker, который имеет интерфейс

```tsx
interface ActionConditionChecker {
  payload: any;
  parameters: any;
  type: 'global' | 'local';
  conditions: Record<string, any>;
  forbid(): void;
  setState(value: any): void;
  getState(): any;
  allow(): void;
}
```

- `payload` - данные, которые были переданы с экшеном
- `parameters` - параметры которые были переданы при создании экшена
- `conditions` - ограничения для текущего экшена
- `type` - тип выполняемого экшена, может быть глобальным или простое выполнение через executeAction
- `forbid` - запрещает выполнение экшена. Если хотя бы один чекер вызовет эту функцию, выполнение экшена будет остановлено
- `setState` - позволяет записать данные проверок. Нужно для кейсов, когда нам нужно знать, с какими данными выполнялось до этого и нужно ли повторить, к примеру ограничения по роли авторизации
- `getState` - получение записанного ранее состояния
- `allow` - сообщаем экшену, что нужно выполниться повторно. Экшен выполнится, если не будет запрещено выполнение через `forbid`

### Пример ограничения

```tsx
const isServer = typeof window === 'undefined';

export const onlyServer: ActionCondition = {
  key: 'onlyServer',
  fn: (checker) => {
    if (checker.conditions.onlyServer && !isServer) {
      checker.forbid();
    }
  },
};
```

После подключение, ограничение будет смотреть, есть ли в экшене поле `onlyServer` в `conditions`, и если есть, изменит поведение экшена

### Подключение ограничений в приложение

Для этого необходимо добавить `multi` провайдер `ACTION_CONDITIONALS` и передать функцию которая будет иметь интерфейс

```tsx
import { provide } from '@tramvai/core';

const provider = provide({
  provide: ACTION_CONDITIONALS,
  multi: true,
  useValue: [onlyServer],
});
```

### Предустановленные ограничения, доступные каждому экшену

- _`always`_ - экшен выполняется на каждый переход внутри приложения
- _`onlyBrowser`_ - экшен выполняется только в браузере
- _`onlyServer`_ - экшен выполняется только на сервере
- _`pageBrowser`_ - глобальный экшен выполняется на каждый переход внутри приложения, только в браузере
- _`pageServer`_ - глобальный экшен выполняется на каждый переход внутри приложения, только на сервере

## Особенности

Нужно помнить, что экшены по-умолчанию **кэшируются** и выполняются только **1 раз** за время жизненного цикла приложения.

Из этого вытекают следующая особенность.

Допустим следующую ситуацию:

- у нас есть страница концертной площадки по урлу `/concertvenue-[objectId]` - где `objectId` это параметр который соответствует идентификатору концертной площадки;
- на эту страницу у нас один компонент `ConcertVenuePage` и один страничный экшен `preparePageAction`;
- `objectId` в урле страницы используется для получения данных в `preparePageAction`, а также для выборки данных для отрисовки страницы;
- у нас есть страница концерта `/concert` на которой есть ссылки на концертные площадки - `/concertvenue-1`, `/concertvenue-2`, `/concertvenue-1`. На все эти ссылки мы можем перейти SPA переходом;
- Переходы между страницами клиентские (SPA), не серверные;

Последовательность действий:

1. На странице концерта мы кликаем на `/concertvenue-1`, открывается старница концертной площадки, страничный экшен выполняется **первый раз**.
2. Уходим обратно на страницу концерта SPA переходом.
3. Кликаем на `/concertvenue-2`.
4. Попадаем на пустую страницу, так как страничный экшен уже **был выполнен**, новые данные не запросились, а выборка данных для отрисовки страницы была произведена по айди из урла - 2.

Если нужно, чтобы при каждом заходе на страницу выполнялся страничный экшен, нужно передать ему соответствующее условие:

```tsx
const preparePageAction = creareAction({
  name: 'preparePageAction',
  fn: () => {
    // ...
  },
  conditions: {
    // с always: true экшен будет вызываться всегда и не кэшироваться
    always: true,
  },
});

ConcertVenuePage.actions = [preparePageAction];
```
