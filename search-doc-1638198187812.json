[{"title":"Бандл","type":0,"sectionRef":"#","url":"docs/concepts/bundle","content":"","keywords":""},{"title":"Динамический импорт бандла","type":1,"pageTitle":"Бандл","url":"docs/concepts/bundle#динамический-импорт-бандла","content":"Для выделения ненужного на каждой странице кода, каждый бандл, передаваемый в createApp, должен иметь сигнатуру () => Promise<{ default: Bundle }>. Весь код, общий с подключаемыми в приложение модулями, останется в основном чанке приложения, и многие бандлы будут весить всего несколько КБ, но как только один из компонентов бандла подключит тяжелую зависимость, например библиотеку с формами, она полностью попадет в соответствующий бандл. Рекомендуется использовать dynamic import с магическим комментарием webpackChunkName для указания имени нового чанка, например: () => import(/* webpackChunkName: \"mainDefault\" */ './bundles/mainDefault') Скопировать "},{"title":"Бандл по умолчанию","type":1,"pageTitle":"Бандл","url":"docs/concepts/bundle#бандл-по-умолчанию","content":"Каждый роут должен иметь свойства bundle с названием бандла, pageComponent и layoutComponent с названиями соответствующих компонентов. По умолчанию задаются следующие значения: bundle: 'mainDefault'pageComponent: 'pageDefault'layoutComponent: 'layoutDefault' При использовании стандартного RenderModule, подключается LayoutModule, который провайдит layoutDefault и отдельный механизм для расширения и переопределения layout в приложении, поэтому нет необходимости добавлять свойство layoutDefault в список components бандла. Для создания бандла, который будет запускаться на всех страницах приложения, у которых отсутствуют специфичные настройки роутов, достаточно двух шагов: Создаем бандл# import { createBundle } from '@tramvai/core';import { MainPage } from './pages/MainPage'; export default createBundle({ name: 'mainDefault', components: { pageDefault: MainPage, },}); Скопировать Подключаем бандл# import { createApp } from '@tramvai/core'; createApp({ name: 'myApp', modules: [ // ... ], providers: [ // ... ], bundles: { mainDefault: () => import(/* webpackChunkName: \"mainDefault\" */ './bundles/mainDefault'), },}); Скопировать "},{"title":"Экшен","type":0,"sectionRef":"#","url":"docs/concepts/action","content":"","keywords":""},{"title":"Пример экшена","type":1,"pageTitle":"Экшен","url":"docs/concepts/action#пример-экшена","content":"import { createAction } from '@tramvai/core'; // создаем экшенconst actionFetchData = createAction({ name: 'fetch-data', fn: (context, payload) => fetch(payload.url),}); // вызываем экшенcontext .executeAction(actionFetchData, { url: 'https://tinkoff.ru' }) .then((data) => context.dispatch(loadData(data))); Скопировать "},{"title":"Глобальные экшены","type":1,"pageTitle":"Экшен","url":"docs/concepts/action#глобальные-экшены","content":"Приложения могут добавить глобальные экшены в приложении, которые необходимы выполнить перед отрисовки страницы, в этих действиях обычно загружают информацию необходимую для отображении страницы, например информацию о депозитах. Перед рендерингом страницы различные типы экшенов собираются в единый список и выполняются параллельно. Вкратце, экшен глобальный, если он добавлен через createApp, createBundle, или статическое свойство компонента - страницы, например PageComponent.actions. По умолчанию, глобальные экшены выполняются один раз, на сервере, и передают статус и результат выполнения экшена на клиент. "},{"title":"Дедлайн выполнения","type":1,"pageTitle":"Экшен","url":"docs/concepts/action#дедлайн-выполнения","content":"Серверы должны отвечать быстро, поэтому мы должны уменьшить количество кейсов, когда глобальные экшены вызывают задержку загрузки страницы, допустим если выйдет из строя какое либо API. Для этого на сервере присутствует ограничение по времени на выполнение глобальных экшенов и если это время проходит, то ожидание экшенов заканчивается и эти экшены должны будут выполниться на стороне клиента. "},{"title":"Синхронизация экшенов между сервером и клиентом","type":1,"pageTitle":"Экшен","url":"docs/concepts/action#синхронизация-экшенов-между-сервером-и-клиентом","content":"Информация о всех успешно выполненных экшенах будут переданы клиенту, который на основе этой информации запустит выполнение глобальных экшенов. При этом, если экшен к примеру выпал за дедлайн или упал по ошибке, то произойдет повторное выполнение на стороне клиента "},{"title":"Виды глобальных экшенов","type":1,"pageTitle":"Экшен","url":"docs/concepts/action#виды-глобальных-экшенов","content":"Глобальные экшены для всего приложения# Для регистрации внутри приложения, мы должны передать массив экшенов в createApp, после этого все эти экшены будут выполняться для каждой страницы и любых бандлов: Подключение# createApp({ name: 'myApp', actions: [loadDepositConfig],}); Скопировать Также можно зарегистрировать экшены в провайдерах: import { ACTIONS_LIST_TOKEN } from '@tramvai/core';import { provide } from '@tramvai/core'; const provider = provide({ provide: ACTIONS_LIST_TOKEN, multi: true, useValue: [loadDepositConfig],}); Скопировать Глобальные экшены для бандла# Для регистрации внутри бандла, мы должны передать в createBundle список экшенов, которые будут после этого выполняться для всех страниц которые присутствуют и используются в бандле. Подключение# createBundle({ name: 'bundle', actions: [loadDepositConfig],}); Скопировать Глобальные экшены привязанные к странице# Это самый низкий уровень добавление глобальных экшенов, для отдельного Page компонента мы можем привязать список экшенов, которые нужно выполнить перед рендерингом страницы. Подключение# Для этого необходимо добавить статичное свойство для page компонента actions и передать список необходимых экшенов class PageComponent extends Copmponent { static actions = [loadDepositConfig];} Скопировать "},{"title":"Ограничения","type":1,"pageTitle":"Экшен","url":"docs/concepts/action#ограничения","content":"Не все экшены могут выполняться при любых обстоятельствах, у нас могут быть экшены которые должны выполняться только на сервере, другие только в браузере, так и имеющие какие любые другие ограничения. Для решения этой проблемы есть свойство conditions: createAction({ name: 'fetch-data', fn: (context, payload) => fetch(payload.url), conditions: { requiredCoreRoles: ['client'], onlyBrowser: true, },}); Скопировать В примере выше мы создаем экшен, который будет выполняться только в браузере и только когда у нас будет роль пользователя у основного core API равная client. "},{"title":"Добавление новых ограничений в приложение","type":1,"pageTitle":"Экшен","url":"docs/concepts/action#добавление-новых-ограничений-в-приложение","content":"Можно реализовать в приложении или модуле свои собственные ограничения. Для этого мы должны создать объект с интерфейсом: interface Condition { key: string; fn(checker: ActionConditionChecker): void;} Скопировать key - идентификатор ограниченияfn - функция проверки, которая будет вызвана для каждого экшена Функция получит в аргументе checker, который имеет интерфейс interface ActionConditionChecker { payload: any; parameters: any; type: 'global' | 'local'; conditions: Record<string, any>; forbid(): void; setState(value: any): void; getState(): any; allow(): void;} Скопировать payload - данные, которые были переданы с экшеномparameters - параметры которые были переданы при создании экшенаconditions - ограничения для текущего экшенаtype - тип выполняемого экшена, может быть глобальным или простое выполнение через executeActionforbid - запрещает выполнение экшена. Если хотя бы один чекер вызовет эту функцию, выполнение экшена будет остановленоsetState - позволяет записать данные проверок. Нужно для кейсов, когда нам нужно знать, с какими данными выполнялось до этого и нужно ли повторить, к примеру ограничения по роли авторизацииgetState - получение записанного ранее состоянияallow - сообщаем экшену, что нужно выполниться повторно. Экшен выполнится, если не будет запрещено выполнение через forbid "},{"title":"Пример ограничения","type":1,"pageTitle":"Экшен","url":"docs/concepts/action#пример-ограничения","content":"const isServer = typeof window === 'undefined'; export const onlyServer: ActionCondition = { key: 'onlyServer', fn: (checker) => { if (checker.conditions.onlyServer && !isServer) { checker.forbid(); } },}; Скопировать После подключение, ограничение будет смотреть, есть ли в экшене поле onlyServer в conditions, и если есть, изменит поведение экшена "},{"title":"Подключение ограничений в приложение","type":1,"pageTitle":"Экшен","url":"docs/concepts/action#подключение-ограничений-в-приложение","content":"Для этого необходимо добавить multi провайдер ACTION_CONDITIONALS и передать функцию которая будет иметь интерфейс import { provide } from '@tramvai/core'; const provider = provide({ provide: ACTION_CONDITIONALS, multi: true, useValue: [onlyServer],}); Скопировать "},{"title":"Предустановленные ограничения, доступные каждому экшену","type":1,"pageTitle":"Экшен","url":"docs/concepts/action#предустановленные-ограничения-доступные-каждому-экшену","content":"always - экшен выполняется на сервере, затем в браузере и на каждый SPA переход внутри приложенияonlyBrowser - экшен выполняется только в браузереonlyServer - экшен выполняется только на сервереpageBrowser - глобальный экшен выполняется только в браузереpageServer - глобальный экшен выполняется только на сервереalways + onlyBrowser - экшен выполняется в браузере и на каждый SPA переход внутри приложения "},{"title":"Особенности","type":1,"pageTitle":"Экшен","url":"docs/concepts/action#особенности","content":"Нужно помнить, что экшены по-умолчанию кэшируются и выполняются только 1 раз за время жизненного цикла приложения. Из этого вытекают следующая особенность. Допустим следующую ситуацию: у нас есть страница концертной площадки по урлу /concertvenue-[objectId] - где objectId это параметр который соответствует идентификатору концертной площадки;на эту страницу у нас один компонент ConcertVenuePage и один страничный экшен preparePageAction;objectId в урле страницы используется для получения данных в preparePageAction, а также для выборки данных для отрисовки страницы;у нас есть страница концерта /concert на которой есть ссылки на концертные площадки - /concertvenue-1, /concertvenue-2, /concertvenue-1. На все эти ссылки мы можем перейти SPA переходом;Переходы между страницами клиентские (SPA), не серверные; Последовательность действий: На странице концерта мы кликаем на /concertvenue-1, открывается старница концертной площадки, страничный экшен выполняется первый раз.Уходим обратно на страницу концерта SPA переходом.Кликаем на /concertvenue-2.Попадаем на пустую страницу, так как страничный экшен уже был выполнен, новые данные не запросились, а выборка данных для отрисовки страницы была произведена по айди из урла - 2. Если нужно, чтобы при каждом заходе на страницу выполнялся страничный экшен, нужно передать ему соответствующее условие: const preparePageAction = creareAction({ name: 'preparePageAction', fn: () => { // ... }, conditions: { // с always: true экшен будет вызываться всегда и не кэшироваться always: true, },}); ConcertVenuePage.actions = [preparePageAction]; Скопировать "},{"title":"Цепочка действий","type":0,"sectionRef":"#","url":"docs/concepts/command-line-runner","content":"","keywords":""},{"title":"Пример использования","type":1,"pageTitle":"Цепочка действий","url":"docs/concepts/command-line-runner#пример-использования","content":"Мы зарегистрировали новый провайдер, который вызовется, когда commandLineRunner дойдет до токена commandLineListTokens.generatePage и выполнится функция render: import { provide } from '@tramvai/core';@Module({ providers: [ provide({ provide: commandLineListTokens.generatePage, useFactory: ({ responseManager }) => { return function render() { responseManager.setBody(ReactDOM.renderToString(<App />)); }; }, deps: { responseManager: RESPONSE_MANAGER_TOKEN, }, multi: true, }), ],})export class RenderModule {} Скопировать "},{"title":"Блоки действий","type":1,"pageTitle":"Цепочка действий","url":"docs/concepts/command-line-runner#блоки-действий","content":"В трамвае предустановлены некоторое количество базовых действий, которые выполняются в определенные этапы работы приложения. На основе этих этапов строится работа базовых модулей трамвая и можно добавлять действия кастомными модулям. "},{"title":"Инициализация (init)","type":1,"pageTitle":"Цепочка действий","url":"docs/concepts/command-line-runner#инициализация-init","content":"При старте tramvai запускается цепочка действий в которой можно инициализировать асинхронные сервисы (если это необходимо) и добавить базовый функционал. Эти действия выполняются только один раз и не доступны провайдерам, которым нужен пользовательский контекст.  "},{"title":"Обработка запросов клиента (customer)","type":1,"pageTitle":"Цепочка действий","url":"docs/concepts/command-line-runner#обработка-запросов-клиента-customer","content":"Для каждого клиента мы запускаем список действий в котором доступен пользовательский контекст и данные. Для каждого клиента, мы создаем свой di контекст в котором будут жить реализации только пока мы обрабатываем запрос клиента.  "},{"title":"SPA-переходы (spa)","type":1,"pageTitle":"Цепочка действий","url":"docs/concepts/command-line-runner#spa-переходы-spa","content":"При SPA-переходах в браузере роутинг запускает список действий  "},{"title":"Завершение работы (close)","type":1,"pageTitle":"Цепочка действий","url":"docs/concepts/command-line-runner#завершение-работы-close","content":"Перед завершением работы приложения, запускается этот список действий  "},{"title":"Токены","type":1,"pageTitle":"Цепочка действий","url":"docs/concepts/command-line-runner#токены","content":""},{"title":"init","type":1,"pageTitle":"Цепочка действий","url":"docs/concepts/command-line-runner#init","content":"Инициализация асинхронных сервисов Для чего: Если вам нужно асинхронно проинициализировать глобальные синглтоны "},{"title":"listen","type":1,"pageTitle":"Цепочка действий","url":"docs/concepts/command-line-runner#listen","content":"Подписка на глобальные события приложением Для чего: Если вам нужно подписаться на глобальные события или порт "},{"title":"customer_start","type":1,"pageTitle":"Цепочка действий","url":"docs/concepts/command-line-runner#customer_start","content":"Стартовый токен в цепочке обработки клиентского запроса. Необходимо для инициализации специальных асинхронных конструкторов. На этом этапе не советуется делать каких-либо долгих асинхронных задач, так как ожидаются только синхронные действия. Для чего: Для инициализации асинхронных сервисов для каждого клиента "},{"title":"resolve_user_deps","type":1,"pageTitle":"Цепочка действий","url":"docs/concepts/command-line-runner#resolve_user_deps","content":"Главная цель этого этапа узнать всю необходимую информацию о странице и клиенте которого мы сейчас обрабатываем. Так как у нас все действия внутри одного этапа выполняются параллельно, то именно в этом этапе эффективно и быстро можно запросить всю необходимую информацию, к примеру одновременно с запросом данных о странице, можно узнать о состоянии авторизации клиента, получить аналитическую информацию о клиенте и подобные действия. Для чего: Для запроса любой глобальной информации о клиенте и странице "},{"title":"resolve_page_deps","type":1,"pageTitle":"Цепочка действий","url":"docs/concepts/command-line-runner#resolve_page_deps","content":"На этом этапы мы уже знаем о клиенте, о том, какая эта страница. Но, мы не запросили необходимые данные для страницы. К примеру: запросить ресурсы из админки, получить список регионов, загрузить необходимые блоки страницы. И всю ту информацию, которая необходима будет при генерации страницы. В этом этапе не стоит делать долгие асинхронные действия и предполагается кэширование либо вынос в resolveUserDeps для достижения максимальной скорости ответа клиентам. На этом этапе выполняются action и возможно они вам лучше подойдут, так как есть множество дополнительного функционала Для чего: Для получение информации необходимой для отрисовки страницы "},{"title":"generate_page","type":1,"pageTitle":"Цепочка действий","url":"docs/concepts/command-line-runner#generate_page","content":"На этом этапе мы уже знаем текущий роут, какой клиент и все действия для страницы уже были загружены. И на этом этапе мы по информации из прошлых этапов генерируем html страницу и отдаем клиенту Для чего: это больше внутренний этап и его не стоит использовать в обычных кейсах. Так как могут появится race condition с рендером приложения "},{"title":"clear","type":1,"pageTitle":"Цепочка действий","url":"docs/concepts/command-line-runner#clear","content":"Этот этап вызовется уже после того, как мы ответили клиенту, но некоторым модулям или библиотекам необходимо удалить данные о клиенте Для чего: Метод нужен, если вам нужно выполнить действия, после успешного ответа пользователю "},{"title":"spa_transition","type":1,"pageTitle":"Цепочка действий","url":"docs/concepts/command-line-runner#spa_transition","content":"Задачи, зарегистрированные на этом этапе, выполняются при SPA-переходах в приложении Для чего: Для обновления meta информации на текущей странице "},{"title":"close","type":1,"pageTitle":"Цепочка действий","url":"docs/concepts/command-line-runner#close","content":"Перед закрытием приложения, некоторым модулям может быть необходимо выполнить специальные действия, к примеру закрыть соединения, отправить данные и подобные активности. Для того, что бы не дублировать код отслеживания закрытия приложения в каждом модуле, был сделан этот этап. Для чего: Если вам нужно выполнить действия, перед закрытием приложения. например закрыть соединения, отправить логи и так далее "},{"title":"Кастомизация","type":1,"pageTitle":"Цепочка действий","url":"docs/concepts/command-line-runner#кастомизация","content":"Приложение может переопределить стандартный список действий, например удалить не нужные или добавить новые. Для этого необходимо в приложении или модуле определить провайдер, который перепишет базовый список import { provide } from '@tramvai/core';[ provide({ provide: COMMAND_LINES_TOKEN, scope: 'singleton', useValue: customLines, }),]; Скопировать Предостережение: не стоит удалять этапы, так как из-за этого могут перестать корректно работать некоторые модули. В таком случае лучшим решением будет удалить модуль, который привязывается на не нужный этап. "},{"title":"Dependency Injection","type":0,"sectionRef":"#","url":"docs/concepts/di","content":"","keywords":""},{"title":"Концепции","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#концепции","content":"Провайдер - Имплементация токена в DIТокены - индетификатор провайдера в DI системе и одновременно его интерфейсКонтейнер - хранилище со всеми провайдерами и их реализациями "},{"title":"Особенности","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#особенности","content":""},{"title":"Динамическая инициализация","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#динамическая-инициализация","content":"Провадйры инициализируются только если в коде прозошло получение инстанса с помощью метода get у di контейнера или если провайдер был указан как deps зависимость у module. В остальных случаях провайдер не будет создан и проинициализирован. Эта особенность позволяем нам регистрировать провайдеры в любой последовательности и заменять реализации. "},{"title":"Замена реализаций","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#замена-реализаций","content":"В некоторых случаях, нам может не подойти базовая реализация функционала и для решения этой проблемы, мы можем переопределить реализацию провайдеров. К примеру нам не подходит текущий логгер из common-module и мы хотим его заменить, для этого нам необходимо закинуть в providers новую реализацию для токена. import { provide } from '@tramvai/core';createApp({ modules: [CommonModule], providers: [ provide({ provide: LOGGER_TOKEN, useValue: console, }), ],}); Скопировать После этого, мы заменим реализацию LOGGER_TOKEN, которая была объявлена в CommonModule, на нативный объект console "},{"title":"Проверка доступности реализации всех зависимостей","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#проверка-доступности-реализации-всех-зависимостей","content":"При инициализации провайдера автоматически проверяется доступность всех зависимостей, если не была найдена зависимость и провайдер не является optional, в development режиме выбрасывается исключение. "},{"title":"Использование DI","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#использование-di","content":""},{"title":"В модулях","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#в-модулях","content":"Передача массива в параметр providers который будут добавлены при инициализации приложения в DI. Подробнее о модулях @Module({ providers: [ // ... ],})export class MyModule {} Скопировать "},{"title":"В createApp","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#в-createapp","content":"Можно передать в createApp массив providers, который будет иметь максимальный приоритет и перепишет реализации интерфейсов модулей и core: createApp({ providers: [ // ... ],}); Скопировать "},{"title":"В экшенах","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#в-экшенах","content":"Для получшения реализаций провайдеров, можно передать объект deps при создании экшена: createAction({ name: 'action', fn: (context, payload, deps) => { deps.logger.error('ERROR'); }, deps: { logger: 'logger', },}); Скопировать "},{"title":"Контейнер","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#контейнер","content":"Контейнер в котором хранится список зарегистрированных провайдеров в приложении, так и инстансы реализаций провайдеров, которые уже были созданы. "},{"title":"Корневой контейнер","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#корневой-контейнер","content":"Глобальный контейнер верхнего уровня, который содержит в себе всех зарегистрированых провайдеров и глобальные синглтоны которые живут все время, пока живет приложение. "},{"title":"Контейнер - потомок","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#контейнер---потомок","content":"Создаваемый для каждого клиента (пользователя, отправившего запрос на сервер) инстанс DI который наследуется от root контейнера. Но позволяет создавать и хранить собственные инстансы классов. Которые могут содержать приватную информацию о клиенте и при этом, эта информация не утечет другим клиентам, например ссылка на актуальный объект Request. Consumer di создается и живет пока мы отвечаем клиенту. Как только мы ответили, consumer di удаляется и очищается вся приватная информация. При этом не нужно делать ручную очистку и удалять di контейнер или его зависимости. Это работа основывается на том, что при ответе клиенту, теряется ссылка на контекст и DI контейнер. После чего GC удалит все из памяти. "},{"title":"Дополнительный материал","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#дополнительный-материал","content":"Видео с рассказом о том, зачем нужен DI и почему его стоит использовать Part 1Part 2Выпуск девшахты который посвещен DI и зачем он нужен https://www.youtube.com/watch?v=3NgWwzwDeTQ "},{"title":"Введение в tramvai","type":0,"sectionRef":"#","url":"docs/concepts/overview","content":"","keywords":""},{"title":"Основные особенности","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#основные-особенности","content":"Модульный подход - можно расширять функционал приложений с помощью модулейUniversal - Работает одинаково хорошо для браузеров и сервераБыстрый - имеет малый вес, не оказывает влияния на общую производительность приложения, максимально распараллеливает действия на сервере "},{"title":"Используемые подходы","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#используемые-подходы","content":" "},{"title":"Модульность","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#модульность","content":"Архитектура tramvai строится на идее, что у нас весь функционал разделен на различные модули и все общение между модулями строится на общих интерфейсах, взаимодействуя через DI. Такая архитектура дает возможность легко добавлять новую функциональность в приложение, и заменять уже существующий функционал. "},{"title":"Стандартизация","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#стандартизация","content":"tramvai дает основу которая позволяет поддерживать и создавать приложения с одинаковой архитектурой для множества команд с возможностью шарить код между проектами, так как tramvai это легковесный слой, который помогает взаимодействовать различными модулям в приложении "},{"title":"Скорость","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#скорость","content":"Ядро tramvai вместе с DI весит 4 кб, всё остальное реализуется через сторонние модули, который расширяют функционал приложения. Это дает возможность делать приложения минимального размера, исключая ненужные фичи. Архитектура и модули разработаны с концепцией performance first для максимальной параллелизации, согласно best practice. "},{"title":"Универсальность","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#универсальность","content":"tramvai это SSR-first фреймворк и учитывает все особенности и проблемы, связанные с сервером, клиентом и взаимодействием между ними: Все модули разрабатываются и для браузера и для сервераИспользуются общие интерфейсыИспользуется цепочка команд на сервере и браузере которая позволяет выполнять действия в определение время жизни приложенияCистема экшенов позволяет одинаково запрашивать данные на сервере и в браузере, используя различные фичи (e.g. повторение в браузере экшена, упавшего на сервере) "},{"title":"Разбиение на внешние библиотеки","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#разбиение-на-внешние-библиотеки","content":"При разработке tramvai стараемся использовать уже готовые решения, либо создавать базовые библиотеки, которые никак не связаны с tramvai и могут использовать в других проектах и фреймворках. "},{"title":"DI с интерфейсом взятым с Nest или Angular DI","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#di-с-интерфейсом-взятым-с-nest-или-angular-di","content":"DI это основа tramvai позволяющая уменьшить связанность кода и разделение функциональности на модули. Внутри tramvai используется библиотека dippy которая реализует DI составляющую. Внутренний интерфейс DI повторяет интерфейс Nest, который позволяет удобно описать зависимости и реализации классов. "},{"title":"Возможность мягкого перехода","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#возможность-мягкого-перехода","content":"На www.tinkoff.ru уже было написано миллион+ строк кода и новое решение не должно было ломать имеющийся код, а также требовать от приложений тяжелого и долгого перехода "},{"title":"Почему был разработан:","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#почему-был-разработан","content":""},{"title":"tramvai","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#tramvai","content":"Зачастую React приложения — это конструктор из разных библиотек, которые были подключены в проект. Это хорошо работает на маленьких масштабах, но плохо работает для больших приложений, где работают 70+ разработчиков, так как в таком подходе легко подключить свое и разойтись кардинально в архитектуре приложений. Эту проблему берет на себя tramvai и стандартизирует и реализует общую архитектуру приложений которую используют все продуктовые команды. На github можно найти не так много open source решений, которые реализуют архитектуру больших приложений. Альтернативы# next.js# Один из самых лучших простых фреймворков для React, которые берет на себя проблему с рендерингом приложений на сервере и роутингом. При этом это легковесный фреймворк который никак не стандартизирует и не решает проблемы с модульностью компонентов. Поэтому большинство кода, который был написан на tramvai пришлось бы написать для next.js и пытаться как-то внедрить, так как в next.js очень ограничена возможность расширения функциональности fusionjs# Похожий фремворк, который развивался и появился в одно и тоже время с tramvai. У fusionjs нет полноценного DI, ограниченная возможность вынесения функциональности в модули и вся архитектура построена на основе middlewares, и присутствуют сложности вокруг зашитых приоритетов плагинов и отсутствия параллелизации действий nest.js# Отличный backend фреймворк который использует схожий DI, но полностью не заточен под SSR. И при использовании его, у нас должно было быть 2 архитектуры, одна для бекенда, другая написанная самим под клиент "},{"title":"dippy","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#dippy","content":"Легковесная DI библиотека с Angular подобным интерфейсом. В открытом доступе нет так много различных вариантов DI которые позволяют разделить реализации классов как базовые общие, так и специфичные для каждого клиента. Альтернативы# inversify# Это самая популярная библиотека для создания DI, при этом: весит 11кб, в сравнении dippy 1.2кбнизкоуровневый API который требует различных врапперов для реализации модульной системы.ts-nest это пример враппера над inversify который имеет слабую поддержку и только враппер содержит примерно столько-же кода как и dippy "},{"title":"state","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#state","content":"Встроенная в tramvai библиотека для управления состоянием почти полностью схожа интерфейсом с Redux, при этом: Позволяет подписывать компоненты только на обновление определенных редьюсеров, решая проблему с перфомансомИмеется много кода, написанного с использованием deprecated версии стейта и нельзя просто перейти на другое решение Альтернативы# redux# Переход на чистый redux не решит проблемы, а только добавит связанные с performance reatom# Очень похожая на state-management новая библиотека, в которой решена проблема с обновлениями и performance. Хороший кандидат, с которого можно взять некоторые фичи. Полный переход сильно дорог из-за кодовой базы effector# Интересная библиотека, которая имеет фокус на client side и не очень подходит для SSR "},{"title":"Concepts","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#concepts","content":""},{"title":"Module","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#module","content":"Основные базовые элементы tramvai архитектуры которые содержат в себе реализацию функциональности. При этом предполагается, что такие модули не будут огромными и будет появляться большое количество разных видов. Документация "},{"title":"DI система","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#di-система","content":"tramvai строится на DI системе которая хранит в себе реализации функциональности и получения реализаций по токенам и ключам. Это позволяет реализовать связи между модулями основываясь только на интерфейсах, при этом имея возможность изменять реализации по необходимости. Документация "},{"title":"CommandLineRunner","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#commandlinerunner","content":"Раннер для списка действий, на которые могут навесить действия модули. Списки действий бывают 2 видов: Инициализация приложенияОбработка запроса для клиента В рамках эти списка действий происходит получение роутов, статуса пользователя, рендеринга страницы и отдачи клиенту html. Документация "},{"title":"Диаграммы","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#диаграммы","content":""},{"title":"Принцип работы на серверной стороне","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#принцип-работы-на-серверной-стороне","content":" "},{"title":"Модуль","type":0,"sectionRef":"#","url":"docs/concepts/module","content":"","keywords":""},{"title":"Жизненный цикл модулей","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#жизненный-цикл-модулей","content":""},{"title":"Инициализация приложения","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#инициализация-приложения","content":"При создании приложения происходит обработка всех задекларированных провайдеров, которые попадут в общий DI контейнер. "},{"title":"Обработка запросов клиента","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#обработка-запросов-клиента","content":"Экземпляр модуля создается один раз на сервере (и используется для всех клиентов), после инициализации приложения, и один раз в браузере, после загрузки страницы и инициализации клиентской части. Эти инстансы содержат экземпляры классов, которые были переданы в deps, и будут переданы в конструктор модуля: import { Module } from '@tramvai/core'; @Module({ providers: [], deps: { log: 'log', },})class TestModule { constructor({ log }) { log.info('TestModule created'); }} Скопировать "},{"title":"Пример модуля","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#пример-модуля","content":"Основной функционал модуля находится в списке providers. Каждый провайдер либо добавляет новый функционал, например делает доступным во всех остальных модулях констатное значение New под ключем Token: import { Module, provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: 'Token', useValue: 'New', }), ],})class TestModule {} Скопировать Либо использует токены из других модулей, например добавление нового параметра окружения через токен ENV_USED_TOKEN, который обработает EnvModule: import { Module, provide } from '@tramvai/core';import { ENV_USED_TOKEN } from '@tramvai/module-common'; @Module({ providers: [ provide({ provide: ENV_USED_TOKEN, multi: true, useValue: [ { key: 'ENV_VARIABLE', value: 'New', optional: true, }, ], }), ],})class TestModule {} Скопировать "},{"title":"Импорт в модуле сторонних модулей","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#импорт-в-модуле-сторонних-модулей","content":"Модули могут внутри себя импортировать провайдеры сторонних модулей. Тем самым позволяя строить цепочку взаимосвязанных модулей. Пример кода import { Module } from '@tramvai/core';import { LogModule } from '@tramvai/module-log'; @Module({ providers: [], imports: [LogModule],})class TestModule {} Скопировать В этом случае, при инициализации TestModule, предварительно произойдет инициализация провайдеров из модуля ModuleLogger и вложенных imports, если они присутствуют. "},{"title":"Динамические модули","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#динамические-модули","content":"Конфигурировать модули можно двумя способами, причем оба способа можно использовать одновременно: передача параметров в moduleвозврат параметров в статическом методе forRoot Пример динамического модуля, в котором мы добавим в DI зависимости metaGenerate первым способом и meta-list вторым, причем одна из них зависит от другой: import { Module, provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: 'metaGenerate', useClass: class MetaGenerate {}, deps: { list: 'meta-list', }, }), ],})export class SeoModule { static forRoot({ metaList }: { metaList?: string[] }) { if (metaList) { return { mainModule: SeoModule, providers: [ provide({ provide: 'meta-list', useValue: metaList, }), ], }; } }} Скопировать Статичный метод должен вернуть объект с интерфейсом: type staticModule = { mainModule: Module; // Ссылка на основной модуль, из которого мы вощьмем всю основную информацию providers: Provider[]; // Провайдеры которые будут добавлены в DI}; Скопировать Теперь этот модуль содержит статичный метод forRoot который к стандартному модулю SeoModule добавляет дополнительные providers. Без этой конструкции нам нужно было бы явно прописывать в приложении провайдеры. Все данные, которые были добавлены в SeoModule будут наследованы и расширены. Теперь мы можем в приложении или в других модулях вызвать наш статичный метод. И результат выполнения forRoot будет добавлен в DI import { Module } from '@tramvai/core';import { SeoModule } from './SeoModule';import { metaFromConfig } from './metaFromConfig'; @Module({ imports: [SeoModule.forRoot([metaFromConfig])],})export class ApplicationModule {} Скопировать При этом стоит учитывать, что forRoot конструкция должна только упрощать использование модуля и мы должны так же поддерживать работоспособность модуля через обычное конфигурирование providers "},{"title":"Рекомендации для модулей","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#рекомендации-для-модулей","content":""},{"title":"Низкая связанность","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#низкая-связанность","content":"Желательно модули строить так, что бы они не зависели прямо от других модулей. Связанность только должна происходить на основе интерфейсов и с возможностью замены. Иначе нельзя будет просто заменить модули и произвести рефакторинг "},{"title":"Не большой размер","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#не-большой-размер","content":"Чем больше модуль, тем больше кода он содержит внутри и тем больше потенциально он имеет связей и причин для изменений. По этому причине модуль будет сложнее менять и будет больше шанс для поломки функционала при изменениях. Желательно, что бы модули реализовывали какую-то не большую часть функциональности. "},{"title":"Опциональные зависимости/конфигурирование","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#опциональные-зависимостиконфигурирование","content":"Модулем удобно пользоваться, если он не требует какое либо конфигурирование и по дефолту работает нормально. Но, если понятно, что для некоторых приложений и кейсов нужна будет дополнительная настройка поведения, то желательно использовать опциональные зависимости, которые смогут определить в приложении. Стоит помечать опциональными зависимостями не критичный функционал, который не обязательно нужен модулю. Для того, чтобы можно было не реализовывать интерфейсы и выкинуть часть логики. К примеру, логирование // @todo пример опциональной зависимости Скопировать "},{"title":"Отладка модулей","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#отладка-модулей","content":"Рекомендуется указывать в документации модуля уникальный идентификатор/namespace логгера, который используется в этом модуле. Пример идентификатора модуля для @tramvai/module-server: const log = logger('server'); // получаем экземпляр logger по токену LOGGER_TOKEN Скопировать "},{"title":"Дополнительные ссылки","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#дополнительные-ссылки","content":"Про DI контейнерПро провайдеры "},{"title":"Версионирование","type":0,"sectionRef":"#","url":"docs/concepts/versioning","content":"","keywords":""},{"title":"Сквозное версионирование","type":1,"pageTitle":"Версионирование","url":"docs/concepts/versioning#сквозное-версионирование","content":"Большинство библиотек в tramvai репозитории объединены в сквозное версионирование - это core пакеты, трамвай модули и токены, все что входит в скоупы @tramvai и @tramvai-tinkoff. Релиз и публикация этих библиотек происходит одновременно, даже если изменения затронули только один пакет из списка. Такой подход вы можете увидеть у Angular, и с некоторыми ограничениями, в монорепозиториях использующих Lerna Основной плюс unified версионирования - гарантируется совместимость между пакетами одной версии. Раньше у пользователя был только один способ поднять версию фреймворка, не потеряв совместимость между пакетами - устанавливать все пакеты до их latest версии. Сейчас, можно указать общую целевую версию для каждой tramvai библиотеки, либо использовать команду tramvai update. Один из минусов подхода - любое обновление пакета из списка unified, требует поднять версии и опубликовать все эти пакеты из списка, что значительно замедляет CI. "},{"title":"Хранение версий в релизных тегах","type":1,"pageTitle":"Версионирование","url":"docs/concepts/versioning#хранение-версий-в-релизных-тегах","content":"Одна из причин для хранения версии в релизных тегах - protected ветка master, в которую мы не можем автоматически внести изменения после релиза и обновления версий пакетов. Хранение версий в релизных тегах само по себе не дает преимуществ, и у нас используется вместе со stub версиями пакетов в исходных package.json файлах. Допустим, у нас был пакет с зависимостями: { \"name\": \"@tramvai/foo\", \"version\": \"0.1.0\", \"dependencies\": { \"@tramvai/bar\": \"^1.1.0\", \"@tramvai/baz\": \"^2.0.0\" } } Скопировать Раньше, каждый крупный Merge Request сопровождался конфликтами, если в master ветке обновлялась версии пакетов, а затронутые библиотеки в MR содержали изменения в dependencies. Теперь, наш пакет выглядит так: { \"name\": \"@tramvai/foo\", \"version\": \"0.0.0-stub\", \"dependencies\": { \"@tramvai/bar\": \"0.0.0-stub\", \"@tramvai/baz\": \"0.0.0-stub\" } } Скопировать Версия 0.0.0-stub никогда не вызовет конфликтов слияния, а вычисление реальных версий происходит только в CI - при создании нового релизного тега и публикации, внутри библиотеки pvm. "},{"title":"Contribute","type":0,"sectionRef":"#","url":"docs/contribute/contribute","content":"Contribute Framework tramvai is in the process of incremental migration from our internal repo to open source. Migration consists of several stages: Push synchronization Сurrent stage, automatic mirroring internal releases to Github repository Pull synchronization Next stage, automatic mirroring pull requests from Github repository to our internal repo Full migration Perspective stage, moving source code, and all CI processes (testing, linting, building, publishing, versioning) to Github repository So for now contributors can open any issues and pull requests, but maintainers will need to manually transfer accepted changes to our internal repo.","keywords":""},{"title":"Провайдер","type":0,"sectionRef":"#","url":"docs/concepts/provider","content":"","keywords":""},{"title":"Формат","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#формат","content":"type Provider = { provide: Token | string; // идентификатор провайдера useValue?: any; // реализация идентификатора useFactory?: any; // реализация идентификатора useClass?: any; // реализация идентификатора deps?: Record<string, Token | string>; // список зависимостей которые необходимы провайдеру для работы multi?: boolean; // возможность зарегистрировать множество реализаций провайдеров, если true, при получении значения этого идентификатора, все зарегестрированные значения будут приходить в массиве scope?: 'request' | 'singleton'; // Если singleton, то контейнер зарегестрирует один экземпляр провайдера на все запросы клиента. Если request то будет создавать свой инстанс для каждого клиента и Request}; Скопировать "},{"title":"Разновидности провайдеров","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#разновидности-провайдеров","content":""},{"title":"Class","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#class","content":"При инициализации инстанса произойдет создание класса переданного в useClass, если были заданы deps то класс вызовется с объектом реализаций первым аргументом import { provide } from '@tramvai/core';const provider = provide({ provide: 'token', useClass: class ImplementClass { constructor({ logger }) {} }, deps: { logger: 'logger', },}); Скопировать "},{"title":"Factory","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#factory","content":"При инициализации инстанса произойдет вызов функции переданной в useFactory, если были заданы deps то функция вызовется с объектом реализаций первым аргументом import { provide } from '@tramvai/core';const provider = provide({ provide: 'token', useFactory: ({ logger }) => new Implement(logger), deps: { logger: 'logger', },}); Скопировать "},{"title":"Value","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#value","content":"Устанавливает значение провайдера теми данными, которые были переданы в параметре useValue, не будет производится дополнительная инициализация и нельзя использовать deps import { provide } from '@tramvai/core';const provider = provide({ provide: 'token', useValue: { appName: 'APP' },}); Скопировать "},{"title":"Multi провайдеры","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#multi-провайдеры","content":"Нам может понадобиться возможность регистрации для одного токена множества реализаций. Например, несколько действий для одного шага. Что бы это реализовать, нужно передать параметр multi в провайдер. В таком случае в di контейнере сохраняется массив провайдеров: import { provide } from '@tramvai/core';const providers = [ provide({ provide: 'token', multi: true, useValue: { route: '/' }, }), provide({ provide: 'token', multi: true, useValue: { route: '/cards' }, }),]; Скопировать "},{"title":"Зависимости (deps)","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#зависимости-deps","content":"Нужны для указания зависимостей, которые нужны для работы провайдера. При создании провайдера будут созданы инстансы зависимостей, которые указаны в deps и переданы в провайдер первым аргументом. Ключами объекта deps будут являться реализации, которые попадут в провайдер. При этом, если не будет найден провайдер в глобальном DI, будет выброшена ошибка с уведомлением что текущий токен не найден. "},{"title":"Формат","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#формат-1","content":"type Provider = { deps: { [key: string]: | Token | { token: Token; optional?: boolean; multi?: boolean; }; };}; Скопировать "},{"title":"Опциональные зависимости","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#опциональные-зависимости","content":"Нам не всегда нужны обязательные зависимости для работы. И мы хотим пометить, что зависимость не обязательно для работы и не нужно кидать ошибку. Для этого можно передать параметр optional который отключит выброс ошибки при отсутствии зависимости. Вместо реализации зависимости провайдеру придет значение null. import { provide } from '@tramvai/core';const provider = provide({ provide: 'token', useClass: class A { constructor({ log }) {} }, deps: { log: { token: 'log', optional: true, }, } as const,}); Скопировать "},{"title":"Multi зависимости","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#multi-зависимости","content":"Некоторые провайдеры являются мульти провайдерами и вместо одной реализации, нам придет массив реализаций. Для правильного вывода типов, мы должны передать параметр multi: true, применить as const для deps блока для корректного вывода типов через TS: import { provide } from '@tramvai/core';const provider = provide({ provide: 'token', useClass: class A { constructor({ commands }) { commands.forEach(); } }, deps: { commands: { token: 'commands', multi: true, }, } as const,}); Скопировать "},{"title":"Circular dependency","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#circular-dependency","content":"DI не позволяет объявлять зависимости, которые находятся в зависимости у друг друга, например: import { provide } from '@tramvai/core';const providers = [ provide({ provide: 'A', deps: { B: 'B', }, }), provide({ provide: 'B', deps: { A: 'A', }, }),]; Скопировать В этом примере мы с не сможем коректно создать инстансы провайдеров и код выкинет ошибку. Подобные провайдеры стоит пересмотреть и вынести общую часть в отдельный класс и провайдер и использовать совместно A и B "},{"title":"Scope","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#scope","content":"Опция влияет только на работу контейнера на сервере, на клиенте работает только один общий контейнер, в котором провайдеры с разным скопом хранятся вместе Позволяет создавать синглтон инстансы которые будут общие между множеством клиентов. В стандартном поведение, каждый объявленный провайдер будет автоматически удаляться и пересоздаваться для каждого нового клиента. Этот функционал был сделан для того, чтобы у нас была возможность хранить, как и синглтоны, к примеру кэш, так и различные персонализированные данные. К примеру статус пользователя и персонализацию. По дефолту все провайдеры имеют значение Scope.REQUEST, что означает, что значения провайдера будет создавать для каждого клиента. Исключение составляют провайдеры useValue, которые ведут себя как синглтон. "},{"title":"Интерфейс","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#интерфейс","content":"import { provide } from '@tramvai/core';const provider = provide({ provide: 'Cache', useFactory: Cache, scope: Scope.SINGLETON,}); Скопировать В этом случае, провайдер Cache зарегистрируются как глобальный синглтон, так как был передан параметр scope и будет использоваться единый инстанс для всех пользователей. "},{"title":"Токены (token)","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#токены-token","content":"Токены используются как идентификатор для провайдера в DI. По значению токена происходит регистрация провайдера и поиск реализации. "},{"title":"Интерфейс","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#интерфейс-1","content":"type token = Token | string; Скопировать Токен может быть как строкой, так и специально созданным с помощью функции createToken в который можно передать интерфейс. При этом можно использовать одновременно и строку и createToken, главное то, что бы идентификатор был одинаковым "},{"title":"createToken","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#createtoken","content":"import { createToken } from '@tinkoff/dippy';import { provide } from '@tramvai/core'; const loggerToken = createToken<Logger>('logger'); const provider = provide({ provide: loggerToken, useClass: Logger,}); Скопировать Основное отличие заключается в том, что в createToken можно передать интерфейс реализации, который потом будет использоваться для проверки типов при получение зависимостей и создание провайдеров. "},{"title":"Автоматические миграции","type":0,"sectionRef":"#","url":"docs/features/migration","content":"","keywords":""},{"title":"Зачем нужны миграции","type":1,"pageTitle":"Автоматические миграции","url":"docs/features/migration#зачем-нужны-миграции","content":"Иногда в трамвае бывает необходимость внести какие-то ломающие изменения и чтобы упростить такой переход для конечных пользователей используются автоматические миграции, т.к. миграции позволяют перевести кодовую базу приложения на новую версию интерфейсов в автоматическом режиме и практически без участия разработчиков. "},{"title":"Как использовать миграции","type":1,"pageTitle":"Автоматические миграции","url":"docs/features/migration#как-использовать-миграции","content":"Миграции выполняются автоматически при установке новых версий пакетов трамвая. Для сохранения информации об уже выполненных миграциях используется файл .tramvai-migrate-applied.json в корне проекта. Всё что остается сделать разработчикам приложений: изучить доку по последним миграциям для пакетовзакомитить изменения в файле .tramvai-migrate-applied.json, т.к. в нем сохраняется игформация о выполненных миграциях и лучше его сохранить чтобы не выполнять миграции повторноесли после миграций изменился package.json, то необходимо выполнить установку пакетов чтобы обновился lock файл в проекте.проревьювить и закомитить все остальные изменения которые произошли в проекте (ревью необходимо т.к. в миграции сложно учесть все кейсы использований, а также результат после преобразования кода может не соответсвовать настройкам линтера в текущем проекте).проверить работу приложения на наличие проблем и внести изменения в соответсвии с докой по миграции "},{"title":"Как отключить миграции","type":1,"pageTitle":"Автоматические миграции","url":"docs/features/migration#как-отключить-миграции","content":"Добавить переменную окружения SKIP_TRAMVAI_MIGRATIONS перед запуском установки пакетов. "},{"title":"Как работают миграции","type":1,"pageTitle":"Автоматические миграции","url":"docs/features/migration#как-работают-миграции","content":"@tramvai/core содержит зависимость @tramvai/tools-migrateв @tramvai/tools-migrate содержится скрипт который выполняется на 'postinstall'скрипт выполняет анализ tramvai модулей в 'node_modules' и находим все миграциидальше проверяется файл .tramvai-migrate-applied.json и из него берется список уже выбранных миграций если такой файл естьвыполняется код миграций, которых нет в списке выполненных. Миграции выполняются последовательнов файл .tramvai-migrate-applied.json добавляется информация о только что выполненных миграциях, если файл был до этого, либо этот файл создаётся "},{"title":"Вопросы/ответы","type":1,"pageTitle":"Автоматические миграции","url":"docs/features/migration#вопросыответы","content":""},{"title":"Нужно ли хранить .tramvai-migrate-applied.json в гите","type":1,"pageTitle":"Автоматические миграции","url":"docs/features/migration#нужно-ли-хранить-tramvai-migrate-appliedjson-в-гите","content":"Да, иначе при следующих миграциях мы не будем знать какие миграции уже были выполнены и будут произведены повторные миграции "},{"title":"Papi introduction","type":0,"sectionRef":"#","url":"docs/features/papi/introduction","content":"","keywords":""},{"title":"Explanation","type":1,"pageTitle":"Papi introduction","url":"docs/features/papi/introduction#explanation","content":"Зачастую приложению нужны микросервисы, которые могут обрабатывать запрос пользователей и отдавать JSON ответы. Именно для решения этих кейсов были разработаны PAPI. PAPi позволяет реализовать обработчики запросов которые могут запросить клиенты и получить ответ в произвольном формате, к примеру JSON. PAPI позволяет быстро и дешево реализовать обработчики, не поднимая дополнительные микросервисы. Связанные с papi разделы Как получить данные с papiКак можно получать данные с DI в papi роутахКак добавить новый papi роут в приложении "},{"title":"How to","type":1,"pageTitle":"Papi introduction","url":"docs/features/papi/introduction#how-to","content":""},{"title":"Как получить данные с papi","type":1,"pageTitle":"Papi introduction","url":"docs/features/papi/introduction#как-получить-данные-с-papi","content":"papi доступно за урлом /${appInfo.appName}/papi. Такой урл выбран потому, что бы разделить множество различных papi сервисов на 1 домене приложении. Для примера выше с добавление роута, итоговый урл будет выглядеть так: /${appInfo.appName}/papi/test где appName это название переданное в createApp Что бы сделать запрос, необходимо использовать PAPI_SERVICE из модуля @tramvai/module-http-client который автоматически на клиенте сделает http запрос к papi а на сервере просто вызовет функцию handler "},{"title":"Как можно получать данные с DI в papi роутах","type":1,"pageTitle":"Papi introduction","url":"docs/features/papi/introduction#как-можно-получать-данные-с-di-в-papi-роутах","content":"Для papi-обработчика есть возможность задать зависимости которые требуются ему для работы. При этом для каждого вызова будет создан отдельный дочерний di-container что позволит использовать как SIGNLETON так и REQUEST зависимости. import { Module, provide } from '@tramvai/core';import { CREATE_CACHE_TOKEN } from '@tramvai/module-common';import { HTTP_CLIENT } from '@tramvai/module-http-client';import { SERVER_MODULE_PAPI_PUBLIC_ROUTE } from '@tramvai/module-server';import { createPapiMethod } from '@tramvai/papi'; @Module({ providers: [ provide({ provide: SERVER_MODULE_PAPI_PUBLIC_ROUTE, multi: true, useFactory: ({ createCache }) => { const cache = createCache(); // cache должен быть общий для всез вызовов handler, поэтому вызываем его за пределеами createPapiMethod return createPapiMethod({ path: '/my/papi', method: 'post', async handler({ httpClient }) { // используем то, что запросили в deps из createPapiMethod if (cache.has('test')) { return 'test'; } const { payload } = await httpClient.get('fake'); return payload; }, deps: { httpClient: HTTP_CLIENT, // эту же зависимость надо пересоздать для каждого вызова и они должны быть независимы }, }); }, deps: { createCache: CREATE_CACHE_TOKEN, // это зависимость из рутового контейнера, котоарая будет создана только один раз }, }), ],})export class PapiTestModule {} Скопировать "},{"title":"Как добавить новый papi роут в приложении","type":1,"pageTitle":"Papi introduction","url":"docs/features/papi/introduction#как-добавить-новый-papi-роут-в-приложении","content":"Существует два способа задания роутов. 1 - основываясь на файловой структуре, 2 - задание через провайдеров Используя file api подход# Самый простой способ создать PAPI роут, это создать в корне проекта директорию papi в которую положить TS файлы с обработчиками. Название файлов будет являться урлом до роута. Например: мы хотим создать новый papi обработчик, который читает body запросов и суммирует пришедшие значения. Для этого создаем файл /papi/getSum.ts с содержимым:  содержимое getSum.ts import { Request, Response } from '@tramvai/papi';import { CREATE_CACHE_TOKEN } from '@tramvai/module-common'; // в tramvai.json мы добавили указание на директорию с файловым апи// \"commands\": {// \"build\": {// \"options\": {// \"server\": \"server-add-file-api/index.ts\",// \"serverApiDir\": \"server-add-file-api/papi\"// }// }// }// и теперь каждый файл в этой директории будет обработчиком какого-то урла в зависимости от имени самого файла// /${appName}/papi/${fileName} т.е. для текушего файла урл будет /server/papi/getSum // экспортируя переменную rootDeps мы можем запросить зависимости из рутового DI на сервере// эти записимости будут переданы в handler третьим параметромexport const rootDeps = { createCache: CREATE_CACHE_TOKEN,}; // если зависимости при этом надо как-то изначально проиницилизировать, то можно использовать// mapDeps который будет вызван один раз, получит в качестве аргумента зависимости из deps, и// результат этой функции будет использован вместо третьего аргумента в handlerexport const mapRootDeps = ({ createCache }: typeof rootDeps) => { return { cache: createCache('memory'), };}; // handler это наш обработчик который будет вызываться на каждый запрос// тоже самое будет если сделать export defaultexport const handler = (req: Request, res: Response, { cache }: ReturnType<typeof mapRootDeps>) => { const { body: { a, b }, method, } = req; if (method !== 'POST') { throw new Error('only post methods'); } if (!a || !b) { return { error: true, message: 'body parameters a and b should be set', }; } const key = `${a},${b}`; if (cache.has(key)) { return { error: false, fromCache: true, result: cache.get(key) }; } const result = +a + +b; cache.set(key, result); return { error: false, fromCache: false, result };}; Скопировать  Этот файл можно будет запросить с помощью papi клиента, либо вызвав урл /${appName}/papi/getSum Используя провайдеры# Необходимо добавить multi провайдер SERVER_MODULE_PAPI_PUBLIC_ROUTE в котором добавить новые papi роуты import { createPapiMethod } from '@tramvai/papi';import { SERVER_MODULE_PAPI_PUBLIC_ROUTE } from '@tramvai/tokens-server';import { provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: SERVER_MODULE_PAPI_PUBLIC_ROUTE, multi: true, useValue: createPapiMethod({ method: 'get', // метод, может быть post, all и так далее path: '/test', // путь по которому будет доступен роут async handler(req, res): Promise<any> { // функция которая будет вызываться, если придут запросы на урл return new Promise({ test: true }); }, }), }), ],})export class PapiTestModule {} Скопировать И после этого будет доступен роут test "},{"title":"File-System Pages","type":0,"sectionRef":"#","url":"docs/features/file-system-pages","content":"","keywords":""},{"title":"Explanation","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#explanation","content":""},{"title":"Motivation","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#motivation","content":"By default, you need to provide page components with bundles, then register this components for the corresponding routes, for example: Create bundle with component (used lazy for granular code splitting): const commentsBundle = createBundle({ name: 'comments', components: { 'comments-list': lazy(() => import('./pages/CommentsList')), },}); Скопировать Create static route with this bundle and component: const routes = [ { name: 'comments', path: '/comments/', config: { bundle: 'comments', pageComponent: 'comments-list', }, },]; Скопировать File-System Pages is designed to remove the first step, or even both steps, and make it easier to add new pages to the application. "},{"title":"File-System Pages","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#file-system-pages","content":"The first option is to automatically read page components from the file system and register them inside an application, without need to specify bundle. You can use this components by unique name in route.config.pageComponent property, and the component to be rendered for that route will be automatically wrapped in lazy. Thus, all routes with file-system pages will load only neccesary JS and CSS chunks. For example, you create page components with this file structure: src└── pages ├── index.tsx └── comments.tsx Скопировать This components will be available in the application with these names: @/pages/index@/pages/comments Скопировать and you can create few static pages from them: const routes = [ { name: 'main', path: '/', config: { pageComponent: '@/pages/index', }, }, { name: 'comments', path: '/comments/', config: { pageComponent: '@/pages/comments', }, },]; Скопировать Example application "},{"title":"File-System Routing","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#file-system-routing","content":"Second option is less flexible, but fully automates the creation of routes in the application. Static routes will be generated from file-system pages, and paths for this routes will be created based on paths to components, strictly conforming to naming conventions. For example, you want to handle this urls by your application: //login//comments//comments/:id/ Скопировать In that case you need to create components with this file structure: src└── pages ├── index.tsx ├── login └── index.tsx └── comments ├── index.tsx └── [id] └── index.tsx Скопировать Where path with square brackets relates to dynamic parts of url. File for /login/ page must be named login/index.tsx instead of login.tsx, because we must have strictly one way to convert url back to page component name. Example application "},{"title":"Usage","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#usage","content":"Experimental feature File-System Pages hidden behind the flag commands.build.configurations.experiments.fileSystemPages.enable in tramvai.json configuration file: { \"projects\": { \"your-app-name\" : { \"commands\": { \"build\": { \"configurations\": { \"experiments\": { \"fileSystemPages\": { \"enable\": true, \"pagesDir\": \"pages\", \"routesDir\": \"routes\" } } } } } } }} Скопировать \"enable\": true - activates the feature \"pagesDir\": \"pages\" - default directory for File-System Pages \"routesDir\": \"routes\" - default directory for File-System Routing "},{"title":"Pages","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#pages","content":"You need to use default export in page components, e.g.: const CommentsPage = () => <h1>Comments</h1>; export default CommentsPage; Скопировать "},{"title":"Actions","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#actions","content":"Page components support global actions in actions static property, these actions will work as bundles actions: const CommentsPage = () => <h1>Comments</h1>; CommentsPage.actions = [fetchCommentsListAction]; export default CommentsPage; Скопировать This actions will be code-splitted with page component code. "},{"title":"Reducers","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#reducers","content":"Page components support reducers in reducers static property, these reducers will be registered in application store: const CommentsPage = () => <h1>Comments</h1>; CommentsPage.reducers = [CommentsStore]; export default CommentsPage; Скопировать This reducers will be code-splitted with page component code. "},{"title":"Components","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#components","content":"Page components support additional React components in components static property, this components will be registered in the application: const CommentsPage = () => <h1>Comments</h1>; CommentsPage.components = { 'modal-box': () => <dialog>Modal Box</dialog>,}; export default CommentsPage; Скопировать This components will be code-splitted with page component code. You can directly access these components with PAGE_SERVICE: import { useDi } from '@tramvai/react';import { PAGE_SERVICE } from '@tramvai/tokens-router'; const CommentsPage = () => { const pageService = useDi(PAGE_SERVICE); const ModalBox = pageService.getComponent('modal-box'); return ( <> <h1>Comments</h1> <ModalBox /> </> )} Скопировать "},{"title":"How to","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#how-to","content":""},{"title":"How to change layout component","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#how-to-change-layout-component","content":"When use File-System Pages, at first, add layout component to page components: const CommentsPage = () => <h1>Comments</h1>; CommentsPage.components = { 'comments-layout': CommentsLayout,}; export default CommentsPage; Скопировать then, add this layout to layoutComponent property of appropriate route: const routes = [ { name: 'comments', path: '/comments/', config: { pageComponent: '@/pages/comments', layoutComponent: 'comments-layout', }, },]; Скопировать When use File-System Routing, at this moment you can't change the page layout. "},{"title":"How to create static route with dynamic parameters","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#how-to-create-static-route-with-dynamic-parameters","content":"File-System Routing example Wrap dynamic part of url in square brackets in file path. For /comments/:id/ create page component with this path pages/comments/[id]/index.tsx: src└── pages └── comments └── [id] └── index.tsx Скопировать Dynamic parameter available in current route params. In react components, use useRoute hook: import { useRoute } from '@tramvai/module-router'; const Comment = () => { const route = useRoute(); return ( <li> Current comment id: {route.params.id} </li> );} Скопировать In actions, use PAGE_SERVICE_TOKEN: import { createAction } from '@tramvai/core'; const someAction = createAction({ name: 'someAction', fn: (_, __, { pageService }) => { const route = pageService.getCurrentRoute(); console.log(`Current comment id: ${route.params.id}`); }, deps: { pageService: PAGE_SERVICE_TOKEN, },}); Скопировать "},{"title":"Migration","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#migration","content":"If you want to migrate from bundles to file-system pages, there is few steps: Enable experiments.fileSystemPages.enable option in tramvai.json, and change default folders for safety: { \"fileSystemPages\": { \"enable\": true, \"pagesDir\": \"new-fs-pages\", // file-system pages directory \"routesDir\": false // force disable file-system routing }} Скопировать Split your bundles to components from this bundle src/bundles/someBundle.ts: import { createBundle } from '@tramvai/core';import { lazy } from '@tramvai/react';import { actionFoo, actionBar } from '../actions';import { StoreFoo, StoreBar } from '../reducers';import { CommonComponent } from '../components'; const someBundle = createBundle({ name: 'someBundle', components: { 'pages/foo-page': lazy(() => import('../pages/Foo')), 'pages/bar-page': lazy(() => import('../pages/Bar')), 'components/common': CommonComponent, }, actions: [actionFoo, actionBar], reducers: [StoreFoo, StoreBar],}); export default someBundle; Скопировать you need to create two page components, src/new-fs-pages/foo.tsx and src/new-fs-pages/bar.tsx, with this content: import { lazy } from '@tramvai/react';import { actionFoo, actionBar } from '../actions';import { StoreFoo, StoreBar } from '../reducers';import { CommonComponent } from '../components'; // the same for src/new-fs-pages/bar.tsxconst FooPage = () => { return <h1>Foo Page</h1>;} FooPage.components = { 'components/common': CommonComponent,};FooPage.actions = [actionFoo, actionBar];FooPage.reducers = [StoreFoo, StoreBar]; export default FooPage; Скопировать then update your routes config from: const routes = [ { name: 'foo', path: '/foo/', config: { bundle: 'sameBundle', pageComponent: 'pages/foo-page', }, }, { name: 'bar', path: '/bar/', config: { bundle: 'sameBundle', pageComponent: 'pages/bar-page', }, },] Скопировать to this: const routes = [ { name: 'foo', path: '/foo/', config: { pageComponent: '@/new-fs-pages/foo', }, }, { name: 'bar', path: '/bar/', config: { pageComponent: '@/new-fs-pages/bar', }, },] Скопировать and remove bundle property from createApp "},{"title":"Working with React","type":0,"sectionRef":"#","url":"docs/features/react","content":"","keywords":""},{"title":"Подключение в проекте","type":1,"pageTitle":"Working with React","url":"docs/features/react#подключение-в-проекте","content":"npm i --save @tramvai/react Скопировать "},{"title":"DI","type":1,"pageTitle":"Working with React","url":"docs/features/react#di","content":"При создание компонентов вам может понадобиться получение данных с di для этого есть hook useDi и HoC withDi "},{"title":"useDi","type":1,"pageTitle":"Working with React","url":"docs/features/react#usedi","content":"type useDi = (deps: Record<string, string | Token>) => Record<string, any>; Скопировать type useDi = (dep: string | Token) => any; Скопировать Хук в который мы можем передать как объект с требуемыми зависимостями и нам вернется объект с данными, так и единичный token, где нам вернется результат. При вызове useDi мы получаем данные из di и если мы не нашли данных в di, произойдет ошибка. import React from 'react';import { useDi } from '@tramvai/react'; const MyComponent = () => { const { logger } = useDi({ logger: 'logger' }); // передаем объект const Region = useDi(regionToken); // передаем единичный токен logger.info('text'); return ( <div> Component <Region /> </div> );}; Скопировать "},{"title":"withDi","type":1,"pageTitle":"Working with React","url":"docs/features/react#withdi","content":"type withDi = ( deps: Record<string, string | Token>) => (wrapper: React.ReactElement<any>) => React.ReactElement<any>; Скопировать Хок, который позволяет обернуть любые компоненты, получить данные из DI и передать результат с зависимостями в props компонента import React from 'react';import { withDi } from '@tramvai/react'; @withDi({ logger: LOGGER_TOKEN })class BoxyPage extends Component { render() { this.props.logger.info('text'); return <div>Component</div>; }} Скопировать "},{"title":"useDiContainer","type":1,"pageTitle":"Working with React","url":"docs/features/react#usedicontainer","content":"type useDiContainer = () => DI.Container; Скопировать Получение инстанса DI контейнера который был добавлен в контекст приложения. Лучше не пользоваться этим hook, так как он сильно низкоуровневый и предназначен для разработки новых hook "},{"title":"Error","type":1,"pageTitle":"Working with React","url":"docs/features/react#error","content":"Для обработки ошибок при рендере в React используются Error Boundary. Этот пакет предоставляет свою версию Error Boundary которая залогирует ошибку через общий логгер и отобразит заглушку для обернутого компонента если произошла ошибка. "},{"title":"ErrorBoundary","type":1,"pageTitle":"Working with React","url":"docs/features/react#errorboundary","content":"Error Boundary компонент, который следит за ошибками ниже по дереву и в случае возникшей ошибки рендера залогирует ошибку и отобразит компонент fallbackComponent (передается как пропс, по дефолту это FallbackError из этого пакета) вместо упавшего поддерева рендера. Можно переопределить fallbackComponent через провайдер ERROR_BOUNDARY_FALLBACK_COMPONENT_TOKEN. "},{"title":"FallbackError","type":1,"pageTitle":"Working with React","url":"docs/features/react#fallbackerror","content":"Компонент используемый по умолчанию как заглушка для поддерева в котором призошла ошибка рендера "},{"title":"withError","type":1,"pageTitle":"Working with React","url":"docs/features/react#witherror","content":"Хок оборачивающий компонент в ErrorBoundary. "},{"title":"lazy","type":1,"pageTitle":"Working with React","url":"docs/features/react#lazy","content":"Для динамического импорта компонентов с поддержкой SSR, существует high order компонент lazy: import { lazy } from '@tramvai/react'; const LazyComponent = lazy(() => import('./components/foo'), { loading: <div>Загрузка...</div>,}); <LazyComponent />; Скопировать "},{"title":"Введение","type":0,"sectionRef":"#","url":"docs/features/routing","content":"Введение На нижнем уровне роутинг основан на библиотеке @tinkoff/router, которая предоставляет удобные хуки на все этапы жизненного цикла маршрутизатора. Интеграцией роутера в приложение занимаются специальные модули. Ожидается, что все роуты приложения описаны в админке, но есть возможность задавать статичные роуты на уровне кода приложения. NoSpaRouterModule создает экземпляр роутера, инициализирует стор для маршрутизации и синхронизирует его с роутером, регистрирует экшены, бандлы, валидаторы, редиректы и прочие возможности на соответствующие хуки роутера. SpaRouterModule переключает роутер на использование History API на клиенте. Для использования всех этих возможностей в приложении, достаточно установить и подключить @tramvai/module-router","keywords":""},{"title":"Create event","type":0,"sectionRef":"#","url":"docs/features/state/create-event","content":"","keywords":""},{"title":"Описание метода","type":1,"pageTitle":"Create event","url":"docs/features/state/create-event#описание-метода","content":"createEvent(eventName: string, payloadCreator?: PayloadTransformer): EventCreator eventName - Уникальные индетификатор событияpayloadCreator - не обязательная функция, которая позволяет объединять множество аргументов в один, В случаях, когда эвент был вызван с множеством аргументов. "},{"title":"Примеры","type":1,"pageTitle":"Create event","url":"docs/features/state/create-event#примеры","content":"Создание эвента без параметров# import { createEvent } from '@tramvai/state'; const userLoadingInformation = createEvent('user loading information'); userLoadingInformation(); Скопировать Создание эвента с параметрами# import { createEvent } from '@tramvai/state'; const userInformation = createEvent<{ age: number; name: string }>('user information'); userInformation({ age: 42, name: 'Tom' }); Скопировать Создание эвента с преобразование payload# import { createEvent } from '@tramvai/state'; const itemPrice = createEvent('user information', (info: string, price: number) => ({ [info]: price,})); itemPrice('car', 3000); Скопировать Использование эвентов в экшенах# Мы создаем экшен, в котором после загрузки информации, создаем эвент и кидаем его в context.dispatch import { createAction } from '@tramvai/core';import { createEvent } from '@tramvai/state'; const userInformation = createEvent < { age: number, name: string } > 'user information'; const action = createAction({ name: 'userLoadInformation', fn: async (context) => { const result = await tinkoffRequest({ method: 'information' }); context.dispatch(userInformation(result)); },}); Скопировать "},{"title":"API","type":0,"sectionRef":"#","url":"docs/features/react-query/api","content":"","keywords":""},{"title":"Explanation","type":1,"pageTitle":"API","url":"docs/features/react-query/api#explanation","content":"Для работы библиотеки необходимо, чтобы в tramvai-приложение был добавлен модуль @tramvai/module-react-query "},{"title":"Api","type":1,"pageTitle":"API","url":"docs/features/react-query/api#api","content":""},{"title":"createQuery","type":1,"pageTitle":"API","url":"docs/features/react-query/api#createquery","content":"Позволяет создать объект Query который позже можно будет использовать в компонентах с помощью useQuery. Используется для выполнения единичных запросов на получение данных. import { createQuery } from '@tramvai/react-query'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get('api/base'); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); Скопировать Уникальные параметры запроса# Для создания общей query, принимающий параметры для запроса, необходимо возвращать уникальный key, подробнее об этом можно почитать в разделе официальной документации Query Keys В качестве параметра key можно использовать: строку, например key: 'query-name'массив, где в качестве элементов можно использовать любые сериализуемые данные, например key: ['query-name', false, { bar: 'baz }]функция, которая принимает параметры, с которыми вызвана query, и возвращает строку - key: (options) => 'query-name'функция, которая принимает параметры, с которыми вызвана query, и возвращает массив, где в качестве элементов можно использовать любые сериализуемые данные - key: (options) => ['query-name', options, { bar: 'baz }] import { createQuery, useQuery } from '@tramvai/react-query'; const query = createQuery({ key: (id: number) => ['user', id], fn: async (id, { apiClient }) => { const { payload } = await apiClient.get(`api/user/${id}`); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); export function Component({ id }) { const { data, isLoading } = useQuery(query, id); return <div>{isLoading ? 'loading...' : data}</div>;} Скопировать "},{"title":"useQuery","type":1,"pageTitle":"API","url":"docs/features/react-query/api#usequery","content":"React-хук для работы с объектом Query Документация из react-query import { useQuery } from '@tramvai/react-query'; export function Component() { const { data, isLoading } = useQuery(query); return <div>{isLoading ? 'loading...' : data}</div>;} Скопировать "},{"title":"createInfiniteQuery","type":1,"pageTitle":"API","url":"docs/features/react-query/api#createinfinitequery","content":"Позволяет создать объект InfiniteQuery который позже можно будет использовать в компонентах с помощью useInfiniteQuery. Используется для выполнения запросов на получение последовательности данных, которые можно подгружать по мере работы компонента. import { createInfiniteQuery } from '@tramvai/react-query'; const query = createInfiniteQuery({ key: 'list', fn: async (_, start = 0, { apiClient }) => { const { payload } = await apiClient.get<Response>('api/list', { query: { count: 30, start, }, }); return payload; }, getNextPageParam: (page: Response) => { return page.nextPage; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); Скопировать "},{"title":"useInfiniteQuery","type":1,"pageTitle":"API","url":"docs/features/react-query/api#useinfinitequery","content":"React-хук для работы с объектом InfiniteQuery Документация из react-query import { useInfiniteQuery } from '@tramvai/react-query'; export function Component() { const { data, isLoading, fetchNextPage, hasNextPage } = useInfiniteQuery(query); if (isLoading) { return 'loading...'; } return ( <div> <div> {data.pages.map((page) => { return page.list.map((entry) => { return <div key={entry}>{entry}</div>; }); })} </div> {hasNextPage && ( <button type=\"button\" onClick={() => fetchNextPage()}> Load more </button> )} </div> );} Скопировать "},{"title":"createMutation","type":1,"pageTitle":"API","url":"docs/features/react-query/api#createmutation","content":"Позволяет создать объект Mutation который позже можно будет использовать в компонентах с помощью useMutation. Используется для отправки и изменения данных в апи. import { createMutation } from '@tramvai/react-query'; const mutation = createMutation({ key: 'post', fn: async (_, data: string, { apiClient }) => { const { payload } = await apiClient.post('api/post', { body: { data, }, }); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); Скопировать "},{"title":"useMutation","type":1,"pageTitle":"API","url":"docs/features/react-query/api#usemutation","content":"React-хук для работы с объектом Mutation Документация из react-query import { useMutation } from '@tramvai/react-query'; export function Component() { const { isLoading, mutate } = useMutation(mutation); if (isLoading) { return 'loading...'; } return ( <button type=\"button\" onClick={() => mutate('test')}> Send data </button> );} Скопировать "},{"title":"How-to","type":1,"pageTitle":"API","url":"docs/features/react-query/api#how-to","content":"Примеры использования @tramvai/react-query "},{"title":"Create reducer","type":0,"sectionRef":"#","url":"docs/features/state/create-reducer","content":"","keywords":""},{"title":"Описание метода","type":1,"pageTitle":"Create reducer","url":"docs/features/state/create-reducer#описание-метода","content":"createReducer(name, initialState) name - уникальное название редьюсера. Не должно пересекаться с другими редьюсерамиinitialState - состояние редьюсера по умолчанию "},{"title":"Типизация","type":1,"pageTitle":"Create reducer","url":"docs/features/state/create-reducer#типизация","content":"По умолчанию, тип стейта редьюсера, и его название, выводятся автоматически: import { createReducer } from '@tramvai/state'; const userReducer = createReducer('user', { name: 'anonymus' }); Скопировать Зачем вообще нужна типизация для названия редьюсера? Тогда этот редьюсер будет удобнее использовать вместе с useSelector. Если передавать тип стейта вручную, желательно указать и название вторым аргументом дженерика: import { createReducer } from '@tramvai/state'; type UserState = { name: string }; const userReducer = createReducer<UserState, 'user'>('user', { name: 'anonymus' }); Скопировать Но, можно просто задать нужный тип для initialState: import { createReducer } from '@tramvai/state'; type UserState = { name?: string }; const userReducer = createReducer('user', {} as UserState); Скопировать "},{"title":"Подписка на эвенты","type":1,"pageTitle":"Create reducer","url":"docs/features/state/create-reducer#подписка-на-эвенты","content":".on(evnet, reducer) При создании редьюсера становится доступным метод .on который позволяет подписаться на события и вернуть новый стейт event - эвент или строка, на которые будет подписан редьюсерreducer(state, payload) - чистая функция которая принимает текущий state, payload из события и должен вернуть новое состояние редьюсера Пример использования .on метода import { createReducer, createEvent } from '@tramvai/state'; export const userLoadInformation = createEvent < { status: string } > 'user load information';export const userAddInformation = createEvent < { name: string, info: {} } > 'user add information'; const userReducer = createReducer('user', { info: {},}) .on(userLoadInformation, (state, info) => ({ info })) .on(userAddInformation, (state, { name, info }) => ({ ...state, state: { ...state.info, [name]: info, }, })); Скопировать "},{"title":"Автоматическое создание эвентов","type":1,"pageTitle":"Create reducer","url":"docs/features/state/create-reducer#автоматическое-создание-эвентов","content":".createEvents(model) метод который позволяет убрать необходимость в создании и явном привязывании эвентов model - объект, в котором ключ это идентификатор эвента, который потом будет передан в createEvent, а значение это функция редьюсера, которая попадет в метод .on() и будет вызываться при срабатывании эвентов Пример использования .createEvents метода import { createReducer } from '@tramvai/state'; const userReducer = createReducer('user', { info: {},});export const { userLoadInformation, userAddInformation } = userReducer.createEvents({ userLoadInformation: (state, info: { status: string }) => ({ info }), userAddInformation: (state, { name, info }: { name: string; info: {} }) => ({ ...state, state: { ...state.info, [name]: info, }, }),}); Скопировать Обязательно необходимо описать типы payload аргумента в редьюсерах, иначе не будет работать вывод типов для эвентов. "},{"title":"DevTools","type":0,"sectionRef":"#","url":"docs/features/state/dev-tools","content":"","keywords":""},{"title":"Возможные проблемы","type":1,"pageTitle":"DevTools","url":"docs/features/state/dev-tools#возможные-проблемы","content":"Для лучшего пользовательского опыта необходимо использовать отдельное окно расширения redux dev tools, а не вкладку в chrome developer tools, т.к. иначе не сохраняется история экшнов issue. "},{"title":"Производительность","type":1,"pageTitle":"DevTools","url":"docs/features/state/dev-tools#производительность","content":"Так как весь стейт приложения со всеми экшенами довольно большой, то наблюдаются ощутимые тормоза при работе с девтулз при использовании прыжков по состояниям\\событиям и при одновременном срабатывании большого количества экшнов. Поэтому: Используйте техники кастомизации для задания pickState для уменьшения размера данных в девтулзах.Увеличьте значение параметра latency (передается в connectViaExtension.connect), который по сути делает debounce на посылку actions в расширение docs "},{"title":"Дополнительный материал","type":1,"pageTitle":"DevTools","url":"docs/features/state/dev-tools#дополнительный-материал","content":"Репозиторий с devtoolsGetting Started with Redux DevTools Extension  "},{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/features/state/overview","content":"","keywords":""},{"title":"Особенности","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#особенности","content":"Redux-like стейт-менеджерВстроенная библиотека, похожая на redux-act, для уменьшения boilerplate кодаСодержит привязки к react компонентам, такие как connect и useSelectorДинамическая инициализация редьюсеров. Можно в любое время зарегистрировать редьюсер или сгенерировать новый.Точечные подписки на изменения состояний редьюсеров. При изменении данных повторно пересчитываются только затронутые connect и useSelector, а не все.Поддержка SSR режима. "},{"title":"Основные концепции","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#основные-концепции","content":"Стор - Класс, который содержит состояние всех редьюсеров, подписки на изменения и создается для каждого клиентаРедьюсеры - сущности в которых мы описываем то, как будут храниться и преобразовываться данныеЭвенты - события, с помощью которых можно изменить состояния редьюсеровЭкшены - функции, которые позволяют выполнять сайд-эффекты и обновлять данные в сторе. Похожи на redux-thunk "},{"title":"Рекомендации","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#рекомендации","content":"Нельзя мутировать данные в редьюсерах. Иначе из-за различных оптимизаций не произойдёт оповещение подписчиков о измененияхИнициализировать редьюсеры как можно раньше и до его использования. Иначе при вызове dispatch(userLoadInformation()) редьюсер еще не будет отслеживать события и не получит данные.Не хранить статичные данные в сторах. Так как эти данные будут передаваться с сервера на клиент, то данные задублируются. Лучше вынести в константы.Разбивать на небольшие редьюсеры. Иначе у нас появляется огромный редьюсер, который содержит большое количество информации и любые изменения будут вызывать перерасчеты для большого количества компонентов. "},{"title":"Установка","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#установка","content":"npm i --save @tramvai/state Скопировать "},{"title":"Базовый пример","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#базовый-пример","content":"import { createReducer, createEvent } from '@tramvai/state'; export const userLoadInformation = createEvent('user load information');export const userAddInformation = createEvent('user add information'); const userReducer = createReducer('user', { info: {},}) .on(userLoadInformation, (state, info) => ({ info })) .on(userAddInformation, (state, { name, info }) => ({ ...state, state: { ...state.info, [name]: info, }, })); Скопировать "},{"title":"React hooks","type":0,"sectionRef":"#","url":"docs/features/state/hooks","content":"","keywords":""},{"title":"useActions","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#useactions","content":"Позволяет исполнять трамвайные экшены в React компонентах "},{"title":"Интерфейс","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#интерфейс","content":"actions - один или массив трамвайных экшенов Если передавать в useActions массив, для типизации требуется указать as const - useActions([] as const) "},{"title":"Использование","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#использование","content":"import { useActions } from '@tramvai/state';import { loadUserAction, getInformationAction, setInformationAction } from './actions'; export const Component = () => { // если передавать один экшен, тип payload для loadUser выводится автоматически const loadUser = useActions(loadUserAction); // если передавать список экшенов, `as const` необходим для корректного вывода типов const [getInformation, setInformation] = useActions([ getInformationAction, setInformationAction, ] as const); return ( <div> <div onClick={loadUser}>load user</div> <div onClick={getInformation}>get information</div> <div onClick={() => setInformation({ user: 1 })}>set information</div> </div> );}; Скопировать "},{"title":"useSelector()","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#useselector","content":"Получение данных со стора в компонентах "},{"title":"Интерфейс","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#интерфейс-1","content":"stores: [] - список токенов на которые будет подписан селектор. Будет влиять на то, какие изменения в сторах вызовут обновление в компонентеselector: (state) => any - сам селектор, это функция, которая будет вызвана при инициализации и любых изменениях сторов переданных в stores. Функция должна вернуть данные которые можно будет использовать в компонентеequalityFn?: (cur, prev) => boolean - не обязательная функция для изменения способа сравнения прошлых и новых значений селектора "},{"title":"Использование","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#использование-1","content":"Для получения данных из стора, можно использовать имя стора, ссылку на стор, или объект с опциональным стором: 'storeName'storeObject{ store: storeObject, optional: true }{ store: 'storeName', optional: true } Можно передавать массив ключей, тогда для корректного вывода типов лучше использовать as const: useSelector(['fooStoreName', barStoreObject] as const, ({ foo, bar }) => null); import { useSelector } from '@tramvai/state'; export const Component = () => { const isBrowser = useSelector('media', (state) => state.media.isBrowser); return <div>{isBrowser ? <span>Browser</span> : <span>Desktop</span>}</div>;}; Скопировать "},{"title":"Оптимизации","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#оптимизации","content":"Для того, чтобы уменьшить количество перерисовок компонентов после каждого вызова selector проверяются возвращаемые значения с теми, которые были раньше. Если возвращаемые данные селектора не изменились, то компонент не будет перерисован. По этой причине, в селекторах лучше получать небольшие куски информации. Тогда меньше шанс, что компонент обновится. К примеру: нам нужны roles пользователя, мы пишем селектор, который запрашивает все данные пользователя (state) => state.user и теперь любые изменения редьюсера user будут обновлять компонент. Лучше, если мы будем получать только необходимые данные (state) => state.user.roles в таком случае перерисовываться компонент будет только тогда, когда изменятся roles пользователя "},{"title":"useStoreSelector","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#usestoreselector","content":"Упрощенная версия хука useSelector, в который можно передать только один стор, созданный через createReducer. Сделан был для улучшения вывода типов селекторов, так как сам useSelector не может этого делать из-за использования внутри строковых имен сторов, токенов и наследников BaseStore "},{"title":"Интерфейс","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#интерфейс-2","content":"store: Reducer - Стор, созданный через createReducerselector: (state) => any - сам селектор, это функция, которая будет вызвана при инициализации и любых изменениях стора, переданного в stores. Функция должна вернуть данные которые можно будет использовать в компоненте "},{"title":"Использование","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#использование-2","content":"import { useStoreSelector } from '@tramvai/state';import { createReducer } from '@tramvai/state'; const myStore = createReducer('myStore', { id: '123' }); export const Component = () => { const id = useStoreSelector((myStore, (state) => state.id)); // Корректно выведется тип id как \"string\" return <div>{id}</div>;}; Скопировать "},{"title":"Оптимизации","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#оптимизации-1","content":"Хук является оберткой над useSelector, поэтому оптимизации аналогичны. Сама функция селектора внутри мемоизируется "},{"title":"useStore","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#usestore","content":"Хук для получения состояния конкретного редьюсера. Особенности: автоматически выводит тип состоянияперерендеривает компонент только при обновлении редьюсерапозволяет создавать редьюсеры \"на лету\" "},{"title":"Интерфейс","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#интерфейс-3","content":"store: Reducer - Стор, созданный через createReducer "},{"title":"Использование","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#использование-3","content":"Базовый пример: import { useStore } from '@tramvai/state';import { createReducer } from '@tramvai/state'; const userReducer = createReducer('user', { id: '123' }); export const Component = () => { const { id } = useStore(userReducer); return <div>{id}</div>;}; Скопировать "},{"title":"Static HTML Export","type":0,"sectionRef":"#","url":"docs/features/static-html-export","content":"","keywords":""},{"title":"Explanation","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#explanation","content":"tramvai static <appName> command run production build of the application, then starts application server, and make requests to all application routes. All responses are saved to .html files inside dist/static directory. This feature is suitable for applications where all pages are independent of dynamic server-side data. You can serve exported HTML files without tramvai server by CDN or any static server. "},{"title":"Usage","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#usage","content":""},{"title":"Development","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#development","content":"Run command to export HTML pages with --serve flag: tramvai static <appName> --serve Скопировать Open server with exported pages at http://localhost:3000/ "},{"title":"Production","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#production","content":"Run command to export HTML pages: tramvai static <appName> Скопировать Deploy HTML pages to your server and static assets to your CDN "},{"title":"Static Assets","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#static-assets","content":"All static resources (js, css files) will be loaded according to the url specified in ASSETS_PREFIX env variable. "},{"title":"Limitations","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#limitations","content":"Dynamic pages (routes like /foo/bar/:id) is not supported, tramvai static command only show warnings for this pages. "},{"title":"Структура проекта","type":0,"sectionRef":"#","url":"docs/get-started/app-structure","content":"","keywords":""},{"title":"Тип репозитория","type":1,"pageTitle":"Структура проекта","url":"docs/get-started/app-structure#тип-репозитория","content":"Multirepo# Структура репозитория рассчитана на одно приложение root-directory├── package.json - описание зависимостей проекта├── tramvai.json - конфигурация проекта для `@tramvai/cli`├── env.development.js - переменные окружения, использующиеся при локальных сборках проекта├── renovate.json - настройки для renovatebot, который автоматически создает MR в проекты, при наличии свежих мажорных обновлений зависимостей├── README.md - документация по проекту└── src - директория с кодом приложения └── ...App block Скопировать Monorepo# Структура репозитория рассчитана на наличие нескольких приложений, и отдельных общих библиотек root-directory├── package.json - описание зависимостей проекта├── tramvai.json - конфигурация проекта для `@tramvai/cli`├── env.development.js - переменные окружения, использующиеся при локальных сборках проекта├── renovate.json - настройки для renovatebot, который автоматически создает MR в проекты, при наличии свежих мажорных обновлений зависимостей├── README.md - документация по проекту├── apps - директория с приложениями│ ├── App block│ ├── App block└── packages - директория с различными библиотеками/модулями, которые будут общими между приложениями ├── Lib block └── Lib block Скопировать "},{"title":"Блоки","type":1,"pageTitle":"Структура проекта","url":"docs/get-started/app-structure#блоки","content":"Приложение# app-directory├── index.ts - стартовая точка для приложения├── vendor.ts - описание vendor зависимостей приложения (по умолчанию react и react-dom)├── polyfill.ts - используемые полифилы приложением (отсутствует по умолчанию)├── postcss.js - базовый набор настроек для postcss├── bundles - список подключенных бандлов в приложении├── components - директория с используемыми компонентами приложением│ ├── features - фича-компоненты│ └── shared - общие компоненты├── layers│ ├── layout - глобальные врапперы которые используются в роутинге│ ├── pages - компоненты страницы которые используются в роутинге├── modules - кастомные модули написанные для приложения (отсутствует по умолчанию)└── reducers - глобальные редьюсеры, эвенты и селекторы (отсутствует по умолчанию) Скопировать "},{"title":"Дополнительные ссылки","type":1,"pageTitle":"Структура проекта","url":"docs/get-started/app-structure#дополнительные-ссылки","content":"Следующие ссылки содержат подробные определения терминов бандл, модуль и описание настроек tramvai.json МодульБандлНастройки Tramvai CLI "},{"title":"Список обязательных модулей","type":0,"sectionRef":"#","url":"docs/get-started/core-modules","content":"","keywords":""},{"title":"Подключение нового модуля","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#подключение-нового-модуля","content":"Подключение модуля в приложение состоит из двух шагов: Установка модуля# npm install @tramvai/module-common Скопировать Добавление в приложение# import { CommonModule } from '@tramvai/module-common'; createApp({ name: 'new-app', modules: [ CommonModule, // ... ], // ...}); Скопировать "},{"title":"CommonModule","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#commonmodule","content":"Самый основной модуль, который должен подключаться всегда и при этом должен быть выставлен самым первым в списке модулей (позиция модуля определяет приоритет провайдеров попадающих в DI - чем модуль ниже тем выше приоритет его провайдеров, поэтому наличие CommonModule в качестве первого модуля позволит другим модулям переопределить какую-либо базовую функциональность tramvai). Содержит в себе: реализацию экшеновменеджер бандловменеджер кешей в приложениираннер коммандрегистр компонентов приложенияконтекстбазовый логгерменеджер модулейpubsubменеджер запроса и ответа на сервереstate-manager "},{"title":"RenderModule","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#rendermodule","content":"Модуль отвечающий за рендер приложения. Рендерит приложение React на сервере и полностью собирает html-страницу. На клиенте гидрирует верстку при первом рендере и обновляет рендер при изменениях роута приложения. "},{"title":"RouterModule","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#routermodule","content":"Роутинг приложения: позволяет получить информацию о текущем роуте, делать спа-переходы и т.п. Используется другими модулями для своей работы (например, RenderModule использует его для определения какие компоненты надо сейчас рендерить). Позволяет задавать фиксированные роуты в приложении через метод RouterModule.forRoot. Если фиксированные роуты не заданы, то для работы потребуется модуль ApiClientModule для загрузки данных из админки. "},{"title":"ServerModule","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#servermodule","content":"Модуль стартующий сервер на основе express. Также добавляет работу с papi методами "},{"title":"HttpClientModule","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#httpclientmodule","content":"Модуль для работы с HTTP запросами. "},{"title":"ErrorIntercepterModule (optional)","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#errorinterceptermodule-optional","content":"Добавляет перехват глобальных ошибок и логгирование таких ошибок. "},{"title":"LogModule (optional)","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#logmodule-optional","content":"Не является обязательным т.к. заменяет реализацию из CommonModule. Однако с этим модулем логи будут лучше форматироваться, фильтроваться и будет возможность отправлять логи с клиента на апи логов. "},{"title":"SeoModule (optional)","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#seomodule-optional","content":"Добавляет мета теги на страницу, на основании роута или явно заданных данных в приложении. "},{"title":"CacheWarmupModule (optional)","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#cachewarmupmodule-optional","content":"Модуль для прогрева кешей на сервере при запуске приложения в проде. "},{"title":"Дополнительные ссылки","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#дополнительные-ссылки","content":"Следующие ссылки содержат описания терминов экшен, внедрение зависимостей и управление состоянием ЭкшенDependency InjectionState management "},{"title":"Создаем приложение на tramvai","type":0,"sectionRef":"#","url":"docs/get-started/create-app","content":"","keywords":""},{"title":"Настройка системы","type":1,"pageTitle":"Создаем приложение на tramvai","url":"docs/get-started/create-app#настройка-системы","content":"Для работы tramvai и @tramvai/cli необходим NodeJS версии 10+ "},{"title":"Установка tramvai CLI","type":1,"pageTitle":"Создаем приложение на tramvai","url":"docs/get-started/create-app#установка-tramvai-cli","content":"Мы будем использовать tramvai CLI для генерации нового проекта и запуска в режиме разработки npm i @tramvai/cli -g Скопировать После этого в терминале будет доступна команда tramvai "},{"title":"Генерация приложения","type":1,"pageTitle":"Создаем приложение на tramvai","url":"docs/get-started/create-app#генерация-приложения","content":"Теперь нам нужно сгенерировать приложение с помощью tramvai tramvai new new-app Скопировать После запуска, необходимо выбрать настройки - шаблон проекта, настройки CI и пакетный менеджер. Для быстрого старта подойдут настройки по умолчанию. Затем команда сгенерирует в директории new-app стартовый проект с базовыми модулями "},{"title":"Запуск приложения","type":1,"pageTitle":"Создаем приложение на tramvai","url":"docs/get-started/create-app#запуск-приложения","content":"Теперь нам нужно запустить наш проект в режиме разработки, для удобной разработки и проверки, что наш проект работает. Для этого выполняем команду cd new-app && npm start Скопировать Эта команда запустит в dev режиме сервер который будет следить за серверным и клиентским кодом. После выполнения команды можно зайти по адресу http://localhost:3000/ и увидеть поднятое чистое приложение "},{"title":"Разбора структуры проекта и процесса инициализации приложения","type":1,"pageTitle":"Создаем приложение на tramvai","url":"docs/get-started/create-app#разбора-структуры-проекта-и-процесса-инициализации-приложения","content":"Стартовой точкой проекта является src/index.ts, который создает экземпляр tramvai приложения и подключает необходимые для работы модули. В проекте уже подключены базовые модули, которые реализуют следующий функционал: Получение роутов (из админки или статичных роутов)Рендеринг приложения на сервере и клиентеЗапуск сервера для приложенияПредоставление сервисов для работы с внешними\\внутренним API При этом не обязательно использовать модули из базового набора tramvai, можно написать свои реализации которые реализуют интерфейсы базовых модулей При старте приложения происходит инициализация зависимостей модули и начинают выполнятся команды из цепочки действий, во время которых происходят запросы данных из API, рендеринг, etc. "},{"title":"Дополнительные ссылки","type":1,"pageTitle":"Создаем приложение на tramvai","url":"docs/get-started/create-app#дополнительные-ссылки","content":"По ссылкам можно ознакомиться со структурой проекта и базовыми модулями, необходимыми для полноценной работы приложения. Структура проектаОбязательные модули "},{"title":"Tramvai integration","type":0,"sectionRef":"#","url":"docs/features/state/tramvai-integration","content":"","keywords":""},{"title":"Провайдеры","type":1,"pageTitle":"Tramvai integration","url":"docs/features/state/tramvai-integration#провайдеры","content":"Модуль @tramvai/module-common подключает StateModule, который делает доступным в приложении провайдер STORE_TOKEN, реализующий все возможности управления стейтом: type Store = { dispatch(event); subscribe(listener); subscribe(reducer, listener); getState(); getState(reducer);} Скопировать "},{"title":"Изменение состояния","type":1,"pageTitle":"Tramvai integration","url":"docs/features/state/tramvai-integration#изменение-состояния","content":"Метод store.dispatch() используется для изменения состояния, например: import { commandLineListTokens } from '@tramvai/core';import { createEvent, createReducer } from '@tramvai/state';import { STORE_TOKEN } from '@tramvai/tokens-common'; const incEvent = createEvent('inc');const countReducer = createReducer('count', 0).on(inc, (state) => state + 1); const provider = { provide: commandLineListTokens.resolveUserDeps, multi: true, useFactory: ({ store }) => { return function updateCountReducer() { store.dispatch(incEvent()); }; }, deps: { store: STORE_TOKEN, },} Скопировать "},{"title":"Чтение состояния","type":1,"pageTitle":"Tramvai integration","url":"docs/features/state/tramvai-integration#чтение-состояния","content":"Метод store.getState() используется для получения общего состояния, или состояния конкретного редьюсера. Использование store.getState(reducer) не подходит для опциональных сторов - если вы не уверены, что стор подключается в приложении напрямую или через модули, используйте const { storeName = defaultValue } = store.getState() Пример: import { commandLineListTokens } from '@tramvai/core';import { createEvent, createReducer } from '@tramvai/state';import { STORE_TOKEN } from '@tramvai/tokens-common'; const userReducer = createReducer('user', {}); const provider = { provide: commandLineListTokens.resolveUserDeps, multi: true, useFactory: ({ store }) => { return function readUserState() { // { user: {} } - получаем все состояние const state = store.getState(); // user: {} - получаем состояние конкретного редьюсера const user = store.getState(userReducer); }; }, deps: { store: STORE_TOKEN, },} Скопировать "},{"title":"Подписка","type":1,"pageTitle":"Tramvai integration","url":"docs/features/state/tramvai-integration#подписка","content":"Метод store.subscribe() используется для подписки на изменение глобального состояния, например: import { commandLineListTokens } from '@tramvai/core';import { createEvent, createReducer } from '@tramvai/state';import { STORE_TOKEN } from '@tramvai/tokens-common'; const incEvent = createEvent('inc');const countReducer = createReducer('count', 0).on(inc, (state) => state + 1); const provider = { provide: commandLineListTokens.resolveUserDeps, multi: true, useFactory: ({ store }) => { return function listenCountState() { let currentState = store.getState(countReducer); const unsubscribe = store.subscribe((nextGlobalState) => { const nextState = store.getState(countReducer); if (currentState !== nextState) { console.log('count reducer state is:', currentState); currentState = nextState; } }); setInterval(() => { store.dispatch(incEvent()); }, 1000); }; }, deps: { store: STORE_TOKEN, },} Скопировать Или для подписки на изменение состояния конкретного редьюсера: import { commandLineListTokens } from '@tramvai/core';import { createEvent, createReducer } from '@tramvai/state';import { STORE_TOKEN } from '@tramvai/tokens-common'; const incEvent = createEvent('inc');const countReducer = createReducer('count', 0).on(inc, (state) => state + 1); const provider = { provide: commandLineListTokens.resolveUserDeps, multi: true, useFactory: ({ store }) => { return function listenCountState() { const unsubscribe = store.subscribe(countReducer, (nextState) => { console.log('count reducer state is:', nextState); }); setInterval(() => { store.dispatch(incEvent()); }, 1000); }; }, deps: { store: STORE_TOKEN, },} Скопировать "},{"title":"Экшены","type":1,"pageTitle":"Tramvai integration","url":"docs/features/state/tramvai-integration#экшены","content":"Модуль @tramvai/module-common подключает в приложении провайдер CONTEXT_TOKEN, которые помимо работы с состоянием (под капотом используется STORE_TOKEN), позволяет запускать экшены: type ConsumerContext = { executeAction(action, payload); dispatch(event); subscribe(listener); getState(); getState(reducer);} Скопировать Пример использования контекста: import { createAction } from '@tramvai/core';import { createEvent, createReducer } from '@tramvai/state'; const loadUser = createEvent('load user');const userReducer = createReducer('user', { name: 'anonymus' }); userReducer.on(loadUser, (state, payload) => payload); const fetchUserAction = createAction({ name: 'fetchUser', fn: async (context, payload, { httpClient }) => { const { name } = context.getState(userReducer); if (name !== 'anonymus') { return; } const response = await httpClient.get('/user'); context.dispatch(loadUser(response.payload)); }, deps: { httpClient: HTTP_CLIENT, },}); Скопировать "},{"title":"Оптимизация бандла","type":0,"sectionRef":"#","url":"docs/guides/bundle-optimization","content":"","keywords":""},{"title":"Code Splitting","type":1,"pageTitle":"Оптимизация бандла","url":"docs/guides/bundle-optimization#code-splitting","content":"Предоставление клиенту минимально необходимого JavaScript кода является одной из самый важных вещей в оптимизации web-приложений. Разделение точек входа при сборке бандлов и динамический import модулей, и использование этих банлов на основе роутинга / пользовательских действий - основные механизмы разделения кода. При сборке множества бандлов и динамических чанков возникает проблема дублирования кода между ними, которую позволяет решить SplitChunksPlugin Tramvai приложения имеют ряд особенностей - единая точнка входа (platform.js на выходе), динамический импорт на уровне каждого bundle, отдельная сборка vendor чанка. Для приложения, имеющего несколько tramvai бандлов под разные страницы, каждая страница будет загружать как минимум чанк platform.js с общим кодом фреймворка и модулей, и чанк {bundleName}.js с уникальным кодом для страницы. Дубликаты могут быть в чанках, созданных под tramvai бандлы (например компоненты ui-kit), и этот код желательно вынести в общие чанки. CLI предлагает три стратегии для разделения кода - один общий common чанк, множество granular чанков, и отключение SplitChunksPlugin. "},{"title":"Отключение SplitChunksPlugin","type":1,"pageTitle":"Оптимизация бандла","url":"docs/guides/bundle-optimization#отключение-splitchunksplugin","content":"Для приложений, которые имеют только один tramvai бандл на все страницы, либо разделяют бандл для десктопной и мобильной версии, в большинстве случаев не требуется разделение кода, и стоит выставить опцию \"commonChunk\": false: { \"projects\": { \"{appName}\": { \"commands\": { \"build\": { \"configurations\": { \"commonChunk\": false } } } } }} Скопировать Почему не оставить common чанк, если он не мешает? Проблема в сторонных библиотеках, которые могут использовать динамический import под капотом, при этом приложение может не использовать этот код, но он может попасть в common чанк, который будет загружаться на каждой странице. Также, если приложение обслуживает множество страниц, и разделяет код на уровне page компонентов через @tramvai/react lazy, имеет смысл рассмотреть другие стратегии, т.к. появятся дубликаты в динамических чанках страниц. "},{"title":"Common Chunk","type":1,"pageTitle":"Оптимизация бандла","url":"docs/guides/bundle-optimization#common-chunk","content":"Стратегия включена в CLI по умолчанию, весь общий код из бандлов и динамических чанков выносится в common-chunk.js. Параметр commonChunkSplitNumber позволяет указать, какое минимальное количество чанков должно использовать этот код, что бы вынести его в common. Для приложений с большим количеством бандлов, common-chunk.js может включать огромное количество кода, которое не нужно на каждой отдельной странице, и стоит либо увеличить commonChunkSplitNumber, либо использовать стратегию Granular Chunks. Пример конфигурации для увеличения минимального количества чанков, использующих общий код: { \"projects\": { \"{appName}\": { \"commands\": { \"build\": { \"configurations\": { \"commonChunkSplitNumber\": 5 } } } } }} Скопировать Как выбрать подходящее число commonChunkSplitNumber? Как вариант, число можно вычислить по формулам commonChunkSplitNumber = bundles / 3 или commonChunkSplitNumber = bundles / 2, где bundles - это количество tramvai бандлов, которые подключаются в конкретное приложение, но скорее всего каждое приложение будет лучше рассматривать отдельно. "},{"title":"Granular Chunks","type":1,"pageTitle":"Оптимизация бандла","url":"docs/guides/bundle-optimization#granular-chunks","content":"Подробное описание использования стратегии в Next.js и Gatsby.js Стратегия включается через параметр granularChunks, позволяет вынести общий код во множество мелких чанков, для эффективного кэширования общего кода, и загрузки на каждую страницу только нужного кода. Баланс достигается за счет того, что общий код как минимум между двумя (настройки по умолчанию) чанками выносится в отдельный чанк с уникальным именем, и таких чанков будет от одного на все остальные, до одного на каждые два чанка. Недостатки этой стратегии: на одну страницу может загружаться значительно больше js скриптов, до нескольких десятков, что не значительно влияет на производительность при использовании HTTP/2; и менее эффективная gzip/brotli архивация, что не так заметно по сравнению с уменьшением количества исходного кода. Параметр granularChunksSplitNumber позволяет переопределить число общих чанков по умолчанию (2), если по каким-то причинам необходимо уменьшить количество итоговых чанков: { \"projects\": { \"{appName}\": { \"commands\": { \"build\": { \"configurations\": { \"granularChunks\": true, \"granularChunksSplitNumber\": 3 } } } } }} Скопировать "},{"title":"Введение в документацию","type":0,"sectionRef":"#","url":"docs/get-started/overview","content":"","keywords":""},{"title":"Первые шаги","type":1,"pageTitle":"Введение в документацию","url":"docs/get-started/overview#первые-шаги","content":"Для первого знакомства с фреймворком рекомендуется пройти урок Создаем приложение на Tramvai "},{"title":"Погружение в tramvai","type":1,"pageTitle":"Введение в документацию","url":"docs/get-started/overview#погружение-в-tramvai","content":"Познакомиться с концепциями, которые лежат в основе фреймворка, можно в разделе Основные концепции "},{"title":"Основные возможности","type":1,"pageTitle":"Введение в документацию","url":"docs/get-started/overview#основные-возможности","content":"Узнать больше о возможностях фреймворка можно в разделе Возможности "},{"title":"Джедайские техники","type":1,"pageTitle":"Введение в документацию","url":"docs/get-started/overview#джедайские-техники","content":"Гайды и рецепты для решения самых популярных задач расположены в разделе Рецепты "},{"title":"Справочник API","type":1,"pageTitle":"Введение в документацию","url":"docs/get-started/overview#справочник-api","content":"Справочник API фреймворка, документация к встроенным модулям и библиотекам расположены в разделе API "},{"title":"Tramvai CLI","type":1,"pageTitle":"Введение в документацию","url":"docs/get-started/overview#tramvai-cli","content":"Документация к Tramvai CLI находится на странице CLI "},{"title":"Создание tramvai библиотеки","type":0,"sectionRef":"#","url":"docs/guides/tramvai-library","content":"","keywords":""},{"title":"Предпосылки","type":1,"pageTitle":"Создание tramvai библиотеки","url":"docs/guides/tramvai-library#предпосылки","content":"Рассмотрим все важные кейсы на примере создания нового tramvai модуля. Допустим, модуль будет предоставлять новый HTTP клиент для работы с API Github. "},{"title":"Название пакета","type":1,"pageTitle":"Создание tramvai библиотеки","url":"docs/guides/tramvai-library#название-пакета","content":"Крайне не рекомендуется использовать скоупы @tramvai и @tramvai-tinkoff вне репозитория tramvai. Если наше приложение называется tincoin, можно например выбрать один из таких скоупов: @tincoin@tramvai-tincoin@tincoin-core Для модулей, как правило используется префикс module-, например: @tramvai-tincoin/module-github-api-client "},{"title":"Версионирование","type":1,"pageTitle":"Создание tramvai библиотеки","url":"docs/guides/tramvai-library#версионирование","content":"Выбор стратегии версионирования исключительно за вами. Мы определенно рекомендуем следовать semver, и можем рекомендовать использовать сквозное версионирование, если: вы поддерживаете монорепу с core библиотекамиэти библиотеки могут быть связаны между собойи эти пакеты используются в приложениях все вместе (или большинство из них) "},{"title":"Dependencies","type":1,"pageTitle":"Создание tramvai библиотеки","url":"docs/guides/tramvai-library#dependencies","content":"Работа с зависимостями у библиотек - не простая задача, и не имеет идеального решения, но есть ряд советов, упрощающих управление зависимостями. Лучше всего начать с разделения зависимостей на различные типы: Framework# Пример таких зависимостей - react и react-dom, @tramvai/* и @tramvai-tinkoff/*. Если мы пишем babel или eslint плагин, то это могут быть @babel/core и eslint. Как правило, конечный пользователь, например tramvai приложение, обязано устанавливать фреймворк зависимости, без них оно просто не будет работать. Поэтому наша библиотека должна устанавливать их в peerDependencies, с максимально свободными версиями, например если пакет завязан на базовый функционал tramvai, и использует React хуки: { \"peerDependencies\": { \"@tramvai/core\": \"*\", \"react\": \">=16.8\", \"react-dom\": \">=16.8\" }} Скопировать Singleton# Ряд зависимостей должен быть строго один в приложении. Любые дубликаты это минус, т.к. увеличивают вес бандла приложения, но такие библиотеки как react или @tinkoff/logger требуют быть в единственном экземпляре в нашем приложении. Для них действует правило как с framework, надо устанавливать их в peerDependencies, с максимально свободными версиями: { \"peerDependencies\": { \"@tinkoff/logger\": \"*\" }} Скопировать Popular# Многие пакеты достаточно популярны, и большая вероятность, что они уже используются в конечном приложении. Пример таких зависимостей - date-fns, lru-cache, @tinkoff/dippy Для них действует правило как с framework, надо устанавливать их в peerDependencies, с максимально свободными версиями: { \"peerDependencies\": { \"@tinkoff/dippy\": \"*\", \"date-fns\": \">=2\", \"lru-cache\": \"*\" }} Скопировать Specific# Допустим, наш новый tramvai модуль поставляет в приложение уникальный функционал, для которого требуется сторонняя библиотека (или даже другой пакет в вашей монорепе) Если мы разрабатываем сервис для работы с API Github, это может быть пакет @octokit/rest. В таком случае, нужно ставить библиотеку в dependencies, и можно оставить стандартный range с помощью ^: { \"dependencies\": { \"@octokit/rest\": \"^18.0.0\" }} Скопировать Development# Завимость может участвовать в сборке вашего пакета - например rollup или @tramvai/build. Зависимость требуется для запуска тестов библиотеки. Зависимость содержит необходимые для сборки тайпинги. Во всех этих случаях, даже если либа уже есть в peerDependencies, стоит добавить более конкретную версию в devDependencies, например: { \"devDependencies\": { \"@tramvai/build\": \"^2.5.0\", \"@types/react\": \"^17.0.0\", \"react\": \"^17.0.0\" }} Скопировать Исключения# Конечно, есть исключительные кейсы. Например, tramvai предоставляет множество тестовых утилит, где все основные @tramvai зависимости были в peerDependencies. Как только эти утилиты начали использовать не в репозиториях с приложениями, а в монорепах с core пакетами, появилась проблема отсутствующих зависимостей, и мы перенесли почти все из peerDependencies в dependencies Действуйте по ситуации, и всегда думайте об удобстве использования вашего продукта :) "},{"title":"Сборка","type":1,"pageTitle":"Создание tramvai библиотеки","url":"docs/guides/tramvai-library#сборка","content":"Предполагается, что итоговую сборку пакетов в контексте приложения будет осуществлять @tramvai/cli. Поэтому, для публикации пакетов, написанных на TypeScript, достаточно использовать tsc, и публиковать множество собранных .js и .d.ts файлов. Но сборка пакетов в бандлы перед публикацией, например через rollup или @tramvai/build, дает ряд возможностей: предварительный tree-shaking отсечет все лишнее, это положительно скажется на сборке приложенияможно сделать несколько бандлов для разного окружения, в CJS или ES modules форматахможно сделать отдельный бандл для браузерной сборки, отдельный для серверной - топ для библиотек с поддержкой SSR  Подробная документация про использование @tramvai/build доступна в документации "},{"title":"Deploy приложения","type":0,"sectionRef":"#","url":"docs/guides/deploy","content":"","keywords":""},{"title":"Общее","type":1,"pageTitle":"Deploy приложения","url":"docs/guides/deploy#общее","content":"Tramvai это обычное node.js приложение которое можно запустить стандартными инструментами доступными в node.js комьюнити. Ограничения только накладываются на файловую структуру и необходимости передать ENV переменные приложению "},{"title":"Список действий необходимых для деплоя приложения","type":1,"pageTitle":"Deploy приложения","url":"docs/guides/deploy#список-действий-необходимых-для-деплоя-приложения","content":"собрать приложение в продакшен режимезалить ассетысбилдить докер контейнер с файлами приложениязапустить, передав ENV переменные "},{"title":"Сборка проекта","type":1,"pageTitle":"Deploy приложения","url":"docs/guides/deploy#сборка-проекта","content":"Для сборки проекта необходимо использовать команду (перед этим установив зависимости в проекте) tramvai build APP_ID Скопировать в APP_ID необходимо передать идентификатор приложения. После выполнения команды появится директория dist с файлами сборки сервера и клиентского кода "},{"title":"Создание докер контейнера","type":1,"pageTitle":"Deploy приложения","url":"docs/guides/deploy#создание-докер-контейнера","content":"Рекомендуемый Dockerfile FROM node:14-buster-slimWORKDIR /appCOPY dist/server /app/COPY package.json /app/ENV NODE_ENV='production' EXPOSE 3000CMD [ \"node\", \"--max-http-header-size=80000\", \"/app/server.js\" ] Скопировать FROM - можете поставить 14+ версию ноды, желательно alpine версию для снижения размера "},{"title":"Заливки клиенской статики","type":1,"pageTitle":"Deploy приложения","url":"docs/guides/deploy#заливки-клиенской-статики","content":"Рекомендуемый способ это заливка файлов на CDN, так как node.js не очень хорошо справляется с раздачей статики, так и будет большой трафик для нашей инфрастуктуры. По этому для продакшен приложений, которые будут использовать клиенты, стоит всегда испольвать CDN. Для этого, содержимое папки dist/client заливаете на CDN по выбранному вами способу, получается URL по которому будут доступны файлы и подставляете этот урл в ENV переменную ASSETS_PREFIX например ASSETS_PREFIX=https://cdn-domain.com/my-awesome-app/ Если вам не нужен CDN, то можете посмотреть ниже в пункте \"Запуск приложения без клиентского CDN\", стоит использовать для тестовых стендов или не нагруженных приложений "},{"title":"Деплой приложения","type":1,"pageTitle":"Deploy приложения","url":"docs/guides/deploy#деплой-приложения","content":"Приложение запускается как обычный node.js процес командой node, при запуске необходимо передать все необходимые ENV переменные (список ENV зависит от используемых модулей приложением). Если не добавить ENV переменные - то приложение не запустится. Не забудьте про переменную ASSETS_PREFIX "},{"title":"Explanation","type":1,"pageTitle":"Deploy приложения","url":"docs/guides/deploy#explanation","content":""},{"title":"Пробы","type":1,"pageTitle":"Deploy приложения","url":"docs/guides/deploy#пробы","content":"Если вы деплоетесь в kubernetes, то для этих кейсов есть специальные урлы для проб которые необходимо использовать /healthz - после старта приложения всегда отдает ответ OK/readyz - после старта приложения всегда отдает OK "},{"title":"Запуск приложения без клиентского CDN","type":1,"pageTitle":"Deploy приложения","url":"docs/guides/deploy#запуск-приложения-без-клиентского-cdn","content":"В трамвай встроен сервер отдачи статики. Так лучше не делать, по той причине что nodeJS не лучший инструмент для этого и статика будет влиять на приложение. В общем виде все то же самое как и при обычном деплое, но необходимо добавить копирование ассетов пользователя, в docker образ, для этого: добавить копирование файлов COPY dist/client /app/public/staticsизменить ENV переменную ASSETS_PREFIX Пример готового Dockerfile FROM node:14-buster-slimWORKDIR /appCOPY dist/server /app/COPY package.json /app/COPY dist/client /app/public/staticsENV NODE_ENV='production' EXPOSE 3000CMD [ \"node\", \"--max-http-header-size=80000\", \"/app/server.js\" ] Скопировать При запуске приложения необходимо передать ASSETS_PREFIX=/statics/. При старте приложения поднимется сервер отдачи статитики и будет доступны все файлы внутри директории /public/. Тем самым клиент сможет получить данные по урлу /statics/payment.js "},{"title":"Локальный запуск в docker контейнере","type":1,"pageTitle":"Deploy приложения","url":"docs/guides/deploy#локальный-запуск-в-docker-контейнере","content":"На устройстве должен быть установлен https://www.docker.com/products/docker-desktop и выполняться команда docker run hello-world Собираем проект в продакшен режиме, у нас появится артифакт в директории dist# yarn build Скопировать Собираем докер образ приложения# docker build -t test/myapp . Скопировать Запускаем собранный образ# docker run --rm -e DANGEROUS_UNSAFE_ENV_FILES='true' -e ASSETS_PREFIX='http://localhost:4000/static/' -v ${PWD}/env.development.js:/app/env.development.js -v ${PWD}/dist/client:/app/static -e DEV_STATIC=true -p 3000:3000 -p 4000:4000 -d test/myapp Скопировать Для остановки контейнера нужно получить CONTAINER ID, выполним команду docker ps и далее выполнить команду docker stop <CONTAINER ID> Для остановки всех контейнеров# docker kill $(docker ps --quiet) Скопировать "},{"title":"Execution of actions depending on conditions","type":0,"sectionRef":"#","url":"docs/how-to/actions-conditions","content":"","keywords":""},{"title":"Использование предустановленных ограничений","type":1,"pageTitle":"Execution of actions depending on conditions","url":"docs/how-to/actions-conditions#использование-предустановленных-ограничений","content":"Допустим, мы хотим выполнять один экшен только на сервере, и один только на клиенте, для этого есть ограничители onlyServer и onlyBrowser:  Создаем экшены import { createAction } from '@tramvai/core';import { set } from '../store'; export const innerAction = createAction({ name: 'innerAction', fn: (context) => { console.log('execute innerAction'); return context.dispatch(set('innerAction')); }, // conditions not set - the action will be executed by default: // if the action is defined as global (in an application, bundle or page), // then the action will first try to execute on the server - if it succeeds, then it will not be executed again on the client // if the action did not manage to be executed within the limit, then it will be launched on the client, // repeated launches when switching to the page with this action will not be executed, because the last successful execution is remembered // if the action is called explicitly through the context, then such an action will always be executed (the execution limit still affects, // and the data may not always be available with ssr, but the action will always try to execute)}); export const innerServerAction = createAction({ name: 'innerServerAction', fn: (context) => { console.log('execute innerServerAction'); return context.dispatch(set('innerServerAction')); }, // this action can only be executed on the server conditions: { onlyServer: true, },}); export const innerBrowserAction = createAction({ name: 'innerBrowserAction', fn: (context) => { console.log('execute innerBrowserAction'); return context.dispatch(set('innerBrowserAction')); }, // this action can only be executed on the browser conditions: { onlyBrowser: true, },}); Скопировать   Используем экшены import { createAction } from '@tramvai/core';import { set } from '../store';import { innerAction, innerBrowserAction, innerServerAction } from './inner'; export const pageServerAction = createAction({ name: 'pageServerAction', fn: async (context) => { console.log('execute pageServerAction'); await context.executeAction(innerAction); await context.executeAction(innerServerAction); await context.executeAction(innerBrowserAction); return context.dispatch(set('pageServerAction')); }, conditions: { pageServer: true, },}); export const pageBrowserAction = createAction({ name: 'pageBrowserAction', fn: async (context) => { console.log('execute pageBrowserAction'); await context.executeAction(innerAction); await context.executeAction(innerServerAction); await context.executeAction(innerBrowserAction); return context.dispatch(set('pageBrowserAction')); }, // this action can only be executed on the browser conditions: { onlyBrowser: true, },}); export const pageAlwaysAction = createAction({ name: 'pageAlwaysAction', fn: async (context) => { console.log('execute pageAlwaysAction'); return context.dispatch(set('pageAlwaysAction')); }, conditions: { always: true, },}); // this action is only executed in the browser, on page load and on every SPA transitionexport const pageBrowserAlwaysAction = createAction({ name: 'pageBrowserAlwaysAction', fn: async (context) => { console.log('execute pageBrowserAlwaysAction'); return context.dispatch(set('pageBrowserAlwaysAction')); }, conditions: { always: true, onlyBrowser: true, },}); Скопировать  "},{"title":"Создание своих ограничений","type":1,"pageTitle":"Execution of actions depending on conditions","url":"docs/how-to/actions-conditions#создание-своих-ограничений","content":"Для этого нужно реализовать интерфейс ActionCondition, и добавить новый ограничитель в DI, через токен ACTION_CONDITIONALS:  Создаем ограничитель import { ActionCondition } from '@tramvai/module-common';import { PAGE_SERVICE_TOKEN } from '@tramvai/tokens-router'; export const condition = ({ pageService,}: { pageService: typeof PAGE_SERVICE_TOKEN;}): ActionCondition => { return { key: 'custom', fn: (checker) => { if (checker.conditions.custom) { const { pathname } = pageService.getCurrentUrl(); console.log(pathname); if (pathname !== '/custom/') { checker.forbid(); } } }, };}; Скопировать   Создаем экшен с этим ограничителем import { createAction } from '@tramvai/core';import { set } from '../store'; export const customAction = createAction({ name: 'customAction', fn: (context) => { console.log('execute customAction'); return context.dispatch(set('customAction')); }, // you can set your own options, which are then used in their conditions checks conditions: { custom: true, },}); Скопировать  "},{"title":"Выполнение экшенов только на определенных страницах","type":1,"pageTitle":"Execution of actions depending on conditions","url":"docs/how-to/actions-conditions#выполнение-экшенов-только-на-определенных-страницах","content":"Для этого используем статическое свойство actions для компонента, который используется на этих страницах:  Компонент Page import reduceObj from '@tinkoff/utils/object/reduce';import React from 'react';import { PAGE_SERVICE_TOKEN } from '@tramvai/tokens-router';import { useSelector } from '@tramvai/state';import { useDi } from '@tramvai/react';import { store } from '../store';import { pageBrowserAction, pageServerAction, pageAlwaysAction, pageBrowserAlwaysAction,} from '../actions/page';import { customAction } from '../actions/custom'; export function Page() { const state = useSelector(store, (x) => x.actionTest); const pageService = useDi(PAGE_SERVICE_TOKEN); return ( <div> <button type=\"button\" onClick={() => pageService.navigate({ url: '/custom/' })}> Navigate To custom </button> {reduceObj( (acc, v, k) => { return acc.concat( <div> {k} loaded from {v} </div> ); }, [], state )} </div> );} Page.actions = [ pageServerAction, pageBrowserAction, pageAlwaysAction, pageBrowserAlwaysAction, customAction,]; Скопировать  "},{"title":"Подключение экшенов и ограничителей в приложении","type":1,"pageTitle":"Execution of actions depending on conditions","url":"docs/how-to/actions-conditions#подключение-экшенов-и-ограничителей-в-приложении","content":"Создаем приложение, подключающее экшены, ограничители и компоненты из предыдущих примеров:  Точка входа в приложение import { createApp, createBundle, provide } from '@tramvai/core';import { ACTION_CONDITIONALS } from '@tramvai/module-common';import { PAGE_SERVICE_TOKEN, ROUTES_TOKEN } from '@tramvai/tokens-router'; import { store } from './store';import { modules } from '../common';import { condition } from './conditions/custom';import { Page } from './components/Page'; const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, }, reducers: [store],}); createApp({ name: 'actions-conditions', modules: [...modules], providers: [ provide({ provide: ACTION_CONDITIONALS, multi: true, useFactory: condition, deps: { pageService: PAGE_SERVICE_TOKEN, }, }), provide({ provide: ROUTES_TOKEN, multi: true, useValue: { name: 'custom', path: '/custom/', }, }), ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Скопировать  "},{"title":"Разделение кода для сервера и клиента","type":0,"sectionRef":"#","url":"docs/guides/universal","content":"","keywords":""},{"title":"Код приложения","type":1,"pageTitle":"Разделение кода для сервера и клиента","url":"docs/guides/universal#код-приложения","content":"Для выполнения веток кода или в определенных окружения, можно использовать несколько проверок: process.env# При сборке проекта tramvai cli проставляет две переменные, указывающие на окружение - process.env.SERVER и process.env.BROWSER. Webpack автоматически удалит код с условием, не соответствующим текущему окружению, например следующий код не попадет в серверный бандл: if (process.env.BROWSER) { console.log(window.innerWidth, window.innerHeight);} Скопировать Для исключения кода из production сборки, независимо от окружения, можно использовать переменную process.env.NODE_ENV: if (process.env.NODE_ENV === 'development') { console.log('отладочная информация');} Скопировать Для исключения импортируемых библиотек из сборки требуется замена верхнеуровневых import на require внутри условия: if (process.env.BROWSER) { const logger = require('@tinkoff/logger'); const log = logger('debug'); log.info(window.location.href);} Скопировать typeof window# Для дополнительных оптимизаций, используется babel плагин, который превращает typeof window из серверной сборке в 'undefined', а из клиентской - в 'object', что позволяет webpack'у вырезать лишний код, например следующее условие работает аналогично проверке process.env.BROWSER: if (typeof window !== 'undefined') { console.log(window.innerWidth, window.innerHeight);} Скопировать package.json# Если нам потребовалось заменять целый файл, а не определенные строки кода, можно вынести его в отдельную папку, описать реализацию для всех окружений, и добавить package.json: // module.server.jsexport const CONSTANT = 'SERVER_SIDE'; Скопировать // module.client.jsexport const CONSTANT = 'CLIENT_SIDE'; Скопировать Далее, в package.json надо указать бандлеру, какой код использовать для разных окружений. Поле main используется для серверного бандла, а browser для клиентского: { \"main\": \"./module.server.js\", \"browser\": \"./module.client.js\"} Скопировать "},{"title":"npm библиотеки","type":1,"pageTitle":"Разделение кода для сервера и клиента","url":"docs/guides/universal#npm-библиотеки","content":"Для создания библиотеки, реализации которой должны отличаться на сервере и клиенте, необходимо поддерживать общий интерфейс экспорта, и настроить package.json аналогично предыдущему примеру. Например, библиотека экспортирует класс Library, и константу LIBRARY_CONSTANT. Создадим две точки входа в нашу библиотеку - server.js и client.js: // server.jsexport class Library { constructor() { // ... }} export const LIBRARY_CONSTANT = 'SERVER_SIDE_LIBRARY'; Скопировать // client.jsexport class Library { constructor() { // ... }} export const LIBRARY_CONSTANT = 'CLIENT_SIDE_LIBRARY'; Скопировать Далее, в package.json надо указать бандлеру, какой код использовать для разных окружений. Поле main используется для серверного бандла, а browser для клиентского: { \"name\": \"library\", \"version\": \"0.1.0\", \"main\": \"server.js\", \"browser\": \"client.js\", \"dependencies\": { ... }} Скопировать После публикации библиотеки, можно импортировать ее в tramvai приложение, и не заботиться о том, какую именно реализацию мы получим: import { LIBRARY_CONSTANT } from 'library'; // при запуске приложения через tramvai start, увидим 'SERVER_SIDE_LIBRARY' в терминале, и 'CLIENT_SIDE_LIBRARY' в консоли браузераconsole.log(LIBRARY_CONSTANT); Скопировать "},{"title":"tramvai модули","type":1,"pageTitle":"Разделение кода для сервера и клиента","url":"docs/guides/universal#tramvai-модули","content":"Новый функционал в tramvai приложение добавляется с помощью модулей, и как правило, поведение этих модулей кардинально отличается в разных окружениях, например: Рендеринг приложения в строку на сервере и гидрация реального DOM на клиентеЗапуск https сервераИнициализация service worker'а По этой причине, в репозитории tramvai, стандартный шаблон tramvai модуля, генерируемый через команду npm run generate:module, сразу разделяет точки входа в модуль на server.js и client.js , с помощью package.json. Разберем это на примере создания модуля, который добавляет в приложение сервис для работы с cookie: Этот сервис должен иметь общий интерфейс: export interface ICookie { get(key); set(key, value);} Скопировать И разные реализации для серверного и клиентского окружения: // src/cookie.server.ts// серверная реализация требует объекты Request и Response для работы с кукамиexport class Cookie implements ICookie { constructor({ req, res }) { // ... } get(key) { // ... } set(key, value) { // ... }} Скопировать // src/cookie.client.ts// клиентская реализация обращается напрямую к объекту Windowexport class Cookie implements ICookie { get(key) { // ... } set(key, value) { // ... }} Скопировать Добавляем сервис в DI с помощью модулей: // src/server.tsimport { Module, Scope, provide } from '@tramvai/core';import { REQUEST, RESPONSE } from '@tramvai/tokens-common';import { Cookie } from './cookie.server'; @Module({ providers: [ provide({ provide: 'cookie', useClass: Cookie, scope: Scope.REQUEST, deps: { req: REQUEST, res: RESPONSE, }, }), ],})export class CookieModule {} Скопировать // src/client.tsimport { Module, Scope, provide } from '@tramvai/core';import { Cookie } from './cookie.client'; @Module({ providers: [ provide({ provide: 'cookie', useClass: Cookie, scope: Scope.SINGLETON, }), ],})export class CookieModule {} Скопировать Настраиваем package.json: { \"name\": \"@tramvai/module-cookie\", \"version\": \"0.1.0\", \"main\": \"lib/server.js\", \"browser\": \"lib/client.js\", \"dependencies\": { ... }} Скопировать После импорта модуля в приложение, мы получаем универсальный доступ к cookies, и не думаем про окружение, при использовании: import { createApp, commandLineListTokens, provide } from '@tramvai/core';import { CookieModule } from '@tramvai/module-cookie'; createApp({ name: 'app', modules: [ // ... CookieModule, ], providers: [ // ... provide({ provide: commandLineListTokens.init, useFactory: ({ cookie }) => { console.log('wuid', cookie.get('wuid')); }, deps: { cookie: 'cookie', }, }), ], // ...}); Скопировать "},{"title":"Как создать экшен?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-action","content":"","keywords":""},{"title":"Создание экшена","type":1,"pageTitle":"Как создать экшен?","url":"docs/how-to/how-create-action#создание-экшена","content":"Подключаем createAction и добавляем функцию по загрузки данных из api и отправки данных в store. import { createAction } from '@tramvai/core';import { loadDepositConfig } from './deposit/reducer'; export const loadDepositAction = createAction({ name: 'load-deposit-config', fn: async (context, payload, deps) => { const data = await deps.apiClient.request({ method: 'deposit_config ' }); return context.dispatch(loadDepositConfig(data)); }, deps: { apiClient: 'tinkoffApiClient', },}); Скопировать Мы создали экшен, которому требуется для работы провайдер tinkoffApiClient, этот экшен делает запрос за данными и сохраняет полученные данные в стор. "},{"title":"Выполнение для конкретной страницы","type":1,"pageTitle":"Как создать экшен?","url":"docs/how-to/how-create-action#выполнение-для-конкретной-страницы","content":"Мы создали экшен и хотим подключить его в приложение. Нам важно, что бы экшен выполнялся на сервере, и сервер дожидался выполнения. При этом данные нужны только на конкретной странице, поэтому мы добавляем его в статическое поле actions нужной страницы. import react, { Component } from 'react';import { loadDepositAction } from './loadDepositAction';import { DepositInfo } from './DepositInfo'; class DepositPage extends Component { static actions = [loadDepositAction]; render() { return ( <div> <DepositInfo /> </div> ); }} Скопировать После этого, при открытии роута пользователем, сервер автоматически запустит экшен привязанный к DepositPage и загрузится данные "},{"title":"Что еще стоит прочитать","type":1,"pageTitle":"Как создать экшен?","url":"docs/how-to/how-create-action#что-еще-стоит-прочитать","content":"О createActionКак работают экшены "},{"title":"How to split a component into an asynchronous chunk?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-async-component","content":"","keywords":""},{"title":"Component example","type":1,"pageTitle":"How to split a component into an asynchronous chunk?","url":"docs/how-to/how-create-async-component#component-example","content":"Let's say we have a heavy React component that we use occasionally and we want to load it only when needed. Right now we have the following code: // file heavy.tsxexport const Heavy = () => <div>123</div>; Скопировать // file page.tsximport Heavy from './heavy.tsx'; const Page = () => ( <> <Heavy /> <Footer /> </>); Скопировать "},{"title":"Connecting the lazy","type":1,"pageTitle":"How to split a component into an asynchronous chunk?","url":"docs/how-to/how-create-async-component#connecting-the-lazy","content":"There are several ways to split the component into asynchronous chunks Add new wrapper for heavy into page.tsx.Put heavy code into a separate file and leave only async wrapper in heavy.tsx. We'll create a new file, as this allows us not to change imports in files that have already used the Heavy component. And it will be harder to forget to reuse the async component in the future: // file heavy-component.tsxexport const Heavy = () => <div>123</div>; Скопировать // file heavy.tsximport { lazy } from '@tramvai/react'; export const Heavy = lazy(() => import('./heavy-component')); Скопировать // file page.tsximport Heavy from './heavy.tsx'; const Page = () => ( <> <Heavy /> <Footer /> </>); Скопировать We created a new file, put all the code of the Heavy component there, and left only the component itself in the old file, which we wrapped in lazy and imported the original component with import. Now instead of the original Heavy component we will have an asynchronous version which we will load only when rendering the Page component. "},{"title":"Result","type":1,"pageTitle":"How to split a component into an asynchronous chunk?","url":"docs/how-to/how-create-async-component#result","content":"The Heavy component will be loaded by demand Next, the component will be: Automatically put in a separate webpack chunkWhen rendering, SSR will automatically download the file and immediately render it on the serverJS and CSS of the chunk will be inserted into the HTML with maximum priorityIt will work seamlessly in the browser Example of work in a test application "},{"title":"How to create a bundle?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-bundle","content":"","keywords":""},{"title":"Creating a bundle","type":1,"pageTitle":"How to create a bundle?","url":"docs/how-to/how-create-bundle#creating-a-bundle","content":"We use the createBundle method and create an empty bundle, in which we write the name field, which is the unique identifier of the bundle: import { createBundle } from '@tramvai/core'; export default createBundle({ name: 'coin', components: {},}); Скопировать "},{"title":"Adding components","type":1,"pageTitle":"How to create a bundle?","url":"docs/how-to/how-create-bundle#adding-components","content":"The next step is to add the components that will be available in this bundle. We recommended to use lazy and dynamic import page components for effective code splitting. The key is the identifier of the component, this identifier can be bound to the router: import { createBundle } from '@tramvai/core';import { lazy } from '@tramvai/react'; const MainPage = lazy(() => import('../pages/main'));import Layout from '../layouts'; export default createBundle({ name: 'coin', components: { 'page/coin-main': MainPage, 'layout/coin-layout': Layout, },}); Скопировать You can register any components for different purposes. For example, we can register components of modal windows, popups and so on in the bundle. All these components will be available in the componentRegistry. "},{"title":"Connecting in the application","type":1,"pageTitle":"How to create a bundle?","url":"docs/how-to/how-create-bundle#connecting-in-the-application","content":"Now we have to register the bundle in the application. To do this we add to the bundles object of createApp: key: the identifier of the bundle. The last part must be the same as the bundle ID passed to name, a function of the form last('platform/coin'.split('/')) is used there, otherwise, there will be no loading of the bundle on the server side.value: the function that should return the promise wrapped bundle object. Usually, asynchronous webpack chunks are used, but you can also write a custom loader of regular js files. The important thing is that the name of the chunk, must be synchronized with the name identifier import { createApp } from '@tramvai/core'; createApp({ bundles: { 'platform/coin': () => import(/* webpackChunkName: \"coin\" */ './bundles/coin'), },}); Скопировать After that, we will have a bundle available in the application and after downloading it, the linked components will be available. Then we can use these components in routing Complete documentation about createBundleComplete documentation about createApp "},{"title":"Defaul bundle","type":1,"pageTitle":"How to create a bundle?","url":"docs/how-to/how-create-bundle#defaul-bundle","content":"The default bundle allows you to handle all (created via RouterModule.forRoot) urls for which no bundle is specifically set. It is done like this: Inside index.ts import { createApp } from '@tramvai/core'; createApp({ name: 'myApp', modules: [ // ... ], providers: [ // ... ], bundles: { mainDefault: () => import(/* webpackChunkName: \"mainDefault\" */ './bundles/mainDefault'), },}); Скопировать In file bundles/mainDefault.ts import { createBundle } from '@tramvai/core' import { MainPage } from '../layers/pages/MainPage'import { Layout } from '../layers/layout/Layout' export default createBundle({ name: 'mainDefault', components: { pageDefault: MainPage, layoutDefault: Layout, },}) Скопировать "},{"title":"Executing actions on different pages","type":0,"sectionRef":"#","url":"docs/how-to/actions-execution","content":"","keywords":""},{"title":"Binding actions to a specific page","type":1,"pageTitle":"Executing actions on different pages","url":"docs/how-to/actions-execution#binding-actions-to-a-specific-page","content":"To do this, you can use the static property actions of page components:  Creating actions import { createAction } from '@tramvai/core';import { ACTION_EXECUTION_LIMIT } from '../constants';import { set } from '../store'; export const pageInLimit = createAction({ name: 'pageInLimit', fn: async (context) => { console.log('execute pageInLimit'); await context.dispatch(set({ name: 'pageInLimit', value: false })); await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT / 2)); await context.dispatch(set({ name: 'pageInLimit', value: true })); },}); export const pageOutLimit = createAction({ name: 'pageOutLimit', fn: async (context) => { console.log('execute pageOutLimit'); await context.dispatch(set({ name: 'pageOutLimit', value: false })); await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT * 2)); await context.dispatch(set({ name: 'pageOutLimit', value: true })); },}); Скопировать   Connecting actions to the page import reduceObj from '@tinkoff/utils/object/reduce';import React from 'react';import { useSelector } from '@tramvai/state';import { store } from '../store';import { pageInLimit, pageOutLimit } from '../actions/page'; export function Page() { const state = useSelector(store, (x) => x.actionTest); return ( <div> {reduceObj( (acc, v, k) => { return acc.concat( <div> {k} = {v.toString()} </div> ); }, [], state )} </div> );} // actions can be specified as a static property of a page component// in this case actions will be executed only on pages with this particular pageComponentPage.actions = [pageInLimit, pageOutLimit]; Скопировать  "},{"title":"Binding actions to a bundle","type":1,"pageTitle":"Executing actions on different pages","url":"docs/how-to/actions-execution#binding-actions-to-a-bundle","content":"Bundles allow you to group pages, you can bind actions to them, which will be executed for each page of the bundle:  Creating actions import { createAction } from '@tramvai/core';import { ACTION_EXECUTION_LIMIT } from '../constants';import { set } from '../store'; export const bundleInLimit = createAction({ name: 'bundleInLimit', fn: async (context) => { console.log('execute bundleInLimit'); await context.dispatch(set({ name: 'bundleInLimit', value: false })); await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT / 2)); await context.dispatch(set({ name: 'bundleInLimit', value: true })); },}); export const bundleOutLimit = createAction({ name: 'bundleOutLimit', fn: async (context) => { console.log('execute bundleOutLimit'); await context.dispatch(set({ name: 'bundleOutLimit', value: false })); await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT * 2)); await context.dispatch(set({ name: 'bundleOutLimit', value: true })); },}); Скопировать   Connecting actions to the bundle import { createBundle } from '@tramvai/core';import { store } from '../store';import { bundleInLimit, bundleOutLimit } from '../actions/bundle';import { Page } from '../components/Page'; export const mainDefault = createBundle({ name: 'mainDefault', components: { pageDefault: Page, }, // let's specify our store, so that it will immediately initialize and subscribe to its dispatch events reducers: [store], // the actions can be specified as part of the bundle - then these actions will be executed for all pages of the bundle actions: [bundleInLimit, bundleOutLimit],}); Скопировать  "},{"title":"Common actions for the application","type":1,"pageTitle":"Executing actions on different pages","url":"docs/how-to/actions-execution#common-actions-for-the-application","content":"Actions connected to application are executed on all pages:  Creating actions import { createAction } from '@tramvai/core';import { ACTION_EXECUTION_LIMIT } from '../constants';import { set } from '../store'; export const globalInLimit = createAction({ name: 'globalInLimit', fn: async (context) => { console.log('execute globalInLimit'); await context.dispatch(set({ name: 'globalInLimit', value: false })); // set the execution delay less than the server's execution limit, so that this action will be executed in time to ssr await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT / 2)); await context.dispatch(set({ name: 'globalInLimit', value: true })); },}); export const globalOutLimit = createAction({ name: 'globalOutLimit', fn: async (context) => { console.log('execute globalOutLimit'); await context.dispatch(set({ name: 'globalOutLimit', value: false })); // set an execution delay higher than the server's execution limit, so that this action will not be executed in time with ssr await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT * 2)); await context.dispatch(set({ name: 'globalOutLimit', value: true })); },}); Скопировать   Connecting actions into the application import { createApp, provide } from '@tramvai/core';import { ACTION_EXECUTION_LIMIT } from './constants';import { modules } from '../common';import { globalInLimit, globalOutLimit } from './actions/global';import { mainDefault } from './bundles/mainDefault'; createApp({ name: 'actions-execution', modules: [...modules], providers: [ provide({ // in the application you can specify a limit on the execution of actions on the server (by default 500ms) provide: 'limitActionGlobalTimeRun', useValue: ACTION_EXECUTION_LIMIT, }), ], // these actions will be executed for all pages of the application actions: [globalInLimit, globalOutLimit], bundles: { mainDefault: () => Promise.resolve({ default: mainDefault }), },}); Скопировать  "},{"title":"Как создать модуль?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-module","content":"","keywords":""},{"title":"Создаем пустой модуль","type":1,"pageTitle":"Как создать модуль?","url":"docs/how-to/how-create-module#создаем-пустой-модуль","content":"Создаем базовый модуль, для этого создаем пустой класс SecurityModule и подключаем декоратор module который необходим для модулей и в который мы будем добавлять интеграции с приложением. import { Module } from '@tramvai/core'; @Module({ providers: [],})export class SecurityModule {} Скопировать Модуль уже можно подключить в приложение, но он не будет ничего делать. "},{"title":"Добавляем провайдеры","type":1,"pageTitle":"Как создать модуль?","url":"docs/how-to/how-create-module#добавляем-провайдеры","content":"Для этого нам необходимо добавить провайдеры в поле providers. У нас была задача добавить хэдеры, для этого мы будем использовать commandLineListTokens, что бы выполнять действия для каждого клиента и будем использовать responseManager в который сможем записать информацию о хэдерах. import { Module, commandLineListTokens, RESPONSE_MANAGER_TOKEN, provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: commandLineListTokens.resolvePageDeps, multi: true, useFactory: ({ responseManager }: { responseManager: typeof RESPONSE_MANAGER_TOKEN }) => function securityHeader() { responseManager.setHeader('X-Frame-Options', 'sameorigin'); }, deps: { responseManager: RESPONSE_MANAGER_TOKEN, }, }), ],})export class SecurityModule {} Скопировать Мы реализовали новый мульти-провайдер, который имеет зависимости и создается через useFactory После подключения модуля в приложение, для каждого клиента сначала выполнится функция useFactory с переданными deps, и после этого вызовется функция securityHeader, в которой мы в полученную зависимость запишем данные, и тем самым выполним нашу цель. "},{"title":"Подключаем в приложение наш новый модуль","type":1,"pageTitle":"Как создать модуль?","url":"docs/how-to/how-create-module#подключаем-в-приложение-наш-новый-модуль","content":"Теперь осталось подключить модуль в приложение, что бы он смог добавить свою реализацию. import { createApp } from '@tramvai/core';import { SecurityModule } from '@tramvai/module-security'; createApp({ modules: [SecurityModule],}); Скопировать После этого модуль добавит свою реализацию и начнет выполняться. Мы можем добавить модуль не только в приложение, но и в другой модуль. Для этого нужно передать в блок imports и тогда при подключении модуля MyCommonModule автоматически подключится и SecurityModule import { Module } from '@tramvai/core';import { SecurityModule } from '@tramvai/module-security'; @Module({ imports: [SecurityModule], providers: [],})export class MyCommonModule {} Скопировать "},{"title":"Итог","type":1,"pageTitle":"Как создать модуль?","url":"docs/how-to/how-create-module#итог","content":"Был создан SecurityModule который будет вызываться для каждого клиента и будет добавлять необходимые хэдеры Подробная дока по модулямПодробная дока по createAppПодробная дока по DI "},{"title":"Как создать обработчик papi?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-papi","content":"","keywords":""},{"title":"Автоматическое создание обработчика","type":1,"pageTitle":"Как создать обработчик papi?","url":"docs/how-to/how-create-papi#автоматическое-создание-обработчика","content":"На основе параметра конфигурации application.commands.build.options.serverApiDir в platform.json (по умолчанию папка ./src/api) определяется директория, в которой хранятся papi-обработчики. Создаем в этой папке новый файл с именем нашего нового обработчика, т.е. getSum.ts для нашего примера. В качестве обработчика будет использован дефолтный экспорт из файла, создаем его: export default () => { return 'hello';}; Скопировать Перезапускаем сервер, чтобы новый обработчик добавился в список papi. Результат вызова функции будет использован как тело ответа, поэтому теперь если обратить по адресу http://localhost:3000/tincoin/papi/getSum то в ответе мы получим объект со свойством payload: 'hello'. Далее добавим логику в наш обработчик: import { Req } from '@tramvai/papi'; // импорт нужен только для типизации, можно обойтись без него или использовать типы из express export default (req: Req) => { const { body: { a, b }, method, } = req; // получаем из объекта запроса всю необходимую ифнормацию if (method !== 'POST') { throw new Error('only post methods'); // выбрасываем ошибку, если хотим обрабатывать только определенные http-методы } if (!a || !b) { // проверяем что были переданы необходимые параметры запроса return { error: true, message: 'body parameters a and b should be set', }; } return { error: false, result: +a + +b }; // возвращаем результат, не забыв сделать все преобразования над строками}; Скопировать Сборку уже перезапускать не нужно и @tramvai/cli сам все пересоберет после сохранения изменений на диск. Теперь можно сделать POST-запрос на http://localhost:3000/tincoin/papi/getSum, передать параметры a и b и получить результат. "},{"title":"Создание обработчика через провайдер","type":1,"pageTitle":"Как создать обработчик papi?","url":"docs/how-to/how-create-papi#создание-обработчика-через-провайдер","content":"При необходимости использовать в обработчике другие зависимости приложения из di, можно добавить провайдер с токеном SERVER_MODULE_PAPI_PUBLIC_ROUTE: // ...import { createPapiMethod } from '@tramvai/papi';import { SERVER_MODULE_PAPI_PUBLIC_ROUTE } from '@tramvai/tokens-server';import { LOGGER_TOKEN } from '@tramvai/tokens-common';import { provide } from '@tramvai/core'; createApp({ // ... providers: [ // ... provide({ provide: SERVER_MODULE_PAPI_PUBLIC_ROUTE, multi: true, useFactory: ({ logger }: { logger: typeof LOGGER_TOKEN }) => { const log = logger('ping-pong'); return createPapiMethod({ method: 'get', path: '/ping', async handler() { log.error('/ping requested'); // логируем с уровнем error, чтобы наверняка увидеть лог return 'pong'; }, }); }, deps: { logger: LOGGER_TOKEN, }, }), ],}); Скопировать Теперь можно сделать запрос по адресу http://localhost:3000/tincoin/papi/ping, в ответе мы получим объект со свойством payload: 'pong', а в терминале с запущенным процессом tramvai start ${APP_ID} увидим лог ошибки /ping requested. "},{"title":"Дополнительные ссылки","type":1,"pageTitle":"Как создать обработчик papi?","url":"docs/how-to/how-create-papi#дополнительные-ссылки","content":"Документация к ServerModule "},{"title":"How to debug modules?","type":0,"sectionRef":"#","url":"docs/how-to/how-debug-modules","content":"","keywords":""},{"title":"Displaying logs on the server","type":1,"pageTitle":"How to debug modules?","url":"docs/how-to/how-debug-modules#displaying-logs-on-the-server","content":"The server log settings are set in the LOG_LEVEL and LOG_ENABLE environment variables, if needed, you can change these settings in runtime, through the papi method /{appName}/private/papi/logger with additional query parameters. You can read more about the available parameters in the documentation @tramvai/module-log LOG_ENABLE='router' // displays all logs for the logger with the ID `router` Скопировать "},{"title":"Displaying logs on the browser","type":1,"pageTitle":"How to debug modules?","url":"docs/how-to/how-debug-modules#displaying-logs-on-the-browser","content":"Client logs settings are controlled by methods of the @tinkoff/logger library. These settings are stored in the localStorage, so to display all client logs with new settings, you must additionally reload the page, or clear the localStorage. import logger from '@tinkoff/logger'; logger.enable('router'); // displays all logs for the logger with the ID `router` Скопировать "},{"title":"How to enable modern mode for an application?","type":0,"sectionRef":"#","url":"docs/how-to/how-enable-modern","content":"","keywords":""},{"title":"Configuring tramvai.json","type":1,"pageTitle":"How to enable modern mode for an application?","url":"docs/how-to/how-enable-modern#configuring-tramvaijson","content":"We need to enable building code for modern versions of browsers. To do this, add the modern: true parameter to tramvai.json: { \"projects\": { \"tincoin\": { \"name\": \"tincoin\", \"root\": \"src\", \"type\": \"application\", \"commands\": { \"build\": { \"options\": { \"vendor\": \"src/vendor.js\", \"polyfill\": \"src/polyfill.ts\", \"server\": \"src/index.ts\" }, \"configurations\": { \"modern\": true } } } } }} Скопировать After that, @tramvai/cli will build two versions of each js file: ES5 and ES2017 After these steps, we will build statics for 2 packs of browsers and RenderModule will give the ES2017-compatible code for modern browsers. "},{"title":"How to enable polyfills?","type":0,"sectionRef":"#","url":"docs/how-to/how-to-enable-polyfills","content":"","keywords":""},{"title":"Setup","type":1,"pageTitle":"How to enable polyfills?","url":"docs/how-to/how-to-enable-polyfills#setup","content":"Install polyfills pack# npm i --save @tinkoff/pack-polyfills Скопировать Create a file polyfill.ts# You need to create a file polyfill.ts inside your project, for example src/polyfill.ts and connect the polyfills inside: import '@tinkoff/pack-polyfills'; Скопировать Set up @tramvai/cli# After that, we need to tell @tramvai/cli that our project has polyfills. To do this, in tramvai.json we add for our project the line \"polyfill: \"src/polyfill.ts\" in projects[APP_ID].commands.build.options.polyfill example: { \"projects\": { \"pfphome\": { \"name\": \"pfphome\", \"root\": \"src\", \"type\": \"application\", \"commands\": { \"build\": { \"options\": { \"server\": \"src/index.ts\", \"vendor\": \"src/vendor.ts\", \"polyfill\": \"src/polyfill.ts\" } } } } }} Скопировать "},{"title":"How polyfills loading works","type":1,"pageTitle":"How to enable polyfills?","url":"docs/how-to/how-to-enable-polyfills#how-polyfills-loading-works","content":"On the @tramvai/cli side, we have configured to build the polyfills into a separate file, so it doesn't mix with the main code. On every build we will have a file with polyfills. module-render if it finds polyfills in the build, then for each client embeds inline code that checks the availability of features in the browser and if the browser does not support any of the features, then we consider the browser is legacy and load polyfills. An example of a check: !window.Promise.prototype.finally || !window.URL || !window.URLSearchParams || !window.AbortController || !window.IntersectionObserver || !Object.fromEntries' "},{"title":"Replacing the polyfills loading check","type":1,"pageTitle":"How to enable polyfills?","url":"docs/how-to/how-to-enable-polyfills#replacing-the-polyfills-loading-check","content":""},{"title":"Why would it be necessary?","type":1,"pageTitle":"How to enable polyfills?","url":"docs/how-to/how-to-enable-polyfills#why-would-it-be-necessary","content":"If you do not fit the standard check for supported features in the browser and polyfills do not load in browsers where they should. In this case, it is better to create issue and we will update the check, or you can replace the check with another. "},{"title":"Important tips","type":1,"pageTitle":"How to enable polyfills?","url":"docs/how-to/how-to-enable-polyfills#important-tips","content":"POLYFILL_CONDITION should return true if the browser does not support some featuresYou should not load polyfiles into all browsersIt is better to extend DEFAULT_POLYFILL_CONDITION with additional checks, rather than replacing it "},{"title":"Replacing the check","type":1,"pageTitle":"How to enable polyfills?","url":"docs/how-to/how-to-enable-polyfills#replacing-the-check","content":"To do this, we need to set provider POLYFILL_CONDITION, which is in import { POLYFILL_CONDITION } from '@tramvai/module-render' and pass a new line. Example: This is a synthetic example, but suppose we want to additionally check for the presence of window.Promise in the browser, to do this we extend DEFAULT_POLYFILL_CONDITION string. The resulting expression should return true if the browsers do not support the feature. import { POLYFILL_CONDITION, DEFAULT_POLYFILL_CONDITION } from '@tramvai/module-render';import { provide } from '@tramvai/core'; const provider = provide({ provide: POLYFILL_CONDITION, useValue: `${DEFAULT_POLYFILL_CONDITION} || !window.Promise`,}); Скопировать "},{"title":"Adding endpoint handler for an application","type":0,"sectionRef":"#","url":"docs/how-to/server-add-path-handler","content":"Adding endpoint handler for an application Tramvai gives you the ability to process any application url yourself, via tokens WEB_APP_BEFORE_INIT_TOKEN и WEB_APP_INIT_TOKEN Example of adding handlers import { createApp, provide } from '@tramvai/core';import { WEB_APP_BEFORE_INIT_TOKEN, WEB_APP_INIT_TOKEN } from '@tramvai/module-server';import { LOGGER_TOKEN } from '@tramvai/module-common';import { modules } from '../common'; createApp({ name: 'server', modules: [...modules], bundles: {}, providers: [ provide({ // Subscribe to WEB_APP_BEFORE_INIT_TOKEN event to subscribe to all default handlers provide: WEB_APP_BEFORE_INIT_TOKEN, multi: true, useFactory: ({ logger }) => { const log = logger('my-path'); // di should get the function from the web application return (app) => { app.use('/my-path', (req, res, next) => { // there will be no cookies in the req because you signed up before setting the cookieParser in @tramvai/module-server log.error('request start!', !!req.cookies); next(); }); }; }, deps: { logger: LOGGER_TOKEN, }, }), provide({ // Subscribe to WEB_APP_INIT_TOKEN event to subscribe to the default root handler provide: WEB_APP_INIT_TOKEN, multi: true, useFactory: ({ logger }) => { const log = logger('my-path'); return (app) => { app.use('/my-path', (req, res) => { // The cookies in the req here will already be there since they signed up after setting the cookieParser in @tramvai/module-server log.error('request start!', !!req.cookies); res.send({ hello: 'world', cookies: req.cookies }); }); }; }, deps: { logger: LOGGER_TOKEN, }, }), ],}); Скопировать","keywords":""},{"title":"SSR with async components","type":0,"sectionRef":"#","url":"docs/how-to/ssr-async-components","content":"SSR with async components When using dynamic import to load React components, we lose the ability to render them on the server. This problem is solved by the library @tramvai/react lazy Example of connecting a lazy component in a bundle import { createApp, createBundle } from '@tramvai/core';import { lazy } from '@tramvai/react';import { modules } from '../common'; const bundle = createBundle({ name: 'mainDefault', components: { // wrap the import in a lazy call so that the component is successfully rendered on the server // and the scripts/styles for the component are preloaded on the client pageDefault: lazy(() => import('./pages/page')), },}); createApp({ name: 'ssr-async-components', modules: [...modules], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Скопировать","keywords":""},{"title":"Обновление tramvai в приложении","type":0,"sectionRef":"#","url":"docs/how-to/tramvai-update","content":"","keywords":""},{"title":"Обновление до latest версии","type":1,"pageTitle":"Обновление tramvai в приложении","url":"docs/how-to/tramvai-update#обновление-до-latest-версии","content":"tramvai update по умолчанию использует latest: tramvai update Скопировать "},{"title":"Обновление до конкретной версии","type":1,"pageTitle":"Обновление tramvai в приложении","url":"docs/how-to/tramvai-update#обновление-до-конкретной-версии","content":"Флаг --to позволяет указать точную версию: tramvai update --to 1.0.0 Скопировать "},{"title":"Проверка версий tramvai в приложении","type":1,"pageTitle":"Обновление tramvai в приложении","url":"docs/how-to/tramvai-update#проверка-версий-tramvai-в-приложении","content":"Для автоматической проверки синхронизации версий трамвай зависимостей создана утилита @tramvai/tools-check-versions, для запуска нужно выполнить команду: yarn tramvai-check-versions Скопировать "},{"title":"Установка нового @tramvai пакета в приложении","type":1,"pageTitle":"Обновление tramvai в приложении","url":"docs/how-to/tramvai-update#установка-нового-tramvai-пакета-в-приложении","content":"tramvai add <packageName> по умолчанию устанавливает пакет в dependencies: tramvai add @tramvai/module-router Скопировать Флаг --dev установит пакет в devDependencies: tramvai add @tramvai/test-unit --dev Скопировать "},{"title":"Using @tramvai/react-query library","type":0,"sectionRef":"#","url":"docs/how-to/react-query-usage","content":"","keywords":""},{"title":"Базовый пример c createQuery и useQuery","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#базовый-пример-c-createquery-и-usequery","content":" Подробнее import React from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get<string>('api/base'); await new Promise((resolve) => setTimeout(resolve, 50)); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); // eslint-disable-next-line import/no-default-exportexport default function Component() { const { data, isLoading } = useQuery(query); return <div>{isLoading ? 'loading...' : data}</div>;} Скопировать  "},{"title":"Предзагрузка данных на сервере для useQuery","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#предзагрузка-данных-на-сервере-для-usequery","content":" Подробнее import React from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get<string>('api/base'); await new Promise((resolve) => setTimeout(resolve, 50)); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); // eslint-disable-next-line import/no-default-exportexport default function Component() { const { data, isLoading } = useQuery(query); return <div>{isLoading ? 'loading...' : data}</div>;} Component.actions = [query.prefetchAction()]; Скопировать  "},{"title":"Шаринг данных useQuery между компонентами","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#шаринг-данных-usequery-между-компонентами","content":" Подробнее import React, { useState, useEffect } from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get<string>('api/base'); await new Promise((resolve) => setTimeout(resolve, 5000)); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); const Child1 = () => { const { isLoading, data } = useQuery(query); return <div>Child1: {isLoading ? 'loading...' : data}</div>;}; const Child2 = () => { const { isLoading, data } = useQuery(query); return <div>Child2: {isLoading ? 'loading...' : data}</div>;}; const Child3 = () => { const { isLoading, data } = useQuery(query); return <div>Child3: {isLoading ? 'loading...' : data}</div>;}; // eslint-disable-next-line import/no-default-exportexport default function Component() { const [child2, setChild2Visible] = useState(false); const [child3, setChild3Visible] = useState(false); useEffect(() => { setTimeout(() => { setChild2Visible(true); }, 3000); setTimeout(() => { setChild3Visible(true); }, 7000); }, []); return ( <> <Child1 /> {child2 && <Child2 />} {child3 && <Child3 />} </> );} Скопировать  "},{"title":"Передача параметров для запроса","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#передача-параметров-для-запроса","content":" Подробнее import React, { useState, useEffect } from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const query = createQuery({ key: (parameter: string) => ['api-group', parameter], fn: async (parameter, { apiClient }) => { console.log(`request to ${parameter}`); const { payload } = await apiClient.get<string>(`api/group/${parameter}`); await new Promise((resolve) => setTimeout(resolve, 5000)); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); const Child1 = () => { const { isLoading, data } = useQuery(query, 'test-1'); return <div>Child1: {isLoading ? 'loading...' : data}</div>;}; const Child2 = () => { const { isLoading, data } = useQuery(query, 'test-1'); return <div>Child2: {isLoading ? 'loading...' : data}</div>;}; const Child3 = () => { const { isLoading, data } = useQuery(query, 'test-2'); return <div>Child3: {isLoading ? 'loading...' : data}</div>;};// eslint-disable-next-line import/no-default-exportexport default function Component() { const [child2, setChild2Visible] = useState(false); const [child3, setChild3Visible] = useState(false); useEffect(() => { setTimeout(() => { setChild2Visible(true); }, 3000); setTimeout(() => { setChild3Visible(true); }, 7000); }, []); return ( <> <Child1 /> {child2 && <Child2 />} {child3 && <Child3 />} </> );} Скопировать  "},{"title":"Задание параметров react-query","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#задание-параметров-react-query","content":" Подробнее import React from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const query = createQuery({ key: 'time', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get<string>('api/time'); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, }, queryOptions: { refetchOnWindowFocus: true, refetchOnMount: true, },});// eslint-disable-next-line import/no-default-exportexport default function Component() { const { data } = useQuery( query.fork({ refetchInterval: 2000, refetchIntervalInBackground: false, }) ); return <div>{data}</div>;} Скопировать  "},{"title":"Падающие запросы","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#падающие-запросы","content":" Подробнее import React from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get('api/fail'); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, }, queryOptions: { retryDelay: 500, },});// eslint-disable-next-line import/no-default-exportexport default function Component() { const { data, isLoading, isError, error } = useQuery(query); if (isLoading) { return <div>loading...</div>; } if (isError) { return <div>error: {error.message}</div>; } return <div>{data}</div>;} Скопировать  "},{"title":"Использование conditions для query","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#использование-conditions-для-query","content":" Подробнее import React from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients';import { TAPI_ROLES } from '@tinkoff/roles'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get('api/auth'); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, }, conditions: { requiredCoreRoles: [TAPI_ROLES.REGISTERED], },});// eslint-disable-next-line import/no-default-exportexport default function Component() { const { data = 'no-data', isLoading } = useQuery(query); return <div>{isLoading ? 'loading...' : data}</div>;} Скопировать  "},{"title":"Базовый пример для createInfiniteQuery и useInfiniteQuery","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#базовый-пример-для-createinfinitequery-и-useinfinitequery","content":" Подробнее import React from 'react';import { createInfiniteQuery, useInfiniteQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; interface Response { nextPage?: number; list: string[];} const query = createInfiniteQuery({ key: 'list', fn: async (_, start = 0, { apiClient }) => { const { payload } = await apiClient.get<Response>('api/list', { query: { count: 30, start, }, }); return payload; }, getNextPageParam: (page: Response) => { return page.nextPage; }, deps: { apiClient: TINKOFF_API_SERVICE, }, infiniteQueryOptions: {},}); // eslint-disable-next-line import/no-default-exportexport default function Component() { const { data, isLoading, fetchNextPage, hasNextPage } = useInfiniteQuery(query); if (isLoading) { return <>loading...</>; } return ( <div> <div> {data!.pages.map((page) => { return page.list.map((entry) => { return <div key={entry}>{entry}</div>; }); })} </div> {hasNextPage && ( <button type=\"button\" onClick={() => fetchNextPage()}> Load more </button> )} </div> );} Скопировать  "},{"title":"Базовый пример для createMutation и useMutation","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#базовый-пример-для-createmutation-и-usemutation","content":" Подробнее import React from 'react';import { createMutation, useMutation } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const mutation = createMutation({ key: 'post', fn: async (_, data: string, { apiClient }) => { const { payload } = await apiClient.post('api/post', { body: { data, }, }); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },});// eslint-disable-next-line import/no-default-exportexport default function Component() { const { isLoading, mutate } = useMutation(mutation); if (isLoading) { return <>loading...</>; } return ( <button type=\"button\" onClick={() => mutate('test')}> Send data </button> );} Скопировать  "},{"title":"Основная дока","type":0,"sectionRef":"#","url":"docs/references/cli/base","content":"","keywords":""},{"title":"Установка","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#установка","content":"Глобальная установка на машине разработчика. В терминале будет доступна команда tramvai. npm i -g --registry https://registry.npmjs.org/ @tramvai/cli Скопировать Локальная установка в проекте npm i --save-dev @tramvai/cli Скопировать "},{"title":"Команды","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#команды","content":"После любой команды можно набрать --help, к примеру tramvai --help или tramvai start --help. После это в консоли появится описание команды и возможные параметры для использования. tramvai new - генерация нового репозитория с tramvai/cli и tramvaitramvai start - запуск приложений в режиме разработкиtramvai start-prod - запуск приложений в режиме разработки, при этом статика собрана в production режимеtramvai build - сборка приложений для сервера и клиентаtramvai analyze - анализ размер приложенияtramvai generate - кодогенерация различных компонентов. К примеру новых проектов, react компонентов, экшенов, сервис и так далееtramvai update - обновление @tramvai/cli и всех @tramvai и @tramvai-tinkoff зависимостей в приложении (делает дедупликацию зависимостей и запускает миграции)tramvai add - добавление @tramvai или @tramvai-tinkoff зависимости в приложении (делает дедупликацию зависимостей и запускает миграции) "},{"title":"Конфигурация","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#конфигурация","content":"Для работы tramvai-cli обязательно должен в корне проекта быть создан конфигурационный файл в формате json, с описанием используемых проектов. tramvai-cli поддерживает следующие названия конфигурационных файлов: platform.jsontramvai.json "},{"title":"Формат файла конфигурации","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#формат-файла-конфигурации","content":"{ \"projects\": { \"react-app\": { \"name\": \"new-app\", \"root\": \"src\", \"type\": \"application\", \"commands\": { \"build\": { \"options\": { ... }, \"configurations\": { ... } }, \"serve\": { \"configurations\": { ... } } } } }} Скопировать projects - описание всех проектов, которые доступны в этом репозитории. Поддерживает множество различных приложений в одном репозитории. Реализовывая концепцию монорепы. "},{"title":"Поддержка JSON схемы файла конфигурации в IDE","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#поддержка-json-схемы-файла-конфигурации-в-ide","content":"Ссылка на актуальную JSON схему для tramvai.json - ./node_modules/@tramvai/cli/schema.json Самый простой способ добавить валидацию и автокомплит схемы - добавить ссылку в поле $schema для tramvai.json: { \"$schema\": \"./node_modules/@tramvai/cli/schema.json\", \"projects\": {}} Скопировать Другой способ - добавление схемы в настройках IDE: Как добавить схему в JetBrains IDE можно посмотреть в официальной документации, кроме добавления ссылки на схему, надо добавить tramvai.json как file path pattern. Как добавить схему в VSCode можно посмотреть в официальной документации Новое приложение, созданное через tramvai new, уже содержит поле $schema в tramvai.json. "},{"title":"Настройки для build этапа","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#настройки-для-build-этапа","content":"Общее описание механизма сборки артефактов и их доставки \"options\": { \"vendor\": \"\", // Путь до vendor файла, если не указан, то не генерируется \"polyfill\": \"\", // Путь до полифилов необходимых для работы приложения, если не указан, то не генерируется \"server\": \"src/server\", // Путь до стартвой точки серверного файла, который будет отдельно собран \"outputServer\": \"dist/server\", // Директория, куда после сборки скопируется серверный код \"outputClient\": \"dist/client\" // Директория, куда после сборки скопируется клиенский код},\"configurations\": { \"commonChunk\": true, // включает генерацию js файла с общим кодом между чанками \"commonChunkSplitNumber\": 3, // количество дубликатов, для выноса в common чанк \"sourceMap\": false, // будут ли сгенерированны сорсмапы для клиентских чанков \"sourceMapServer\": false, // будут ли сгенерированны сорсмапы для серверных чанков \"modern\": true, // Включение отдельной сборки для новых браузеров без дополнительной компиляции \"checkAsyncTs\": false, // включает проверку в фоне типов, подробное описание ниже \"terserParallel\": true, // включает параллельное сжатие \"granularChunks\": false, // Включает разбитие common chunk на множество мелких частей. Потенциально может снизить размер js в сборке \"granularChunksSplitNumber\": 2, // количество дубликатов, для выноса в granular чанки \"generateDataQaTag\": false, // автоматическая генерация уникальных id для реакт компонентов. Депрекейтед! \"definePlugin\": { // конфигурация параметров сборки приложения. Позволяет во время сборки заменить значения на преданные ниже \"prod\": {}, \"dev\": {} }, \"threadLoader\": { // конфигурация параметров многопоточной сборки приложения (https://webpack.js.org/loaders/thread-loader/). }, \"postcss\": { // конфигурация postcss лоадера \"cssLocalIdentName\": \"[hash:base64:5]\", // какой будет идентификатор \"config\": \"postcss.config\" // где расположен конфиг для postcss }, \"alias\": {}, // объект с алисами внутри приложения. Документация подробнее о формате можно прочитать в https://www.npmjs.com/package/babel-plugin-module-resolver \"removeTypeofWindow\": true, // настраивает babel плагин transform-define на замену всех конструкций typeof window на 'undefined' или 'object' в зависимости от окружения \"dedupe\": \"equality\" | \"semver\" | false, // подключение плагина для дедупликации зависимостей, с которыми не справился пакетный менеджер \"svgo\": { \"plugins\": [{ \"cleanupIDs\": false }, { \"collapseGroups\": false }], // плагины для svgo (https://github.com/svg/svgo#what-it-can-do) }, \"imageOptimization\": { // конфигурация процесса оптимизации изображений enabled: true, // включение оптимизации изображений options: {} // опции для гибкой настройки оптимизации (https://github.com/tcoopman/image-webpack-loader#options) }} Скопировать "},{"title":"Добавление новых параметров конфигурации","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#добавление-новых-параметров-конфигурации","content":"Параметры конфигурации CLI описаны в TypeScript интерфейсах, из них автоматически генерируется JSON Schema. Схема используется для валидации конфига, и применения значений по умолчанию, с помощью ajv. Например, если мы хотим добавить параметр для команды build, для приложения: Описываем параметр в интерфейсе ApplicationBuild "},{"title":"Возможности","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#возможности","content":""},{"title":"Генерация кода","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#генерация-кода","content":"Для упрощения жизни разработчиков в tramvai cli доступна возможность кодогенерации, которая позволяет при выполнении команды сгенерировать шаблонный код. Для запуска генератора, введи в консоли npm tramvai generate и выберете из списка то, что нужно сгенерировать: actionbundlereducerpagecomponentmodule После ввода названия, будет сгенерирован шаблонный файл "},{"title":"Генерация нового проекта","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#генерация-нового-проекта","content":"Для быстрого старта нового проекта добавлена команда tramvai new которая позволяет сгенерировать чистый проект с tramvai и tramvai-cli Установите глобального tramvai-cliВведите команду tramvai new NAME_YOUR_APPИ выберете опции: будет ли это монорепа, нужен ли CI и какие используются тестовые фреймворки После выполнения команды и установки зависимостей, для вас сгенерируется проект "},{"title":"Сборка библиотек","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#сборка-библиотек","content":"Команда tramvai build позволяет собирать библиотеки в отдельные бандлы под разные окружения: CommonJS модули + код стандарта ES2015 (для NodeJS без поддержки ES модулей) - поле main в package.jsonES модули + код стандарта ES2015 (для NodeJS с поддержкой ES модулей) - поле module в package.jsonES модули + код стандарта ES5 (для legacy браузеров) - поле browser в package.jsonES модули + код стандарта ES2017 (для современных браузеров) - поле es2017 в package.json Для создания библиотеки в tramvai.json необходимо добавить проект с типом package: { \"projects\": { \"{{packageName}}\": { \"name\": \"{{packageName}}\", \"type\": \"package\", \"root\": \"libs/{{packageName}}\" } }} Скопировать Все дополнительные настройки необходимо указать в package.json библиотеки: { \"name\": \"{{packageName}}\", \"version\": \"1.0.0\", \"source\": \"src/index.ts\", // точка входа в библиотеку \"browserSource\": \"src/browser.ts\", // опциональное поле, точка входа в библиотеку для браузерного окружения, использовать если требуется разделить реализации для сервера и браузера \"main\": \"dist/index.js\", // название собранного CommonJS + ES2015 бандла \"module\": \"dist/index.es.js\", // название собранного ESM + ES2015 бандла \"browser\": \"dist/browser.js\", // опциональное поле, название собранного CommonJS + ES2015 бандла, использовать вместе с полем `browserSource` \"es2017\": \"dist/browser.es2017.js\", // название собранного ESM + ES2017 бандла, если не указывать, вычисляется из поля `source` \"sideEffects\": false, \"scripts\": { \"start\": \"tramvai build {{packageName}} --watch\", // продакшн сборка в watch режиме \"build\": \"tramvai build {{packageName}}\" // разовая продакшн сборка }} Скопировать "},{"title":"Hot refresh в dev-режиме","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#hot-refresh-в-dev-режиме","content":"Есть возможность включить обновление react-компонентов на странице без перезагрузки страницы, аналогичный фиче из React Native. Помимо быстрой перезагрузки страницы (hot-reload), в этом режиме сохраняется значение в хуках useState и useRef. Для возможности принудительно сбросить значения, можно добавить комментарий // @refresh reset - он действует на весь файл. При различных синтаксических и рантайм ошибках, fast-refresh плагин ждет исправления ошибки, затем разработка продолжается в обычном режиме. Ограничения режима: state у классовых компонентов не сохраняетсяuseEffect, useMemo, и useCallback обновляются при каждом изменении кода, независимо от списка их зависимостей, в том числе если список пустой, т.е. useEffect(() => {}, []) будет выполняться постоянно - это не ожидаемое поведение, но приучает писать устойчивый к холостым ререндерам код Подключение режима: \"commands\": { \"serve\": { \"configurations\": { \"hotRefresh\": true } }} Скопировать Конфигурация режима через настройку hotRefreshOptions, подробная конфигурация в доке react-refresh: \"commands\": { \"serve\": { \"configurations\": { \"hotRefresh\": true, \"hotRefreshOptions\": { \"overlay\": false // отключаем overlay с сообщением об ошибках } } }} Скопировать "},{"title":"Анализ бандлов приложений","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#анализ-бандлов-приложений","content":"Посмотреть что попадает в бандл# Для это существует отличный плагин webpack-bundle-analyzer который позволяет показать наглядно все файлы Для запуска необходимо выполнить команду npx tramvai analyze APP_ID Скопировать после этого приложение соберется в проде и откроется новая вкладка в браузере Найти причину попадания зависимости в бандл# Для решения этого кейса существует утилита whybundled которая позволяет распарсить stats.json файл webpack и отобразить причину попадения файла Для использования необходимо выполнить команду npx tramvai analyze APP_ID --plugin whybundled Скопировать После этого сгенерируется json файл сборки который можно будет анализировать с помощью whybundled. Путь до файла будет отображен в терминале # Хочу найти причину попадания зависимости debug в сборкуnpx whybundled ./dist/client/stats.json debug # Хочу узнать что за собой потянула зависимость debug в сборкуnpx whybundled ./dist/client/stats.json --by debug Скопировать Больше возможностей можно найти в whybundled "},{"title":"Настройка нотификаций при сборке\\пересборке проекта","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#настройка-нотификаций-при-сборкепересборке-проекта","content":"В файле platform.json можно задать настройки для нотификации по пути commands.serve.notifications. Параметры задаются для пакета webpack-build-notifier. Можно задать как общую конфигурацию, так и отдельную для клиента\\сервера. \"commands\": { \"serve\": { \"notifications\": { \"suppressSuccess\": \"always\", \"server\": { \"suppressWarning\": true }, \"client\": { \"activateTerminalOnError\": true } } }} Скопировать "},{"title":"Включение сорсмапов в дев-режиме","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#включение-сорсмапов-в-дев-режиме","content":"В platform.json \"commands\": { \"serve\": { \"configurations\": { \"sourceMap\": true } }} Скопировать "},{"title":"Работа modern в дев-режиме","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#работа-modern-в-дев-режиме","content":"В деве возможно работать только с одним режимом: modern или legacy. По умолчанию выставлен legacy. Для включения modern режима в деве необходимо в platform.json добавить опцию modern: true: \"commands\": { \"serve\": { \"configurations\": { \"modern\": true } }} Скопировать "},{"title":"Настройка генерации имен css классов","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#настройка-генерации-имен-css-классов","content":"Генерация настраивается через свойства cssLocalIdentNameDev и cssLocalIdentNameProd (или общее cssLocalIdentName которое будет использовано если явно не заданы prod или dev). \"commands\": { \"build\": { \"configurations\": { \"postcss\": { \"cssLocalIdentName\": \"[hash:base64:5]\", // значение по умолчанию, переопределит оба нижних параметра (deprecated) \"cssLocalIdentNameDev\": \"[name]__[local]_[minicss]\", // возможные опции смотри в readme для css-loader https://github.com/webpack-contrib/css-loader \"cssLocalIdentNameProd\": \"[minicss]\", // можно дополнительно указать при генерации тег minicss чтобы генерировать минимальные имена css https://dev.to/denisx/reduce-bundle-size-via-one-letter-css-classname-hash-strategy-10g6 }; }; };}; Скопировать "},{"title":"Полифиллы для страндартных NodeJS модулей","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#полифиллы-для-страндартных-nodejs-модулей","content":"По умолчанию, webpack начиная с 5й версии, больше не добавляет в бандл полифиллы для браузера, при использовании стандартных NodeJS модулей в универсальном коде, пример таких модулей - crypto, path, process, buffer, etc. В @tramvai/cli явно подключены полифиллы для path и process. Эти модули часто используются, а их полифиллы имеют небольшой размер. "},{"title":"Проверка типов checkAsyncTs","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#проверка-типов-checkasyncts","content":"Включается по флагу “checkAsyncTs”: true Скопировать При запуске tramvai start будет происходить компиляция ts и проверка типов. Можно задать в формате объекта: \"checkAsyncTs\": { \"failOnBuild\": true, // необязательная опция \"pluginOptions\": {} // необязательная опция}, Скопировать failOnBuild добавит компиляцию ts при работе tramvai build. Таким образом команда build не будет проходить при невалидном ts. pluginOptions – список дополнительных опций плагина fork-ts-checker-webpack-plugin Если вы хотите переопределить путь до конфига в pluginOptions.tsconfig, его нужно рассчитать относительно папки c tramvai cli, т.е. node_modules/@tramvai/cli. По умолчанию конфиг ищется в корне проекта: \\<rootDir>/tsconfig.json "},{"title":"Дедупликация модулей","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#дедупликация-модулей","content":"Параметр commands.build.configurations.dedupe отвечает за подключение плагина, отвечающего за дедупликацию модулей. Возможные значения: \"equality\" - выбран по умолчанию, строгое сравнение версий, схлопывает импорты пакетов одинаковых версий из разных мест Например, импорты node_modules/package/index.js и node_modules/nested-package/node_modules/package/index.js, в обычном случае положили бы в бандл оба модуля. \"semver\" - сравнение версий пакетов по semver, позволяет схлопнуть дополнительно те импорты, у которых отличаются только minor или patch версии. Например, будут схлопнуты пакеты версий 1.14.0 и 1.16.2 до 1.16.2, 0.14.1 и 0.16.5 до 0.16.5, а пакеты версий 0.0.2 и 0.0.5 останутся без изменений. false - отключает плагин дедупликации "},{"title":"Explanation","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#explanation","content":""},{"title":"Debug приложения","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#debug-приложения","content":"При разработке приложения иногда нужно напрямую продебажить node.js приложение, посмотреть потребление CPU, памяти. Для этого в команды start и start-prod добавлен параметр --debug которая: включит сорсмапы для сборки на клиенте и серверезапустит процесс сервера с флагом --inspect. И далее можно открыть отладчик в chrome devtools - chrome://inspect Source Maps# webpack предлагает несколько видов качества кода при генерации source maps, из них основные это: Исходный код - код до транспиляции и бандлинга, слепок наших исходников, разделенный по модулямТрансформированный код - код после транспиляции лоадерами (etc. babel), разделенный по модулямСгенерированный код - код после транспиляции и бандлинга, разделенный по модулям, все импорты и экспорты заменены на webpack-специфичные Для разработки используются source maps для трансформированного или сгенерированного кода, т.к. скорость их сборки выше, и показан именно тот код, который выполняется в целевом окружении, основное отличие от отладки без source map - указаны модули, в которых находится отлаживаемый код. tramvai генерирует большой общий бандл с серверным кодом, поэтому для отладки серверного кода лучше не увеличивать размер этого файла и использовать source maps в отдельном .js.map файле, который генерируется с исходным кодом приложения. Development# По умолчанию, для клиентского кода включены самые быстрые source maps, для серверного кода source-maps отключены. Флаг --debug активирует генерацию source map с исходным кодом для серверного бандла. Параметр commands.serve.configurations.sourceMap активирует генерацию source map с исходным кодом для клиентского и серверного бандлов. Production# По умолчанию, отключены source maps для клиентского и серверного кода. Флаг --debug активирует генерацию source map с исходным кодом для клиентского и серверного бандлов. Параметр commands.build.configurations.sourceMap активирует генерацию source map с исходным кодом для клиентского бандла. Параметр commands.build.configurations.sourceMapServer активирует генерацию source map с исходным кодом для серверного бандла. "},{"title":"How to","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#how-to","content":""},{"title":"Как можно запустить nodejs приложение в debug режиме?","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#как-можно-запустить-nodejs-приложение-в-debug-режиме","content":"Добавить при запуске приложения параметр --debug tramvai start my-app --debug Скопировать Далее открыть chrome devTools в левом верхнем углу кликнуть на лого Node.js. В итоге у вас откроется отдельный инспекторовщик вашего node.js приложения и вы можете снять снэпшот памяти, продебажить код и провести профилировку приложения "},{"title":"Получить расширенную информацию о deprecated и warnings","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#получить-расширенную-информацию-о-deprecated-и-warnings","content":"Может быть полезно для получения стектрейса различных предупреждений. Запускает сервер приложения с дополнительными опциями. Например, если при работе приложения отображается лог вида (node:2898) DeprecationWarning: ...(Use `node --trace-deprecation ...` to show where the warning was created) Скопировать Нужно добавить при запуске приложения параметр --trace tramvai start my-app --trace Скопировать После запуска приложения с такой опцией логи будут отображаться со стеком вызова. "},{"title":"Как протестировать приложение используя browserstack","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#как-протестировать-приложение-используя-browserstack","content":"Получить доступы к browserstack можно написав в слаке команду /bs Запустите приложение как обычно командой tramvai start и используя инструкцию browserstack настройте локальное тестирование на своей машине. Если всё сделано правильно, то теперь в browserstack можно будет получить доступ к localhost и протестировать работу приложения. "},{"title":"Как протестировать приложение на мобилке или другом устройстве в локальной сети","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#как-протестировать-приложение-на-мобилке-или-другом-устройстве-в-локальной-сети","content":"Необходимо чтобы оба устройства на котором запускается приложение и на котором требуется проверить работу находилось в одной сети. Для организации доступа приложения в сети необходимо: узнать ip адрес машины на которой запускается приложение в интересующей сетизапустить команду tramvai start с параметров staticHost равным этому ip адресу (пример tramvai start tincoin --staticHost 192.168.1.3)с тестового устройства теперь можно будет получить доступ к приложению обратившись по адресу хоста = ip При передаче параметров в @tramvai/cli через npm скрипты необходимо перед параметрами для cli добавить --, т.е. команда должна выглядеть примерно так npm start -- --staticHost 192.168.1.3 "},{"title":"Как ускорить сборку приложения при разработке","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#как-ускорить-сборку-приложения-при-разработке","content":"Указать только определённые бандлы для разработки# Приложение может содержать несколько бандлов и чем их больше, тем больше кода в приложении, а, следовательно, и дольше сборка и пересборка проекта в процессе разработки. Чтобы ускорить этот процесс при запуске @tramvai/cli можно указать какие бандлы нужны сейчас для разработки и cli будет собирать только их Бандлы должны находиться в папке bundles и импортироваться из главного файла приложения. При попытке запроса бандлов, которые отключены в данный момент, сервер упадёт с 500-ой ошибкой, т.к. это неожидаемое поведение для сервера, что бандла нет # если нужен только один бандл для разработкиtramvai start myapp --onlyBundles=account# если нужно несколько бандловtramvai start myapp --onlyBundle=account,trading Скопировать "},{"title":"Интеграция с browserslist","type":0,"sectionRef":"#","url":"docs/references/cli/browserslist","content":"","keywords":""},{"title":"Виды env для browserslist","type":1,"pageTitle":"Интеграция с browserslist","url":"docs/references/cli/browserslist#виды-env-для-browserslist","content":"В cli используется определённый список возможных env target для работы с browserslist: modern - используется для сборки клиентского кода для современных браузеровnode - используется при сборке серверного кодаdefaults - используется в остальных случаях, т.е. для сборки клиентского кода для устаревших браузеров "},{"title":"Настройка в cli","type":1,"pageTitle":"Интеграция с browserslist","url":"docs/references/cli/browserslist#настройка-в-cli","content":"По умолчанию в cli используются определения из библиотеки @tinkoff/browserslist-config. Чтобы расширить или переопределить настройки по умолчанию можно использовать любой из способов задания конфига browserslist следуя правилам: Менять конфигурацию можно для env из списка, используемого в cli - как задавать. Если какого-то env в конфиге не будет, то будет использован конфиг по умолчанию.Если необходимо расширить списки по умолчанию, то используйте возможность расширения конфига \"browserslist\": { \"modern\": [ \"extends @tinkoff/browserslist-config\", \"chrome > 25\" ], \"node\": [ \"extends @tinkoff/browserslist-config\" ], \"defaults\": [ \"extends @tinkoff/browserslist-config\", \"chrome > 27\" ]} Скопировать В случае если необходимо сузить список браузеров, то откажитесь от использования extends @tinkoff/browserslist-config и пропишите список всех браузеров самостоятельно, ориентируясь на список в @tinkoff/browserslist-config. При необходимости сделайте это для всех env - те env которые не будут переопределены будут работать по умолчанию "},{"title":"Дебаг","type":1,"pageTitle":"Интеграция с browserslist","url":"docs/references/cli/browserslist#дебаг","content":"Чтобы проверить работу browserslist можно выполнить следующие команды из корня приложения: npx browserslist --env=modern # покажет список браузеров для modernnpx browserslist --env=node # покажет список поддерживаемых версий nodejsnpx browserslist # покажет список браузеров вместе с legacy браузерами Скопировать "},{"title":"Нюансы","type":1,"pageTitle":"Интеграция с browserslist","url":"docs/references/cli/browserslist#нюансы","content":""},{"title":"autoprefixer","type":1,"pageTitle":"Интеграция с browserslist","url":"docs/references/cli/browserslist#autoprefixer","content":"Из-за особенностей устройства самого autoprefixer при сборке будет использован только defaults конфиг. Если есть серьёзная заинтересованность в раздельной компиляции css, то напишите, пожалуйста, об этом в slack-чате #tramvai "},{"title":"Experimental settings","type":0,"sectionRef":"#","url":"docs/references/cli/experiments","content":"","keywords":""},{"title":"Настройки Webpack","type":1,"pageTitle":"Experimental settings","url":"docs/references/cli/experiments#настройки-webpack","content":"Сам webpack предоставляет список экспериментальных опций, которые можно задать как и описано в доке через experiments.webpack. Обратите особенно внимание на флаг futureDefaults который позволяет включить все экспериментальные опции, которые планируются включить в следующий мажорный релиз по умолчанию "},{"title":"minicss","type":1,"pageTitle":"Experimental settings","url":"docs/references/cli/experiments#minicss","content":"Задаются через experiments.minicss и позволяют включать экспериментальные настройки для mini-css-extract-plugin useImportModule - включает особый способ компиляции модулей css, который должен ускорить время сборки и уменьшить потребление памяти. Подробнее в оф. доке "},{"title":"Вставка inline-кода для клиента на сервере","type":0,"sectionRef":"#","url":"docs/references/cli/serverInline","content":"","keywords":""},{"title":"Решение","type":1,"pageTitle":"Вставка inline-кода для клиента на сервере","url":"docs/references/cli/serverInline#решение","content":"Для клиента с помощью webpack + babel уже и так происходит транспиляция кода для работы в нужных браузерах. Поэтому нам по сути остаётся специальным образом указать, что некий код предназначен для клиента и потому его нужно собрать особым образом. Правила для сборки определённого кода для клиента: код для вставки должен быть вынесен в отдельный файлв самом файле не должно быть импортов других модулей - на клиенте импорты требуют runtime вебпака, который не знает о тех файлах, которые используются на сервересам код должен быть оформлен в виде экспортируемых функций и эти функции могут использовать только переданные ей аргументы, использование внешних переменных вне тела функции запрещеныимя файла должно оканчиваться на .inline(.es)?.[tj]s - это работает как флаг, указывающий что файл надо собрать клиентским конфигомвместо инлайн кода вставляется как строка вызова экспортируемой функции с передачей ей аргументов - благодаря тому, что для функции преобразование в строку вернёт тело этой функции в виде строки, такая вставка будет работать "},{"title":"Пример","type":1,"pageTitle":"Вставка inline-кода для клиента на сервере","url":"docs/references/cli/serverInline#пример","content":"Создадим файл с инлайн кодом test.inline.ts export const test = (arg: string) => { class Test { log() { console.log({ arg, a: 1, }); } } const t = new Test(); t.log();}; Скопировать Теперь импортируем функцию и вставляем её в начальный html import { Module } from '@tramvai/core';import { RENDER_SLOTS, ResourceType, ResourceSlot } from '@tramvai/module-render';import { test } from './test.inline'; @Module({ providers: [ { provide: RENDER_SLOTS, multi: true, useFactory: () => { const arg = 'Hello'; return { slot: ResourceSlot.HEAD_SCRIPTS, type: ResourceType.inlineScript, // обратите внимание, что добавляем используем функцию как будто пишем iife функцию, только вместо тела функции используем код импорт из модуля // при этом передаваемые строки надо дополнительно заключать в кавычки payload: `(${test})('${arg}')`, }; }, }, ],})export class CustomModule {} Скопировать После сборки проекта и запуска страницы в браузере должен получить такой код, вместо изначального <script> (function test(arg) { var Test = /*#__PURE__*/ (function () { function Test() {} var _proto = Test.prototype; _proto.log = function log() { console.log({ arg: arg, a: 1, }); }; return Test; })(); var t = new Test(); t.log(); })('Hello');</script> Скопировать "},{"title":"browserslist-config","type":0,"sectionRef":"#","url":"docs/references/libs/browserslist-config","content":"","keywords":""},{"title":"Api","type":1,"pageTitle":"browserslist-config","url":"docs/references/libs/browserslist-config#api","content":""},{"title":"defaults","type":1,"pageTitle":"browserslist-config","url":"docs/references/libs/browserslist-config#defaults","content":"Contains config for every supported browser "},{"title":"modern","type":1,"pageTitle":"browserslist-config","url":"docs/references/libs/browserslist-config#modern","content":"Contains config for, so called \"modern\" browser. Browser's versions in this list are higher than for defaults and these browsers support more functionality "},{"title":"node","type":1,"pageTitle":"browserslist-config","url":"docs/references/libs/browserslist-config#node","content":"Contains config for nodejs "},{"title":"legacy","type":1,"pageTitle":"browserslist-config","url":"docs/references/libs/browserslist-config#legacy","content":"Config for legacy but still supported browsers. Currently this is equal to defaults "},{"title":"browser-timings","type":0,"sectionRef":"#","url":"docs/references/libs/browser-timings","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"browser-timings","url":"docs/references/libs/browser-timings#installation","content":"Install npm package npm i --save @tinkoff/browser-timings Скопировать "},{"title":"How to","type":1,"pageTitle":"browser-timings","url":"docs/references/libs/browser-timings#how-to","content":"import { browserTimings } from '@tinkoff/browser-timings'; window.addEventListener('load', () => { setTimeout(() => { // setTimeout is necessary in order to get metrics about loadEventEnd const perfData = browserTimings(); }, 0);}); Скопировать After executing perfData will contain client performance metrics which may be send to any external system for further analysis. Call of the library should be executed only after page load in order to get actual data. Otherwise, it may return empty object without data. "},{"title":"Lib interface","type":1,"pageTitle":"browser-timings","url":"docs/references/libs/browser-timings#lib-interface","content":"export interface Timings { /* Connection timing from client to server */ connection: number; /* How much time backend was preparing response */ backend: number; /* Page download to client */ pageDownload: number; /* Timing of first paint for a page */ 'first-paint': number; /* Timing when DOM becomes interactive */ domInteractive: number; /* DOM building is complete */ domComplete: number; /* Page and every resource were loaded */ pageLoadTime: number; /* Common information about resources and its loading time grouped by type */ download: { html: TimingResource; js: TimingResource; css: TimingResource; img: TimingResource; font: TimingResource; other: TimingResource; };} interface TimingResource { /* Timing of resource loading */ duration: number; /* Byte-size measure of data used by resource */ encodedDecodeSize: number; /* Byte-size measure of data transferred by network. Calculating difference between encodedDecodeSize - transferSize may reveal how much data where stored in browser cache */ transferSize: number;} Скопировать "},{"title":"error-handlers","type":0,"sectionRef":"#","url":"docs/references/libs/error-handlers","content":"","keywords":""},{"title":"Api","type":1,"pageTitle":"error-handlers","url":"docs/references/libs/error-handlers#api","content":"globalErrorHandler = (logger: Logger = console) - init logging of global errorsunhandledRejectionHandler = (logger: Logger = console) - init logging of unhandled rejection promise "},{"title":"Parameters","type":1,"pageTitle":"error-handlers","url":"docs/references/libs/error-handlers#parameters","content":"Logger - used for logging errors export interface Logger { warn: Function; error: Function;} Скопировать "},{"title":"express-terminus","type":0,"sectionRef":"#","url":"docs/references/libs/express-terminus","content":"","keywords":""},{"title":"Features","type":1,"pageTitle":"express-terminus","url":"docs/references/libs/express-terminus#features","content":"healthChecks handlers are creater for an express app, in contrast to original library which redefines request event handler of server object. Original behaviour is more complicated in case of a need to add common logic for every request in the app, including healthChecks itself. E.g. it was not possible to add http-header in single place to make it work for every request. "},{"title":"eslint-plugin-tramvai","type":0,"sectionRef":"#","url":"docs/references/libs/eslint-plugin-tramvai","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"eslint-plugin-tramvai","url":"docs/references/libs/eslint-plugin-tramvai#installation","content":"Install necessary packages first npm i --save-dev @tinkoff/eslint-config @tinkoff/eslint-config-react @tinkoff/eslint-plugin-tramvai Скопировать Add recommended settings to .eslintrc: { \"extends\": [ \"@tinkoff/eslint-config/app\", \"@tinkoff/eslint-config-react\", \"plugin:@tinkoff/tramvai/recommended\" ]} Скопировать Or add plugin manually: { \"extends\": [ \"@tinkoff/eslint-config/app\", \"@tinkoff/eslint-config-react\" ], \"plugins\": [ \"@tinkoff/tramvai\" ], \"rules\": { \"@tinkoff/tramvai/bundle-chunk-name\": \"warn\" }} Скопировать "},{"title":"Rules","type":1,"pageTitle":"eslint-plugin-tramvai","url":"docs/references/libs/eslint-plugin-tramvai#rules","content":""},{"title":"bundle-chunk-name","type":1,"pageTitle":"eslint-plugin-tramvai","url":"docs/references/libs/eslint-plugin-tramvai#bundle-chunk-name","content":"In a tramvai app, in order to work properly with the bundle system it is necessary to put a special comment for dynamic imports. This rule checks that dynamic imports of bundles are marked with a proper control comment webpackChunkName: [name]. The rule also provides autofix in order to add add/fix control comment automatically. Example of the wrong code: createApp({ bundles: { 'tramvai/bundle-1': () => import('./bundles/bundle1'), 'tramvai/bundle-2': () => import(/* webpackChunkName: \"randomValue\" */ './bundles/bundle2'), },}); Скопировать Example of the right code after autofix for the code above: createApp({ bundles: { 'tramvai/bundle-1': () => import(/* webpackChunkName: \"bundle-1\" */ './bundles/bundle1'), 'tramvai/bundle-2': () => import(/* webpackChunkName: \"bundle-2\" */ './bundles/bundle2'), },}); Скопировать Options: propertyNames: defines array of object properties which will be analyzed. By default it equals to [\"bundles\"]. "},{"title":"hooks","type":0,"sectionRef":"#","url":"docs/references/libs/hooks","content":"","keywords":""},{"title":"Explanation","type":1,"pageTitle":"hooks","url":"docs/references/libs/hooks#explanation","content":"Working with lib consist of two phases: Adding in the target code hook runner call, e.g. runAsyncHooks, with unique event key and additional parameters. It creates a slot for this event that allow to subscribe on the event.Registering hook handler with registerHooks that will be executed when run... function will be called "},{"title":"Caveats","type":1,"pageTitle":"hooks","url":"docs/references/libs/hooks#caveats","content":"There is different types hooks that are not interoperable. So carefully add new registrations with checking expected hook type. Also you should preserve data chain, e.g. return data with same interface from hook, as it otherwise may break other hooks. "},{"title":"API","type":1,"pageTitle":"hooks","url":"docs/references/libs/hooks#api","content":"Hooks# Create new instance of @tinkoff/hook-runner import { Hooks } from '@tinkoff/hook-runner'; const hookRunner = new Hooks(); Скопировать registerHooks(key, hooks)# Register new hook for a specific key. runHooks(key, context, payload, options)# Execute sync hooks. payload is passed through every hook and will be returned as a result (it may be changed by hooks). runAsyncHooks(key, context, payload, options)# Executes async hooks using setTimeout. payload is passed to every hook with its initial value. runPromiseHooks(key, context, options) => (payload) => Promise# Execute promise-based hooks. payload is passed through every hook and will be returned as a result (it may be changed by hooks) "},{"title":"Hooks","type":1,"pageTitle":"hooks","url":"docs/references/libs/hooks#hooks-1","content":""},{"title":"Types","type":1,"pageTitle":"hooks","url":"docs/references/libs/hooks#types","content":"sync# Accepts (context, payload, options). Hooks are running in order passing previous hook result as input for next hook. async# Accepts (context, payload, options). Hooks are running independently from each other. promise# Accepts (context, payload, options). Hooks are running in order passing previous hook result as input for next hook with wrapping call in promise. "},{"title":"is-modern-lib","type":0,"sectionRef":"#","url":"docs/references/libs/is-modern-lib","content":"","keywords":""},{"title":"Usage","type":1,"pageTitle":"is-modern-lib","url":"docs/references/libs/is-modern-lib#usage","content":"Based on example from the article Publish, ship, and install modern JavaScript // webpack.config.jsconst { modernLibsFilter } = require('@tinkoff/is-modern-lib'); module.exports = { module: { rules: [ // Transpile for your own first-party code: { test: /\\.[cm]?js$/i, loader: 'babel-loader', exclude: /node_modules/, }, // Transpile modern dependencies: { test: /\\.[cm]?js$/i, include: modernLibsFilter, use: { loader: 'babel-loader', options: { babelrc: false, configFile: false, presets: ['@babel/preset-env'], }, }, }, ], },}; Скопировать "},{"title":"http-client","type":0,"sectionRef":"#","url":"docs/references/libs/http-client","content":"","keywords":""},{"title":"API","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#api","content":""},{"title":"HttpClient","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#httpclient","content":"type HttpClient = { // common method for sending HTTP requests request<P = any>(request: HttpClientRequest): Promise<HttpClientResponse<P>>; // method for sending GET requests get<R = any>( path: string, payload?: Pick<HttpClientRequest, 'query' | 'headers'>, config?: Omit<HttpClientRequest, 'url' | 'query' | 'body' | 'headers'> ): Promise<HttpClientResponse<R>>; // method for sending POST requests, uses `requestType: 'json'` by default post<R = any>( path: string, payload?: Pick<HttpClientRequest, 'query' | 'body' | 'headers'>, config?: Omit<HttpClientRequest, 'url' | 'query' | 'body' | 'headers'> ): Promise<HttpClientResponse<R>>; // method for sending PUT requests, uses `requestType: 'json'` by default put<R = any>( path: string, payload?: Pick<HttpClientRequest, 'query' | 'body' | 'headers'>, config?: Omit<HttpClientRequest, 'url' | 'query' | 'body' | 'headers'> ): Promise<HttpClientResponse<R>>; // method for sending DELETE requests delete<R = any>( path: string, payload?: Pick<HttpClientRequest, 'query' | 'headers'>, config?: Omit<HttpClientRequest, 'url' | 'query' | 'body' | 'headers'> ): Promise<HttpClientResponse<R>>; // method for creating a new instance of the HTTP client, based on the settings of the current fork(options?: HttpClientRequest, mergeOptionsConfig?: { replace?: boolean }): HttpClient;} Скопировать "},{"title":"HttpClientRequest","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#httpclientrequest","content":"type HttpClientRequest = { // absolute url of the request, do not use simultaneously with `path` url?: string; // url of the request, not to be used simultaneously with `url` path?: string; // base url, which is added to all queries before the `path` value baseUrl?: string; // basic HTTP methods are supported - GET, POST, PUT, DELETE method?: HttpMethod; // request data type, `form` by default requestType?: HttpContentType; // response data type, is calculated from the `content-type` header by default responseType?: HttpContentType; // HTTP request headers headers?: Record<string, any>; // request query parameters query?: Record<string, any>; // request body body?: Record<string, any>; // request execution time limit, in ms timeout?: number; // disabling logging inside the HTTP client. It is recommended to use if a request error is logged manually silent?: boolean; // disabling the request cache cache?: boolean; // if `abortPromise` is resolved, the request will be canceled abortPromise?: Promise<void>; // method to modify request data modifyRequest?: (req: HttpClientRequest) => HttpClientRequest; // method to modify response data modifyResponse?: <P = any>(res: HttpClientResponse<P>) => HttpClientResponse<P>; // method to modify the error object modifyError?: (error: HttpClientError, req: HttpClientRequest) => HttpClientError; [key: string]: any;} Скопировать "},{"title":"HttpClientResponse","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#httpclientresponse","content":"type HttpClientResponse<P = any> = { // response body payload: P; // HTTP response code status: number; // HTTP response headers headers: Record<string, any>;} Скопировать "},{"title":"HttpClientError","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#httpclienterror","content":"type HttpClientError = Error & { [key: string]: any;} Скопировать "},{"title":"ApiService","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#apiservice","content":"ApiService - abstract class for easy creation of services for working with API, allows you to override custom logic in the request method, on top of which the rest of the basic methods work. For example, a service that automatically displays a pop-up window when a request error occurs: class CustomApiService extends ApiService { constructor({ httpClient }: { httpClient: HttpClient }) { super(httpClient); } request<R = any>(request: HttpClientRequest): Promise<HttpClientResponse<R>> { return this.httpClient.request(request).catch((error) => { alert(error); }); }} const service = new CustomApiService({ httpClient }); service.request({ path: 'fake' }) // show alertservice.get('fake') // also show alert Скопировать "},{"title":"Layout factory","type":0,"sectionRef":"#","url":"docs/references/libs/layout-factory","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"Layout factory","url":"docs/references/libs/layout-factory#installation","content":"Install @tinkoff/layout-factory using your package manager, e.g. for npm: npm i @tinkoff/layout-factory Скопировать Create new layout object import React from 'react';import { createLayout } from '@tinkoff/layout-factory';import { Content, Page, Feedback } from './components';import { layoutWrapper, feedbackWrapper } from './wrappers'; const MyLayout = createLayout({ components: { page: Page, content: Content, feedback: Feedback, }, wrappers: { layout: layoutWrapper, feedback: feedbackWrapper, },}); Скопировать "},{"title":"Layout structure","type":1,"pageTitle":"Layout factory","url":"docs/references/libs/layout-factory#layout-structure","content":"Layout has the following structure: <LayoutWrapper> {globalComponents} <ContentWrapper> <HeaderWrapper> <Header /> </HeaderWrapper> <PageWrapper>{page}</PageWrapper> <FooterWrapper> <Footer /> </FooterWrapper> </ContentWrapper></LayoutWrapper> Скопировать Any of the wrappers could be customized. By default, every wrapper just renders passed children prop, but HeaderWrapper and FooterWrapper render only if components Header and Footer were passed as props to result layout. "},{"title":"Customization ways","type":1,"pageTitle":"Layout factory","url":"docs/references/libs/layout-factory#customization-ways","content":"Customization is made through options components and wrappers "},{"title":"Components","type":1,"pageTitle":"Layout factory","url":"docs/references/libs/layout-factory#components","content":"React components header, footer, layout, content, page are base components for wrappers. They should render passed prop children. By default, layout, content, page are \"render children\" while header and footer are \"render prop\"any of the other components are, so called, globalComponents. They are just rendered as components inside LayoutWrapper "},{"title":"Wrappers","type":1,"pageTitle":"Layout factory","url":"docs/references/libs/layout-factory#wrappers","content":"HOC for components header, footer, layout, content, page - HOC for the base componentsall of the other components are HOCs for все остальные wrappers - HOC for corresponding globalComponents It is possible to pass a list of HOCs. This way order of render wrapping for passed component will be from end to start of the list. Such wrappers and used for: hide/show elements by conditionset additional css style for componentsinject additional code/handlerpass additional props Example of such wrapper: function layoutWrapper(WrappedComponent) { return (props) => ( <div className=\"ui-layout\"> <WrappedComponent {...props} /> </div> );} Скопировать "},{"title":"meta-tags-generate","type":0,"sectionRef":"#","url":"docs/references/libs/meta-tags-generate","content":"","keywords":""},{"title":"Api","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#api","content":"Meta({ list: [] }): Meta - object used for constructing an instance of meta-tags based on passed sourcesRender(meta: Meta): { render(): string } - render of specific Meta instance as a string. Used in SSRUpdate(meta: Meta): { update(): void } - updates meta-tags layout in browser. Used in browser while SPA-navigations "},{"title":"Format","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#format","content":"Library accepts special parameters which are used to generate result html tags. These parameters have next format: { customTag: { tag: 'meta', attributes: { name: 'k', content: 'i' }, innerHtml: '1' }} Скопировать thar renders in the next tag: <meta name=\"k\" content=\"i\">1</meta> Скопировать "},{"title":"Converters","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#converters","content":"Converters are used to convert meta-tags with specific keys in format view new Meta({ list, converters: { title: (value) => ({ tag: 'meta', innerHtml: value }) } }); Скопировать After that you now can pass meta as { title: 'Тинькофф' } in order to render it through converter above. "},{"title":"Sources","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#sources","content":"Through options list can be passed sources for meta-tags generating. These sources have the form of function that are called in runtime for generating result render. E.g.: const list = [ (walker) => walker.updateMeta(10, { title: 'test', tag: { tag: 'meta', attributes: { link: 'link' } }, }), (walker) => walker.updateMeta(20, { title: 'tinkoff', ogTitle: 'tinkoff', }),];const meta = new Meta({ list, converters }); Скопировать When generating meta tags all functions passed in list will be called with argument of class Walker. Inside such function it is possible to modify data using method updateMeta, which accepts the priority of the change and value. Elements with higher priority overrides values with lower priorities. "},{"title":"How to","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#how-to","content":""},{"title":"Set Meta","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#set-meta","content":"import { Meta, Render, Update } from '@tinkoff/meta-tags-generate'; const list = [ (walker) => walker.updateMeta(10, { title: 'test', tag: { tag: 'meta', attributes: { link: 'link' } }, }),];const meta = new Meta({ list, converters }); const metaContent = new Render(meta).render();console.log(metaContent); // > <title>test</title><meta link=link/> new Update(meta).update(); // Removes all previous meta and adds new one Скопировать "},{"title":"Remove meta parameters","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#remove-meta-parameters","content":"In order to remove data just pass null as a value. E.g. if you want to remove keywords meta: (walker) => walker.updateMeta(30, { keywords: null, }); Скопировать After that specified meta tag will be remove "},{"title":"minicss","type":0,"sectionRef":"#","url":"docs/references/libs/minicss","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"minicss","url":"docs/references/libs/minicss#installation","content":"Install using yarn yarn add --dev @tinkoff/minicss-class-generator Скопировать or npm npm i --save-dev @tinkoff/minicss-class-generator Скопировать "},{"title":"Setup","type":1,"pageTitle":"minicss","url":"docs/references/libs/minicss#setup","content":"Define options localIdentName и getLocalIdent for css-loader config inside your webpack config: ({ loader: 'css-loader', options: { modules: { getLocalIdent: createGenerator(), localIdentName: '[minicss]', }, },}); Скопировать For localIdentName it is possible to pass any template which is accepted by css-loader. E.g. if you want to add the origin filename and the className pass [name]__[local]_[minicss] as localIdentName "},{"title":"How does it work","type":1,"pageTitle":"minicss","url":"docs/references/libs/minicss#how-does-it-work","content":"Plugin generate unique key for a className using formula ${order}${contentHash} where contentHash is a hash of the source file content and order - ordered key of class definition inside source file. Using contentHash from source allows to generate less unique string and allows to reuse the same contentHash for every className that leads for better data compression with gzip/brotli. Using order helps sustain uniqueness for every className in single source file. Examples: [hash:base64:5]file: Button.css .2hlLi .32BZU Скопировать [minicss]file: Button.css .abhUzy .bbhUzy Скопировать "},{"title":"logger","type":0,"sectionRef":"#","url":"docs/references/libs/logger","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#installation","content":"Install using package manager, e.g. for npm: npm i --save @tinkoff/logger Скопировать for yarn: yarn add @tinkoff/logger Скопировать "},{"title":"Api","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#api","content":""},{"title":"Child loggers","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#child-loggers","content":"You can create child loggers using method .child of the current logger instance. Child logger will inherit parent logger settings and can override these settings. const log = logger({ name: 'test' }); const childLog = log.child('child'); // as this logger is child logger the result name will be 'test.child' const childLogWithDefaults = log.child({ name: 'withDefaults', defaults: { // defaults might be used to specify properties which will be merged to log objects logged with this logger child: true, },}); const childLogWithOverrides = log.child({ name: 'override', reporters: [], // may override settings of the parent logger filters: [], extensions: [],}); Скопировать "},{"title":"Display logs","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#display-logs","content":"Library allows to specify used logging level, show/hide logs for specific instances of the logger, reset display settings. By default, error level is used for every logger. Settings display level higher than error for single logger, e.g. logger.enable('info', 'my-logger'), overrides logging level only for my-logger. It is impossible to set logging level lower than common level, e.g. when using common logging level equal to error calls to logger.enable('fatal', 'my-logger') changes nothing. All subsequent setup for log displaying are preserved, e.g. subsequent calls logger.enable('info', 'my-logger') and logger.enable('trace', 'yet-another-logger') will enable logs to both logger according to their settings. Display logs on server# For control of displaying logs on server environment variables LOG_LEVEL and LOG_ENABLE are used: LOG_LEVEL = trace | debug | info | warn | error | fatal - enables displaying logs for specified level and higher. E.g.: if LOG_LEVEL=info then all logs of levels info, warn, error, fatal will be showed. LOG_ENABLE = ${name} | ${level}:${name} - let to enable displaying logs for a specific name and level. It can accept several entries that are passed as comma-separated. E.g.: if LOG_ENABLE=server then all logs for name server will be displayedif LOG_ENABLE=trace:server* then for logs with name server only trace level will be showedif LOG_ENABLE=info:server,client,trace:shared then displaying logs will be enabled for specified loggers using rules above Display logs in browser# In browser display settings are stored in localStorage, so it will work even after page reloads. In order to reset settings you may clear localStorage. For convenient usage a special object logger is added to window object in the browser. logger === window.logger; logger.setLevel('warn'); // enable displaying log for level `warn` and higher logger.enable('info', 'test'); // enable displaying logs for logger `test` with level `info` также отображать вывод логгера test уровня info logger.enable('my-logger'); // show all logs for logger `my-logger` logger.enable('perf*'); // enable all logs with name starting with `perf` logger.disable('my-logger'); // disable displaying logs for `my-logger` logger.clear(); // reset all settings Скопировать "},{"title":"Configuration","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#configuration","content":"Local logger configuration# import { logger } from '@tinkoff/logger'; const log = logger({ name: 'my-logger' }); // name is required field in order to identify logsconst log = logger('my-logger'); // same as above const log = logger({ name: 'remote-logger', defaults: { remote: true, },}); Скопировать Options: name[='log'] - name of the new logger "},{"title":"Extend logger functionality","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#extend-logger-functionality","content":"@tinkoff/logger might be extended using next entities: Filter# Filters can disable logging for specific logs base on inner conditions import { logger } from '@tinkoff/logger'; interface Filter { filter(logObj: LogObj): boolean;} logger.addFilter(filter as Filter); // add new filter to list of previously added filterslogger.setFilters([filter1, filter2]); // replace current filters with passed list. that allows to override default settings Скопировать Extension# Extensions can extend or override log object before making actual logging import { logger } from '@tinkoff/logger'; interface Extension { extend(logObj: LogObj): LogObj;} logger.addExtension(extension as Extension); // add new extension to list of previously added extensionslogger.setExtensions([extension1, extension2]); // replace current extensions with passed list. that allows to override default settings Скопировать Reporter# Reporters can change the way logs are showed (json, fancy logs in browser, send logs to remote api). Be default, enabled only reporters for displaying logs in console based on display logs settings Reporters are depends of logger level settings as reporters will not be called if level of the current log are lower than display logs setting import { logger } from '@tinkoff/logger'; interface Reporter { log(logObj: LogObj): void;} logger.addReporter(reporter as Reporter); // add new reporter to list of previously added reporterslogger.setReporters([reporter1, reporter2]); // replace current reporters with passed list. that allows to override default settings Скопировать BeforeReporter# Same as usual Reporter but BeforeReporter are called unconditionally for every log and get called before any other extension. import { logger } from '@tinkoff/logger'; interface Reporter { log(logObj: LogObj): void;} logger.addBeforeReporter(reporter as Reporter); // add new beforeReporter to list of previously added beforeReporterlogger.setBeforeReporters([reporter1, reporter2]); // replace current beforeReporters with passed list. that allows to override default settings Скопировать "},{"title":"Bundled Reporters","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#bundled-reporters","content":"BrowserReporter# Standard reporter to show logs in browser NodeDevReporter# Standard reporter to showing logs in the server console with handy formatting Used by default in dev-mode or if environment variable process.env.DEBUG_PLAIN is specified. NodeBasicReporter# Minimal reporter to showing logs in the server console. JSONReporter# Show logs in json format. RemoteReporter# Sends logs on remote api. import { logger, RemoteReporter } from '@tinkoff/logger'; const remote = new RemoteReporter({ requestCount: 1, // number of parallel request emitLevels: { error: true, fatal: true }, // log levels which will be send to api async makeRequest(logObj) { // function that accepts log object and sends data to api return await request(); },}); logger.addReporter(remote); const log = logger({ name: 'test-remote' }); // settings for remote will be inherited from RemoteReporter itself log.error('error'); // will be sent to apilog.info('test'); // will not be sent to api const remoteLog = logger({ name: 'remote-for-all', remote: true }); // `remote` allows to override settings from RemoteReporter and send logs unconditionally remoteLog.info('test'); // will be sent to apiremoteLog.debug('test'); // will be sent to api const traceLog = logger({ name: 'log-trace', emitLevels: { trace: true } }); // override RemoteReporter settings traceLog.trace('test'); // will be sent to apitraceLog.error('test'); // will not be sent to api Скопировать "},{"title":"How to","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#how-to","content":""},{"title":"Base usage","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#base-usage","content":"import logger from '@tinkoff/logger'; // import logger const log = logger('my-component'); // create new logger with an id `my-component`. This id will be added for every log at field `name`. Using unique ids will help to find source of the logs // logs can be created with different levelslog.trace('trace');log.debug('debug');log.info({ event: 'client-visited', message: 'client visited tinkoff.ru' });log.warn('warn');log.error({ event: 'form-send-error', error: new Error('form') });log.fatal('fatal error'); Скопировать More about logging level and what do they mean in the article. "},{"title":"How to log properly","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#how-to-log-properly","content":"To log properly it is suitable to use next format: interface Log { event?: string; // unique id of event which is might be easily found in log management tool message?: string; // log description error?: Error; // error if appropriate [key]: any; // any other data} Скопировать In case of logging simple text just use string template to pass result string to logger. For json format this string will be available in the message props. logger.info('hello logger'); // identical to logger.info({ message: 'hello logger' }); Скопировать In order to log some object or many arguments, compile they together to single object: logger.warn({ message: 'be warn', event: 'my-warning', ...obj1, ...obj2, a: 1, b: 2,}); Скопировать In order to log error object either pass the error with the props error or pass it to logger as only argument logger.error({ error: new Error('message'),}); logger.error(new Error('message'));logger.error(new Error('typeError'), 'custom error message'); // a special format to redefine error message Скопировать In case of several arguments were passed to logger then only the first argument will be proceeded with the rules from above while all of the other arguments will be passed as an args props logger.debug( { event: 'watch', data: 'some data', }, 'arg2', 'arg3'); Скопировать These formatting rules are handful to connect logging to external tools like kibana, splunk. So it is desirable to follow these rules, otherwise it may lead to troubles with searching and analyzing your logs. "},{"title":"Troubleshooting","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#troubleshooting","content":""},{"title":"I use logger in my Nest.js application, and it does not work","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#i-use-logger-in-my-nestjs-application-and-it-does-not-work","content":"Be sure that you set all required environment variable (LOG_LEVEL and LOG_ENABLE) before app initialization. If you set all variable in .env and parse them via Nest.js's ConfigModule, they will not be available in the logger initialization phase.ConfigModule parses .env-file later. Also, check herethat DEBUG_PLAIN or NODE_ENV variables are available. "},{"title":"mocker","type":0,"sectionRef":"#","url":"docs/references/libs/mocker","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#installation","content":"Install @tinkoff/mocker: yarn add @tinkoff/mocker Скопировать Add your first mock to file mocks/first-api.js: module.exports = { api: 'first-api', mocks: { 'GET /endpoint': { status: 200, headers: {}, payload: 'mocked response', }, },}; Скопировать Set up mocker in your project: import { Mocker, FileSystemMockRepository } from '@tinkoff/mocker'; // Repository will read mocks from directory `mocks` relative from current dirconst repository = new FileSystemMockRepository({ cwd: process.cwd(), root: 'mocks' });// Mocker to all of the request on `/first-api/...` will response with mock found in fs or with proxying request to the source APIconst options = { apis: { 'first-api': { target: 'https://real-first-api.com/', }, }, passUnhandledRequests: true,}; const mocker = new Mocker({ options, repository, logger: console }); (async () => { // with this call mocker reads mocks from repository and creates according routes await mocker.init(); mocker.start(4000, () => { console.log('Mocker is running at 4000 port'); });})(); Скопировать Now we can make a GET request to mocker (async () => { const response = await fetch('http://localhost:4000/first-api/endpoint'); const data = await response.json(); console.log(data); // \"mocked response\"})(); Скопировать "},{"title":"Explanation","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#explanation","content":"Library is based on express. mocker can be used as standalone server or as a middleware for existing server through call mocker.use(req, res). FileSystemMockRepository supports mock in js и json formats. js mocks are able to define custom express handler as a mock handler. For choosing right mock for request next parameters of the request are considered: method, url and query. Mocker supports proxying requests to API that allows to mock only part of the API and not a whole backend "},{"title":"Routing","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#routing","content":"If mocker is running as a standalone server, for example on 4000 port, then it will be accessible at url http://localhost:4000/. For every api from settings options.apis will be created a nester router, e.g. for first-api it will be http://localhost:4000/first-api/. Routes for api are getting created based on mocks, in which key is a method + url of the request, e.g. mock GET /endpoint will be accessible at http://localhost:4000/first-api/endpoint for GET requests. "},{"title":"FileSystem mocks","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#filesystem-mocks","content":"Mocker reads mocks using Repository, that allows to store mocks in FileSystem or on the another server. FileSystemMockRepository works with FileSystem and supports next kinds of mocks: mock.json { \"api\": \"first-api\", \"mocks\": { \"GET /foo\": { \"status\": 200, \"headers\": {}, \"payload\": { \"fake\": \"true\" } } }} Скопировать mock.js module.exports = { api: 'first-api', mocks: { 'GET /bar': { status: 200, headers: {}, payload: { fake: 'true', }, }, 'POST /bar': (req, res) => { res.status(200); res.set('X-Mock-Server', 'true'); res.json({ fake: 'true' }); }, },}; Скопировать "},{"title":"API","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#api","content":""},{"title":"Mocker","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#mocker","content":"interface Mocker { new (params: { options: MockerOptions; repository: MockRepository; logger: Logger }): Mocker; init(): Promise<void>; update(): Promise<void>; use(req: IncomingMessage, res: ServerResponse): express.Express; start(port: number, callback?: (...args: any[]) => void): Server;} Скопировать Mocker.init - resolve mocks using MockRepository, routing initialization. Must be called before using server with mocks. Mocker.update - updating mocks using MockRepository, routing update. Might be called in runtime. Mocker.use - express middleware. Might be used for adding mocker on the existing server. Mocker.start - run mocker as a standalone http-server. "},{"title":"MockerOptions","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#mockeroptions","content":"interface MockerOptions { apis: Record<string, { target: string }>; passUnhandledRequests?: boolean; apiRoutePrefix?: string;} Скопировать MockerOptions.apis - list of APIs for mocking, key target points to the source API. MockerOptions.passUnhandledRequests - when enabled, all of the request without according mock will be proxied to the target, otherwise fail the request. MockerOptions.apiRoutePrefix - if mocker is used in existing server on nested route, e.g. /mocker, this option might be used to pass this route as apiRoutePrefix for proper routing. "},{"title":"MockRepository","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#mockrepository","content":"interface MockRepository { get(api: string, endpoint: string): Promise<Mock>; getAll(api: string): Promise<Record<string, Mock>>; add(api: string, endpoint: string, mock: Mock): Promise<void>; delete(api: string, endpoint: string): Promise<void>;} Скопировать MockRepository.getAll - get all mocks for specified API. MockRepository.get - get specific mock for specific API. MockRepository.add - add new mock for specific API. MockRepository.delete - remove specific mock for specific API. "},{"title":"How to","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#how-to","content":""},{"title":"How to mock request with specific query parameters?","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#how-to-mock-request-with-specific-query-parameters","content":"Mocker allows to specify query parameters for mocks. In the example below request to /endpoint?foo=bar will be mocked with first mock, and request to /endpoint?foo=baz will be mocked with second. All of the other requests with\\without query will be proxied to source API (if passUnhandledRequests is enabled). module.exports = { api: 'api', mocks: { 'GET /endpoint?foo=bar': { status: 200, headers: {}, payload: 'mocked bar response', }, 'GET /endpoint?foo=baz': { status: 200, headers: {}, payload: 'mocked baz response', }, },}; Скопировать "},{"title":"How to proxy specific request to source API?","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#how-to-proxy-specific-request-to-source-api","content":"It might be useful if option passUnhandledRequests is disabled. In that case you may pass option pass: true to mock: module.exports = { api: 'api', mocks: { 'ALL /endpoint': { pass: true, }, },}; Скопировать "},{"title":"papi","type":0,"sectionRef":"#","url":"docs/references/libs/papi","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"papi","url":"docs/references/libs/papi#подключение","content":"Необходимо установить @tramvai/papi yarn add @tramvai/module-papi Скопировать "},{"title":"Использование","type":1,"pageTitle":"papi","url":"docs/references/libs/papi#использование","content":"import { createPapiMethod } from '@tramvai/papi'; export const papi = createPapiMethod({ path: '/my/papi', method: 'post', async handler(deps) { return 'test'; }, deps: { tinkoffApiService: TINKOFF_API_SERVICE, },}); Скопировать "},{"title":"prettier","type":0,"sectionRef":"#","url":"docs/references/libs/prettier","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"prettier","url":"docs/references/libs/prettier#installation","content":"Install with package manager, e.g. for npm: npm i --save-dev prettier-config-tinkoff Скопировать Create new file .prettierrc.js in project root: module.exports = require('prettier-config-tinkoff'); Скопировать It will set default settings from config, in order to change some settings follow official guide for prettier "},{"title":"React Hooks","type":0,"sectionRef":"#","url":"docs/references/libs/react-hooks","content":"","keywords":""},{"title":"Api","type":1,"pageTitle":"React Hooks","url":"docs/references/libs/react-hooks#api","content":""},{"title":"useShallowEqual","type":1,"pageTitle":"React Hooks","url":"docs/references/libs/react-hooks#useshallowequal","content":"Makes shallow equal check for passed argument. If current argument is equal to previous then result of the hook will not be changed. Otherwise it will be equal to a current argument. import { useEffect } from 'react';import { useShallowEqual } from '@tinkoff/react-hooks'; export function Cmp({ obj }) { // obj - some object // objRef - reference to object. For example, if reference obj were changed after sequential render, // but it still shallow equals to initial obj then objRef will reference to the initial obj ссылка на объект obj const objRef = useShallowEqual(obj); useEffect(() => { // React checks deps with reference equality that may lead to unnecessary hook call when reference were changed // but we care only about actual changes to object itself not reference // in that case objRef will not lead to effect call in case new reference is shallowly equal to previous }, [objRef]);} Скопировать "},{"title":"pubsub","type":0,"sectionRef":"#","url":"docs/references/libs/pubsub","content":"","keywords":""},{"title":"subscribe - event subscription","type":1,"pageTitle":"pubsub","url":"docs/references/libs/pubsub#subscribe---event-subscription","content":"pubsub.subscribe('type', callback) - subscribe to event with name type. callback accepts as arguments payload from pubsub.publish. callback can return promise which will can be awaited from call pubsub.publish. "},{"title":"publish - event publish","type":1,"pageTitle":"pubsub","url":"docs/references/libs/pubsub#publish---event-publish","content":"pubsub.publish('type', ...args) - publish event with name type. args will be passed as arguments to the subscribers. Return promise which will be resolved after resolve of all subscriptions. "},{"title":"Typed PubSub","type":1,"pageTitle":"pubsub","url":"docs/references/libs/pubsub#typed-pubsub","content":"PubSub can use typed events. For example: a common PubSub with many events and subscriptions. In order to enable type checking for event subscriptions: Create a new type with all event definitions: type MyAwesomeFeatureEvents = { event1: (payload: number) => any; event2: (payload: { prop: boolean }) => any;}; Скопировать Do a typecast in code when using PubSub instance. It will enable type checks for every usage for a new typed instance const featurePubSub = (pubSub as any) as PubSub<MyAwesomeFeatureEvents>; // OK! 👍featurePubSub.subscribe('event1', (payload) => console.log(1 + payload));featurePubSub.publish('event1', 2); // Error 👎featurePubSub.subscribe('event3', (payload) => console.log(1 + payload)); // No such eventfeaturePubSub.publish('event3', 2); // НNo such event featurePubSub.subscribe('event1', (payload) => payload.toLowerCase()); // Wrong payload typefeaturePubSub.publish('event1', 'string'); // number expected Скопировать "},{"title":"safe-strings","type":0,"sectionRef":"#","url":"docs/references/libs/safe-strings","content":"","keywords":""},{"title":"safeParseJSON","type":1,"pageTitle":"safe-strings","url":"docs/references/libs/safe-strings#safeparsejson","content":"Tries to parse json and if it successful returns it, otherwise returns second argument as default value. "},{"title":"safeStringify","type":1,"pageTitle":"safe-strings","url":"docs/references/libs/safe-strings#safestringify","content":"Converts object to json with a replacement of insecure symbols that allows to insert result string in the response html "},{"title":"safeStringiyfJSON","type":1,"pageTitle":"safe-strings","url":"docs/references/libs/safe-strings#safestringiyfjson","content":"Converts object to json with a circular reference handling "},{"title":"removeXss","type":1,"pageTitle":"safe-strings","url":"docs/references/libs/safe-strings#removexss","content":"Removes possible xss strings "},{"title":"tinkoff-request-http-client-adapter","type":0,"sectionRef":"#","url":"docs/references/libs/tinkoff-request-http-client-adapter","content":"","keywords":""},{"title":"API","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#api","content":""},{"title":"createAdapter","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#createadapter","content":"createAdapter - factory to create an HTTP client. It configures an instance of @tinkoff/request via createTinkoffRequest, and based on it creates an instance of HttpClientAdapter type createAdapter = (options: TinkoffRequestOptions) => HttpClient; Скопировать "},{"title":"TinkoffRequestOptions","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#tinkoffrequestoptions","content":"interface TinkoffRequestOptions extends HttpClientRequest { // tramvai logger logger?: typeof LOGGER_TOKEN; // namespace for the logger, the prefix `request.` will be added to it name?: string; // will disable the default caching via `@tinkoff/request-plugin-cache-memory` disableCache?: boolean; // cache factory for `@tinkoff/request-plugin-cache-memory` createCache?: (options: any) => any; // cache ttl for `@tinkoff/request-plugin-cache-memory` cacheTime?: number; // the default request execution time limit, in ms defaultTimeout?: number; // response validator for `@tinkoff/request-plugin-validate` validator?: RequestValidator; // error validator for `@tinkoff/request-plugin-validate` errorValidator?: RequestValidator; // method allows you to modify the error object before sending logs from `@tinkoff/request-plugin-log` errorModificator?: RequestValidator;} Скопировать "},{"title":"createTinkoffRequest","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#createtinkoffrequest","content":"createTinkoffRequest - creates an instance of @tinkoff/request with all the necessary plugins type createTinkoffRequest = (options: TinkoffRequestOptions) => MakeRequest; Скопировать "},{"title":"HttpClientAdapter","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#httpclientadapter","content":"HttpClientAdapter - adapts @tinkoff/request to the interface HttpClient. The request method wraps the request parameters in the modifyRequest option, and passes them to @tinkoff/request. Then, the received response is modified in the HttpClientRequest, and wrapped in the modifyResponse option. If there is an error, it will wrapped into the modifyError option. The fork method creates a new instance of HttpClientAdapter, but with the same @tinkoff/request instance. type HttpClientAdapter = HttpClient; Скопировать "},{"title":"mergeOptions","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#mergeoptions","content":"By default, mergeOptions compose modifyRequest, modifyResponse and modifyError options, with the corresponding options from options being executed first, then from nextOptions. If you pass a third parameter { replace: true }, all parameters of the same name from options will simply be overwritten by parameters from nextOptions type mergeOptions = ( options: HttpClientRequest, nextOptions: HttpClientRequest, config?: { replace?: boolean }) => HttpClientRequest; Скопировать "},{"title":"router","type":0,"sectionRef":"#","url":"docs/references/libs/router","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"router","url":"docs/references/libs/router#installation","content":"You need to install @tinkoff/router: yarn add @tinkoff/router Скопировать And connect it to the project: import { Router } from '@tinkoff/router'; const router = new Router(); Скопировать "},{"title":"Explanation","type":1,"pageTitle":"router","url":"docs/references/libs/router#explanation","content":"Features: The library supports options for working both on the server and on the client.It is possible to use different client transition options: with or without SPA transitions.There are Guards to check the availability of a route under specific conditions.You can subscribe to different stages of the transition through hooksComponents and hooks for easy routing from react "},{"title":"Server and client version","type":1,"pageTitle":"router","url":"docs/references/libs/router#server-and-client-version","content":"It is enough just to import routing from the library itself and, based on the settings in package.json, the required version for the server or client will be returned import { Router } from '@tinkoff/router'; Скопировать "},{"title":"Client routing with/without SPA transitions","type":1,"pageTitle":"router","url":"docs/references/libs/router#client-routing-withwithout-spa-transitions","content":"By default, routing with SPA transitions is enabled on the client. If you need to disable SPA transitions, you need to import a special version of the routing import { Router, SpaHistory } from '@tinkoff/router';import { NoSpaRouter } from '@tinkoff/router'; const spaRouter = new Router({ history: new SpaHistory() });const noSpaRouter = new NoSpaRouter(); Скопировать "},{"title":"Router Guards","type":1,"pageTitle":"router","url":"docs/references/libs/router#router-guards","content":"Guards allow you to control the availability of a particular route for a specific transition. From the guard, you can block the transition or initiate a redirect. import { NavigationGuard } from '@tinkoff/router'; export const myGuard: NavigationGuard = async ({ to }) => { if (to.config.blocked) { return false; // block this transition } if (to.config.redirect) { return '/login/'; // call a redirect to the specified page } // if nothing is returned, the transition will be performed as usual}; Скопировать "},{"title":"Transitions hooks","type":1,"pageTitle":"router","url":"docs/references/libs/router#transitions-hooks","content":"Transition hooks allow you to perform your asynchronous actions at different stages of the transition. import { NavigationHook } from '@tinkoff/router'; export const myHook: NavigationHook = async ({ from, to, url, fromUrl }) => { console.log(`navigating from ${from} to route ${to}`);}; Скопировать "},{"title":"API","type":1,"pageTitle":"router","url":"docs/references/libs/router#api","content":""},{"title":"Getting data about the current route or url","type":1,"pageTitle":"router","url":"docs/references/libs/router#getting-data-about-the-current-route-or-url","content":"router.getCurrentRoute(); // will return the current routerouter.getCurrentUrl(); // will return the parsed version of the url of the current page Скопировать "},{"title":"Transition initiation","type":1,"pageTitle":"router","url":"docs/references/libs/router#transition-initiation","content":"There are two methods for initializing the navigation and updating the address bar in the browser. The main difference between these two methods is that one of them will launch a full-fledged transition with data updating and starting heavy data loading actions. The second method is mainly used to update the state for the current route: to update the query parameters on the page or change the dynamic parameters of the route itself. navigate# Initiates a full transition, defining the next route and updating the state in the browser. router.navigate('/test');router.navigate({ url: './test', query: { a: '1' } }); Скопировать Transition hooks: beforeResolvebeforeNavigateafterNavigate updateCurrentRoute# The transition is based on the current route (therefore this method cannot be called on the server) and allows you to simply update some data for the current page router.updateCurrentRoute({ params: { id: 'abc' } });router.updateCurrentRoute({ query: { a: '1' } }); Скопировать Hooks: beforeUpdateCurrentafterUpdateCurrent "},{"title":"Working with query","type":1,"pageTitle":"router","url":"docs/references/libs/router#working-with-query","content":"query option# Allows you to set a search string for an url as an object via the query option when navigating. The previous query value will be cleared router.getCurrentUrl().query; // { с: 'c' } router.navigate({ query: { a: 'a', b: 'b' } });router.updateCurrentRoute({ query: { a: 'a', b: 'b' } }); router.getCurrentUrl().query; // { a: 'a', b: 'b' } Скопировать preserveQuery# Allows you to keep the query value from the current navigation and use them in a new transition router.getCurrentUrl().query; // { с: 'c' } router.navigate({ query: { a: 'a' }, preserveQuery: true });router.updateCurrentRoute({ query: { a: 'a' }, preserveQuery: true }); router.getCurrentUrl().query; // { a: 'a', c: 'c' } Скопировать If you pass undefined as the value for a specific query key, then this value will be cleared in a new query: router.getCurrentUrl().query; // { a: 'a', b: 'b' } router.navigate({ query: { a: undefined, c: 'c' }, preserveQuery: true });router.updateCurrentRoute({ query: { a: undefined, c: 'c' }, preserveQuery: true }); router.getCurrentUrl().query; // { b: 'b', c: 'c' } Скопировать "},{"title":"Integration with React","type":1,"pageTitle":"router","url":"docs/references/libs/router#integration-with-react","content":"Library has some useful React hooks and components for working with routing useRoute# Returns current active route of the application import React from 'react';import { useRoute } from '@tinkoff/router'; export const Component = () => { const route = useRoute(); return <div>Route path: {route.actualPath}</div>;}; Скопировать useUrl# Returns current active URL of the application import React from 'react';import { useUrl } from '@tinkoff/router'; export const Component = () => { const url = useUrl(); return <div>Url query: {JSON.stringify(url.query)}</div>;}; Скопировать useNavigate# Creates a callback with a navigation call that can be passed to child components or used as an event handler export const Cmp = () => { const navigate = useNavigate('/test/'); return <div onClick={navigate}>Test</div>;}; Скопировать Link# A wrapper for a react component that makes it clickable If the react component is passed to the Link as children, then this passed component will be rendered and the href, onClick props will be passed as props to that component and they should be used to make the navigation. Otherwise, the <a> tag will be rendered with children as a child. import { Link } from '@tinkoff/router';import CustomLink from '@custom-scope/link'; export const Component = () => { return ( <Link url=\"/test/\"> <CustomLink /> </Link> );}; export const WrapLink = () => { return <Link url=\"/test/\">Click me</Link>;}; Скопировать "},{"title":"url","type":0,"sectionRef":"#","url":"docs/references/libs/url","content":"","keywords":""},{"title":"Api","type":1,"pageTitle":"url","url":"docs/references/libs/url#api","content":""},{"title":"parse","type":1,"pageTitle":"url","url":"docs/references/libs/url#parse","content":"Parses url and returns object of class URL with additional property query which represents searchParams as a simple object. import { parse } from '@tinkoff/url'; const url = parse('https://tinkoff.ru/test/?a=1&b=2#abc'); url.protocol; // => :httpsurl.href; // => https://tinkoff.ru/test/?a=1&b=2#abcurl.origin; // => https://tinkoff.ruurl.pathname; // => /test/url.hash; // => #abcurl.query; // => { a: '1', b: '2' } Скопировать "},{"title":"rawParse","type":1,"pageTitle":"url","url":"docs/references/libs/url#rawparse","content":"Same as parse but instead of returning wrapper for URL returns raw URL object "},{"title":"resolve","type":1,"pageTitle":"url","url":"docs/references/libs/url#resolve","content":"Computes absolute url for relative url of base value import { resolve } from '@tinkoff/url'; resolve('//tinkoff.ru', './test123'); // => http://tinkoff.ru/test123resolve('//tinkoff.ru/a/b/c/', '../../test'); // => http://tinkoff.ru/a/testresolve('https://tinkoff.ru/a/b/c/?test=123#abc', '.././test/?me=123#123'); // => https://tinkoff.ru/a/b/test/?me=123#123 Скопировать "},{"title":"resolveUrl","type":1,"pageTitle":"url","url":"docs/references/libs/url#resolveurl","content":"Computes absolute url for relative url of base value. Unlike resolve can accept string or URL and return URL wrapper "},{"title":"rawResolveUrl","type":1,"pageTitle":"url","url":"docs/references/libs/url#rawresolveurl","content":"Same as resolveUrl but instead of returning wrapper for URL returns raw URL object "},{"title":"isAbsoluteUrl","type":1,"pageTitle":"url","url":"docs/references/libs/url#isabsoluteurl","content":"Checks that passed string is absolute url "},{"title":"isInvalidUrl","type":1,"pageTitle":"url","url":"docs/references/libs/url#isinvalidurl","content":"Checks that passed string represents invalid url import { isAbsoluteUrl } from '@tinkoff/url'; isAbsoluteUrl('https://www.exmaple.com'); // true - secure http absolute URLisAbsoluteUrl('//cdn.example.com/lib.js'); // true - protocol-relative absolute URLisAbsoluteUrl('/myfolder/test.txt'); // false - relative URL Скопировать "},{"title":"convertRawUrl","type":1,"pageTitle":"url","url":"docs/references/libs/url#convertrawurl","content":"Returns handy wrapper for URL in form of plain object with some additional fields "},{"title":"rawAssignUrl","type":1,"pageTitle":"url","url":"docs/references/libs/url#rawassignurl","content":"Allows to set parameters to passed raw URL object (passed URL-object will be changed) "},{"title":"user-agent","type":0,"sectionRef":"#","url":"docs/references/libs/user-agent","content":"user-agent Library for parsing and executing check to userAgent string. Based on ua-parser-js","keywords":""},{"title":"autoscroll","type":0,"sectionRef":"#","url":"docs/references/modules/autoscroll","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"autoscroll","url":"docs/references/modules/autoscroll#подключение","content":"Необходимо установить @tramvai/module-autoscroll yarn add @tramvai/module-autoscroll Скопировать Подключить в проекте AutoscrollModule import { createApp } from '@tramvai/core';import { AutoscrollModule } from '@tramvai/module-autoscroll'; createApp({ name: 'tincoin', modules: [AutoscrollModule],}); Скопировать Если нужно отключить подскрол для отдельных страниц - при переходе navigate нужно указать navigateState.disableAutoscroll = true import { useNavigate } from '@tramvai/module-router'; function Component() { const navigateToWithoutScroll = useNavigate({ url: '/url/', navigateState: { disableAutoscroll: true }, }); return <Button onClick={navigateToWithoutScroll} />;} Скопировать behavior: smooth поддерживается не во всех браузерах (например, плавный подскролл не работает в Safari). При необходимости подключите полифил smoothscroll-polyfill в свое приложение. "},{"title":"cache-warmup","type":0,"sectionRef":"#","url":"docs/references/modules/cache-warmup","content":"","keywords":""},{"title":"Как подключить?","type":1,"pageTitle":"cache-warmup","url":"docs/references/modules/cache-warmup#как-подключить","content":"По умолчанию модуль уже подключается в @tramvai/module-server и при его использовании дополнительных действий не требуется. import { createApp } from '@tramvai/core';import { CacheWarmupModule } from '@tramvai/module-cache-warmup'; createApp({ modules: [CacheWarmupModule],}); Скопировать "},{"title":"Что делает?","type":1,"pageTitle":"cache-warmup","url":"docs/references/modules/cache-warmup#что-делает","content":"При старте приложения с запрашивает у bundleInfo список урлов приложения. Затем шлет по 2 запроса на каждый из урлов, но не более 2 запросов одновременно. 2 запроса нужны для того, чтобы симулировать запрос с десктопа и мобильного устройства. User-Agentы, которые использует модуль: [ /** Chrome on Mac OS */ 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.87 Safari/537.36', /** Chrome on Mobile */ 'Mozilla/5.0 (Linux; Android 7.0; SM-G930V Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.125 Mobile Safari/537.36',]; Скопировать Модуль выполняется только при NODE_ENV === production. "},{"title":"Отладка","type":1,"pageTitle":"cache-warmup","url":"docs/references/modules/cache-warmup#отладка","content":"Модуль использует логгер с идентификатором cache-warmup "},{"title":"common","type":0,"sectionRef":"#","url":"docs/references/modules/common","content":"","keywords":""},{"title":"Подключение в проект","type":1,"pageTitle":"common","url":"docs/references/modules/common#подключение-в-проект","content":""},{"title":"1. Зависимости","type":1,"pageTitle":"common","url":"docs/references/modules/common#1-зависимости","content":"Необходимо установить @tramvai/module-common с помощью npm npm i @tramvai/module-common Скопировать "},{"title":"2. Подключение модуля","type":1,"pageTitle":"common","url":"docs/references/modules/common#2-подключение-модуля","content":"Нужно передать в список модулей приложения CommonModule import { createApp } from '@tramvai/core';import { CommonModule } from '@tramvai/module-common'; createApp({ modules: [CommonModule],}); Скопировать "},{"title":"Включенные модули","type":1,"pageTitle":"common","url":"docs/references/modules/common#включенные-модули","content":""},{"title":"CommandModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#commandmodule","content":"Модуль которые добавляет в проект реализацию commandLineRunner и дефолтных команд Модуль использует логгер с идентификатором command:command-line-runner "},{"title":"StateModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#statemodule","content":"Подключает и инициализирует state-manager в проекте "},{"title":"ActionModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#actionmodule","content":"Реализация системы экшенов Модуль использует логгер с идентификатором action:action-page-runner "},{"title":"CookieModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#cookiemodule","content":"Подключен модуль который позволяет работать с куками, документация "},{"title":"EnvironmentModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#environmentmodule","content":"Модуль для работы с env переменные в приложении на стороне сервера и клиента, документация "},{"title":"PubSub","type":1,"pageTitle":"common","url":"docs/references/modules/common#pubsub","content":"Для отправки событий между модулями используется PubSub который позволяет отправлять сообщения и подписываться на изменения, документация Модуль использует логгер с идентификатором pubsub "},{"title":"LogModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#logmodule","content":"Минимальная реализация логгера для токена LOGGER_TOKEN без фильтров и дополнительных фич "},{"title":"CacheModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#cachemodule","content":"Модуль для работы с кешами. Функции: Создать новый инстанс кеша (на данный момент это lru-cache)Очистить все ранее созданные кешиПодписка на событие очистки кеша для реализации собственного тригера очистки своих кешейДобавляет papi-метод '/clear-cache' который генерирует событе очистки кешей Модуль использует логгер с идентификатором cache:papi-clear-cache Пример# import { provide } from '@tramvai/core'; export const providers = [ provide({ provide: MY_MODULE_PROVIDER_FACTORY, scope: Scope.SINGLETON, useFactory: ({ createCache }) => { const cache = createCache('memory', ...args); // тип кеша и дополнительные аргументы которые будут переданы в конструктор кеша return someFactory({ cache }); }, deps: { createCache: CREATE_CACHE_TOKEN, }, }), provide({ provide: REGISTER_CLEAR_CACHE_TOKEN, scope: Scope.SINGLETON, useFactory: ({ cache }) => { return async () => { await cache.reset(); console.log('my module cache cleared'); }; }, deps: { cache: MY_MODULE_CACHE, }, }), provide({ provide: commandLineListTokens.clear, useFactory: ({ clearCache }) => { return function clear() { clearCache(); // очистить кеши явно в своем провайдере }; }, deps: { clearCache: CLEAR_CACHE_TOKEN, }, }),]; Скопировать "},{"title":"RequestManagerModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#requestmanagermodule","content":"Модуль для работы с параметрами запроса "},{"title":"ResponseManagerModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#responsemanagermodule","content":"Модуль для работы с параметрами ответа "},{"title":"Экспортируемые токены","type":1,"pageTitle":"common","url":"docs/references/modules/common#экспортируемые-токены","content":"tokens-commoncookieenv "},{"title":"client-hints","type":0,"sectionRef":"#","url":"docs/references/modules/client-hints","content":"","keywords":""},{"title":"Подключение в проект","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#подключение-в-проект","content":""},{"title":"1. Зависимости","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#1-зависимости","content":"Необходимо установить @tramvai/module-client-hints с помощью npm npm i --save @tramvai/module-client-hints Скопировать или yarn add @tramvai/module-client-hints Скопировать "},{"title":"2. Подключение модуля","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#2-подключение-модуля","content":"Нужно передать в список модулей приложения ClientHintsModule import { createApp } from '@tramvai/core';import { ClientHintsModule } from '@tramvai/module-client-hints'; createApp({ modules: [ClientHintsModule],}); Скопировать "},{"title":"Экспортируемые токены","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#экспортируемые-токены","content":""},{"title":"USER_AGENT_TOKEN","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#user_agent_token","content":"Объект - результат парсинга строки юзер-агента с помощью @tinkoff/user-agent. Парсинг происходит только на сервере, на клиенте - используется инфомация с сервера. "},{"title":"Сторы","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#сторы","content":""},{"title":"userAgent","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#useragent","content":"Стор который хранит результат парсинга юзер-агента. "},{"title":"media","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#media","content":"Стор который хранит медиа-информацию о типе и размере экрана клиента. API для проверки media# Данные в сторе media: type Media = { width: number; height: number; isTouch: boolean; retina: boolean; supposed?: boolean; synchronized?: boolean;}; Скопировать fromClientHints(media: Media): boolean - возвращает true, когда media синхронизированны на сервере и на клиенте isSupposed(media: Media): boolean - возвращает true, когда media определены на сервере по User-Agent, и могут измениться на клиенте isRetina(media: Media): boolean - вовзращает true, когда плотность пикселей на экране 2 или выше useMedia(): Media - возвращает текущее состояние стора media useFromClientHints(): boolean - вычисляет fromClientHints из стора media useIsSupposed(): boolean - вычисляет isSupposed из стора media useIsRetina(): boolean - вычисляет isRetina из стора media "},{"title":"Особенности работы с media на сервере и клиенте","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#особенности-работы-с-media-на-сервере-и-клиенте","content":"Одна из проблем SSR - рендеринг компонентов, которые зависят от текущего размера экрана, например карусель изображений, которая должна рендерить определенное количество картинок, в зависимости от ширины экрана. По умолчанию, узнать точные размеры мы можем только на стороне клиента, и не имеем возможности отрисовать на сервере контент, идентичный клиенту. Если этот контент не требуется для SEO, можно использовать скелетоны или спиннеры, но это подходит не для всех случаев. Модуль Client Hints позволяет частично решить эту проблему, сохраняя данные об устройстве пользователя в cookies при первом заходе, и используя эти данные на сервере при следующих заходах на страницы приложения. "},{"title":"Механизм работы Client Hints","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#механизм-работы-client-hints","content":"Первый заход на страницу# При первом заходе на страницу, на стороне сервере, модуль определяет тип устройство по User-Agent, и сохраняет предположительные данные об устройстве в стор media. Например, при первом заходе с компьютера, значение стора media будет таким: const state = { width: 1024, height: 768, isTouch: false, retina: false, supposed: true, synchronized: false,}; Скопировать На клиенте, ориентируясь на значение supposed: true, модуль получает реальные данные об устройстве, и обновляет стор media, вызывая перерендер зависимых компонентов. После этого, для широкоэкранного монитора, значение стора media может быть таким: const state = { width: 1920, height: 1080, isTouch: false, retina: true, supposed: false, synchronized: false,}; Скопировать Пока мы имеем значение synchronized: false, нельзя полагаться на данные из media для серверного рендеринга компонентов, т.к. это вызовет \"скачок\" при сохранении реальных данных об устройстве. Повторный заход на страницу# При повторном заходе на страницу, данные об устройстве считываются из cookies, значение synchronized выставляется в true. Таким образом, и на сервере, и на клиенте, мы получим одно значение стора media, и отсутствие перерендера на клиенте: const state = { width: 1920, height: 1080, isTouch: false, retina: true, supposed: false, synchronized: true,}; Скопировать Итоги# Общая информация для компонентов, которые зависят от текущего размера экрана: При первом заходе на страницу, нельзя гарантировать одинаковый результат рендеринга на сервере и на клиенте При первом заходе на страницу, можно показать юзеру скелетон компонента, отображая скелетон при свойстве supposed: true Гарантировать одинаковый результат рендеринга на сервере и на клиенте можно при свойстве synchronized: true Рецепт, который позволит показать скелетон только один раз, при первой загрузке приложения: const App = () => { const isSupposed = useIsSupposed(); if (isSupposed) { return <AdaptiveSliderSkeleton />; } return <AdaptiveSlider />;}; Скопировать Рецепт, который позволит рендерить общий адаптивный компонент при первой загрузке приложения, и выбирать отдельные под desktop и mobile при повторных загрузках: const App = () => { const media = useMedia(); const fromClientHints = useFromClientHints(); let Block = AdaptiveBlock; if (fromClientHints) { Block = media.width >= 1024 ? DesktopBlock : MobileBlock; } return <Block />;}; Скопировать "},{"title":"deps-graph","type":0,"sectionRef":"#","url":"docs/references/modules/deps-graph","content":"","keywords":""},{"title":"Установка","type":1,"pageTitle":"deps-graph","url":"docs/references/modules/deps-graph#установка","content":""},{"title":"1. Зависимости","type":1,"pageTitle":"deps-graph","url":"docs/references/modules/deps-graph#1-зависимости","content":"Необходимо установить @tramvai/module-deps-graph с помощью npm/yarn npm i @tramvai/module-deps-graph Скопировать "},{"title":"2. Подключение модуля","type":1,"pageTitle":"deps-graph","url":"docs/references/modules/deps-graph#2-подключение-модуля","content":"Нужно передать в список модулей приложения CommonModule import { createApp } from '@tramvai/core';import { DepsGraphModule } from '@tramvai/module-deps-graph'; createApp({ modules: [DepsGraphModule],}); Скопировать "},{"title":"Использование","type":1,"pageTitle":"deps-graph","url":"docs/references/modules/deps-graph#использование","content":"Добавляет папи роут /deps-graph (можно найти по адресу /:appName/papi/deps-graph, где appName - поле name из tramvai.json), по которому выводится граф всех зависимостей с возможностью поиска по токену и имени модуля Описание графа# Синий - обычный провайдерЖелтый - mutli-провайдерКрасный - подпавший под поиск  "},{"title":"cookie","type":0,"sectionRef":"#","url":"docs/references/modules/cookie","content":"","keywords":""},{"title":"Features","type":1,"pageTitle":"cookie","url":"docs/references/modules/cookie#features","content":"Изоморфный код, работает на сервере и в браузереНа сервере происходит дедубликация одинаковых кук и при добавлении куки, кука будет доступна в методе getПо дефолту мы проставляем secure параметр "},{"title":"Установка","type":1,"pageTitle":"cookie","url":"docs/references/modules/cookie#установка","content":"Уже поставляется внутри @tramvai/module-common и не нужно устанавливать, если подключен module-common. Иначе, нужно подключить @tramvai/module-cookie "},{"title":"Использование","type":1,"pageTitle":"cookie","url":"docs/references/modules/cookie#использование","content":"import { COOKIE_MANAGER, Module, provide } from '@tramvai/core'; @Module({ providers: [ provide({ // Управление куками в приложении provide: 'my_module', useFactory: ({ cookie }) => { cookie.get('sid'); // > ads.api3 }, deps: { cookie: COOKIE_MANAGER, // добавляем в зависимость }, }), ],})class MyModule {} Скопировать "},{"title":"Интерфейс","type":1,"pageTitle":"cookie","url":"docs/references/modules/cookie#интерфейс","content":"Реализует интерфейс CookieManager и добавляет в di провайдер COOKIE_MANAGER. @tinkoff/core "},{"title":"Экспортируемые токены","type":1,"pageTitle":"cookie","url":"docs/references/modules/cookie#экспортируемые-токены","content":"COOKIE_MANAGER_TOKEN# Сущность для работы с куками interface CookieSetOptions { name: string; value: string; expires?: number | Date | string; domain?: string; path?: string; secure?: boolean; httpOnly?: boolean; sameSite?: boolean | 'lax' | 'strict' | 'none';} interface CookieManager { get(name: any): string; all(): Record<string, string>; set({ name, value, ...options }: CookieSetOptions): void; remove(name: string): void;} Скопировать "},{"title":"error-interceptor","type":0,"sectionRef":"#","url":"docs/references/modules/error-interceptor","content":"","keywords":""},{"title":"Интеграция с tramvai","type":1,"pageTitle":"error-interceptor","url":"docs/references/modules/error-interceptor#интеграция-с-tramvai","content":"Модуль не предоставляет публтичного интерфейса, а только подписывается на события инициализации и подключает @tinkoff/error-handlers который перехватывает ошибки в браузере и клиенте "},{"title":"Принцип работы","type":1,"pageTitle":"error-interceptor","url":"docs/references/modules/error-interceptor#принцип-работы","content":"На сервере подписываемся на события unhandledRejection и внезапные остановки выполнения с помощью библиотеки death, затем ошибку кидает в консоль. "},{"title":"env","type":0,"sectionRef":"#","url":"docs/references/modules/env","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"env","url":"docs/references/modules/env#подключение","content":"Уже поставляется внутри @tramvai/module-common и не нужно устанавливать, если подключен module-common. Иначе, нужно установить @tramvai/module-environment "},{"title":"Explanation","type":1,"pageTitle":"env","url":"docs/references/modules/env#explanation","content":""},{"title":"Динамически генерируемый список используемых ENV переменных","type":1,"pageTitle":"env","url":"docs/references/modules/env#динамически-генерируемый-список-используемых-env-переменных","content":"Все используемые параметры в приложения регистрируются с помощью реализации в DI токена ENV_USED_TOKEN и предполагается, что каждый модуль по отдельности регистрирует только те ENV параметры, которые ему необходимы. В таком случае при подключении модуля, будет автоматическая валидация всех переданных параметров, которые необходимы для работы приложения import { provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: ENV_USED_TOKEN, useValue: [ { key: 'DEBUG_MODULE', optional: true }, { key: 'DEBUG_MODULE_URL', optional: true }, ], multi: true, }), ],})export class MyModule {} Скопировать В выше примере, модуль регистрирует несколько env токенов, которые будут проинициализированы и будут доступны в environmentManager.get('DEBUG_MODULE'). При этом, был передан параметр optional который указывает, что переменные не обязательные для работы приложения. "},{"title":"Валидация переданных параметров","type":1,"pageTitle":"env","url":"docs/references/modules/env#валидация-переданных-параметров","content":"При старте приложения происходит проверка тех токенов, которые были зарегистрированы в DI и были переданы в ENV при запуске. Если в приложение не были переданы все требуемые ENV переменные, то приложение упадет. Так-же есть возможность написать валидаторы для ENV значений, которые запустятся при инициализации приложения. import { provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: ENV_USED_TOKEN, useValue: [ { key: 'MY_ENV', validator: (env) => { if (!env.includes('https')) { return 'Не правильный формат ссылки. Ссылка должна содержать https'; } }, }, ], multi: true, }), ],})export class MyModule {} Скопировать "},{"title":"Функциональность работает на сервере и в браузере","type":1,"pageTitle":"env","url":"docs/references/modules/env#функциональность-работает-на-сервере-и-в-браузере","content":"Все ENV переменные будут доступны как на сервере, так и браузере без каких либо дополнительных действий и настроек. В браузер автоматически передаются env переменные, которые имеют dehydrate: true "},{"title":"Приоритет получения значений для env переменных","type":1,"pageTitle":"env","url":"docs/references/modules/env#приоритет-получения-значений-для-env-переменных","content":"Так-как есть возможность перезаписывать значения переменных, то переменные заменятся по определенным правилам Правила замены, расположены в порядке приоритета, от меньшего к высокому: Параметры заданные в токенах { key: 'ENV_PARAM', value: 'env value' }Параметры записанные в файле env.development.jsПередача параметров запуска приложения MY_ENV=j node server.js "},{"title":"API","type":1,"pageTitle":"env","url":"docs/references/modules/env#api","content":" Экспортируемые токены и TS интерфейс import { createToken } from '@tinkoff/dippy'; export interface EnvironmentManager { get(name: string): string; getInt(name: string, def: number): number; getAll(): Record<string, string>; update(result: Record<string, string>): void; clientUsed(): Record<string, string>; updateClientUsed(result: Record<string, string>): void;} /** * @description * Сущность `environmentManager` c помощью которого можно получить данные env переменных на сервере и клиенте */export const ENV_MANAGER_TOKEN = createToken<EnvironmentManager>('environmentManager'); /** * @description * Список токенов которые необходимы модулю или приложению. * Позднее все токены из этого списка будут доступны через `environmentManager` * Формат токена ENV_USED_TOKEN: - `key` - идентификатор env переменной. Под этим ключем будет доступно в `environmentManager` и будет получено из внешних источников - `value` - предустановленное значение для токена `key` с низким приоритетом - `optional` - является ли параметр опциональным для работы приложения. Если `true`, то приложение не будет падать, если не было передано значение - `validator` - функция валидации переданного значения. Если функция вернет текст, то выкинется ошибка - `dehydrate` - если передано `false`, то env параметр не передастся клиенту и можно будет получить значение только на серверной стороне * * @example ```tsx interface EnvParameter { key: string; value?: string; optional?: boolean; validator?: (value: string) => boolean | string; dehydrate?: boolean; } ``` */export interface EnvParameter { key: string; value?: string; optional?: boolean; validator?: (value: string) => boolean | string; dehydrate?: boolean;} export const ENV_USED_TOKEN = createToken<EnvParameter[]>('envUsed', { multi: true }); Скопировать  "},{"title":"How to","type":1,"pageTitle":"env","url":"docs/references/modules/env#how-to","content":""},{"title":"Как прочитать данные в приложении","type":1,"pageTitle":"env","url":"docs/references/modules/env#как-прочитать-данные-в-приложении","content":"Допустим мы зарегистрировали используемый ENV параметр CONFIG_API с помощью токена ENV_USED_TOKEN, теперь в приложении нужно подключить environmentManager и прочитать данные import { provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: 'MY_SERVICE', useClass: class MyService { constructor({ environmentManager }) { console.log(environmentManager.get('CONFIG_API')); } }, deps: { environmentManager: ENV_MANAGER_TOKEN, }, }), ],})export class MyModule {} Скопировать Этот код будет работать как на сервере, так и в браузере "},{"title":"Как можно просто передать параметры при локальной разработке","type":1,"pageTitle":"env","url":"docs/references/modules/env#как-можно-просто-передать-параметры-при-локальной-разработке","content":"Для этого создайте файл env.development.js в корне проекта и пропишите все ENV переменные для приложения. При инициализации приложения, будет прочитан этот файл. Особенности использования env.developmen.js в production сборке# Приложение двенадцати факторов хранит конфигурацию в переменных окружения, поэтому по умолчанию при process.env.NODE_ENV === 'production' EnvironmentManger не будет считывать файл env.development.js. Если же необходимо локально протестировать приложение с NODE_ENV=production, можно передать флаг DANGEROUS_UNSAFE_ENV_FILES='true' чтобы EnvironmentManger прочитал файл env.development.js и не пришлось вводить все переменные руками. "},{"title":"Как при деплоях передать ENV параметры приложению","type":1,"pageTitle":"env","url":"docs/references/modules/env#как-при-деплоях-передать-env-параметры-приложению","content":"Для этого при запуске приложения передайте ENV параметры. Например в Docker можно это сделать через параметр -e docker run -e MY_ENV_VAR=/ my-image "},{"title":"log","type":0,"sectionRef":"#","url":"docs/references/modules/log","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"log","url":"docs/references/modules/log#подключение","content":"Уже входит в @tramvai/module-common и отдельно не нужно подключать "},{"title":"Пример","type":1,"pageTitle":"log","url":"docs/references/modules/log#пример","content":"import { Module, commandLineListToken, provide } from '@tramvai/core';import { LOGGER_TOKEN } from '@tramvai/module-common'; @Module({ providers: [ provide({ provide: commandLineListToken.customerStart, useFactory: ({ logger }) => { logger.debug('customer start'); // логгирование в глобальном пространстве логов const myLogger = logger({ name: 'test', }); myLogger.warn('warning'); // логгирование в пространстве test myLogger.error('error!'); }, deps: { logger: LOGGER_TOKEN, }, }), ],})export class MyModule {} Скопировать "},{"title":"Отображение логов","type":1,"pageTitle":"log","url":"docs/references/modules/log#отображение-логов","content":"см. @tinkoff/logger "},{"title":"Отправка логов на апи","type":1,"pageTitle":"log","url":"docs/references/modules/log#отправка-логов-на-апи","content":"Предполагается что логи с сервера собираются через отдельный механизм, который имеет доступ к выводу консоли сервера и поэтому в логгировании на внешнее апи нет смысла. В браузере логи на апи отправляются с помощью RemoteReporter. По умолчанию отправляются все логи уровня error и fatal. Урл апи определяется из переменной окружения FRONT_LOG_API. Для индивидуальной настройки смотри документацию к RemoteReporter. "},{"title":"Просмотр логов с сервера в браузере","type":1,"pageTitle":"log","url":"docs/references/modules/log#просмотр-логов-с-сервера-в-браузере","content":"Данная функция доступна в дев режиме и создана для упрощения работы с логами при разработке. В консоли браузера при заходе на страницу приложения появится специальная группа логов, под тегом Tramvai SSR Logs при раскрытии логов будут отображены логи которые были залогированы для даного конретного запроса на сервера, причем будут отображены именно те логи, которые подпадают под настройки отображения для сервера. Если необходимо отобразить все логи с сервера с настройками отображения для клиента, то нужно запустить сервер с переменной окружения DEBUG_FULL_SSR "},{"title":"Просмотр логов для запросов на основе @tinkoff/request","type":1,"pageTitle":"log","url":"docs/references/modules/log#просмотр-логов-для-запросов-на-основе-tinkoffrequest","content":"Логгер и настройки для него должны явно передаваться в плагин логгирования, что уже делается в http-client. В плагине используется генерация тега для логгера в виде request.${name} поэтому чтобы отобразить такие необходимо настроить фильтры для отображения для конкретной фабрики запросов: const logger = di.get(LOGGER_TOKEN);const makeRequest = request([...otherPlugins, logger({ name: 'my-api-name', logger })]); Скопировать Т.к. имя для логгера равно my-api-name, то для отображения логов необходимо: на сервере дополнить переменную окружения LOG_ENABLE: 'request.my-api-name'на клиенте включить логгирование через вызов logger.enable('request.my-api-name') "},{"title":"Как правильно форматировать логи","type":1,"pageTitle":"log","url":"docs/references/modules/log#как-правильно-форматировать-логи","content":"Смотри Как правильно логгировать "},{"title":"Экспортируемые токены","type":1,"pageTitle":"log","url":"docs/references/modules/log#экспортируемые-токены","content":""},{"title":"LOGGER_TOKEN","type":1,"pageTitle":"log","url":"docs/references/modules/log#logger_token","content":"Сущность логгера. Заменяет стандартную реализацию LOGGER_TOKEN из @tramvai/module-common "},{"title":"Изменение серверных настроек логгера","type":1,"pageTitle":"log","url":"docs/references/modules/log#изменение-серверных-настроек-логгера","content":"По умолчанию, настройки отображения логгера на сервере берутся из переменной окружения LOG_ENABLE, а настройки уровня логирования из переменной окружения LOG_LEVEL Для изменения этих настроек в рантайме существует papi роут {app}/private/papi/logger Отображение логов меняется через query параметр enable, например: https://localhost:3000/{app}/private/papi/logger?enable=request.tinkoff Скопировать Уровень логгирования меняется через query параметр level, например: https://localhost:3000/{app}/private/papi/logger?level=warn Скопировать Вернуть настройки по умолчанию, из переменных окружения, можно с параметром mode=default: https://localhost:3000/{app}/private/papi/logger?mode=default Скопировать "},{"title":"Переменные окружения","type":1,"pageTitle":"log","url":"docs/references/modules/log#переменные-окружения","content":"LOG_LEVEL = trace | debug | info | warn | error | fatal - включает отображение логов для заданного уровня и все уровней выше. Пример: если LOG_LEVEL=info, то будут отображаться все логи уровней info, warn, error, fatal LOG_ENABLE = ${name} | ${level}:${name} - позволяет включить отображение всех логов по определенному имени логгера или по определенному имени и уровню. Несколько вхождений передаются через запятую. Примеры: если LOG_ENABLE=server, то будут отображены логи всех уровней с именем serverесли LOG_ENABLE=trace:server*, то будут отображены только логи для server с уровнем traceесли LOG_ENABLE=info:server,client,trace:shared, то будут включены логи для заданных логгеров по правилам выше "},{"title":"Отладка","type":1,"pageTitle":"log","url":"docs/references/modules/log#отладка","content":"Модуль использует логгер с идентификатором ssr-logger "},{"title":"http-client","type":0,"sectionRef":"#","url":"docs/references/modules/http-client","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#installation","content":"You need to install @tramvai/module-http-client yarn add @tramvai/module-http-client Скопировать And connect in the project import { createApp } from '@tramvai/core';import { HttpClientModule } from '@tramvai/module-http-client'; createApp({ name: 'tincoin', modules: [HttpClientModule],}); Скопировать "},{"title":"Features","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#features","content":"The http-client module adds functionality to the application related to API requests. Available providers allow you to create new services to work with any API and create more specific services with preset settings for specific APIs. The module implements interfaces from the library @tramvai/http-client using a special library - adapter @tramvai/tinkoff-request-http-client-adapter, running on top of @tinkoff/request. "},{"title":"Concepts","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#concepts","content":""},{"title":"HTTP client","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#http-client","content":"HTTP client - implementation of the HttpClient interface, created via the HTTP_CLIENT_FACTORY token. HTTP client accepts general settings, some of which will be used as defult values ​​for all requests. The HTTP client does not provide an opportunity to add additional methods for requests, and to perform side actions when the request is completed or failed. "},{"title":"Services for working with API","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#services-for-working-with-api","content":"The API service inherits from the ApiService class, which is exported from @tramvai/http-client. The API service takes an HTTP client in its constructor and uses it for requests. The API service implements all methods for requests from the HttpClient interface, but allows you to modify them. For example, you can replace the implementation of the request method by adding an error message to the catch request via an HTTP client - this logic will automatically work for all other methods - get, put, post, delete. In the API service, you can add custom methods for requests to certain API endpoints, and specify only the necessary parameters in them, and type responses. Additional reasons to create API services - if you need to use several different HTTP clients to work with a specific API, or you need the ability to add a convenient abstraction on top of the basic methods for sending requests. "},{"title":"Usage","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#usage","content":""},{"title":"Create a new HTTP client","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#create-a-new-http-client","content":"Each new HTTP client must directly or indirectly inherit HTTP_CLIENT_FACTORY. New HTTP clients / API services should not be created with scope: Scope.SINGLETON, because each request is supplemented with default parameters specific to each user, for example - passing the X-Real-Ip header from the request to the application in all requests to the API. Basic HTTP client# The HTTP_CLIENT_FACTORY token - provides a factory for creating new HTTP clients. The options are preinstalled with a logger and a cache factory. Peculiarities# For all requests to the API, headers are added from the list returned by the API_CLIENT_PASS_HEADERS token, and X-Real-Ip from the current request to the application Token interface: type HTTP_CLIENT_FACTORY = (options: HttpClientFactoryOptions) => HttpClient; Скопировать Token use: import { Scope, provide } from '@tramvai/core';import { ENV_MANAGER_TOKEN } from '@tramvai/tokens-common';import { HTTP_CLIENT_FACTORY } from '@tramvai/tokens-http-client'; const provider = provide({ provide: 'WHATEVER_API_HTTP_CLIENT', useFactory: ({ factory, envManager, }: { factory: typeof HTTP_CLIENT_FACTORY; envManager: typeof ENV_MANAGER_TOKEN; }) => { return factory({ name: 'whatever-api', baseUrl: envManager.get('WHATEVER_API'), }); }, deps: { factory: HTTP_CLIENT_FACTORY, envManager: ENV_MANAGER_TOKEN, },}); Скопировать "},{"title":"Using existing HTTP clients","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#using-existing-http-clients","content":"Most HTTP clients implement additional logic for requests, and inherit from ApiService. Thus, each service has methods get, post, put, delete and request, but there may be specific methods. Common HTTP client# The HTTP_CLIENT token provides a basic client for sending requests to any URLs, request caching is disabled. Token use: import { createAction } from '@tramvai/core';import { HTTP_CLIENT } from '@tramvai/tokens-http-client'; export const fetchAction = createAction({ name: 'fetch', fn: async (_, __, { httpClient }) => { const { payload, headers, status } = await httpClient.get( 'https://www.domain.com/api/endpoint' ); return payload; }, deps: { httpClient: HTTP_CLIENT, },}); Скопировать "},{"title":"Adding custom data to requests","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#adding-custom-data-to-requests","content":"Let's consider a case using the abstract service WHATEVER_API_SERVICE as an example. Let's say we want to add an X-Real-Ip header to every request: import { provide } from '@tramvai/core';import { HttpClientRequest, HttpClient } from '@tramvai/http-client';import { REQUEST_MANAGER_TOKEN } from '@tramvai/tokens-common'; const provider = provide({ provide: 'WHATEVER_API_SERVICE', useFactory: ({ factory, requestManager, envManager, }: { factory: typeof HTTP_CLIENT_FACTORY; requestManager: typeof REQUEST_MANAGER_TOKEN; envManager: typeof ENV_MANAGER_TOKEN; }) => { return factory({ name: 'whatever-api', baseUrl: envManager.get('WHATEVER_API'), modifyRequest: (request: HttpClientRequest) => { return { ...request, headers: { ...request.headers, 'X-real-ip': requestManager.getClientIp(), }, }; }, }); }, deps: { factory: HTTP_CLIENT_FACTORY, requestManager: REQUEST_MANAGER_TOKEN, envManager: ENV_MANAGER_TOKEN, },}); Скопировать "},{"title":"How to","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#how-to","content":""},{"title":"How to disable HTTP request caching?","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#how-to-disable-http-request-caching","content":"To disable caching for all HTTP clients, pass the env variable HTTP_CLIENT_CACHE_DISABLED: true to the application "},{"title":"Testing","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#testing","content":"Testing your api clients# If you have a module or providers that define api-clients, then it will be convenient to use special utilities in order to test them separately import { testApi } from '@tramvai/module-http-client/tests';import { CustomModule } from './module'; describe('testApi', () => { it('test', async () => { const { di, fetchMock, mockJsonResponse } = testApi({ modules: [CustomModule], env: { TEST_API: 'testApi', }, }); const httpClient: typeof HTTP_CLIENT = di.get('CUSTOM_HTTP_CLIENT') as any; mockJsonResponse({ a: 'aaa' }); const { payload } = await httpClient.get('test'); expect(payload).toEqual({ a: 'aaa' }); expect(fetchMock).toHaveBeenCalledWith('http://testApi/test', expect.anything()); });}); Скопировать "},{"title":"Logging","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#logging","content":"By default, @tinkoff/request will log every failed requests with status error. You can disable logging by pass { silent: true } parameter to request parameters. Useful meta information about request will be available in error.__meta property. Example: const log = logger('request:test'); httpClient.request({ path: 'test', silent: true }).catch((error) => { log.info(error);}); Скопировать "},{"title":"Exported tokens","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#exported-tokens","content":"link "},{"title":"Environment Variables","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#environment-variables","content":"HTTP_CLIENT_CACHE_DISABLED - disable caching for all HTTP clientsHTTP_CLIENT_CIRCUIT_BREAKER_DISABLED - disable plugin https://tinkoffcreditsystems.github.io/tinkoff-request/docs/plugins/circuit-breaker.html "},{"title":"metrics","type":0,"sectionRef":"#","url":"docs/references/modules/metrics","content":"","keywords":""},{"title":"Как пользоваться","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#как-пользоваться","content":"import { createToken } from '@tinkoff/dippy';import { Module, provide } from '@tramvai/core';import { Counter, Metrics, METRICS_MODULE_TOKEN } from '@tramvai/tokens-metrics'; interface SomeModuleOptions { metrics: Metrics;} class SomeModule { private metricActionCounter: Counter; constructor(options: SomeModuleOptions) { this.metricActionCounter = options.metrics.counter({ name: 'some_actions_total', help: 'Total count of some actions', }); } public action(): void { this.metricActionCounter.inc(); // Do some meaningful action }} export const SOME_MODULE = createToken<SomeModule>('someModule'); @Module({ providers: [ provide({ provide: SOME_MODULE, useFactory: (deps) => new SomeModule(deps), deps: { metrics: METRICS_MODULE_TOKEN, }, }), ],})export class SomeModuleContainer {} Скопировать "},{"title":"Мониторинг исходящих запросов","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#мониторинг-исходящих-запросов","content":"Для того чтобы мониторить состояние исходящих запросов (количество запросов, количество ошибок, время выполнения) в модуле манкипатчатся методы request и get модулей http и https. Чтобы это заработало необходимо просто подключить модуль метрик в приложение. В метрики попадают лейблы: http методhttp код ответаимя сервиса Метрики определяют имя сервиса сопоставляя урлы со значениями в MetricsServicesRegistry. Изначательно туда загружается инвертированное содержимое env, то есть если урл из env является подстрокой урла запроса, то ключ станет именем сервиса. Если совпадает несколько, то берётся самый длинный урл из env. "},{"title":"Как сделать чтобы для запросов в метриках было имя сервиса вместо адреса хоста","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#как-сделать-чтобы-для-запросов-в-метриках-было-имя-сервиса-вместо-адреса-хоста","content":"Можно подсказать модулю метрик имя сервиса, если урл получается динамически. Для этого нужно: подключить модуль по токену METRICS_SERVICES_REGISTRY_TOKEN;вызвать metricsServicesRegistry.register(\"Часть урла или весь урл\", \"Имя сервиса\") "},{"title":"Использование метрик для профилирования перформанса на стороне браузера","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#использование-метрик-для-профилирования-перформанса-на-стороне-браузера","content":"Для измерения продолжительности события, необходимо использовать метод startTimer у классов Gauge, Histogram и Summary. В dev-режиме эти классы патчатся и методы работы с таймером использует PerformanceApi. "},{"title":"Пример использования","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#пример-использования","content":"Без дополнительных полей const metric = metrics.gauge({ name: 'request_measure', help: 'Request duration measure',}); const endTimer = metric.startTimer(); fetch(url).then(() => { endTimer(); // выводим результат - performance.getEntriesByName('request_measure');}); Скопировать Добавляем динамические поля const metric = metrics.gauge({ name: 'request_measure', help: 'Request duration measure',}); const endTimer = metric.startTimer({ method: 'GET' }); fetch(url).then(() => { endTimer({ status: 200 }); // выводим результат - performance.getEntriesByName('request_measure{method=\"GET\",status=\"200\"}');}); Скопировать "},{"title":"Клиентские метрики","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#клиентские-метрики","content":"Модуль реализует в себе возможность собирать метрики с клиента и раздавать их прометеусам с помощью обычного серверного механизма через отправку метрик в papi-роуты. Механика работы заключается в том что заводится counter и специальный папи-роут, дёрнув который по http мы можем инкрементировать этот counter. В модуле уже реализован весь общий для таких случаев функционал. Чтобы создать метрику необходимо создать провайдер с токеном REGISTER_INSTANT_METRIC_TOKEN, провайдер должен возвращать список из двух сущностей где первая это slug papi-роута, а вторая это инстанс счётчика. Например: import { provide } from '@tramvai/core'; provide({ provide: REGISTER_INSTANT_METRIC_TOKEN, multi: true, deps: { metrics: METRICS_MODULE_TOKEN, }, useFactory({ metrics }) { return [ 'page-load', new Counter({ name: 'client_page_load_total', help: 'Загрузки страниц у клиентов' }), ]; },}); Скопировать Теперь для того чтобы инкрементировать метрику client_page_load_total достаточно дёрнуть papi-роут /metrics/page-load. instantMetricsReporter# На практике выяснилось что часто помимо сбора метрик необходимо отправить логи с подробностями. Эту потребность реализует instantMetricsReporter. При вызове логгера он проверяет наличие метрик со slug аналогичным полю event в логах и если такие метрики существуют, то отправляет запрос на соответствующий papi-роут. Таким образом можно одновременно залогировать событие и инкрементировать серверную метрику. import { provide } from '@tramvai/core';provide({ provide: commandLineListTokens.init, multi: true, deps: { logger: LOGGER_TOKEN, }, useFactory({ logger }) { return () => { window.on('load', () => { logger.info({ event: 'page-load' }); }) }; },}), Скопировать "},{"title":"Отладка","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#отладка","content":"Модуль использует логгеры с идентификаторами: metrics:perf, metrics:papi "},{"title":"Экспортируемые токены","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#экспортируемые-токены","content":"ссылка "},{"title":"mocker","type":0,"sectionRef":"#","url":"docs/references/modules/mocker","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#подключение","content":"Необходимо установить @tramvai/module-mocker: yarn add @tramvai/module-mocker Скопировать Создать первый мок, в файле mocks/my-api.js, где свойство api должно содержать env переменную с урлом API, который требуется мокировать, в данном случае MY_API: module.exports = { api: 'MY_API', mocks: { 'GET /endpoint?foo=bar': { status: 200, headers: {}, payload: { result: { type: 'json', value: { a: 'b' }, }, }, }, },}; Скопировать Подключить модуль в проекте: import { createApp } from '@tramvai/core';import { MockerModule } from '@tramvai/module-module'; createApp({ name: 'tincoin', modules: [ MockerModule ],}); Скопировать Запустить приложения с env переменной MOCKER_ENABLED, например: MOCKER_ENABLED=\"true\" tramvai start tincoin Скопировать После этого, все запросы на MY_API и на клиенте и на сервере автоматически будут отправлены в мокер, а если не нашлось подходящих моков, проксируются в оригинальное API. "},{"title":"Explanation","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#explanation","content":"Особенности мокера описаны в документации библиотеки. Модуль подключает middleware мокера на papi роуте /mocker, и заменяет все env переменные мокируемых API ссылками на papi, подходящие для серверного и для клиентского кода. По умолчанию, мокируются все API, которые были найдены в моках, это поведение можно переопределить. Мокер подключается только при наличии env переменной MOCKER_ENABLED=\"true\". "},{"title":"Замена env переменных","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#замена-env-переменных","content":"Допустим, приложение имеет env переменную MY_API: https://www.my-api.com/, и для этого API зарегистрирован мок. Модуль рассчитан на работу локально, на динамических стендах, и в test/stage окружениях, это порождает сложность с определением пути до papi эндпоинта: На сервере мы должны делать запрос по абсолютном пути, и тут приложение всегда доступно на localhost, значит env переменные заменяются на урлы вида http://localhost:3000/tincoin/papi/mocker/MY_API/ На клиенте, на стендах мы не знаем текущий домен приложения, и надо делать запросы по относительным путям, поэтому клиентские env переменные заменяются на урлы вида /tincoin/papi/mocker/MY_API/ Благодаря этой замене, все запросы приложения на мокируемое API, клиентские и серверные, автоматически отправляются в мокер. "},{"title":"How to","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#how-to","content":""},{"title":"У меня есть моки для нескольких API, как мокировать только одно из них?","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#у-меня-есть-моки-для-нескольких-api-как-мокировать-только-одно-из-них","content":"По умолчанию все API считываются из моков при старте приложения. Это поведение можно переопределить, передавая список API для мокирования при инициализации модуля: MockerModule.forRoot({ config: () => ({ apis: ['MY_API'], }),}); Скопировать "},{"title":"Экспортируемые токены","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#экспортируемые-токены","content":" import { createToken } from '@tinkoff/dippy';import type { Mocker, MockRepository } from '@tinkoff/mocker'; export interface MockerOptions { apis: string[];} export const MOCKER = createToken<Mocker>('MOCKER'); export const MOCKER_REPOSITORY = createToken<MockRepository[]>('MOCKER_REPOSITORY', { multi: true,}); export const MOCKER_CONFIGURATION = createToken<() => Promise<MockerOptions>>( 'MOCKER_CONFIGURATION'); Скопировать  "},{"title":"react-query","type":0,"sectionRef":"#","url":"docs/references/modules/react-query","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#подключение","content":"Необходимо установить @tramvai/module-react-query yarn add @tramvai/module-react-query Скопировать И подключить в проекте import { createApp } from '@tramvai/core';import { ReactQueryModule } from '@tramvai/module-react-query'; createApp({ name: 'tincoin', modules: [...ReactQueryModule],}); Скопировать "},{"title":"Explanation","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#explanation","content":"Модуль добавляет в DI инстанс react-query QueryClient и позволяет указывать через DI опции для его создания. Также модуль добавляет React-обёртки для react-query в рендер приложения, которые позволяют использовать функции для работы с query внутри компонентов. "},{"title":"Server","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#server","content":"На сервере модуль также дополнительно выполняет дегидрацию предзагруженных на сервере данных, чтобы передать их на клиент "},{"title":"Client","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#client","content":"В браузере дополнительно выполняется регидрация данных предзагруженных на сервере. "},{"title":"API","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#api","content":"Модуль в основном предоставляет необходимые вещи в DI для работы библиотеки @tramvai/react-queryи сам по себе может понадобится только если есть необходимость изменить настройки для QueryClient или использовать QueryClient напрямую (но лучше напрямую не использовать) "},{"title":"Экспортируемые токены","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#экспортируемые-токены","content":" import { createToken } from '@tinkoff/dippy';import type { QueryClient, DefaultOptions } from 'react-query';import type { DehydratedState } from 'react-query/hydration'; /** * @description * [Клиент react-query](https://react-query.tanstack.com/reference/QueryClient) */ export const QUERY_CLIENT_TOKEN = createToken<QueryClient>('reactQuery queryClient'); /** * @description * [Дефолтные опции для клиента react-query](https://react-query.tanstack.com/guides/important-defaults) */export const QUERY_CLIENT_DEFAULT_OPTIONS_TOKEN = createToken<DefaultOptions>( 'reactQuery queryClientDefaultOptions'); /** * @description * [Стейт для клиента react-query](https://react-query.tanstack.com/reference/hydration/dehydrate), иницилизированный на сервере */export const QUERY_CLIENT_DEHYDRATED_STATE_TOKEN = createToken<DehydratedState>( 'reactQuery queryClientDehydratedState'); Скопировать  "},{"title":"render","type":0,"sectionRef":"#","url":"docs/references/modules/render","content":"","keywords":""},{"title":"Быстрый обзор","type":1,"pageTitle":"render","url":"docs/references/modules/render#быстрый-обзор","content":" Модуль который внутри себя содержит логику по генерацию html страницы, начиная от получения текущего компонента, так и заканчивая генерации конечного html c помощью библиотеки htmlpagebuilder. Из особенностей, в этом модуле присутствует код создания верхнеуровнего реакт компонента, получения пэйдж компонента и лайаута из роутинга и создание композиции из провайдеров в приложении "},{"title":"Подключение","type":1,"pageTitle":"render","url":"docs/references/modules/render#подключение","content":"Необходимо установить @tramvai/module-render с помощью npm npm i @tramvai/module-render Скопировать И подключить в проекте import { createApp } from '@tramvai/core';import { RenderModule } from '@tramvai/module-render'; createApp({ name: 'tincoin', modules: [RenderModule],}); Скопировать "},{"title":"Explanation","type":1,"pageTitle":"render","url":"docs/references/modules/render#explanation","content":""},{"title":"Разные режимы отрисовки React","type":1,"pageTitle":"render","url":"docs/references/modules/render#разные-режимы-отрисовки-react","content":"Подробнее о режимах рендеринга можете узнать в официальной доке в module-render есть поддержка всех типов и вы можете выбрать для своего приложения актуальный тип Для задания режима, необходимо при инициализации RenderModule передать параметр mode RenderModule.forRoot({ mode: 'concurrent' }); Скопировать Доступны варианты: 'legacy' | 'strict' | 'blocking' | 'concurrent' Постепенная миграция на concurrent режим "},{"title":"Ассеты в приложении","type":1,"pageTitle":"render","url":"docs/references/modules/render#ассеты-в-приложении","content":"Для работы с ресурсами в tramvai был разработан модуль ассетов который позволяет задать в DI список ресурсов и дальше их отрисовать в определенные слоты. Пример: createApp({ providers: [ { multi: true, useValue: [ { type: ResourceType.inlineScript, // inlineScript обернет payload в тег <script> slot: ResourceSlot.HEAD_CORE_SCRIPTS, // определяет позицию где в html будет вставлен ресурс payload: 'alert(\"render\")', }, { type: ResourceType.asIs, // asIs занчит вставить ресурс как есть. без обработки slot: ResourceSlot.BODY_TAIL, payload: '<div>hello from render slots</div>', }, ], }, ],}); Скопировать type - тип ресурса, уже есть готовые пресеты которые упрощает добавление кода на страницу, без прокидывания дополнительных параметров и так далееslot - место в html странице, куда будет добавлен этот ресурсpayload - что будет отрисовано  Доступные слоты export const REACT_RENDER = 'react:render';export const HEAD_PERFORMANCE = 'head:performance';export const HEAD_META = 'head:meta';export const HEAD_POLYFILLS = 'head:polyfills';export const HEAD_CORE_STYLES = 'head:core-styles';export const HEAD_CORE_SCRIPTS = 'head:core-scripts';export const HEAD_DYNAMIC_SCRIPTS = 'head:dynamic-scripts';export const HEAD_ANALYTICS = 'head:analytics';export const HEAD_ICONS = 'head:icons';export const BODY_START = 'body:start';export const BODY_END = 'body:end';export const BODY_TAIL_ANALYTICS = 'body:tail:analytics';export const BODY_TAIL = 'body:tail'; Скопировать   Схема разметки слотов в HTML странице import type { StaticDescriptor, DynamicDescriptor } from '@tinkoff/htmlpagebuilder';import { dynamicRender, staticRender } from '@tinkoff/htmlpagebuilder';import { ResourceSlot } from '@tramvai/tokens-render';import { formatAttributes } from './utils'; const { REACT_RENDER, HEAD_CORE_SCRIPTS, HEAD_DYNAMIC_SCRIPTS, HEAD_META, HEAD_POLYFILLS, HEAD_CORE_STYLES, HEAD_PERFORMANCE, HEAD_ANALYTICS, BODY_START, BODY_END, HEAD_ICONS, BODY_TAIL_ANALYTICS, BODY_TAIL,} = ResourceSlot; export const htmlPageSchemaFactory = ({ htmlAttrs,}): Array<StaticDescriptor | DynamicDescriptor> => { return [ staticRender('<!DOCTYPE html>'), staticRender(`<html ${formatAttributes(htmlAttrs, 'html')}>`), staticRender('<head>'), staticRender('<meta charset=\"UTF-8\">'), dynamicRender(HEAD_META), dynamicRender(HEAD_PERFORMANCE), dynamicRender(HEAD_CORE_STYLES), dynamicRender(HEAD_POLYFILLS), dynamicRender(HEAD_DYNAMIC_SCRIPTS), dynamicRender(HEAD_CORE_SCRIPTS), dynamicRender(HEAD_ANALYTICS), dynamicRender(HEAD_ICONS), staticRender('</head>'), staticRender(`<body ${formatAttributes(htmlAttrs, 'body')}>`), dynamicRender(BODY_START), // react app dynamicRender(REACT_RENDER), dynamicRender(BODY_END), dynamicRender(BODY_TAIL_ANALYTICS), dynamicRender(BODY_TAIL), staticRender('</body>'), staticRender('</html>'), ];}; Скопировать  Как добавить загрузку ассетов на странице "},{"title":"Автоматический инлайнинг ресурсов","type":1,"pageTitle":"render","url":"docs/references/modules/render#автоматический-инлайнинг-ресурсов","content":"Контекст# Большое количество файлов ресурсов создаёт проблемы при загрузке страницы, т.к. браузеру приходится создавать много соединений на небольшие файлы Решение# Решили добавить возможность включить часть ресурсов прямо в приходящий с сервера HTML. Чтобы не инлайнить вообще всё, добавлена возможность задать верхнюю границу размера файлов. Подключение и конфигурация# С версии 0.60.7 инлайнинг для стилей включен по умолчанию, инлайнятся CSS-файлы размером меньше 40kb до gzip (+-10kb после gzip). Для переопределения этих настроек нужно добавить провайдер с указанием типов ресурсов, которые будут инлайниться (стили и\\или скрипты), а также верхнюю границу размера файлов (в байтах, до gzip): import { RESOURCE_INLINE_OPTIONS } from '@tramvai/tokens-render';import { ResourceType } from '@tramvai/tokens-render';import { provide } from '@tramvai/core'; provide({ provide: RESOURCE_INLINE_OPTIONS, useValue: { types: [ResourceType.script, ResourceType.style], // Включаем для стилей и скриптов threshold: 1024, // 1kb unzipped },}), Скопировать Особенности# Инлайнятся все скрипты и\\или стили (в зависимости от настроек), зарегистрированные через ResourcesRegistry Загрузка файлов на сервере происходит в lazy-режиме асинхронно. Это означает, что при первой загрузке страницы инлайнинга не будет происходить. Также это означает, что никакого дополнительного ожидания загрузки ресурсов на стороне сервера не происходит. После попадания файла в кэш он будет инлайниться. Кэш имеет TTL 30 минут, сброс кэша не предусмотрен. "},{"title":"Автоматический предзагрузка ассетов приложений","type":1,"pageTitle":"render","url":"docs/references/modules/render#автоматический-предзагрузка-ассетов-приложений","content":"Для ускорения загрузки данных добавлена система подзагрузки данных для ресурсов и асинхронных чанков, которая работает по следующему сценарию: После рендеринга приложения мы получаем информацию о всех используемых в приложении css, js и асинхронных чанкахДальше добавляем все css в прелоад тег и навешиваем onload событие. Нам необходимо максимально быстро загрузить блокирующие ресурсы.При загрузке любого css файла, добавляем в предзагрузку все необходимые js файлы Особенности# Обязательно должен быть синхронизирована последняя часть идентификатора бандла с названием чанка const dashboard = () => require.ensure([], (require) => require('./bundles/dashboard'), 'dashboard');bundles: { 'platform/mvno/dashboard': dashboard,} Скопировать или если используете import const dashboard = () => import(/* webpackChunkName: \"dashboard\" */ './bundles/dashboard');bundles: { 'platform/mvno/dashboard': dashboard,} Скопировать В примере выше, 'dashboard' и last('platform/mvno/dashboard'.split('/')) имеют одинаковое значение. Иначе мы не сможем на стороне сервера узнать, какой из списка чанков подходит в бандлу и подзагрузка произойдет только на стороне клиента. "},{"title":"Базовый layout","type":1,"pageTitle":"render","url":"docs/references/modules/render#базовый-layout","content":"В module-render встроен дефолтный базовый layout, который поддерживает различные способы расширения и добавления функциональности Подробнее про лайаут можете почитать на странице библиотеке Добавление базовых header и footer# Можно добавить компоненты header и footer, которые будут отрисовываться по умолчанию для всех страниц Через провайдер# Зарегистрировать компоненты header и footer через провайдеры import { DEFAULT_HEADER_COMPONENT, DEFAULT_FOOTER_COMPONENT } from '@tramvai/tokens-render';import { provide } from '@tramvai/core'; createApp({ providers: [ provide({ provide: DEFAULT_HEADER_COMPONENT, useValue: DefaultHeader, }), provide({ provide: DEFAULT_FOOTER_COMPONENT, useValue: DefaultFooter, }), ],}); Скопировать Через бандл# Можно зарегистрировать в бандле компонент headerDefault и footerDefault, которые будет отрисовываться для всех роутов, у которых не переопределены headerComponent и footerComponent. createBundle({ name: 'common-bundle', components: { headerDefault: CustomHeader, footerDefault: CustomFooter, },}); Скопировать Добавление компонентов и враперов# Добавить кастомные компоненты и врапперы для layout можно через токен LAYOUT_OPTIONS import { provide } from '@tramvai/core';@Module({ providers: [ provide({ provide: 'LAYOUT_OPTIONS', multi: true, useValue: { // react компоненты components: { // базовые кастомные компоненты врапперы для отрисовки страницы и контента content: Content, page: Page, // глобальные компоненты alerts: Alerts, feedback: Feedback, }, // HOC для компонентов wrappers: { layout: layoutWrapper, alerts: [alertWrapper1, alertWrapper2], }, }, }), ],})export class MyLayoutModule {} Скопировать Подробнее про опции components и wrappers можно узнать в @tinkoff/layout-factory Замена базового layout# Если вам не подходит базовый лайаут, вы можете его подменить на любой другой React компонент. При этом вам нужно самостоятельно реализовывать все врапперы и подключать глобальные компоненты, если они вам нужны. Заменить можно двумя способами: Добавить layoutComponent у роута# Вы можете прописать параметр layoutComponent у роута в properties и зарегистрировать компонент в bundle. При отрисовке страницы отобразится зарегистрированный компонент createBundle({ name: 'common-bundle', components: { myCustomLayout: CustomLayout, },}); Скопировать Переопределить layoutDefault# Вы можете зарегистрировать в бандле компонент layoutDefault который автоматически будет отрисовываться для всех роутов, у которых не переопределен layoutComponent createBundle({ name: 'common-bundle', components: { layoutDefault: CustomLayout, },}); Скопировать "},{"title":"How to","type":1,"pageTitle":"render","url":"docs/references/modules/render#how-to","content":""},{"title":"Как добавить загрузку ассетов на странице","type":1,"pageTitle":"render","url":"docs/references/modules/render#как-добавить-загрузку-ассетов-на-странице","content":"Присутствует 2 способа, как можно добавить ресурсы в приложение токен RENDER_SLOTS, в который можно передать список ресурсов, например HTML разметка, inline скрипты, тег scriptтокен RESOURCES_REGISTRY для получения менеджера ресурсов, и регистрации нужных ресурсов вручную Пример:  Пример приложения import React from 'react';import { createApp, createBundle, commandLineListTokens } from '@tramvai/core';import { RENDER_SLOTS, RESOURCES_REGISTRY, ResourceType, ResourceSlot,} from '@tramvai/module-render';import { modules } from '../common'; function Page() { return <div>Render</div>;} const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, },}); createApp({ name: 'render-add-resources', modules: [...modules], providers: [ { // Если требуется добавить свои ресурсы (скрипты, стили, картинки) для загрузки, то можно использовать // провайдер RENDER_SLOTS для добавления необходимого, все это потом будет использовано в RenderModule // и вставлено в html provide: RENDER_SLOTS, multi: true, useValue: [ { type: ResourceType.inlineScript, // inlineScript обернет payload в тег <script> slot: ResourceSlot.HEAD_CORE_SCRIPTS, // определяет позицию где в html будет вставлен ресурс payload: 'alert(\"render\")', }, { type: ResourceType.asIs, // asIs занчит вставить ресурс как есть. без обработки slot: ResourceSlot.BODY_TAIL, payload: '<div>hello from render slots</div>', }, ], }, { provide: commandLineListTokens.resolveUserDeps, multi: true, // также ресурсы можно добавить отдельно через di и токен RESOURCES_REGISTRY useFactory: ({ resourcesRegistry }) => { return function addMyScripts() { resourcesRegistry.register({ slot: ResourceSlot.HEAD_ANALYTICS, // место вставки type: ResourceType.script, // script создаст новый тег скрипт с src равном payload payload: './some-script.js', }); }; }, deps: { resourcesRegistry: RESOURCES_REGISTRY, }, }, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Скопировать  "},{"title":"Как можно перевести приложения на Concurrent render mode","type":1,"pageTitle":"render","url":"docs/references/modules/render#как-можно-перевести-приложения-на-concurrent-render-mode","content":"React позволяет выполнить постепенную миграцию приложения Этапы миграции: Strict Mode - строгий режим, в котором React предупреждает об использовании легаси API Для подключения необходимо сконфигурировать render-module modules: [ RenderModule.forRoot({ mode: 'strict' })] Скопировать Затем необходимо исправить все новые предупреждения, такие как использование легаси методов жизненного цикла и строковые рефы. Blocking Mode - добавляет часть возможностей Concurrent Mode, например Suspense на сервере. Подходит для постепенной миграции на Concurrent Mode. Для подключения необходимо установить экспериментальную версию React и сконфигурировать render-module npm install react@experimental react-dom@experimental Скопировать modules: [ RenderModule.forRoot({ mode: 'blocking' })] Скопировать На этом этапе надо проверить работоспособность приложения, и можно попробовать новые API, например SuspenseList Concurrent Mode Для подключения необходимо установить экспериментальную версию React и сконфигурировать render-module npm install react@experimental react-dom@experimental Скопировать modules: [ RenderModule.forRoot({ mode: 'concurrent' })] Скопировать На этом этапе надо проверить работоспособность приложения, и можно попробовать новые API, например useTransition "},{"title":"Тестирование","type":1,"pageTitle":"render","url":"docs/references/modules/render#тестирование","content":"Тестирование расширений рендера через токены RENDER_SLOTS или RESOURCES_REGISTRY# Если у вас имеется модуль или провайдеры которые определяют RENDER_SLOTS или используют RESOURCES_REGISTRY, то удобно будет использовать специальные утилиты для того чтобы протестировать их отдельно import { RENDER_SLOTS, ResourceSlot, RESOURCES_REGISTRY, ResourceType,} from '@tramvai/tokens-render';import { testPageResources } from '@tramvai/module-render/tests';import { CustomModule } from './module';import { providers } from './providers'; describe('testPageResources', () => { it('modules', async () => { const { render } = testPageResources({ modules: [CustomModule], }); const { head } = render(); expect(head).toMatchInlineSnapshot(`\"<meta charset=\\\\\"UTF-8\\\\\"><script>console.log(\\\\\"from module!\\\\\")</script>\"`); }); it('providers', async () => { const { render, runLine } = testPageResources({ providers, }); expect(render().body).toMatchInlineSnapshot(`\"\" `); await runLine(commandLineListTokens.resolvePageDeps); expect(render().body).toMatchInlineSnapshot(`\"<script defer=\\\\\"defer\\\\\" charset=\\\\\"utf-8\\\\\" crossorigin=\\\\\"anonymous\\\\\" src=\\\\\"https://scripts.org/script.js\\\\\"></script><span>I\\`m body!!!</span>\" `); });}); Скопировать "},{"title":"Экспортируемые токены","type":1,"pageTitle":"render","url":"docs/references/modules/render#экспортируемые-токены","content":"ссылка "},{"title":"sentry","type":0,"sectionRef":"#","url":"docs/references/modules/sentry","content":"","keywords":""},{"title":"Подключение в проект","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#подключение-в-проект","content":""},{"title":"Переменные окружения","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#переменные-окружения","content":"Обязательные: SENTRY_DSN - DSN приложения Опциональные: SENTRY_RELEASE - информация о текущем релизе приложенияSENTRY_ENVIRONMENT - информация об окруженииSENTRY_SDK_URL - URL для загрузки Sentry SDK в браузере, задан по умолчаниюSENTRY_DSN_CLIENT - DSN приложения для использования только в браузере. "},{"title":"Подключение модуля","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#подключение-модуля","content":"SentryModule следует подключать в приложение одним из первых import { SentryModule } from '@tramvai/module-sentry'; createApp({ modules: [SentryModule],}); Скопировать И обязательно добавьте SENTRY_DSN параметр на стендах. Иначе плагин не будет работать. "},{"title":"Пример отправки кастомных ошибок","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#пример-отправки-кастомных-ошибок","content":"import { createAction } from '@tramvai/core';import { SENTRY_TOKEN } from '@tramvai/module-sentry';import { loadUsers } from './users'; export default createAction({ name: 'loadUsers', fn: async (context, _, { sentry }) => { try { await loadUsers(); } catch (e) { sentry.captureException(e); throw e; } }, deps: { sentry: SENTRY_TOKEN, },}); Скопировать "},{"title":"Локальный дебаг модуля","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#локальный-дебаг-модуля","content":"Локально Sentry отключен и если вы хотите оддебажить модуль, то необходимо явно включить Sentry SentryModule.forRoot({ enabled: true, debug: true }); Скопировать И добавить в env.development.js параметр SENTRY_DSN после этого Sentry включится при локальной разработке "},{"title":"Получение DSN","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#получение-dsn","content":"Для этого: Зайдите в UI интерфейс SentryНажмите на таб SettingsВ табе Projects выберите свой проектВыберите Client Keys (DSN)Скопируйте текст с DefaultDSN поля. "},{"title":"Sensitive Data","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#sensitive-data","content":"Прежде чем начать использовать модуль, следует ознакомиться с документаций и в случае необходимости сконфигурировать под свое приложение Sentry старается максимально обогощать контекст ошибки, формируя breadcrumbs и получая информацию от дополнительных интеграций. Все это можно конфигурировать, но следует внимательно следить за тем, какая информация в итоге попадает в Sentry хранилище. "},{"title":"Поведение","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#поведение","content":"Модуль использует universal подход, что позволяет логировать ошибки на клиенте и сервере. Интеграция c Sentry SDK происходит на шаге commandLineListTokens.init. По умолчанию Sentry включается только для production и если имется DSN. "},{"title":"Browser","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#browser","content":"Концептуально используется lazy loaded подход при котором Sentry SDK подключается динамически (возможно по необходимости), то есть @sentry/browser не попадает в итоговый бандл "},{"title":"Node","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#node","content":"Используется @sentry/node и Sentry express middleware "},{"title":"Загрузка sourcemaps","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#загрузка-sourcemaps","content":"Для загрузки sourcemaps в Sentry систему можно использовать @sentry/cli. Важно правильно указать --url-prefix. --rewrite нужен, чтобы сократить размер загружаемых файлов и выполнить проверку валидности сорсмап Пример такого скрипта для загрузки: ci/sentry-upload-sourcemaps:# set -eu -o pipefail -x PACKAGE_VERSION=$(node -p -e \"require('./package.json').version\")VERSION=${SENTRY_RELEASE:-\"${PACKAGE_VERSION}-${CI_COMMIT_SHA}\"}export SENTRY_PROJECT=\"${APP}\"export SENTRY_URL=\"${SENTRY_URL_TEST}\"export SENTRY_AUTH_TOKEN=\"${SENTRY_AUTH_TOKEN_TEST}\"sentry-cli releases files $VERSION upload-sourcemaps --rewrite --url-prefix \"~/\" ./server/ & \\sentry-cli releases files $VERSION upload-sourcemaps --rewrite --url-prefix \"~/platform/\" ./assets/ Скопировать Чтобы генерировались sourcemaps для сервера, нужно указать \"sourceMapServer\": true в configurations для приложения в platform.json. "},{"title":"Экспортируемые токены","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#экспортируемые-токены","content":"SENTRY_TOKEN# Подготовленный инстанс Sentry на основе Node SDK или Browser SDK "},{"title":"SENTRY_OPTIONS_TOKEN","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#sentry_options_token","content":"Опции для конфигурирования Sentry для Node и Browser окружений "},{"title":"SENTRY_REQUEST_OPTIONS_TOKEN","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#sentry_request_options_token","content":"Опции для конфигурирования парсера данных из запроса для express middleware "},{"title":"SENTRY_FILTER_ERRORS","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#sentry_filter_errors","content":"Позволяет передать функцию для фильтрации ошибок перед отправкой в Sentry. Механизм фильтрации описан в документации Sentry, в функцию передаются аргументы event и hint метода beforeSend. "},{"title":"seo","type":0,"sectionRef":"#","url":"docs/references/modules/seo","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#подключение","content":"Необходимо установить @tramvai/module-seo с помощью npm npm i @tramvai/module-seo Скопировать И подключить в проекте import { createApp } from '@tramvai/core';import { SeoModule } from '@tramvai/module-seo'; createApp({ name: 'tincoin', modules: [...SeoModule],}); Скопировать "},{"title":"Интеграция с tramvai","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#интеграция-с-tramvai","content":"Модуль не добавляет публичное api в di для использования. Для рендера seo используется возможности @tramvai/module-render для вставки кода в html-страницу. "},{"title":"Базовые источники данных","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#базовые-источники-данных","content":"default - список базовых пред установленных параметровconfig/meta - список мета параметров, которые были переданы и проставлены в блоке seo в админке "},{"title":"Подключение дополнительных источников данных","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#подключение-дополнительных-источников-данных","content":"Библиотека @tinkoff/meta-tags-generate позволяет подключать дополнительные источники данных для мета тегов с возможностью перезаписать базовые. Для этого необходимо определить мульти провайдер META_UPDATER_TOKEN import { createApp, provide } from '@tramvai/core';import { SeoModule, META_UPDATER_TOKEN, META_PRIORITY_ROUTE } from '@tramvai/module-seo'; const metaSpecial = (meta) => { meta.updateMeta(META_PRIORITY_ROUTE, { // приоритет - 10 title: 'title', // ключ/значение в мете, metaCustom: { // подробная информация о формате [в доке](references/libs/meta-tags-generate.md) tag: 'meta', attributes: { name: 'metaCustomNameAttribute', content: 'metaCustomContent', }, }, });}; createApp({ providers: [ provide({ // либо добавить через провайдер provide: META_UPDATER_TOKEN, multi: true, useValue: metaSpecial, }), ], modules: [ SeoModule.forRoot({ list: [metaSpecial], }), ],}); Скопировать Каждый источник представляет собой функцию которая принимает meta и позволяет расширять мету через вызов updateMeta. Приоритет представляет собой положительное число, для каждого конкретного ключа меты будет использовано значение с наивысшим приоритетом, значение с приоритетом 0 обозначают значение по умолчанию. Подробнее о формате в доке "},{"title":"Установка seo данных динамически","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#установка-seo-данных-динамически","content":"Если требуется установить seo в страничном экшене или на одном из шагов commandLineRunner, то можно использовать явно сущность MetaWalk из либы @tinkoff/meta-tags-generate import { createAction } from '@tramvai/core';import { META_WALK_TOKEN, META_PRIORITY_APP } from '@tramvai/module-seo'; createAction({ name: 'action', fn: async (context, payload, { meta }) => { meta.updateMeta(META_PRIORITY_APP, { title: 'WoW, such dynamic!', }); }, deps: { meta: META_WALK_TOKEN, }, conditions: { always: true, },}); Скопировать "},{"title":"Замена default seo данных","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#замена-default-seo-данных","content":"SEO модуль поставляется с default паком seo тегов. Если они вам не подходят, вы можете заменить реализацию провайдера и поставить свои данные: import { createApp } from '@tramvai/core';import { SeoModule, META_DEFAULT_TOKEN } from '@tramvai/module-seo'; createApp({ providers: [ // Изменяем реализацию токена metaDefaultPack { provide: META_DEFAULT_TOKEN, useValue: { title: 'E Corp' }, }, ], modules: [SeoModule],}); Скопировать После этого у нас будут подставляться другие дефолтные параметры "},{"title":"Meta параметры","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#meta-параметры","content":"В библиотеке уже предопределены часть базовых параметров для удобного использования при конфигурировании роутов. И мы можем использовать мета параметры вида title: 'Тинькофф' Список таких конвертеров, необходимо смотреть в файле src/converters/converters.ts "},{"title":"How to","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#how-to","content":""},{"title":"Тестирование","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#тестирование","content":"Тестирование работы с META_UPDATER_TOKEN и META_DEFAULT_TOKEN# Если у вас имеется модуль или провайдеры которые определяют META_UPDATER_TOKEN или META_DEFAULT_TOKEN, то удобно будет использовать специальные утилиты для того чтобы протестировать их отдельно import { Module, provide } from '@tramvai/core';import { testMetaUpdater } from '@tramvai/module-seo/tests';import { META_PRIORITY_APP, META_DEFAULT_TOKEN, META_UPDATER_TOKEN } from '@tramvai/module-seo'; describe('testMetaUpdater', () => { it('modules', async () => { const metaUpdater = jest.fn< ReturnType<typeof META_UPDATER_TOKEN>, Parameters<typeof META_UPDATER_TOKEN> >((walker) => { walker.updateMeta(META_PRIORITY_APP, { title: 'test title', }); }); @Module({ providers: [ provide({ provide: META_UPDATER_TOKEN, multi: true, useValue: metaUpdater, }), ], }) class CustomModule {} const { renderMeta } = testMetaUpdater({ modules: [CustomModule], }); const { render, metaWalk } = renderMeta(); expect(metaWalk.get('title').value).toBe('test title'); expect(render).toMatch('<title data-meta-dynamic=\"true\">test title</title>'); }); it('providers', async () => { const { renderMeta } = testMetaUpdater({ providers: [ provide({ provide: META_DEFAULT_TOKEN, useValue: { title: 'default title', }, }), ], }); const { render } = renderMeta(); expect(render).toMatch('<title data-meta-dynamic=\"true\">default title</title>'); });}); Скопировать "},{"title":"router","type":0,"sectionRef":"#","url":"docs/references/modules/router","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"router","url":"docs/references/modules/router#installation","content":"You need to install @tramvai/module-router: yarn add @tramvai/module-router Скопировать And connect in the project: import { createApp } from '@tramvai/core';import { NoSpaRouterModule, SpaRouterModule } from '@tramvai/module-router'; createApp({ name: 'tincoin', modules: [SpaRouterModule], // modules: [ NoSpaRouterModule ], if you want to disable client SPA transitions}); Скопировать "},{"title":"Explanation","type":1,"pageTitle":"router","url":"docs/references/modules/router#explanation","content":"The module is based on the library @tinkoff/router "},{"title":"Navigation flow on the server","type":1,"pageTitle":"router","url":"docs/references/modules/router#navigation-flow-on-the-server","content":" "},{"title":"Flow of the first navigation on the client","type":1,"pageTitle":"router","url":"docs/references/modules/router#flow-of-the-first-navigation-on-the-client","content":" "},{"title":"Flow of navigation on the client without SPA transitions","type":1,"pageTitle":"router","url":"docs/references/modules/router#flow-of-navigation-on-the-client-without-spa-transitions","content":" "},{"title":"Flow of navigation on the client with SPA transitions","type":1,"pageTitle":"router","url":"docs/references/modules/router#flow-of-navigation-on-the-client-with-spa-transitions","content":" "},{"title":"API","type":1,"pageTitle":"router","url":"docs/references/modules/router#api","content":""},{"title":"Static routes in the application","type":1,"pageTitle":"router","url":"docs/references/modules/router#static-routes-in-the-application","content":"Route description format: const routes = [ { // the name of the route is required name: 'route1', // the path of the route is required path: '/route/a/', // additional configs for the route config: { // layout component name layoutComponent: 'layout', // page component name pageComponent: 'page', }, },]; Скопировать You can explicitly transfer a list of routes to routing when adding a router module: import { createApp } from '@tramvai/core';import { SpaRouterModule } from '@tramvai/module-router'; const routes = [ // ...]; createApp({ modules: [ // ..., SpaRouterModule.forRoot(routes), ],}); Скопировать Or separately with the ROUTES_TOKEN token (you can set it several times): import { ROUTES_TOKEN } from '@tramvai/module-router';import { provide } from '@tramvai/core'; const routesCommon = [ // ...];const routesSpecific = [ // ...]; const providers = [ // ..., provide({ provide: ROUTES_TOKEN, multi: true, useValue: routesCommon, }), provide({ provide: ROUTES_TOKEN, multi: true, useValue: routesSpecific, }),]; Скопировать "},{"title":"PAGE_SERVICE_TOKEN","type":1,"pageTitle":"router","url":"docs/references/modules/router#page_service_token","content":"Service wrapper for working with routing. Serves to hide routing work and is the preferred way of routing work. Methods: getCurrentRoute() - get the current routegetCurrentUrl() - object-result of parsing the current urlgetConfig() - get the config of the current pagegetContent() - get content for the current pagegetMeta() - get the meta for the current pagenavigate(options) - navigation to a new page moreupdateCurrentRoute(options) - update the current route with new parameters moreback() - go back through historyforward() - go forward through historygo(to) - go to the specified delta by historyaddComponent(name, component) - add new component to current page into ComponentRegistrygetComponent(name) - get component from current page components from ComponentRegistry "},{"title":"RouterStore","type":1,"pageTitle":"router","url":"docs/references/modules/router#routerstore","content":"Store that stores information about the current and previous routes. Properties: currentRoute - current routecurrentUrl - current urlpreviousRoute - previous routepreviousUrl - previous url "},{"title":"ROUTER_GUARD_TOKEN","type":1,"pageTitle":"router","url":"docs/references/modules/router#router_guard_token","content":"Allows you to block or redirect the transition to the page under certain conditions. See @tinkoff/router "},{"title":"Redirects","type":1,"pageTitle":"router","url":"docs/references/modules/router#redirects","content":"Redirects can be done via guards or explicitly via the redirect property in the route. const routes = [ // ..., { name: 'redirect', path: '/from/', redirect: '/to/', },]; Скопировать "},{"title":"Not Found route","type":1,"pageTitle":"router","url":"docs/references/modules/router#not-found-route","content":"The route used if no matches were found for the current page, can be specified in a special way in the list of routes. const route = [ // ...other routes, { name: 'not-found', path: '*', config: { pageComponent: 'notfoundComponentName', }, },]; Скопировать "},{"title":"ROUTE_RESOLVE_TOKEN","type":1,"pageTitle":"router","url":"docs/references/modules/router#route_resolve_token","content":"Allows you to define an asynchronous function that returns a route object that will be called if no suitable static route was found in the application. "},{"title":"ROUTE_TRANSFORM_TOKEN","type":1,"pageTitle":"router","url":"docs/references/modules/router#route_transform_token","content":"Transformer function for application routes (set statically and those that will be loaded via ROUTE_RESOLVE_TOKEN) "},{"title":"Method of setting when actions should be performed during SPA transitions","type":1,"pageTitle":"router","url":"docs/references/modules/router#method-of-setting-when-actions-should-be-performed-during-spa-transitions","content":"By default, SPA transitions execute actions after defining the next route, but before the actual transition, which allows the page to be displayed immediately with new data, but can cause a noticeable visual lag if the actions are taken long enough. It is possible to change the behavior and make the execution of actions after the transition itself. Then, when developing components, you will need to take into account that data will be loaded as it becomes available. Configurable explicitly when using the routing module: import { createApp } from '@tramvai/core';import { SpaRouterModule } from '@tramvai/module-router'; createApp({ modules: [ // ..., SpaRouterModule.forRoot([], { spaActionsMode: 'after', // default is 'before' }), ],}); Скопировать or through token ROUTER_SPA_ACTIONS_RUN_MODE_TOKEN: import { ROUTER_SPA_ACTIONS_RUN_MODE_TOKEN } from '@tramvai/module-router';import { provide } from '@tramvai/core'; const providers = [ // ..., provide({ provide: ROUTER_SPA_ACTIONS_RUN_MODE_TOKEN, useValue: 'after', }),]; Скопировать "},{"title":"How to","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to","content":""},{"title":"Working with navigation in providers and actions","type":1,"pageTitle":"router","url":"docs/references/modules/router#working-with-navigation-in-providers-and-actions","content":"In this case, it is best to use the PAGE_SERVICE_TOKEN import { provide, createAction } from '@tramvai/core';import { PAGE_SERVICE_TOKEN } from '@tramvai/module-router'; const provider = provide({ provide: 'token', useFactory: ({ pageService }) => { if (pageService().getCurrentUrl().pathname === '/test/') { return pageService.navigate({ url: '/redirect/', replace: true }); } }, deps: { pageService: PAGE_SERVICE_TOKEN, },}); const action = createAction({ name: 'action', fn: (_, __, { pageService }) => { if (pageService.getConfig().pageComponent === 'pageComponent') { return page.updateCurrentRoute({ query: { test: 'true' } }); } }, deps: { pageService: PAGE_SERVICE_TOKEN, },}); Скопировать "},{"title":"Working with navigation in React components","type":1,"pageTitle":"router","url":"docs/references/modules/router#working-with-navigation-in-react-components","content":"You can work with routing inside React components using hooks and components - useNavigate, useRoute, Link from the @tinkoff/router  An example of working with navigation in the application import React from 'react';import { createApp, createBundle } from '@tramvai/core';import { SpaRouterModule, useNavigate, useUrl, Link } from '@tramvai/module-router';import { modules } from '../common'; const Navigation = ['/1/', '/2/', '/3/']; function Page() { // useUrl allows you to get the current url const { pathname, path } = useUrl(); // useNavigate allows you to get a function with which you can call the navigation const navigate = useNavigate(); // useNavigate also allows you to set properties immediately so that the result can be passed immediately as a callback const navigateToRoot = useNavigate({ url: '/', query: { a: '1', b: '2' } }); return ( <div> <div>Current Path: {path}</div> <div> <button type=\"button\" onClick={navigateToRoot}> Navigate to Root </button> {/* the Link component allows you to create a link with a transition */} <Link url=\"/link/\" replace> <button type=\"button\">Navigate By Link</button> </Link> </div> {Navigation.map((p) => { if (p !== pathname) { return ( <button type=\"button\" onClick={() => navigate({ url: p })}> Navigate to {p} </button> ); } return null; })} </div> );} const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, },}); createApp({ name: 'route-navigate', modules: [ SpaRouterModule.forRoot([ { name: 'root', path: '/', }, { name: 'link', path: '/link/', }, { name: '1', path: '/1/', }, { name: '2', path: '/2/', }, { name: '3', path: '/3/', }, ]), ...modules, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Скопировать  "},{"title":"How to set static routes","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to-set-static-routes","content":"RouterModule allows you to add new routes when configuring your application. The second way is to pass static routes to DI via the ROUTES_TOKEN token.  An example of adding static routes to an application import React from 'react';import { createApp, createBundle } from '@tramvai/core';import { useSelector } from '@tramvai/state';import { useDi } from '@tramvai/react';import { SpaRouterModule, ROUTES_TOKEN, PAGE_SERVICE_TOKEN } from '@tramvai/module-router'; import { modules } from '../common'; const Navigation = ['/1/', '/2/', '/3/']; function Page() { // useSelector to get the current route // store 'router' is provided by RouterModule const state = useSelector('router', (x) => x.router); // pageService - a wrapper for working with a router, you can get various properties and initiate a transition // but through useDi you cannot subscribe to data changes inside services, so to subscribe to route changes // used by useSelector above const pageService = useDi(PAGE_SERVICE_TOKEN); const { pathname, path } = state.currentUrl; return ( <div> <div>Current Path: {path}</div> {Navigation.map((p) => { if (p !== pathname) { return ( <button type=\"button\" onClick={() => pageService.navigate({ url: p })}> Navigate to {p} </button> ); } return null; })} </div> );} const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, },}); createApp({ name: 'route-static-routes', modules: [ // the static forRoot method allows you to define static routes in the application - // these routes are always available and the config for them is not loaded from the admin panel, but are set right there SpaRouterModule.forRoot([ { name: '1', path: '/1/', }, { name: '2', path: '/2/', }, ]), ...modules, ], providers: [ { // you can also set static routes by a separate provider provide: ROUTES_TOKEN, multi: true, useValue: [ { name: '3', path: '/3/', }, ], }, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Скопировать  "},{"title":"How to set Route Guard","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to-set-route-guard","content":"ROUTER_GUARD_TOKEN is set as an asynchronous function, which allows you to perform various actions and influence the routing behavior.  Example router guards job in application import React from 'react';import { createReducer, createEvent } from '@tramvai/state';import { createApp, createBundle, createAction } from '@tramvai/core';import { SpaRouterModule, ROUTER_GUARD_TOKEN, useNavigate, useUrl } from '@tramvai/module-router';import { STORE_TOKEN, CONTEXT_TOKEN, COMBINE_REDUCERS } from '@tramvai/module-common';import { modules } from '../common'; const Navigation = ['/1/', '/2/', '/3/', '/redirect/', '/block/']; function Page() { const navigate = useNavigate(); const { pathname, path } = useUrl(); return ( <div> <div>Current Path: {path}</div> {Navigation.map((p) => { if (p !== pathname) { return ( <button type=\"button\" onClick={() => navigate({ url: p })}> Navigate to {p} </button> ); } return null; })} </div> );} const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, },}); const event = createEvent<boolean>('event');const store = createReducer<boolean | void>('store', undefined).on(event, (_, val) => val); const action = createAction({ name: 'action', fn: async (context) => { await new Promise<void>((res) => setTimeout(res, 1200)); return context.dispatch(event(true)); },}); createApp({ name: 'route-navigate', modules: [ SpaRouterModule.forRoot([ { name: 'root', path: '/', }, { name: '1', path: '/1/', }, { name: '2', path: '/2/', }, { name: '3', path: '/3/', }, { name: 'redirect', path: '/redirect/', }, { name: 'block', path: '/block/', }, ]), ...modules, ], providers: [ { provide: COMBINE_REDUCERS, multi: true, useValue: store, }, { provide: ROUTER_GUARD_TOKEN, multi: true, useValue: async ({ to }) => { if (to.path === '/redirect/') { // we can make a redirect from the guard return '/3/'; } }, }, { provide: ROUTER_GUARD_TOKEN, multi: true, useFactory: ({ store: state, context }) => { return async ({ to }) => { if (to.path === '/block/') { if (state.getState().store === undefined) { await context.executeAction(action); } if (state.getState().store) { // we can block navigation return false; } } }; }, deps: { store: STORE_TOKEN, context: CONTEXT_TOKEN, }, }, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Скопировать  "},{"title":"How to set the Not found route","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to-set-the-not-found-route","content":"The Not found route is used if the corresponding route is not found for the url. Such a route is specified in the list of routes with the special * character in the path property.  An example of setting a Not Found route in an application import React from 'react';import { createApp, createBundle } from '@tramvai/core';import { SpaRouterModule, useNavigate, useUrl } from '@tramvai/module-router';import { modules } from '../common'; const Navigation = [ '/1/', '/2/', '/3/', '/not-found', '/child/1/', '/child/2/', '/child/3/', '/child/not-found',]; function Page() { const navigate = useNavigate(); const { pathname, path } = useUrl(); return ( <div> <div>Current Path: {path}</div> {Navigation.map((p) => { if (p !== pathname) { return ( <button type=\"button\" onClick={() => navigate({ url: p })}> Navigate to {p} </button> ); } return null; })} </div> );} // Defining a separate pageconst NotFoundRoot = () => { return 'not found root';}; const NotFoundChild = () => { return 'not found child';}; const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, notFoundRoot: NotFoundRoot, notFoundChild: NotFoundChild, },}); createApp({ name: 'route-navigate', modules: [ SpaRouterModule.forRoot([ { name: 'root', path: '/', }, { name: '1', path: '/1/', }, { name: '2', path: '/2/', }, { name: '3', path: '/3/', }, { name: 'child-1', path: '/child/1/', }, { name: 'child-2', path: '/child/2/', }, { name: 'child-1', path: '/child/3/', }, { name: 'not-found-root', path: '*', config: { pageComponent: 'notFoundRoot', }, }, { name: 'not-found-child', path: '/child/*', config: { pageComponent: 'notFoundChild', }, }, ]), ...modules, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Скопировать  "},{"title":"Testing","type":1,"pageTitle":"router","url":"docs/references/modules/router#testing","content":"Testing ROUTER_GUARD_TOKEN extensions# If you have a module or providers that define ROUTER_GUARD_TOKEN, then it will be convenient to use special utilities to test them separately import { ROUTER_GUARD_TOKEN } from '@tramvai/tokens-router';import { testGuard } from '@tramvai/module-router/tests';import { CustomModule } from './module';import { providers } from './providers'; describe('router guards', () => { it('should redirect from guard', async () => { const { router } = testGuard({ providers, }); await router.navigate('/test/'); expect(router.getCurrentUrl()).toMatchObject({ path: '/redirect/', }); }); it('should block navigation', async () => { const { router } = testGuard({ modules: [CustomModule], }); expect(router.getCurrentUrl()).toMatchObject({ path: '/' }); await router.navigate('/test/').catch(() => null); expect(router.getCurrentUrl()).toMatchObject({ path: '/', }); });}); Скопировать "},{"title":"Exported tokens","type":1,"pageTitle":"router","url":"docs/references/modules/router#exported-tokens","content":"link "},{"title":"server","type":0,"sectionRef":"#","url":"docs/references/modules/server","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"server","url":"docs/references/modules/server#подключение","content":"Необходимо установить @tramvai/module-server с помощью npm npm i --save @tramvai/module-server Скопировать И подключить в проекте import { createApp } from '@tramvai/core';import { ServerModule } from '@tramvai/module-server'; createApp({ name: 'tincoin', modules: [ServerModule],}); Скопировать "},{"title":"Explanation","type":1,"pageTitle":"server","url":"docs/references/modules/server#explanation","content":""},{"title":"Обработка запросов пользователей","type":1,"pageTitle":"server","url":"docs/references/modules/server#обработка-запросов-пользователей","content":"Основной функционал модуля заключается в том, что-бы обработать запрос пользователя, запустить commandLine у tramvai приложения и забрать данные страницы с RESPONSE_MANAGER_TOKEN "},{"title":"Проксирование запросов","type":1,"pageTitle":"server","url":"docs/references/modules/server#проксирование-запросов","content":"В server модуле доступна функциональность, которая позволяет настроить проксирование урлов в приложение используя библиотеку http-proxy-middleware. Эта фича работает как в дев режиме, так и на проде Для включения проксирования необходимо в корне проекта создать файл proxy.conf.js или proxy.conf.json который будет экспортировать объект-маппинг запросов, либо можно использовать токен PROXY_CONFIG_TOKEN. Формат прокси-файла# Объект ключ-значение# const testStand = 'https://example.org'; module.exports = { // ключ - path pattern для express который будет передан в app.use // значение может быть строкой, для того чтобы проксировать все урлы начинающиеся с /login/ '/login/': testStand, // или может быть объектом конфига для [http-proxy](https://github.com/chimurai/http-proxy-middleware#http-proxy-options) '/test/': { target: testStand, auth: true, xfwd: true, ... }}; Скопировать Объект со свойствами context и target# module.exports = { // context - аналогичен опции для [http-proxy-middleware](https://github.com/chimurai/http-proxy-middleware#context-matching) context: ['/login/', '/registration/', '/auth/papi/'], target: 'https://example.org', // разные дополнительные опции changeOrigin: true,}; Скопировать Массив со свойствами context и target# [ { \"context\": [\"/a/\", \"/b/*/c/\"], \"target\": \"https://example.org\" }] Скопировать Используя провайдеры с помощью токена PROXY_CONFIG_TOKEN# import { Scope, provide } from '@tramvai/core';import { PROXY_CONFIG_TOKEN } from '@tramvai/tokens-server'; [ provide({ provide: PROXY_CONFIG_TOKEN, scope: Scope.SINGLETON, useValue: { context: ['/a/', '/b/*/c/'], target: 'https://example.org', }, multi: true, }),]; Скопировать "},{"title":"Раздача статических файлов","type":1,"pageTitle":"server","url":"docs/references/modules/server#раздача-статических-файлов","content":"В module-server встроен статический сервер, который позволяет раздавать статичные файлы пользователям. Для раздачи файлов, необходимо в корне проекта создать директорию public в который поместить необходимые файлы. После этого все файлы будут доступны для запроса браузерами К примеру, мы хотим раздать sw.js файл из корня проекта: для этого создаем папку public в которой закидываем файл sw.js. Теперь на стороне клиента, мы сможем запросить данные с урла http://localhost:3000/sw.js. Так-же скорее всего нужны будут доработки на стороне CD, для того что бы скопировать папаку public на стенды. Эта функция доступна так-же и на продакшене. Для этого необходимо в докер контейнер скопировать папку public "},{"title":"PAPI","type":1,"pageTitle":"server","url":"docs/references/modules/server#papi","content":"Papi - API роуты для tramvai приложения. Подробная информация доступна в разделе Papi "},{"title":"Эмуляция проблем с сетью/бэкендами в приложении","type":1,"pageTitle":"server","url":"docs/references/modules/server#эмуляция-проблем-с-сетьюбэкендами-в-приложении","content":"(функционал доступен только в dev режиме) На сервере есть возможность увеличить время ответа всех запросов. Для этого необходимо: стартануть приложениеотправить post-запрос на /private/papi/debug-http-request с указанием задержки для запроса: curl --location --request POST 'http://localhost:3000/tincoin/private/papi/debug-http-request' \\--header 'Content-Type: application/x-www-form-urlencoded' \\--data-urlencode 'delay=2000' Скопировать проверить работу приложения. Внимание! после каждого перезапуска сервера настройки сбрасываются, поэтому после каждой пересборки надо обращаться к papi снова.отключить таймаут можно обратившись к тому же papi методом delete curl --location --request DELETE 'http://localhost:3000/tincoin/private/papi/debug-http-request' Скопировать "},{"title":"Логгирование запросов отправленных на сервере","type":1,"pageTitle":"server","url":"docs/references/modules/server#логгирование-запросов-отправленных-на-сервере","content":"В дев режиме все запросы отправленные через стандартные библиотеки http и https для nodejs логгируются под специальным ключом node-debug.request. Это позволяет увидеть все запросы которые были отправлены на сервере, даже если для запросов не было определено логгирование явно. Чтобы включить такие логи, достаточно добавить в переменную окружения DEBUG_ENABLE ключ node-debug.request "},{"title":"Health checks","type":1,"pageTitle":"server","url":"docs/references/modules/server#health-checks","content":"/healthz - после старта приложения всегда отдает ответ OK/readyz - после старта приложения всегда отдает OK "},{"title":"Метрики","type":1,"pageTitle":"server","url":"docs/references/modules/server#метрики","content":"В модуль сервера автоматически подключен модуль метрик. Подробную информацию по метрикам, можете почитать в документации метрик "},{"title":"Прогрев кэшей приложения","type":1,"pageTitle":"server","url":"docs/references/modules/server#прогрев-кэшей-приложения","content":"В модуль сервера автоматически подключен модуль прогрева кэшей. Подробную информацию по прогреву кэшей, можете почитать в документации cache-warmup "},{"title":"Специальные заголовки","type":1,"pageTitle":"server","url":"docs/references/modules/server#специальные-заголовки","content":"Информация о сборке и деплое# В модуле проставляются особые заголовки, которые помогают определить точную информацию о версии собранного приложения, коммите, ветке и т.п.: x-app-id - имя приложения указанного в createApp. Указывается в коде приложения.x-host - hostname сервера на котором запущено текущее приложение. Вычисляется в рантайме.x-app-version - версия запущенного приложения. Передаётся через переменную окружения APP_VERSION (внутри tinkoff проставляется в рамках стандартных пайплайнов gitlab ci).x-deploy-branch - ветка с которой был собран текущий образ приложения. Передаётся через переменную окружения DEPLOY_BRANCH (внутри tinkoff проставляется с помощью unic).x-deploy-commit - sha коммита с которого был собран текущий образ приложения. Передаётся через переменную окружения DEPLOY_COMMIT (внутри tinkoff проставляется с помощью unic).x-deploy-version - номер ревизии деплоя в k8s. Передаётся через переменную окружения DEPLOY_VERSION (внутри tinkoff проставляется с помощью unic).x-deploy-repository - ссылка на репозиторий приложения. Передаётся через переменную окружения DEPLOY_REPOSITORY (внутри tinkoff проставляется с помощью unic). Для всех заголовков выше, которые передаются через переменные окружения, чтобы они были доступны, необходимо чтобы внешняя инфраструктура передавала их при сборке и деплое образа приложения (внутри tinkoff это делается автоматически). "},{"title":"Отладка","type":1,"pageTitle":"server","url":"docs/references/modules/server#отладка","content":"Модуль использует логгеры с идентификаторами: server, server:static, server:webapp, server:node-debug:request "},{"title":"Экспортируемые токены","type":1,"pageTitle":"server","url":"docs/references/modules/server#экспортируемые-токены","content":"ссылка "},{"title":"Integration tests","type":0,"sectionRef":"#","url":"docs/references/test/test-integration","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"Integration tests","url":"docs/references/test/test-integration#подключение","content":"npm i --save-dev @tramvai/test-integration Скопировать "},{"title":"How To","type":1,"pageTitle":"Integration tests","url":"docs/references/test/test-integration#how-to","content":""},{"title":"Тестирование запросов к tramvai приложению без запуска в браузере (aka curl)","type":1,"pageTitle":"Integration tests","url":"docs/references/test/test-integration#тестирование-запросов-к-tramvai-приложению-без-запуска-в-браузере-aka-curl","content":"Для тестирования полноценных запросов к tramvai приложению используется библиотеки superagent и node-html-parser При вызове метода app.request отправляются запросы в приложение, и доступны все возможности superagent. При вызове метода app.render можно получить доступ к HTML разметке, которую вернул запрос в приложение. import { startCli } from '@tramvai/test-integration';import { initPuppeteer, wrapPuppeteerPage } from '@tramvai/test-puppeteer'; beforeAll(async () => { app = await startCli('bootstrap', { env: { SOME_ENV: 'test', }, });}, 80000); afterAll(() => { return app.close();}); it('request to main page return status 200', async () => { return app.request('/').expect(200);}); it('main page HTML snapshot', async () => { const parsed = await app.render('/'); const applicationInnerHtml = parsed.application; expect(parsed.application).toMatchInlineSnapshot();}); Скопировать "},{"title":"Тестирование приложения в браузере с помощью Puppeteer","type":1,"pageTitle":"Integration tests","url":"docs/references/test/test-integration#тестирование-приложения-в-браузере-с-помощью-puppeteer","content":"Для запуска полноценных браузерных тестов можно использовать библиотеку @tramvai/test-puppeteer "},{"title":"Использование @tinkoff/mocker в тестах","type":1,"pageTitle":"Integration tests","url":"docs/references/test/test-integration#использование-tinkoffmocker-в-тестах","content":"Для использования мокера в интеграционных тестах необходимо добавить модуль @tramvai/module-mocker в список модулей для приложения Затем мокер подтянет файловые моки как описано в доке к самому мокеру и есть возможность добавлять моки динамически в тестах: it('should work with mocker', async () => { await app.mocker.addMocks('CONFIG_API', { 'GET /test/': { status: 200, payload: { status: 'OK', response: 'smth', }, }, }); await app.request('/api/').expect(200); await app.papi.clearCache(); await app.mocker.removeMocks('CONFIG_API', ['GET /test/']); await app.request('/api/').expect(500);}); Скопировать "},{"title":"JSDom tests","type":0,"sectionRef":"#","url":"docs/references/test/test-jsdom","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"JSDom tests","url":"docs/references/test/test-jsdom#подключение","content":"npm i --save-dev @tramvai/test-jsdom Скопировать "},{"title":"Api","type":1,"pageTitle":"JSDom tests","url":"docs/references/test/test-jsdom#api","content":""},{"title":"waitRaf","type":1,"pageTitle":"JSDom tests","url":"docs/references/test/test-jsdom#waitraf","content":"Позволяет подождать выполнения requestAnimationFrame калбеков в тесте import { waitRaf } from '@tramvai/test-jsdom'; describe('test', () => { it('test', async () => { // some code with raf usage await waitRaf(); });}); Скопировать "},{"title":"Jest integration","type":0,"sectionRef":"#","url":"docs/references/test/test-integration-jest","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"Jest integration","url":"docs/references/test/test-integration-jest#подключение","content":"npm i --save-dev @tramvai/test-integration-jest Скопировать "},{"title":"How To","type":1,"pageTitle":"Jest integration","url":"docs/references/test/test-integration-jest#how-to","content":""},{"title":"Дебаг и разработка интеграционных тестов в Jest","type":1,"pageTitle":"Jest integration","url":"docs/references/test/test-integration-jest#дебаг-и-разработка-интеграционных-тестов-в-jest","content":"Используя наш пресет для jest можно запускать в watch режиме интеграционные тесты, при этом само приложение запустится только один раз и будет работать в фоне. Добавляем в jest.integration.config.js пресет @tramvai/test-integration-jest module.exports = { preset: '@tramvai/test-integration-jest',}; Скопировать Добавляем в package.json отдельный скрипт для запуска в watch-режиме: { \"scripts\": { \"test:integration\": \"jest -w=3 --config ./jest.integration.config.js\", \"test:integration:watch\": \"jest --runInBand --watch --config ./jest.integration.config.js\" }} Скопировать Запускаем интересующий тест через yarn test:integration:watch <path_to_test>. При этом можно будет зайти на стандартный урл http://localhost:3000 и посмотреть приложение во время работы. "},{"title":"Окружение для запуска Jest","type":1,"pageTitle":"Jest integration","url":"docs/references/test/test-integration-jest#окружение-для-запуска-jest","content":"Минимальный набор зависимостей для запуска jest: npm i --save-dev jest @types/jest jest-circus Скопировать "},{"title":"Puppeteer tests","type":0,"sectionRef":"#","url":"docs/references/test/test-puppeteer","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"Puppeteer tests","url":"docs/references/test/test-puppeteer#подключение","content":"npm i --save-dev @tramvai/test-puppeteer Скопировать "},{"title":"How To","type":1,"pageTitle":"Puppeteer tests","url":"docs/references/test/test-puppeteer#how-to","content":""},{"title":"Тестирование приложения в браузере с помощью Puppeteer","type":1,"pageTitle":"Puppeteer tests","url":"docs/references/test/test-puppeteer#тестирование-приложения-в-браузере-с-помощью-puppeteer","content":"Puppeteer запускает тесты в headless Chrome браузере, документация доступна на официальном сайте import { startCli } from '@tramvai/test-integration';import { initPuppeteer, wrapPuppeteerPage } from '@tramvai/test-puppeteer'; beforeAll(async () => { app = await startCli('bootstrap', { env: { SOME_ENV: 'test', }, });}, 80000); afterAll(() => { return app.close();}); it('puppeteer', async () => { const { browser } = await initPuppeteer(app.serverUrl); const page = await browser.newPage(); const wrapper = wrapPuppeteerPage(page); await page.goto(app.serverUrl); expect( await page.$eval('.application', (node) => (node as HTMLElement).innerText) ).toMatchInlineSnapshot(`\"Main Page click link\"`); await wrapper.router.navigateWithReload('./second'); expect( await page.$eval('.application', (node) => (node as HTMLElement).innerText) ).toMatchInlineSnapshot(`\"Second Page click link\"`); await browser.close();}); Скопировать "},{"title":"Mocks","type":0,"sectionRef":"#","url":"docs/references/test/test-mocks","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#подключение","content":"npm i --save-dev @tramvai/test-mocks Скопировать "},{"title":"Api","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#api","content":""},{"title":"STORE_TOKEN","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#store_token","content":"Creates mock instance for token STORE_TOKEN which used in app as a common storage for store Empty State# import { createMockStore } from '@tramvai/test-mocks'; const store = createMockStore();const state = store.getState(); store.dispatch('event'); Скопировать Initial State# import { createMockStore } from '@tramvai/test-mocks'; const initialState = { a: 1, b: 2 };const reducerC = createReducer('c', 3);const store = createMockStore({ stores: [reducerC], initialState }); const state = store.getState(); Скопировать  More examples import { createReducer, createEvent } from '@tramvai/state';import { createMockStore } from './store'; describe('test/unit/mocks/store', () => { it('should create empty store', () => { const store = createMockStore(); const spyGetState = jest.spyOn(store, 'getState'); expect(store.getState()).toEqual({}); expect(spyGetState).toHaveBeenCalled(); }); it('should update stores with dispatch', () => { const event = createEvent<string>('testEvent'); const reducer = createReducer('test', { a: 'test' }).on(event, (_, data) => { return { a: data, }; }); const store = createMockStore({ stores: [reducer] }); expect(store.getState()).toEqual({ test: { a: 'test' } }); store.dispatch(event('dispatched')); expect(store.getState()).toEqual({ test: { a: 'dispatched' } }); }); it('should create store by initialState', () => { const initialState = { a: 1, b: 2 }; const reducerA = createReducer('a', {}); const reducerB = createReducer('b', {}); const store = createMockStore({ stores: [reducerA, reducerB], initialState }); expect(store.getState()).toEqual(initialState); }); it('should create fake reducer stores for every key in initialState', () => { const initialState = { a: 1, b: 2 }; const reducerC = createReducer('c', 3); const store = createMockStore({ stores: [reducerC], initialState }); expect(store.getState()).toEqual({ a: 1, b: 2, c: 3, }); });}); Скопировать  "},{"title":"DI","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#di","content":"Creates mock instance of DI-container import { createMockDi } from '@tramvai/test-mocks'; const di = createMockDi(); const dep = di.get(SOME_TOKEN); Скопировать "},{"title":"Context","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#context","content":"Creates mock instance for CONTEXT_TOKEN import { createMockContext } from '@tramvai/test-mocks'; it('test', async () => { const context = createMockContext(); await context.dispatch('event'); await context.executeAction(action); const spyExecuteAction = jest.spyOn(context, 'executeAction'); expect(spyExecuteAction).toHaveBeenCalled();}); Скопировать  More examples import { createEvent, createReducer } from '@tramvai/state';import { createMockContext } from './context'; describe('test/unit/mocks/context', () => { it('should create consumer context', () => { const context = createMockContext(); expect(context.executeAction).toBeInstanceOf(Function); expect(context.getState).toBeInstanceOf(Function); expect(context.dispatch).toBeInstanceOf(Function); expect(context.getState()).toEqual({}); }); it('should dispatch data', async () => { const event = createEvent<string>('mockEvent'); const reducer = createReducer('a', 'data').on(event, (_, data) => data); const context = createMockContext({ stores: [reducer], }); const spyDispatch = jest.spyOn(context, 'dispatch'); await context.dispatch(event('mock1')); expect(spyDispatch).toHaveBeenCalledWith(event('mock1')); expect(context.getState()).toEqual({ a: 'mock1' }); });}); Скопировать  "},{"title":"Router","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#router","content":"Creates mock instance for @tinkoff/router import { createMockRouter } from '@tramvai/test-mocks'; describe('test', () => { it('should create router mock', () => { const router = createMockRouter(); expect(router.getCurrentRoute()).toMatchObject({ path: '/' }); expect(router.getCurrentUrl()).toMatchObject({ path: '/' }); }); it('should allow to specify currentRoute', () => { const router = createMockRouter({ currentRoute: { name: 'page', path: '/page/test/' } }); expect(router.getCurrentRoute()).toMatchObject({ path: '/page/test/' }); expect(router.getCurrentUrl()).toMatchObject({ path: '/page/test/' }); });}); Скопировать "},{"title":"React tests","type":0,"sectionRef":"#","url":"docs/references/test/test-react","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"React tests","url":"docs/references/test/test-react#подключение","content":"npm i --save-dev @tramvai/test-react Скопировать "},{"title":"How to","type":1,"pageTitle":"React tests","url":"docs/references/test/test-react#how-to","content":""},{"title":"Тестирование компонентов","type":1,"pageTitle":"React tests","url":"docs/references/test/test-react#тестирование-компонентов","content":"Для тестирования компонентов под капотом используется библиотека @testing-library/react /** * @jest-environment jsdom */import { testComponent } from '@tramvai/test-react'; describe('test', () => { it('render', async () => { const { render, context, act, fireEvent } = testComponent(<Cmp />); // проверить рендер компонента expect(render.getByTestId('test').textContent).toBe('Content'); // проверить рендер после обновления данных в сторе act(() => { context.dispatch(event('data')); }); // Взаимодействовать с компонентом fireEvent.click(render.getByText('Button')); });}); Скопировать  Больше примеров /** * @jest-environment jsdom */ import React from 'react';import { createReducer, createEvent, useStore } from '@tramvai/state';import { useDi } from '@tramvai/react';import { useRoute } from '@tinkoff/router';import { testComponent } from './testComponent'; describe('test/unit/react/testComponent', () => { it('should render simple component', async () => { const Cmp = () => { return ( <div> <div>Root</div> <div data-testid=\"test\">Content</div> </div> ); }; const { render } = testComponent(<Cmp />); expect(render.getByTestId('test').textContent).toBe('Content'); }); it('should rerender component on store updates', async () => { const event = createEvent<void>('evnt'); const store = createReducer('store', { a: 1 }).on(event, (state) => ({ a: state.a + 1 })); const Cmp = () => { const { a } = useStore(store); return ( <div> <span data-testid=\"content\">Counter: {a}</span> </div> ); }; const { context, render, act } = testComponent(<Cmp />, { stores: [store] }); expect(render.getByTestId('content').textContent).toBe('Counter: 1'); act(() => { context.dispatch(event()); }); expect(render.getByTestId('content').textContent).toBe('Counter: 2'); }); it('should work with di', async () => { const Cmp = () => { const { provider } = useDi({ provider: 'provider' }); return <span role=\"text\">{provider}</span>; }; const { render } = testComponent(<Cmp />, { providers: [ { provide: 'provider', useValue: 'test', }, ], }); expect(render.getByRole('text')).toMatchInlineSnapshot(` <span role=\"text\" > test </span> `); }); it('should work with routing', async () => { const Cmp = () => { const route = useRoute(); return ( <div> <div data-testid=\"route\"> <div data-testid=\"route-path\">{route.actualPath}</div> <div data-testid=\"route-name\">{route.name}</div> </div> </div> ); }; const { render } = testComponent(<Cmp />, { currentRoute: { name: 'test', path: '/test/' } }); expect(render.getByTestId('route-path').textContent).toBe('/test/'); expect(render.getByTestId('route-name').textContent).toBe('test'); });}); Скопировать  "},{"title":"Тестирование React-хуков","type":1,"pageTitle":"React tests","url":"docs/references/test/test-react#тестирование-react-хуков","content":"Для тестирования компонентов под капотом используется библиотека @testing-library/react-hooks /** * @jest-environment jsdom */import { testHooks } from '@tramvai/test-react'; describe('test', () => { it('hook', async () => { const { result, context, act } = testHook(() => useHook()); // проверить результат вызова хука expect(result.current).toBe('result'); // проверить результат после обновления данных в сторе act(() => { context.dispatch(event('data')); }); });}); Скопировать  Больше примеров /** * @jest-environment jsdom */ import { createReducer, createEvent, useStore } from '@tramvai/state';import { useDi } from '@tramvai/react';import { useRoute } from '@tinkoff/router';import { waitRaf } from '@tramvai/test-jsdom';import { testHook } from './testHook'; describe('test/unit/react/testHook', () => { it('should render simple hook', async () => { const useHook = jest.fn((p: string) => 'result'); const { result } = testHook(() => useHook('test')); expect(result.current).toBe('result'); expect(useHook).toHaveBeenCalledWith('test'); }); it('should rerender hook', async () => { const event = createEvent<void>('evnt'); const store = createReducer('store', { a: 1 }).on(event, (state) => ({ a: state.a + 1 })); const useHook = () => { return useStore(store).a; }; const { context, result, act } = testHook(() => useHook(), { stores: [store] }); expect(result.current).toBe(1); await act(async () => { await context.dispatch(event()); await waitRaf(); }); expect(result.current).toBe(2); }); it('should work with di', async () => { const useHook = () => { return useDi({ provider: 'provider' }).provider; }; const { result } = testHook(() => useHook(), { providers: [ { provide: 'provider', useValue: 'test', }, ], }); expect(result.current).toEqual('test'); }); it('should work with routing', async () => { const useHook = () => { const route = useRoute(); return [route.actualPath, route.name]; }; const { result } = testHook(() => useHook(), { currentRoute: { name: 'test', path: '/test/' }, }); expect(result.current).toEqual(['/test/', 'test']); });}); Скопировать  "},{"title":"Jest unit","type":0,"sectionRef":"#","url":"docs/references/test/test-unit-jest","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"Jest unit","url":"docs/references/test/test-unit-jest#installation","content":"Install package: npm i --save-dev @tramvai/test-unit-jest Скопировать Add new preset to your jest.config: module.exports = { preset: '@tramvai/test-unit-jest',}; Скопировать "},{"title":"Explanation","type":1,"pageTitle":"Jest unit","url":"docs/references/test/test-unit-jest#explanation","content":"This presets implements next settings: use jest-circus as testRunnerdefault testEnvironment is nodeuses babel-jest for transformationcss files are mapped with identity-obj-proxyimage files are mapped to empty string "},{"title":"How To","type":1,"pageTitle":"Jest unit","url":"docs/references/test/test-unit-jest#how-to","content":""},{"title":"Override testEnvironment for file","type":1,"pageTitle":"Jest unit","url":"docs/references/test/test-unit-jest#override-testenvironment-for-file","content":"Based on jest doc Just add at the start of test file following comment: /** * @jest-environment your-environment */ Скопировать "},{"title":"common-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/common-tokens","content":"","keywords":""},{"title":"Список action токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-action-токенов","content":" import { createToken } from '@tinkoff/dippy';import type { Action } from '@tramvai/core'; /** * @description * Регистр для хранения экшенов по типам */export const ACTION_REGISTRY_TOKEN = createToken<ActionsRegistry>('actionRegistry'); /** * @description * Сущность для исполнения экшенов */export const ACTION_EXECUTION_TOKEN = createToken<ActionExecution>('actionExecution'); /** * @description * Сушность для выполнения экшенов при переходах */export const ACTION_PAGE_RUNNER_TOKEN = createToken<ActionPageRunner>('actionPageRunner'); /** * @description * Позволяет добавлять условия на возможность исполнения экшенов */export const ACTION_CONDITIONALS = createToken<ActionCondition[]>('actionConditionals', { multi: true,}); export interface ActionsRegistry { add(type: string, actions: Action | Action[]): void; get(type: string, addingActions?: Action[]): Action[]; getGlobal(): Action[]; remove(type: string, actions?: Action | Action[]): void;} export interface ActionExecution { execution: Map<string, any[]>; run(action: Action, payload: any): Promise<any>;} export interface ActionPageRunner { runActions(actions: Action[], stopRunAtError?: (error: Error) => boolean): Promise<any>;} export interface ActionConditionChecker<State = any> { payload: any; parameters: any; conditions: Record<string, any>; type: 'global' | 'local'; allow(): void; setState(value: State): void; getState(): State; forbid(): void;} export type ActionCondition = { key: string; fn: (checker: ActionConditionChecker) => void;}; Скопировать  "},{"title":"Список bundle токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-bundle-токенов","content":" import { createToken } from '@tinkoff/dippy';import type { Bundle } from '@tramvai/core'; /** * @description * Хранилище бандлов. При получении бандла дополнительно добавляем экшены и компоненты из бандла в соответсвующие хранилища */export const BUNDLE_MANAGER_TOKEN = createToken<BundleManager>('bundleManager'); /** * @description * Токен для предоставления дополнительных бандлов в приложение. * Важно! Не перезаписывает существующие бандлы. */export const ADDITIONAL_BUNDLE_TOKEN = createToken<{ [key: string]: Bundle }>('additional bundle', { multi: true,}); export interface BundleManager { bundles: Record<string, any>; get(name: string, pageComponent: string): Promise<any>; has(name: string, pageComponent: string): boolean;} Скопировать  "},{"title":"Список componentRegistry токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-componentregistry-токенов","content":" import { createToken } from '@tinkoff/dippy'; /** * @description * React components storage. * Components in the repository are divided into groups, e.g. you can specify a bundle or a page component as a group key. * The entity also allows you to get static component parameters through the `getComponentParam` method (will not work with `lazy` components) */export const COMPONENT_REGISTRY_TOKEN = createToken<ComponentRegistry>('componentRegistry'); export interface ComponentRegistry { components: Record<string, any>; add(name: string, component: any, group?: string): void; get(name: string, group?: string): any; getComponentParam<T>(param: string, defaultValue: T, component: string, group?: string): T;} Скопировать  "},{"title":"Список env токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-env-токенов","content":" import { createToken } from '@tinkoff/dippy'; export interface EnvironmentManager { get(name: string): string; getInt(name: string, def: number): number; getAll(): Record<string, string>; update(result: Record<string, string>): void; clientUsed(): Record<string, string>; updateClientUsed(result: Record<string, string>): void;} /** * @description * Сущность `environmentManager` c помощью которого можно получить данные env переменных на сервере и клиенте */export const ENV_MANAGER_TOKEN = createToken<EnvironmentManager>('environmentManager'); /** * @description * Список токенов которые необходимы модулю или приложению. * Позднее все токены из этого списка будут доступны через `environmentManager` * Формат токена ENV_USED_TOKEN: - `key` - идентификатор env переменной. Под этим ключем будет доступно в `environmentManager` и будет получено из внешних источников - `value` - предустановленное значение для токена `key` с низким приоритетом - `optional` - является ли параметр опциональным для работы приложения. Если `true`, то приложение не будет падать, если не было передано значение - `validator` - функция валидации переданного значения. Если функция вернет текст, то выкинется ошибка - `dehydrate` - если передано `false`, то env параметр не передастся клиенту и можно будет получить значение только на серверной стороне * * @example ```tsx interface EnvParameter { key: string; value?: string; optional?: boolean; validator?: (value: string) => boolean | string; dehydrate?: boolean; } ``` */export interface EnvParameter { key: string; value?: string; optional?: boolean; validator?: (value: string) => boolean | string; dehydrate?: boolean;} export const ENV_USED_TOKEN = createToken<EnvParameter[]>('envUsed', { multi: true }); Скопировать  "},{"title":"Список context токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-context-токенов","content":" import type { Container } from '@tinkoff/dippy';import { createToken } from '@tinkoff/dippy';import type { ConsumerContext as BaseConsumerContext } from '@tramvai/types-actions-state-context';import type { PUBSUB_TOKEN } from './pubsub'; export { PlatformAction } from '@tramvai/types-actions-state-context'; /** * @description * Реализация контекста */export const CONTEXT_TOKEN = createToken<ConsumerContext>('context'); export interface ConsumerContext extends BaseConsumerContext { readonly di: Container; readonly pubsub: typeof PUBSUB_TOKEN; dehydrate: () => { dispatcher: { stores: Record<string, any>; }; };} Скопировать  "},{"title":"Список hook токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-hook-токенов","content":" import { createToken } from '@tinkoff/dippy'; /** * @description * В некоторых случаях нам нужно встроиться в функционал и это позволяют сделать хуки, [документация](https://tramvai.dev/docs/references/libs/hooks) */export const HOOK_TOKEN = createToken<Hooks>('hooks'); type Hook<TPayload> = (context: any, payload?: TPayload, options?: any) => TPayload; export interface Hooks { /** * Регистрация хуков */ registerHooks<TPayload>(name: string, list: Hook<TPayload>[] | Hook<TPayload>): void; /** * Запуск синхронных хуков, payload проходит через все хуки и будет результатом выполнения */ runHooks<TPayload>(name: string, context: any, payload?: TPayload, options?: any): TPayload; /** * Запуск ассихронных хуков */ runAsyncHooks<TPayload>(name: string, context: any, payload: TPayload, options?: any): TPayload; /** * Запуск проммис хуков */ runPromiseHooks( name: string, context: any, options?: any ): <TPayload>(payload: TPayload) => Promise<TPayload> | Promise<never>;} Скопировать  "},{"title":"Список logger токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-logger-токенов","content":" import type { Logger } from '@tinkoff/logger';import { createToken } from '@tinkoff/dippy'; /** * @description * Реализация логгера */export const LOGGER_TOKEN = createToken<LoggerFactory>('logger'); /** * @description * Дает возможность модифицировать логгер на этапе реализации */export const LOGGER_INIT_HOOK = createToken<LoggerInitHook>('loggerHook'); type Config = { name: string; [key: string]: any;}; export type LoggerFactory = Logger & ((configOrName: string | Config) => Logger); type LoggerInitHook = (logger: LoggerFactory) => void; export type { Logger, LogFn, LogArg } from '@tinkoff/logger'; Скопировать  "},{"title":"Список pubsub токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-pubsub-токенов","content":" import { createToken } from '@tinkoff/dippy'; /** * @description * Фабрика для создания инстанса pubsub */export const PUBSUB_FACTORY_TOKEN = createToken<() => PubSub>('pubsubFactory'); /** * @description * Глобальный инстанс pubsub который живет все время */export const PUBSUB_TOKEN = createToken<PubSub>('pubsub'); /** * @description * Инстанс pubsub который создается для каждого клиента */export const ROOT_PUBSUB_TOKEN = createToken<PubSub>('rootPubsub'); export interface PubSub { subscribe(event: string, fn: (payload?: any) => void): () => boolean; publish(event: string, ...args: unknown[]): any;} Скопировать  "},{"title":"Список requestManager токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-requestmanager-токенов","content":" import { createToken } from '@tinkoff/dippy';import type { Request } from 'express'; // Это костыль чтобы обойти инлайнинг Request'а и выставление наружу внутренних зависимостей express'аtype RequestExt = Request;/** * @description * Прямая ссылка на объект запроса */export const REQUEST = createToken<RequestExt>('request'); /** * @description * Сущность для работы с инстансами запроса (заголовки запросов, query-параметры, куки). * В основном используется только на сервере, но на клиенте есть обрезанный функционал, для упрощения реализации изоморфного приложения */export const REQUEST_MANAGER_TOKEN = createToken<RequestManager>('requestManager'); export interface RequestManager { getBody(): unknown; getUrl(): string; getMethod(): string; getCookie(key: string): string; getCookies(): Record<string, string>; getHeader(key: string): string | string[]; getHeaders(): Record<string, string | string[]>; getClientIp(): string; getHost(): string;} Скопировать  "},{"title":"Список responseManager токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-responsemanager-токенов","content":" import { createToken } from '@tinkoff/dippy';import type { Response } from 'express'; /** * @description * Прямая ссылка на объект ответа */export const RESPONSE = createToken<Response>('response'); /** * @description * Сущность для работы с инстансами ответа (заголовки ответа, куки, тело ответа). * В основном используется только на сервере, но на клиенте есть обрезанный функционал, для упрощения реализации изоморфного приложения */export const RESPONSE_MANAGER_TOKEN = createToken<ResponseManager>('responseManager'); export interface ResponseManager { getBody(): string; setBody(value: string): void; getHeader(key: string): string | string[]; getHeaders(): Record<string, string | string[]>; setHeader(key: string, value: string): void; getCookie(key: string): string; getCookies(): Record<string, string>; setCookie(key: string, value: string): void; getStatus(): number; setStatus(status: number): void;} Скопировать  "},{"title":"Список state токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-state-токенов","content":" import { createToken } from '@tinkoff/dippy';import type { DispatcherContext, Event, Middleware, Reducer } from '@tramvai/state'; /** * @description * Реализация dispatcher */export const DISPATCHER_TOKEN = createToken('dispatcher'); /** * @description * Реализция dispatcher context */export const DISPATCHER_CONTEXT_TOKEN = createToken<DispatcherContext<any>>('dispatcherContext'); /** * @description * Позволяет добавлять свои сторы созданные через createReducer */export const COMBINE_REDUCERS = createToken('combineReducers', { multi: true }); /** * @description * Общий стор приложения */export const STORE_TOKEN = createToken<Store>('store'); /** * @description * Позволяет задавать свои middlewares для работы со стейтом */export const STORE_MIDDLEWARE = createToken<Middleware>('storeMiddleware', { multi: true }); export interface Store<State = Record<string, any>> { dispatch: <Payload>(actionOrNameEvent: string | Event<Payload>, payload?: Payload) => Payload; subscribe(callback: (state: Record<string, any>) => void): () => void; subscribe<S>(reducer: Reducer<S>, callback: (state: S) => void): () => void; getState(): State; getState<S>(reducer: Reducer<S>): S;} Скопировать  "},{"title":"Unit tests","type":0,"sectionRef":"#","url":"docs/references/test/test-unit","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#installation","content":"npm i --save-dev @tramvai/test-unit Скопировать "},{"title":"How to","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#how-to","content":""},{"title":"Testing reducers","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#testing-reducers","content":"import { testReducer } from '@tramvai/test-unit'; it('test', async () => { const { dispatch, getState } = testReducer(reducer); expect(getState()).toEqual([]); dispatch(event(1)); expect(getState()).toEqual([1]);}); Скопировать  More examples import { createEvent, createReducer } from '@tramvai/state';import { testReducer } from './testReducer'; describe('test/unit/testReducer', () => { it('should handle state change', () => { const handle = jest.fn((state: number[], payload: number) => { return [...state, payload]; }); const event = createEvent<number>('push'); const reducer = createReducer('test', [] as number[]).on(event, handle); const { dispatch, getState } = testReducer(reducer); expect(getState()).toEqual([]); expect(handle).not.toHaveBeenCalled(); dispatch(event(1)); expect(getState()).toEqual([1]); expect(handle).toHaveBeenCalledWith([], 1); dispatch(event(3)); expect(getState()).toEqual([1, 3]); expect(handle).toHaveBeenCalledWith([1], 3); }); it('should handle several tests reducers at separate', () => { const event = createEvent<number>('push'); const reducer = createReducer('test', [] as number[]).on(event, (state, payload) => { return [...state, payload]; }); const test1 = testReducer(reducer); const test2 = testReducer(reducer); expect(test1.getState()).toEqual([]); expect(test2.getState()).toEqual([]); test1.dispatch(event(1)); expect(test1.getState()).toEqual([1]); expect(test2.getState()).toEqual([]); test2.dispatch(event(2)); expect(test1.getState()).toEqual([1]); expect(test2.getState()).toEqual([2]); });}); Скопировать  "},{"title":"Testing actions","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#testing-actions","content":"import { testAction } from '@tramvai/test-unit'; it('test', async () => { const { run } = testAction(action); expect(await run(true)).toBe('hello'); expect(await run(false)).toBe('world');}); Скопировать  More examples import { createAction } from '@tramvai/core';import { createEvent } from '@tramvai/state';import { createMockContext } from '@tramvai/test-mocks';import { testAction } from './testAction'; describe('test/unit/state/testAction', () => { it('should call action', async () => { const action = createAction({ name: 'test', fn: (context, payload: boolean) => { if (payload) { return 'hello'; } return 'world'; }, }); const { run } = testAction(action); expect(await run(true)).toBe('hello'); expect(await run(false)).toBe('world'); }); it('should call action with custom context', async () => { const context = createMockContext(); const event = createEvent<string>('test'); const action = createAction({ name: 'dispatch', fn: (ctx, payload: string) => { return ctx.dispatch(event(`action${payload}`)); }, }); const spyDispatch = jest.spyOn(context, 'dispatch'); const { run } = testAction(action, { context }); await run('ping'); expect(spyDispatch).toHaveBeenCalledWith({ payload: 'actionping', type: 'test' }); await run('pong'); expect(spyDispatch).toHaveBeenCalledWith({ payload: 'actionpong', type: 'test' }); }); it('should not require payload', async () => { const action = createAction({ name: 'no-payload', fn: () => { return 'empty'; }, }); const { run } = testAction(action); await expect(run()).resolves.toBe('empty'); });}); Скопировать  "},{"title":"Testing tramvai module","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#testing-tramvai-module","content":"Testing module in isolation# import { testModule } from '@tramvai/test-unit'; it('test', async () => { const { di, module, runLine } = testModule(TestModule); expect(module).toBeInstanceOf(TestModule); expect(di.get('testToken')).toEqual({ a: 1 }); // Run only specific command line in order to execute handlers for this line inside module await runLine(commandLineListTokens.generatePage);}); Скопировать Testing module in conjunction with other modules# import { createTestApp } from '@tramvai/test-unit'; it('test', async () => { const { app } = await createTestApp({ modules: [TestModule, DependentModule] }); // get tokens from di implemented by module expect(app.di.get('testToken')).toEqual({ a: 1 });}); Скопировать  More examples import { commandLineListTokens, DI_TOKEN, Module } from '@tramvai/core';import { Container } from '@tinkoff/dippy';import { testModule } from './testModule'; describe('test/unit/module/testModule`', () => { it('should test module', () => { const mockConstructor = jest.fn(); @Module({ providers: [ { provide: 'testToken', useFactory: () => { return { a: 1 }; }, }, ], deps: { di: DI_TOKEN, optToken: { token: 'optional_token', optional: true }, }, }) class TestModule { constructor(deps: any) { mockConstructor(deps); } } const { di, module } = testModule(TestModule); expect(module).toBeInstanceOf(TestModule); expect(mockConstructor).toHaveBeenCalledWith({ di: expect.any(Container), optToken: null }); expect(di.get('testToken')).toEqual({ a: 1 }); }); it('should test command line', async () => { const mock = jest.fn(); @Module({ providers: [ { provide: commandLineListTokens.generatePage, multi: true, useFactory: () => { return mock; }, }, ], }) class TestModule {} const { runLine } = testModule(TestModule); expect(() => runLine(commandLineListTokens.customerStart)).toThrow(); expect(mock).not.toHaveBeenCalled(); await runLine(commandLineListTokens.generatePage); expect(mock).toHaveBeenCalledWith(); });}); Скопировать  "},{"title":"Testing app","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#testing-app","content":"Testing app works only in node-environment. See jest docs import { testApp } from '@tramvai/test-unit'; it('test', async () => { const { request, render } = await testApp(app); const response = await request('/').expect(200).expect('X-App-Id', 'unit-app'); expect(response.text).toMatch('<html class=\"no-js\" lang=\"ru\">'); expect(response.text).toMatch('<div class=\"application\">rootPage</div>'); expect(response.text).toMatch('<script>var initialState ='); const rootPage = await render('/'); expect(rootPage.application).toEqual('rootPage'); const secondPage = await render('/second/'); expect(secondPage.application).toEqual('secondPage'); expect(secondPage.initialState).toEqual({ stores: expect.objectContaining({ environment: { FRONT_LOG_API: 'test', }, router: expect.objectContaining({ currentUrl: expect.objectContaining({ path: '\\\\u002Fsecond\\\\u002F', }), }), }), });}); Скопировать  More examples import { NoSpaRouterModule } from '@tramvai/module-router';import { commandLineListTokens, createApp, createBundle } from '@tramvai/core';import { CommonModule, ENV_USED_TOKEN } from '@tramvai/module-common';import { LogModule } from '@tramvai/module-log';import { RenderModule } from '@tramvai/module-render';import { ServerModule } from '@tramvai/module-server';import { testApp } from './testApp'; type ThenArg<T> = T extends PromiseLike<infer U> ? U : T; const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: () => 'rootPage', pageSecond: () => 'secondPage', },}); describe('test/unit/app/testApp', () => { let testEnv: ThenArg<ReturnType<typeof testApp>>; describe('normal', () => { beforeAll(async () => { const app = createApp({ name: 'unit-app', bundles: { mainDefault: () => Promise.resolve({ default: bundle }), }, modules: [ CommonModule, LogModule, RenderModule, ServerModule, NoSpaRouterModule.forRoot([ { name: 'root', path: '/', }, { name: 'other', path: '/second/', config: { pageComponent: 'pageSecond', }, }, ]), ], providers: [ { provide: ENV_USED_TOKEN, multi: true, useValue: { key: 'FRONT_LOG_API', value: 'test' }, }, ], }); testEnv = await testApp(app); }); afterAll(() => { return testEnv.close(); }); it('should request to server', async () => { const { request } = testEnv; const response = await request('/').expect(200).expect('X-App-Id', 'unit-app'); expect(response.text).toMatch('<html class=\"no-js\" lang=\"ru\">'); expect(response.text).toMatch('<div class=\"application\">rootPage</div>'); expect(response.text).toMatch('<script>var initialState ='); }); it('should return render of page', async () => { const { render } = testEnv; const rootPage = await render('/'); expect(rootPage.application).toEqual('rootPage'); const secondPage = await render('/second/'); expect(secondPage.application).toEqual('secondPage'); expect(secondPage.initialState).toEqual({ stores: expect.objectContaining({ environment: { FRONT_LOG_API: 'test', }, router: expect.objectContaining({ currentUrl: expect.objectContaining({ path: '/second/', }), }), }), }); }); it('should return mocker instance', async () => { const { mocker } = testEnv; expect(mocker).toBeDefined(); }); }); describe('fail', () => { beforeAll(async () => { const app = createApp({ name: 'unit-app', bundles: { mainDefault: () => Promise.resolve({ default: bundle }), }, modules: [CommonModule, LogModule, RenderModule, ServerModule], providers: [ { provide: commandLineListTokens.resolveUserDeps, multi: true, useFactory: ({ wrong }) => { return wrong.test(); }, deps: { wrong: '_unknown_provider', }, }, ], }); testEnv = await testApp(app); }); afterAll(() => { return testEnv.close(); }); it('render with 500 status should fail', async () => { const { render } = testEnv; await expect(render('/')).rejects.toThrowError( 'Error: Token not found _unknown_provider at resolve_user_deps' ); }); });}); Скопировать  "},{"title":"Adding providers to DI","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#adding-providers-to-di","content":"Most of the helpers accepts option providers which allows to redefine already existing providers or add new. For example, passing providers to helper testAction allows to access this provider inside action itself: import { createAction } from '@tramvai/core';import { testAction } from '@tramvai/test-unit'; const action = createAction({ name: 'action', fn: (_, __, { test }) => { console.log(test); // token value }, deps: { test: 'token name', },}); it('test', async () => { const { run } = testAction(action, { providers: [ { provide: 'token name', useValue: 'token value', }, ], });}); Скопировать "},{"title":"Create app only for testing","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#create-app-only-for-testing","content":"import { createTestApp } from '@tramvai/test-unit'; it('test', async () => { const { app } = await createTestApp({ modules: [TestModule, DependentModule] }); // get tokens from di implemented by module expect(app.di.get('testToken')).toEqual({ a: 1 });}); Скопировать  More examples import http from 'http';import { ENV_MANAGER_TOKEN } from '@tramvai/tokens-common';import { SERVER_TOKEN } from '@tramvai/tokens-server';import { CommonModule } from '@tramvai/module-common';import { createTestApp } from './createTestApp'; describe('test/unit/app/createTestApp', () => { it('should return app', async () => { const { app, close } = await createTestApp(); const envManager = app.di.get(ENV_MANAGER_TOKEN); expect(envManager.get('FRONT_LOG_API')).toBe('test'); expect(envManager.get('TEST_ENV')).toBeUndefined(); expect(app.di.get(SERVER_TOKEN)).toBeInstanceOf(http.Server); return close(); }); it('should specify env', async () => { const { app, close } = await createTestApp({ env: { TEST_ENV: '1234', }, }); const envManager = app.di.get(ENV_MANAGER_TOKEN); expect(envManager.get('FRONT_LOG_API')).toBe('test'); expect(envManager.get('TEST_ENV')).toBe('1234'); return close(); }); it('should ignore default modules', async () => { const { app } = await createTestApp({ excludeDefaultModules: true, modules: [CommonModule], }); expect(() => app.di.get(SERVER_TOKEN)).toThrow('Token not found'); }); it('should return mocker instance', async () => { const { mocker, close } = await createTestApp(); expect(mocker).toBeDefined(); return close(); });}); Скопировать  "},{"title":"http-client-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/http-client-tokens","content":"","keywords":""},{"title":"Список токенов","type":1,"pageTitle":"http-client-tokens","url":"docs/references/tokens/http-client-tokens#список-токенов","content":" import { createToken } from '@tinkoff/dippy';import type { ApiService, HttpClient } from '@tramvai/http-client';import type { TinkoffRequestOptions } from '@tramvai/tinkoff-request-http-client-adapter'; export type HttpClientFactoryOptions = TinkoffRequestOptions & { name: string }; /** * @description * Фабрика HTTP клиентов с минимальными базовыми настройками */export const HTTP_CLIENT_FACTORY = createToken<(options: HttpClientFactoryOptions) => HttpClient>( 'HTTP_CLIENT_FACTORY'); /** * @description * Универсальный HTTP клиент для произвольных запросов */export const HTTP_CLIENT = createToken<HttpClient>('HTTP_CLIENT'); /** * @description * Список headers, которые проксируются из запроса в приложение во все запросы в API */export const API_CLIENT_PASS_HEADERS = createToken<string[]>('apiClientPassHeaders', { multi: true,}); /** * @description * Работа с внутренним апи текущего сервера. * Использует значение `APP_INFO_TOKEN` из di для определения адреса для запросов */export const PAPI_SERVICE = createToken<ApiService>('papi service'); Скопировать  "},{"title":"metrics-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/metrics-tokens","content":"","keywords":""},{"title":"Список токенов","type":1,"pageTitle":"metrics-tokens","url":"docs/references/tokens/metrics-tokens#список-токенов","content":" import { createToken } from '@tinkoff/dippy';import type { Counter, CounterConfiguration, Gauge, GaugeConfiguration, Histogram, HistogramConfiguration, Summary, SummaryConfiguration,} from 'prom-client'; interface Metrics { counter<T extends string = string>(opt: CounterConfiguration<T>): Counter<T>; gauge<T extends string = string>(opt: GaugeConfiguration<T>): Gauge<T>; histogram<T extends string = string>(opt: HistogramConfiguration<T>): Histogram<T>; summary<T extends string = string>(opt: SummaryConfiguration<T>): Summary<T>;} export { Counter, Gauge, Histogram, Summary, Metrics }; /** * @description * Реализация модуля метрик */export const METRICS_MODULE_TOKEN = createToken<Metrics>('metricsModule'); export interface MetricsServicesRegistryInterface { register(url: string, serviceName: string): void; registerEnv(env: Record<string, unknown>): void; getServiceName(url: string): string | void;} /** * @description * Утилита для того чтобы указать модулю метрик какое имя сервиса подставлять для разных запросов */export const METRICS_SERVICES_REGISTRY_TOKEN = createToken<MetricsServicesRegistryInterface>( 'metricsServicesRegistry'); /** * @description * Токен для регистрации counter-метрик которые затем можно будет инктерементировать через POST * запрос papi роута */export const REGISTER_INSTANT_METRIC_TOKEN = createToken<[string, Counter<string>]>( 'registerInstantMetric'); Скопировать  "},{"title":"router-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/router-tokens","content":"","keywords":""},{"title":"Список токенов","type":1,"pageTitle":"router-tokens","url":"docs/references/tokens/router-tokens#список-токенов","content":" import { createToken } from '@tinkoff/dippy';import type { AbstractRouter, NavigationGuard, Route, Navigation, NavigationRoute, NavigateOptions, UpdateCurrentRouteOptions, HistoryOptions,} from '@tinkoff/router'; /** * @description * Token to access the router instance */export const ROUTER_TOKEN = createToken<AbstractRouter>('router router'); /** * @description * Token for defining static routes */export const ROUTES_TOKEN = createToken<Route>('router routes', { multi: true });/** * @description * Token for providing guard handlers for page transitions */export const ROUTER_GUARD_TOKEN = createToken<NavigationGuard>('router guard', { multi: true }); /** * @description * Encapsulates the logic of working with the router - contains methods for getting the configuration of the route and performing navigation */export const PAGE_SERVICE_TOKEN = createToken<PageService>('router pageService'); /** * @description * Hook to resolve route dynamically */export const ROUTE_RESOLVE_TOKEN = createToken<RouteResolve>('router routeResolve'); /** * @description * Hook to transform route config */export const ROUTE_TRANSFORM_TOKEN = createToken<RouteTransform>('router routeTransform', { multi: true,}); /** * @description * Flag for SPA-transitions, indicating that actions must be executed before or after a route update in the stor */export const ROUTER_SPA_ACTIONS_RUN_MODE_TOKEN = createToken<'before' | 'after'>( 'router spaRunMode'); export interface PageService { getCurrentRoute(): NavigationRoute; getCurrentUrl(): ReturnType<AbstractRouter['getCurrentUrl']>; getConfig(): Route['config']; getContent(): Record<string, any>; getMeta(): { seo: Record<string, string>; analytics: Record<string, string> }; navigate(options: string | NavigateOptions): Promise<void>; updateCurrentRoute(options: UpdateCurrentRouteOptions): Promise<void>; back(options?: HistoryOptions): Promise<void>; forward(): Promise<void>; go(to: number, options?: HistoryOptions): Promise<void>; addComponent(name: string, component: any): void; getComponent(name: string): any;} export type RouteResolve = (navigation: Navigation) => Promise<Route | void>; export type RouteTransform = (route: Route) => Route; Скопировать  "},{"title":"render-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/render-tokens","content":"","keywords":""},{"title":"Список токенов","type":1,"pageTitle":"render-tokens","url":"docs/references/tokens/render-tokens#список-токенов","content":" import type { ReactElement, ComponentType } from 'react';import { createToken } from '@tinkoff/dippy';import { StorageRecord } from '@tinkoff/htmlpagebuilder';import * as ResourceSlot from './slots'; /** * @description * Позволяет добавлять ресурсы в определенные слоты при рендере приложения. * Используется только на сервере, эквивалентно использованию RESOURCES_REGISTRY. * * [Пример использования](https://tramvai.dev/docs/how-to/render-add-resources) */export const RENDER_SLOTS = createToken<PageResource | PageResource[]>('RENDER_SLOTS', { multi: true,}); /** * @description * Позволяет переопределять атрибуты для html, body и контейнера приложения. Имейте в виду, что: - это именно html атрибуты, а не реакт (т.е. должен быть не className, а class). - новые атрибуты затирают старые - поддерживаются только текстовые значения * * @example ```tsx { provide: HTML_ATTRS, useValue: { target: 'body', attrs: { class: 'custom-class', }, }, multi: true, }, ``` */export const HTML_ATTRS = createToken<HtmlAttrs>('HTML_ATTRS', { multi: true }); /** * @description * Позволяет повесить Node-style колбэк на событие рендеринга в браузере. * Первым аргументом отправляет ошибку, если таковая имелась */export const RENDERER_CALLBACK = createToken<((e?: Error) => void)[]>('RENDERER_CALLBACK', { multi: true,}); /** * @description * Позволяет задать функцию-обертку для рендера и переопределить параметры или результат рендера */export const CUSTOM_RENDER = createToken('CUSTOM_RENDER'); /** * @description * Регистр ресурсов - используется на сервере для регистрации дополнительных ресурсов (скриптов, стилей, верстки) которые должны быть вставлены в итоговую html-страницу */export const RESOURCES_REGISTRY = createToken<ResourcesRegistry>('resourcesRegistry'); /** * @description * Строка отвечающая за проверку требуется ли загрузить файл полифиллов в конкретном браузере. * Полифиллы грузятся всегда для браузеров без поддержки модулей, а в браузерах с поддержкой будет выполняться данная проверка * (по умолчанию проверяет на Promise.prototype.finally и реализацию URL, URLSearchParams) * * [Документация по полифилам](https://tramvai.dev/docs/how-to/how-to-enable-polyfills) */export const POLYFILL_CONDITION = createToken<string>('POLYFILL_CONDITION'); /** * @description * Позволяет включить разные режимы работы React приложения - `strict`, `blocking`, `concurrent`, по умолчанию используется `legacy` - обычный режим работы * * [Подробнее в документации к module-render](https://tramvai.dev/docs/references/modules/render) */export const RENDER_MODE = createToken<RenderMode>('RENDER_MODE'); /** * @description * Позволяет сделать обертку для текущего провайдера. * Позволяет добавлять, например, свои React.Context.Provider для разного функционала */export const EXTEND_RENDER = createToken<Array<(current: ReactElement) => ReactElement>>( 'EXTEND_RENDER', { multi: true, }); /** * @description * Токен инициализации лайаута по умолчанию для страниц */export const DEFAULT_LAYOUT_COMPONENT = createToken('defaultLayoutComponent'); /** * @description * Токен инициализации шапки по умолчанию для страниц */export const DEFAULT_HEADER_COMPONENT = createToken('defaultHeaderComponent'); /** * @description * Токен инициализации футера по умолчанию для страниц */export const DEFAULT_FOOTER_COMPONENT = createToken('defaultFooterComponent'); /** * @description * Токен для кастомизации дефолтного лейаута страниц */export const LAYOUT_OPTIONS = createToken<LayoutOptions[]>('layoutOptions', { multi: true }); type ReactComponent = ComponentType<any>; type Wrapper = (WrappedComponent: ReactComponent) => ReactComponent; export interface LayoutOptions { components?: Record<string, ReactComponent>; wrappers?: Record<string, Wrapper | Wrapper[]>;} export interface PageResource { type: keyof typeof StorageRecord; slot: typeof ResourceSlot[keyof typeof ResourceSlot]; payload: string | null; attrs?: Record<string, string | null>;} export interface ResourcesRegistry { register(resource: PageResource | PageResource[]): void; getPageResources(): PageResource[];} export type HtmlAttrs = { target: 'html' | 'body' | 'app'; attrs: { [name: string]: string | boolean | Record<string, any> | number };}; export type RenderMode = 'legacy' | 'strict' | 'blocking' | 'concurrent'; type ResourceInlineOptions = { threshold: number; types: (keyof typeof StorageRecord)[];}; /** * @description * Настройки инлайнинга ресурсов в HTML-страницу * * threshold Максимальное значение (в байтах) размера файла, до которого он инлайнится в HTML-страницу * * types Типы ресурсов, которые нужно инлайнить */export const RESOURCE_INLINE_OPTIONS = createToken<ResourceInlineOptions>( 'resourceInlineThreshold'); export { ResourceSlot };export { StorageRecord as ResourceType }; Скопировать  "},{"title":"Список доступных слотов для ассетов","type":1,"pageTitle":"render-tokens","url":"docs/references/tokens/render-tokens#список-доступных-слотов-для-ассетов","content":" export const HEAD_META = 'head:meta';export const HEAD_PERFORMANCE = 'head:performance';export const HEAD_CORE_STYLES = 'head:core-styles';export const HEAD_POLYFILLS = 'head:polyfills';export const HEAD_CORE_SCRIPTS = 'head:core-scripts';export const HEAD_DYNAMIC_SCRIPTS = 'head:dynamic-scripts';export const HEAD_ANALYTICS = 'head:analytics';export const HEAD_ICONS = 'head:icons';export const BODY_START = 'body:start';export const REACT_RENDER = 'react:render';export const BODY_END = 'body:end';export const BODY_TAIL_ANALYTICS = 'body:tail:analytics';export const BODY_TAIL = 'body:tail'; Скопировать  "},{"title":"@tramvai/build","type":0,"sectionRef":"#","url":"docs/references/tools/build","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#подключение","content":"Необходимо установить @tramvai/build: yarn add @tramvai/build Скопировать Заполнить необходимые поля в package.json: { \"main\": \"lib/index.js\", \"typings\": \"src/index.ts\"} Скопировать \"main\": \"lib/index.js\" на основе этого поля вычисляется, что точка входа для сборки должна называться \"src/index.ts\" \"typings\": \"src/index.ts\" желательно должен указывать на точку входа, это удобно для монореп, т.к. не требует сборки пакета для его использования в других пакетах. После сборки для публикации это поле заменится на файл с собранными типами, в данном случае - \"typings\": \"lib/index.d.ts\" И в tsconfig.json: { \"compilerOptions\": { \"moduleResolution\": \"node\", \"target\": \"ES5\", \"module\": \"CommonJS\", \"declaration\": true, \"importHelpers\": true, \"skipLibCheck\": true, \"rootDir\": \"./src\", \"outDir\": \"./lib\", \"declarationDir\": \"./lib\" }, \"include\": [ \"./src\" ]} Скопировать Добавить в dependencies библиотеку tslib: yarn add tslib Скопировать Собрать пакет через команду tramvai-build: tramvai-build --forPublish Скопировать с флагом --forPublish tramvai-build заменяет некоторые поля в package.json на необходимые для корректного использования библиотеки в приложениях, например \"typings\": \"src/index.ts\" заменяется на \"typings\": \"lib/index.d.ts\" "},{"title":"Explanation","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#explanation","content":"Основное предназначение библиотеки - эффективная production сборка TypeScript пакетов с помощью rollup, также поддерживается watch режим. Такие сборки, особенно при наличии большого количества пакетов в монорепозитории, могут занимать слишком много времени, и не подойдут для эффективной и удобной разработки. По этой причине, для development окружения рекомендуется использовать tsc, с фичами project references и incremental build. Рекомендуемый и автоматически генерируемый package.json для @tramvai/build позволяет приложениям использовать пакеты собранные и через tsc, и через @tramvai/build, без дополнительных действий. Все собранные бандлы содержат код стандарта ES2019, ожидается то их будет резолвить бандлер (Webpac, etc.), для которого уже настроена транспиляция через babel пакетов в node_modules, написанных на современном JS, в код стандарта ES5. "},{"title":"Бандл под NodeJS в CommonJS формате","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#бандл-под-nodejs-в-commonjs-формате","content":"NodeJS до 12 версии не поддерживает ES модули, либо поддерживает их под специальным флагом.@tramvai/build генерирует бандл с кодом стандарта ES2019, в формате CommonJS, автоматически, название итогового бандла берется из поля main в package.json, например lib/index.js. При сборке нашего пакета в приложении через webpack с опцией target: 'node', этот бандл скорее всего не будет использован, т.к. в приоритете будет бандл из поля module. Ожидается, что этот бандл, из поля \"main\", будет резолвить только NodeJS, а бандлеры (Webpac, etc.) предпочтут бандл из поля \"module\" "},{"title":"Бандл под бандлеры (Webpack, etc.) в формате ES modules","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#бандл-под-бандлеры-webpack-etc-в-формате-es-modules","content":"Современные бандлеры (Webpac, etc.) поддерживают ES модули, и нестандартное поле \"module\" в package.json.@tramvai/build генерирует бандл с кодом стандарта ES2019, в формате ES modules, автоматически, название итогового бандла вычисляется из поля main в package.json, и добавляется суффикс .es например lib/index.es.js. Если сборка произведена через tramvai-build --forPublish, в package.json добавится поле \"module\": \"lib/index.es.js\". При сборке нашего пакета в приложении через webpack с опцией target: 'node', бандл из поля module будет иметь больший приоритет, чем поле main. Генерируется код стандарта ES2019, т.к. ожидается, что этот бандл, из поля \"module\", будут резолвить бандлер (Webpac, etc.), для которого уже настроена транспиляция через babel пакетов в node_modules, написанных на современном JS, в код стандарта ES5. Почему мы не советуем оставлять ES2019 код? Оказалось, что код в ES5 работает заметно быстрее на NodeJS сервере. При этом, размер итогового бандла на сервере не имеет значения. "},{"title":"Бандл для браузеров","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#бандл-для-браузеров","content":"Современные бандлеры (Webpac, etc.) поддерживают ES модули, и нестандартное поле \"browser\" в package.json. При наличии поля browser в package.json, @tramvai/build генерирует бандл с кодом стандарта ES2019, в формате ES modules. Если поле browser в package.json является строкой, то из этого файла вычисляется точка входа для browser бандла, и его новое название. Например, при \"browser\": \"lib/browser.js\", точкой входа будет src/browser.ts, а бандл будет называться lib/browser.js. Иначе, если поле browser является объектом и сборка произведена через tramvai-build --forPublish, название вычисляется из поля main в package.json, и добавляется суффикс .browser, например lib/index.browser.js. Далее в поле browser добавится свойство, указывающее сборщикам приложений, какой бандл резолвить для браузерной сборки, вместо поля module: { \"browser\": { ..., \"./index.es.js\": \"./index.browser.js\" }} Скопировать Спецификация поля browserГенерируется код стандарта ES2019, т.к. ожидается, что этот бандл, из поля \"browser\", будут резолвить бандлер (Webpac, etc.), для которого уже настроена транспиляция через babel пакетов в node_modules, написанных на современном JS, в код согласно актуальному browserslist конфигу. При сборке нашего пакета в приложении через webpack с опцией target: 'web', бандл из поля browser будет иметь больший приоритет, чем поле module. "},{"title":"Копирование статических файлов","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#копирование-статических-файлов","content":"При каждом билде автоматически копируются все файлы, кроме JS/TS скриптов и JSON, например CSS, изображения, шрифты, и сохраняются исходные пути до файлов (src/css/style.css -> lib/css/style.css). Копирование можно отключить, собирая пакет с флагом copyStaticAssets: tramvai-build --copyStaticAssets false Скопировать "},{"title":"Сборка и копирование миграций","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#сборка-и-копирование-миграций","content":"При наличии файлов в папке migrations, они считаются исходниками миграций. Эти файлы компилируются в .js и копируются в папку __migrations__. "},{"title":"CLI","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#cli","content":""},{"title":"Разовая сборка","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#разовая-сборка","content":"tramvai-build Скопировать "},{"title":"Сборка в watch режиме","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#сборка-в-watch-режиме","content":"tramvai-build --watch Скопировать "},{"title":"Копирование статических файлов","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#копирование-статических-файлов-1","content":"tramvai-copy Скопировать "},{"title":"Доступные флаги","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#доступные-флаги","content":"tramvai-build --help Скопировать "},{"title":"JavaScript API","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#javascript-api","content":""},{"title":"TramvaiBuild","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#tramvaibuild","content":"TramvaiBuild позволяет конфигурировать утилиту для дальнейшего использования. import { TramvaiBuild } from '@tramvai/build'; new TramvaiBuild(options); Скопировать Доступные опции:  export type Options = { sourceDir?: string; watchMode?: boolean; copyStaticAssets?: boolean; forPublish?: boolean;}; Скопировать  "},{"title":"Сборка","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#сборка","content":"Метод TramvaiBuild.start позволяет собрать пакет, разово или в watch режиме, в зависимости от конфигурации экземпляра TramvaiBuild: import { TramvaiBuild } from '@tramvai/build'; new TramvaiBuild(options).start(); Скопировать "},{"title":"Копирование статических файлов","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#копирование-статических-файлов-2","content":"Метод TramvaiBuild.copy позволяет разово копировать статические файлы в output директорию: import { TramvaiBuild } from '@tramvai/build'; new TramvaiBuild(options).copy(); Скопировать "},{"title":"How to","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#how-to","content":""},{"title":"Как собрать отдельный бандл для браузерной сборки?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-собрать-отдельный-бандл-для-браузерной-сборки","content":"Допустим, у нас есть две точки входа, серверная - src/server.ts, и клиентская - src/browser.ts. В таком случае, необходимо настроить поле browser в package.json таким образом: { \"main\": \"lib/server.js\", \"browser\": \"lib/browser.js\"} Скопировать После сборки для публикации мы получим такой package.json: { \"main\": \"lib/server.js\", \"browser\": \"lib/browser.js\", \"typings\": \"lib/server.d.ts\", \"module\": \"lib/server.es.js\"} Скопировать "},{"title":"Как заменить отдельный модуль для браузерной сборки?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-заменить-отдельный-модуль-для-браузерной-сборки","content":"Допустим, у нас есть одна точка входа - src/index.ts, а модуль src/external.ts мы хотим заменить на src/external.browser.ts. В таком случае, необходимо настроить поле browser в package.json таким образом: { \"main\": \"lib/index.js\", \"browser\": { \"./lib/external.js\": \"./lib/external.browser.js\" }} Скопировать После сборки для публикации мы получим такой package.json: { \"main\": \"lib/index.js\", \"browser\": { \"./lib/external.js\": \"./lib/external.browser.js\", \"./lib/index.es.js\": \"./lib/index.browser.js\", }, \"typings\": \"lib/index.d.ts\", \"module\": \"lib/index.es.js\"} Скопировать "},{"title":"Как собирать все пакеты в монорепе при разработке, в watch режиме?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-собирать-все-пакеты-в-монорепе-при-разработке-в-watch-режиме","content":"@TODO + ссылка на @tinkoff/fix-ts-references "},{"title":"Как сделать чтобы модуль импортировался только при определенных условиях, а иначе игнорировался при сборке?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-сделать-чтобы-модуль-импортировался-только-при-определенных-условиях-а-иначе-игнорировался-при-сборке","content":"Вместо статичных импортов можно использовать динамический import или require. В этом случае, импортированный модуль будет собран в отдельный чанк и будет добавлен в сборку вебпаком при необходимости, причем при использовании динамического импорта также будет создан отдельный чанк после сборки вебпака, при использовании require отдельного чанка не будет. let func = noop; if (process.env.NODE_ENV !== 'production') { func = require('./realFunc').func;} export { func }; Скопировать "},{"title":"Как использовать json файлы в пакете?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-использовать-json-файлы-в-пакете","content":"По умолчанию в корневом tsconfig.json включена опция resolveJsonModule которая позволяет импортировать json-файлы также как и обычный код используя import, причем всё будет работать с типизацией и tree-shaking при публикации пакета. Для того чтобы ts не ругался на такие импорты необходимо в tsconfig.json пакета добавить новое вхождение в поле includes: { \"includes\": [\"./src\", \"./src/**/*.json\"]} Скопировать "},{"title":"Как использовать файлы других расширений в пакете (например .css)?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-использовать-файлы-других-расширений-в-пакете-например-css","content":"Такие файлы не используются в сборке или явно в коде, и ts такие файлы игнорирует. Для правильной работы пакета потребуется дополнительная настройка, а именно прописать в package.json пакета скрипт tramvai-copy: { \"scripts\": { \"copy-static-assets\": \"tramvai-copy\" }} Скопировать Цель этого скрипта в копировании файлов не относящихся к исходному коду в директорию сборки. Само копирование происходит либо при установке зависимостей в корне репозитория, либо при непосредственной публикации пакетов. Так как в некоторых кейсах по какой-либо причине директория сборки может быть удалена то возможно потребуется перезапуск команды tramvai-copy для данных пакетов. "},{"title":"Как использовать css-модули в пакете?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-использовать-css-модули-в-пакете","content":"Для того, чтобы typescript не ругался на импорты css-модулей, в папку src внутри пакета нужно добавить файл typings.d.ts с определением: declare module '*.css' { const value: any; export default value;} Скопировать Для копирования css во время dev-сборки нужно изменить команду: \"watch\": \"tramvai-copy && tsc -w\" Скопировать Такие импорты никак не преобразуются, для правильной сборки нужно использовать @tramvai/cli или другие решения для css-модулей. При сборке корректность импортов не проверяется, так что проверяйте пакет перед публикацией. "},{"title":"server-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/server-tokens","content":"","keywords":""},{"title":"Список токенов","type":1,"pageTitle":"server-tokens","url":"docs/references/tokens/server-tokens#список-токенов","content":" import type { Server } from 'http';import type { Application } from 'express';import { createToken } from '@tinkoff/dippy';import type { Papi } from '@tramvai/papi'; /** * @description * Позволяет задавать базовый урл для публичных папи обработчиков. По умолчанию это `/[appName]/papi` */export const SERVER_MODULE_PAPI_PUBLIC_URL = createToken<string>('serverModulePapiPublicUrl'); /** * @description * Позволяет задавать базовый урл для приватных папи обработчиков. По умолчанию это `/[appName]/private/papi` */export const SERVER_MODULE_PAPI_PRIVATE_URL = createToken<string>('serverModulePapiPrivateUrl'); /** * @description * Позволяет задавать приватные роуты для papi */export const SERVER_MODULE_PAPI_PRIVATE_ROUTE = createToken<Papi>('serverModulePapiPrivateRoute', { multi: true,}); /** * @description * Позволяет задавать публичные роуты для papi */export const SERVER_MODULE_PAPI_PUBLIC_ROUTE = createToken<Papi>('serverModulePapiPublicRoute', { multi: true,}); /** * @description * Настройки для работы статики */export const SERVER_MODULE_STATICS_OPTIONS = createToken<ServerModuleStaticsOptions>( 'serverModuleStaticsOptions'); /** * @description * Инстанс node-сервера `http.Server`. * Позволяет добавлять логику для расширения работы сервера (обработка ошибок, настройки соединений) * * @example ```tsx { provide: commandLineListTokens.init, multi: true, useFactory: ({ server }) => { return function serverListen() { createTerminus(server, {}); }; }, deps: { SERVER_TOKEN, }, }, ``` */export const SERVER_TOKEN = createToken<Server>('server'); /** * @description * Инстанс текущего приложения. По умолчанию предполагается что это `express` приложения. * Позволяет настраивать обработку запросов и добавлять свои роуты * * @example ```tsx { provide: SERVER_TOKEN, useFactory: ({ webApp }) => { const server = https.createServer(); server.on('request', webApp); return server; }, deps: { WEB_APP_TOKEN, } } ``` */export const WEB_APP_TOKEN = createToken<Application>('webApp'); /** * @description * Подписка на инициализацию веб-приложения. Вызывается перед заданием любых стандартных обработчиков * * @example ```tsx { provide: WEB_APP_BEFORE_INIT_TOKEN, multi: true, useValue: (app) => { app.use(cookieParser()) } } ``` */export const WEB_APP_BEFORE_INIT_TOKEN = createToken<APP_INIT_HANDLER>('webAppBeforeInit', { multi: true,}); /** * @description * Подписка на инициализацию веб-приложения. * Вызывается после глобальных обработчиков запросов, но до обработчика для рендера страниц приложения * * @example ```tsx { provide: WEB_APP_INIT_TOKEN, multi: true, useValue: (app) => { app.use('mm.css', proxyCss()); app.use('mm.js', proxyClientJs()); } } ``` */export const WEB_APP_INIT_TOKEN = createToken<APP_INIT_HANDLER>('webAppInit', { multi: true }); /** * @description * Подписка на инициализацию веб-приложения. Вызывается после задания всех других обработчиков * * @example ```tsx { provide: WEB_APP_AFTER_INIT_TOKEN, multi: true, useValue: (app) => { app.use(logMiddleware()) } } ``` */export const WEB_APP_AFTER_INIT_TOKEN = createToken<APP_INIT_HANDLER>('webAppAfterInit', { multi: true,}); /** * @description * Добавляет ресурсы для проксирования запросов в приложение через `http-proxy-middleware` */export const PROXY_CONFIG_TOKEN = createToken<ProxyConfig[]>('proxyConfigToken', { multi: true,}); /** * @description * Позволяет переопределить функцию фильтрации при обращении к papi-методу `/dependenciesVersion` */export const DEPENDENCIES_VERSION_FILTER_TOKEN = createToken<DepsFilter>( 'dependenciesVersionFilter'); /** * @description * Позволяет задавать список специальных URL'ов на сервере (например, healthz и readyz) * Матчинг осущствляется при помощи библиотеки `path-to-regexp`. */export const SPECIAL_SERVER_PATHS = createToken<string>('specialServerPaths', { multi: true }); export interface ServerModuleStaticsOptions { path: string;} export type APP_INIT_HANDLER = Array<(app?: Application) => Promise<never> | never>; export type ProxyConfig = | { [key: string]: | string | { target: string; [key: string]: any; }; } | { context: string | string[]; target: string; [key: string]: any; }; export type DepsFilter = ( deps: Record<string, string>) => Record<string, string> | Promise<Record<string, string>>; Скопировать  "},{"title":"@tramvai/tools-check-versions","type":0,"sectionRef":"#","url":"docs/references/tools/check-versions","content":"","keywords":""},{"title":"Prerelease версии","type":1,"pageTitle":"@tramvai/tools-check-versions","url":"docs/references/tools/check-versions#prerelease-версии","content":"Инструмент позволяет устанавливать prerelease версии tramvai зависимостей для тестирования нового функционала, пример валидного списка зависимостей: \"dependencies\": { \"@tramvai/core\": \"0.5.0-rc.2\", // release candidate версия, выше по SemVer чем остальные зависимости, ошибок не будет \"@tramvai/module-common\": \"0.4.2\", \"@tramvai/module-router\": \"0.4.2\", \"@tramvai/state\": \"0.4.2\",} Скопировать "},{"title":"Паттерны связанных зависимостей","type":1,"pageTitle":"@tramvai/tools-check-versions","url":"docs/references/tools/check-versions#паттерны-связанных-зависимостей","content":"/^@tramvai\\/core$//^@tramvai\\/module-//^@tramvai-tinkoff\\/module-//^@tramvai\\/tokens-/ "},{"title":"@tramvai/tools-migrate","type":0,"sectionRef":"#","url":"docs/references/tools/migrate","content":"","keywords":""},{"title":"Отключение выполнения миграций","type":1,"pageTitle":"@tramvai/tools-migrate","url":"docs/references/tools/migrate#отключение-выполнения-миграций","content":"Для отключения миграций можно проставить переменную окружения SKIP_TRAMVAI_MIGRATIONS. "},{"title":"Добавление новой миграции","type":1,"pageTitle":"@tramvai/tools-migrate","url":"docs/references/tools/migrate#добавление-новой-миграции","content":"Добавить новую миграцию можно с помощью команды yarn generate:migration после чего потребуется указать имя пакета для которого предназначена миграция и имя новой миграции. Также для этого пакета потребуется добавить в package.json в поле files папку с собранными миграциями, если они не были указаны ранее: \"files\": [ \"lib\", \"__migrations__\"], Скопировать "},{"title":"Реализация миграции","type":1,"pageTitle":"@tramvai/tools-migrate","url":"docs/references/tools/migrate#реализация-миграции","content":"Миграция представляет собой функцию, принимающую специальное апи с помощью которого можно осуществлять изменения кода или конфигов. export interface Api { packageJSON: PackageJSON; // объект-представление корневого package.json tramvaiJSON: TramvaiJSON; // объект-представление файла tramvai.json или platform.json transform: (transformer: Transform, pathTransformer?: PathTransformer) => Promise<void>; // функция принимающая функцию-траснформер для jscodeshift и функцию-трансформер для переименования файлов} Скопировать Трансформация кода осуществляется с помощью jscodeshift "},{"title":"How to","type":1,"pageTitle":"@tramvai/tools-migrate","url":"docs/references/tools/migrate#how-to","content":""},{"title":"Write migration","type":1,"pageTitle":"@tramvai/tools-migrate","url":"docs/references/tools/migrate#write-migration","content":"Transformation# Rules: Prefer to return null | undefined or original source from the transform function in cases when migration doesn't change source code. Otherwise it will lead to unnecessary fs writing.Prefer to use embedded methods of collections returned by call j(source) to make searches and transforms "},{"title":"@tinkoff-monorepo/fix-ts-references","type":0,"sectionRef":"#","url":"docs/references/tools/monorepo-tools/fix-ts-references","content":"","keywords":""},{"title":"Install","type":1,"pageTitle":"@tinkoff-monorepo/fix-ts-references","url":"docs/references/tools/monorepo-tools/fix-ts-references#install","content":"yarn add fix-ts-references Скопировать "},{"title":"Usage","type":1,"pageTitle":"@tinkoff-monorepo/fix-ts-references","url":"docs/references/tools/monorepo-tools/fix-ts-references#usage","content":"npx fix-ts-references --fix Скопировать Соответственно скрипт выполняет: С флагом --fix: Удаление ссылки из references модуля если зависимость убрана из package.jsonДобавление ссылки в references модуля если зависимость добавлена в package.jsonПростановка tsconfig.compilerOptions.rootDir=./src если не поставленаУдаление ссылки из reference solution'а проекта если модуль удален из репозиторияДобавление ссылки в reference solution'а проекта если модуль добавлен в репозиторий Без флага --fix выводит список неисправленных ошибок "},{"title":"@tinkoff-monorepo/pkgs-collector-dir","type":0,"sectionRef":"#","url":"docs/references/tools/monorepo-tools/pkgs-collector-dir","content":"","keywords":""},{"title":"Конфиг","type":1,"pageTitle":"@tinkoff-monorepo/pkgs-collector-dir","url":"docs/references/tools/monorepo-tools/pkgs-collector-dir#конфиг","content":""},{"title":"pkgDirs","type":1,"pageTitle":"@tinkoff-monorepo/pkgs-collector-dir","url":"docs/references/tools/monorepo-tools/pkgs-collector-dir#pkgdirs","content":"Список паттернов путей до пакетов в формате glob "},{"title":"@tinkoff-monorepo/depscheck","type":0,"sectionRef":"#","url":"docs/references/tools/monorepo-tools/depscheck","content":"","keywords":""},{"title":"Параметры конфига для .depscheckrc.yml и cli","type":1,"pageTitle":"@tinkoff-monorepo/depscheck","url":"docs/references/tools/monorepo-tools/depscheck#параметры-конфига-для-depscheckrcyml-и-cli","content":"Все доступные параметры для depcheck можно посмотреть в доке, но есть проблема с недопубликованностью. Поэтому параметры ниже работают, но с оговорками (см --ignore-patterns), а остальные нужно проверять. > yarn depscheck -h collector --collector Модуль, отвечающий за сбор пакетов для проверки и реализующий интерфейс @tinkoff-monorepo/pkgs-collector -> CollectorInterface (сейчас используется @tinkoff-monorepo/pkgs-collector-pvm) [required] [default: {\"name\":\"@tinkoff-monorepo/pkgs-collector-workspaces\"}] --collector-config-strategy [string] [choices: \"about-to-update\", \"update\", \"changed\", \"changed-since-release\", \"affected\", \"released\", \"updated\", \"all\"] [default: [\"affected\"]] depcheck --depcheck-ignore-matches Список паттернов имен модулей отсутствие которых в зависимостях не должно приводить к ошибке [array] [default: []] --depcheck-ignore-dirs Список имен директорий, которые не нужно проверять на не описанные зависимости [array] [default: []] --depcheck-skip-missing Вообще не проверять на не описанные зависимости [boolean] [default: false] --depcheck-ignore-bin-package Не делать проверок в bin файлах пакета [boolean] [default: false] Options: --version Show version number [boolean] --config false если конфиг не нужен совсем и можно задать путь до файла конфига. Иначе отработает логика cosmiconfig [default: \"auto\"] --fix Включает режим исправления ошибок. В данный момент исправляет только unused ошибки. [boolean] [default: false] --ignore-patterns Список паттернов файлов, в которых не нужно делать проверку на missing deps [array] [default: []] --ignore-peer-dependencies Список паттернов модулей из peerDependencies, отсутствие которых в dependencies не должно приводить к ошибке [array] [default: []] -h Show help [boolean] Скопировать "},{"title":"Пример конфига","type":1,"pageTitle":"@tinkoff-monorepo/depscheck","url":"docs/references/tools/monorepo-tools/depscheck#пример-конфига","content":"ignore-patterns: ['**/*.spec.{ts,tsx}', '**/*.test.{ts,tsx}', '**/dynamic-components/*/shared/externals.{js,ts}']depcheck-ignore-dirs: ['__integration__', 'examples', '__tests__']depcheck-ignore-matches: ['@platform/cli', '@tramvai/tools-migrate'] Скопировать "},{"title":"@tinkoff-monorepo/pkgs-collector-workspaces","type":0,"sectionRef":"#","url":"docs/references/tools/monorepo-tools/pkgs-collector-workspaces","content":"@tinkoff-monorepo/pkgs-collector-workspaces Получает все пакеты, описанные в package.json -> workspaces","keywords":""},{"title":"createAction","type":0,"sectionRef":"#","url":"docs/references/tramvai/create-action","content":"","keywords":""},{"title":"createAction({ name, fn, deps, conditions })","type":1,"pageTitle":"createAction","url":"docs/references/tramvai/create-action#createaction-name-fn-deps-conditions-","content":"name - The name of the action, a unique identifier is expectedfn(context, payload, deps) - Implementation of the action, this function will be called when the action is used, maybe async context - ConsumerContextpayload - data passed to actiondeps - provider instances from deps deps - List of providers that are needed for the action to workconditions - List of restrictions for the execution of the action "},{"title":"Usage example","type":1,"pageTitle":"createAction","url":"docs/references/tramvai/create-action#usage-example","content":"import { createAction } from '@tramvai/core'; createAction({ name: 'action log error', fn: (context, payload, deps) => { deps.logger.error('ERROR'); }, deps: { logger: 'logger', }, conditions: { requiredCoreRoles: ['god'], },}); Скопировать "},{"title":"createApp","type":0,"sectionRef":"#","url":"docs/references/tramvai/create-app","content":"","keywords":""},{"title":"createApp({ modules, bundles, providers })","type":1,"pageTitle":"createApp","url":"docs/references/tramvai/create-app#createapp-modules-bundles-providers-","content":"modules - array with used modules in the applicationbundles - object with used bundles with data in the application. The key is the bundle identifier, the value is Promise which returns the bundleproviders - an array with application providers, which will be added last in the DI (after module providers) and thus it will be possible to overwrite the implementation of the tokensactions - array with global actions, which will be registered for all bundles and pages "},{"title":"Usage","type":1,"pageTitle":"createApp","url":"docs/references/tramvai/create-app#usage","content":"import { createApp, provide } from '@tramvai/core';import { RouterModule } from '@tramvai/module-router';import { RenderModule } from '@tramvai/module-render';import { ServerModule } from '@tramvai/module-server'; createApp({ name: 'my-awesome-app', modules: [RouterModule, RenderModule, ServerModule], providers: [ provide({ provide: 'options', useValue: {}, }), ], bundles: { mainDefault: () => import(/* webpackChunkName: \"mainDefault\" */ './bundles/mainDefault'), }, actions: [loadDepositConfig],}); Скопировать After calling createApp, СommandLineRunner is started which performs the chain of actions necessary to initialize the application. "},{"title":"module","type":0,"sectionRef":"#","url":"docs/references/tramvai/module","content":"","keywords":""},{"title":"@Module({ providers, deps, imports })(class)","type":1,"pageTitle":"module","url":"docs/references/tramvai/module#module-providers-deps-imports-class","content":"providers - Providers, which will be added to the root DI container and become available in other modulesdeps - List of dependencies from the DI container, necessary to initialize the moduleimports - A list of modules from which providers will be obtained and added to the DI. Allows you to create modules that combine many other modules "},{"title":"Usage","type":1,"pageTitle":"module","url":"docs/references/tramvai/module#usage","content":"import { Module, provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: 'token', useValue: 'value-in-token', }), ], deps: { logger: 'logger', }, imports: [ModuleLogger],})class ModulePubSub { constructor({ logger }) { logger.info('Module create'); }} Скопировать "},{"title":"createBundle","type":0,"sectionRef":"#","url":"docs/references/tramvai/create-bundle","content":"","keywords":""},{"title":"Properties BundleOptions","type":1,"pageTitle":"createBundle","url":"docs/references/tramvai/create-bundle#properties-bundleoptions","content":"name - Name of the bundle. The value will be used as a bundle identifier.components: {} - An object with registered components for the bundle, which you can use in application routespresets?: [] - A list of additional properties for the current bundle. This list is merged with the current properties. Needed to extract common parts, e.g. a set with actions and components for authorization. Reference - babel and eslint presetsactions?: [] - List of actions that will be registered globally for the bundlereducers?: [] - List of reducers, which must be registered with the loading of the bundle "},{"title":"Usage","type":1,"pageTitle":"createBundle","url":"docs/references/tramvai/create-bundle#usage","content":"import { createBundle } from '@tramvai/core';import { lazy } from '@tramvai/react'; createBundle({ name: 'app/bundle', presets: [commonPreset], components: { 'app/pages/MainPage': lazy(() => import('../pages/MainPage')), 'app/pages/SecondPage': lazy(() => import('../pages/SecondPage')), }, actions: [fooAction, barAction], reducers: [bazReducer],}); Скопировать "}]