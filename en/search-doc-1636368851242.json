[{"title":"Bundle","type":0,"sectionRef":"#","url":"docs/concepts/bundle","content":"","keywords":""},{"title":"Dynamic bundle import","type":1,"pageTitle":"Bundle","url":"docs/concepts/bundle#dynamic-bundle-import","content":"To highlight unnecessary code on each page, each bundle passed to createApp must have the signature () => Promise<{default: Bundle}>. All the code shared with the modules plugged into the application will remain in the main chunk of the application, and many bundles will weigh only a few KB, but as soon as one of the components of the bundle includes a heavy dependency, for example, a library with forms, it will completely fall into the corresponding bundle. It is recommended to use dynamic import with the magic comment webpackChunkName to specify the name of the new chunk, for example: () => import(/* webpackChunkName: \"mainDefault\" */ './bundles/mainDefault') Copy "},{"title":"Default bundle","type":1,"pageTitle":"Bundle","url":"docs/concepts/bundle#default-bundle","content":"Each route must have properties bundle with the name of the bundle, pageComponent and layoutComponent with the names of the corresponding components. The default values ​​are as follows: bundle: 'mainDefault'pageComponent: 'pageDefault'layoutComponent: 'layoutDefault' When using the standard RenderModule, the LayoutModule is included, which will provide the layoutDefault and a separate mechanism for extending and overriding layout in the application, so there is no need to add the layoutDefault property to the components list of the bundle. To create a bundle that will run on all application pages that do not have specific route settings, two steps are enough: Create a bundle# import { createBundle } from '@tramvai/core';import { MainPage } from './pages/MainPage'; export default createBundle({ name: 'mainDefault', components: { pageDefault: MainPage, },}); Copy Connect the bundle# import { createApp } from '@tramvai/core'; createApp({ name: 'myApp', modules: [ // ... ], providers: [ // ... ], bundles: { mainDefault: () => import(/* webpackChunkName: \"mainDefault\" */ './bundles/mainDefault'), },}); Copy "},{"title":"Actions chain","type":0,"sectionRef":"#","url":"docs/concepts/command-line-runner","content":"","keywords":""},{"title":"Usage example","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#usage-example","content":"We have registered a new provider that will be called when commandLineRunner reaches the commandLineListTokens.generatePage token and the render function is executed: import { provide } from '@tramvai/core';@Module({ providers: [ provide({ provide: commandLineListTokens.generatePage, useFactory: ({ responseManager }) => { return function render() { responseManager.setBody(ReactDOM.renderToString(<App />)); }; }, deps: { responseManager: RESPONSE_MANAGER_TOKEN, }, multi: true, }), ],})export class RenderModule {} Copy "},{"title":"Action blocks","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#action-blocks","content":"A number of basic actions are predefined in the tram, which are performed at certain stages of the application. Based on these stages, the work of the basic tram modules is built and actions can be added to custom modules. "},{"title":"Initialization (init)","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#initialization-init","content":"When tramvai starts, a chain of actions is launched in which you can initialize asynchronous services (if necessary) and add basic functionality. These actions are performed only once and are not available to providers who need a custom context.  "},{"title":"Handling customer requests","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#handling-customer-requests","content":"For each client, we run a list of actions in which the user context and data are available. For each client, we create our own di context in which the implementations will live only while we process the client's request.  "},{"title":"SPA transitions (spa)","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#spa-transitions-spa","content":"For SPA transitions in the browser, routing triggers a list of actions  "},{"title":"Shutdown (close)","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#shutdown-close","content":"Before exiting the application, this list of actions is launched  "},{"title":"Tokens","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#tokens","content":""},{"title":"init","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#init","content":"Initializing Asynchronous Services For what: If you need to initialize global singletons asynchronously "},{"title":"listen","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#listen","content":"Subscribing to global events by the application For what: If you need to subscribe to global events or a port "},{"title":"customer_start","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#customer_start","content":"The starting token in the client request processing chain. Required to initialize custom asynchronous constructors. It is not advised to do any lengthy asynchronous tasks at this stage, as only synchronous actions are expected. For what: To initialize asynchronous services for each client "},{"title":"resolve_user_deps","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#resolve_user_deps","content":"The main goal of this stage is to find out all the necessary information about the client we are currently processing. Since all actions within one stage are performed in parallel with us, it is at this stage that you can efficiently and quickly request all the necessary information, for example, simultaneously with the request for customer data, you can find out about the status of the customer's authorization, get analytical information about the customer and similar actions. For what: To request any global customer information "},{"title":"resolve_page","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#resolve_page","content":"The main goal of this stage is to find out all the necessary information about the page the client visited. For what: To request information about the page "},{"title":"resolve_page_deps","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#resolve_page_deps","content":"At this stage, we already know about the client, about what this page is. But, we have not requested the necessary data for the page. For example: request resources from the admin panel, get a list of regions, load the necessary page blocks. And all the information that will be needed when generating the page. At this stage, it is not worth doing long asynchronous actions and it is supposed to be cached or moved to resolveUserDeps to achieve the maximum speed of response to clients. At this stage, action is executed and perhaps they will suit you better, as there are many additional functionality For what: To get the information needed to render the page "},{"title":"generate_page","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#generate_page","content":"At this stage, we already know the current route, which client and all actions for the page have already been loaded. And at this stage, according to the information from the previous stages, we generate an html page and give it to the client For what: this is more of an internal stage and should not be used in ordinary cases. Since race condition with application rendering "},{"title":"clear","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#clear","content":"This stage will be called after we have responded to the client, but some modules or libraries need to delete client data For what: The method is needed if you need to perform actions after a successful response to the user "},{"title":"spa_transition","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#spa_transition","content":"Tasks registered at this stage are executed on SPA transitions in the application For what: To update meta information on the current page "},{"title":"close","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#close","content":"Before closing the application, some modules may need to perform special actions, for example, close connections, send data and similar activities. In order not to duplicate the application closure tracking code in each module, this stage was made. For what: If you need to perform actions before closing the application. for example close connections, send logs and so on "},{"title":"Customization","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#customization","content":"The application can override the standard list of actions, for example, delete unnecessary ones or add new ones. To do this, you need to define a provider in the application or module that will rewrite the base list import { provide } from '@tramvai/core';[ provide({ provide: COMMAND_LINES_TOKEN, scope: 'singleton', useValue: customLines, }),]; Copy Caution: do not delete stages, as this may cause some modules to stop working correctly. In this case, the best solution would be to delete the module that is being linked to an unnecessary stage. "},{"title":"Action","type":0,"sectionRef":"#","url":"docs/concepts/action","content":"","keywords":""},{"title":"Example action","type":1,"pageTitle":"Action","url":"docs/concepts/action#example-action","content":"import { createAction } from '@tramvai/core'; // create an actionconst actionFetchData = createAction({ name: 'fetch-data', fn: (context, payload) => fetch(payload.url),}); // execute the actioncontext .executeAction(actionFetchData, { url: 'https://tinkoff.ru' }) .then((data) => context.dispatch(loadData(data))); Copy "},{"title":"Global Actions","type":1,"pageTitle":"Action","url":"docs/concepts/action#global-actions","content":"Applications can add global actions in the application that need to be executed before rendering the page, in these actions they usually load the information necessary to display the page, for example, information about deposits. Before rendering the page, the different types of actions are collected into a single list and executed in parallel. In short, an action is global if added via createApp, createBundle, or a static property of a page component, such as PageComponent.actions. By default, global actions are executed once, on the server, and pass the status and result of the action to the client. "},{"title":"Execution Deadline","type":1,"pageTitle":"Action","url":"docs/concepts/action#execution-deadline","content":"Servers must respond quickly, so we must reduce the number of cases when global actions cause a delay in page loading, for example, if an API fails. To do this, there is a time limit on the server for executing global actions, and if this time passes, then waiting for actions ends and these actions must be executed on the client side. "},{"title":"Synchronizing actions between server and client","type":1,"pageTitle":"Action","url":"docs/concepts/action#synchronizing-actions-between-server-and-client","content":"Information about all successfully executed actions will be transferred to the client, which will start the execution of global actions based on this information. At the same time, if an action, for example, fell out of the deadline or fell by mistake, then it will be re-executed on the client side. "},{"title":"Types of global actions","type":1,"pageTitle":"Action","url":"docs/concepts/action#types-of-global-actions","content":"Application-wide global actions# To register within the application, we must pass an array of actions to createApp, after that all these actions will be executed for each page and any bundles: Connection# createApp({ name: 'myApp', actions: [loadDepositConfig],}); Copy You can also register actions with providers: import { ACTIONS_LIST_TOKEN } from '@tramvai/core';import { provide } from '@tramvai/core'; const provider = provide({ provide: ACTIONS_LIST_TOKEN, multi: true, useValue: [loadDepositConfig],}); Copy Global actions for the bundle# To register inside a bundle, we must pass to createBundle a list of actions that will then be executed for all pages that are present and used in the bundle. Connection# createBundle({ name: 'bundle', actions: [loadDepositConfig],}); Copy Global actions linked to the page# This is the lowest level of adding global actions, for a separate Page component, we can bind a list of actions that need to be performed before rendering the page. Connection# To do this, you need to add a static property to the page of the actions component and pass the list of required actions class PageComponent extends Copmponent { static actions = [loadDepositConfig];} Copy "},{"title":"Restrictions","type":1,"pageTitle":"Action","url":"docs/concepts/action#restrictions","content":"Not all actions can be executed under all circumstances, we can have actions that should be executed only on the server, others only in the browser, and having any other restrictions. There is a conditions property to solve this problem: createAction({ name: 'fetch-data', fn: (context, payload) => fetch(payload.url), conditions: { requiredCoreRoles: ['client'], onlyBrowser: true, },}); Copy In the example above, we create an action that will be executed only in the browser and only when we have the user role of the main core API equal to client. "},{"title":"Adding new restrictions to the application","type":1,"pageTitle":"Action","url":"docs/concepts/action#adding-new-restrictions-to-the-application","content":"You can implement your own constraints in an application or module. To do this, we must create an object with an interface: interface Condition { key: string; fn(checker: ActionConditionChecker): void;} Copy key - restriction identifierfn - a validation function that will be called for each action The function will receive in the argument checker, which has an interface interface ActionConditionChecker { payload: any; parameters: any; type: 'global' | 'local'; conditions: Record<string, any>; forbid(): void; setState(value: any): void; getState(): any; allow(): void;} Copy payload - data that was transferred with the actionparameters - parameters that were passed when creating the actionconditions - restrictions for the current actiontype - type of the executed action, can be global or simple execution via executeActionforbid - prohibits the execution of the action. If at least one checker calls this function, the action execution will be stoppedsetState - allows you to write the check data. It is necessary for cases when we need to know with what data it was executed before and whether it needs to be repeated, for example, restrictions on the authorization rolegetState - getting the previously recorded stateallow - tell the action to be executed again. The action will execute unless execution is forbidden via forbid "},{"title":"Example of a constraint","type":1,"pageTitle":"Action","url":"docs/concepts/action#example-of-a-constraint","content":"const isServer = typeof window === 'undefined'; export const onlyServer: ActionCondition = { key: 'onlyServer', fn: (checker) => { if (checker.conditions.onlyServer && !isServer) { checker.forbid(); } },}; Copy After connecting, the constraint will look if the action has a onlyServer field in conditions, and if so, it will change the action's behavior "},{"title":"Connecting restrictions to the application","type":1,"pageTitle":"Action","url":"docs/concepts/action#connecting-restrictions-to-the-application","content":"To do this, you need to add the multi provider ACTION_CONDITIONALS and pass a function that will have an interface import { provide } from '@tramvai/core'; const provider = provide({ provide: ACTION_CONDITIONALS, multi: true, useValue: [onlyServer],}); Copy "},{"title":"Preset limits available for each action","type":1,"pageTitle":"Action","url":"docs/concepts/action#preset-limits-available-for-each-action","content":"always - the action is executed on the server, then in the browser and on each SPA transition within the applicationonlyBrowser - the action is executed only in the browseronlyServer - the action is executed only on the serverpageBrowser - the global action is executed only in the browserpageServer - the global action is executed only on the serveralways + onlyBrowser - the action is executed in the browser and for each SPA transition within the application "},{"title":"Peculiarities","type":1,"pageTitle":"Action","url":"docs/concepts/action#peculiarities","content":"Keep in mind that actions are cached by default and are only executed once during the life cycle of the application. The following feature follows from this. Let's assume the following situation: we have a page of the concert venue at the url /concertvenue-[objectId] - where objectId is a parameter that corresponds to the concert venue identifier;on this page we have one component ConcertVenuePage and one page action preparePageAction;objectId in the url of the page is used to get data in preparePageAction, as well as to fetch data for rendering the page;we have a concert page /concert on which there are links to concert venues -/concertvenue-1, /concertvenue-2, /concertvenue-1. We can navigate to all these links with a SPA transition;Transitions between pages are client-side (SPA), not server-side; Sequencing: On the concert page we click on /concertvenue-1, the page of the concert venue opens, the page action is performed for the first time.We go back to the SPA concert page by transition.Click on /concertvenue-2.We get to an empty page, since the page action has already been executed, new data has not been requested, and the data selection for drawing the page was made according to ID from url - 2. If you want a page action to be executed every time you visit the page, you need to pass it the appropriate condition: const preparePageAction = creareAction({ name: 'preparePageAction', fn: () => { // ... }, conditions: { // with always: true, the action will always be called and not cached always: true, },}); ConcertVenuePage.actions = [preparePageAction]; Copy "},{"title":"Dependency Injection","type":0,"sectionRef":"#","url":"docs/concepts/di","content":"","keywords":""},{"title":"Concepts","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#concepts","content":"Provider - Token implementation in DITokens - provider identifier in DI system and at the same time its interfaceContainer - storage with all providers and their implementations "},{"title":"Features","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#features","content":""},{"title":"Dynamic Initialization","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#dynamic-initialization","content":"Providers are initialized only if the code got an instance using the get method from the di container or if the provider was specified as a deps dependency on module. In other cases, the provider will not be created and initialized. This feature allows us to register providers in any order and replace implementations. "},{"title":"Replacing implementations","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#replacing-implementations","content":"In some cases, the basic implementation of the functionality may not be suitable for us, and to solve this problem, we can override the implementation of the providers. For example, the current logger from the common-module is not suitable for us and we want to replace it, for this we need to drop a new implementation for the token into the providers. import { provide } from '@tramvai/core';createApp({ modules: [CommonModule], providers: [ provide({ provide: LOGGER_TOKEN, useValue: console, }), ],}); Copy After that, we will replace the implementation of LOGGER_TOKEN, which was declared in CommonModule, with a native object console "},{"title":"Checking the availability of the implementation of all dependencies","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#checking-the-availability-of-the-implementation-of-all-dependencies","content":"When initializing the provider, the availability of all dependencies is automatically checked if no dependency was found and the provider is not optional, an exception is thrown in development mode. "},{"title":"Using DI","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#using-di","content":""},{"title":"In modules","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#in-modules","content":"Passing an array to the providers parameter that will be added when the application is initialized in DI. More about modules @Module({ providers: [ // ... ],})export class MyModule {} Copy "},{"title":"In createApp","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#in-createapp","content":"You can pass the providers array to createApp, which will have the highest priority and will overwrite the implementations of the modules and core interfaces: createApp({ providers: [ // ... ],}); Copy "},{"title":"In actions","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#in-actions","content":"To get provider implementations, you can pass a deps object when creating an action: createAction({ name: 'action', fn: (context, payload, deps) => { deps.logger.error('ERROR'); }, deps: { logger: 'logger', },}); Copy "},{"title":"Container A","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#container-a","content":"container that stores a list of registered providers in the application, as well as instances of provider implementations that have already been created. "},{"title":"Root container","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#root-container","content":"Top-level global container that contains all registered providers and global singletons that live as long as the application lives. "},{"title":"Container is a child","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#container-is-a-child","content":"A DI instance created for each client (user who sent a request to the server) that inherits from the container root. But it allows you to create and store your own class instances. Which can contain private information about the client and at the same time, this information will not leak to other clients, for example, a link to the actual Request object. Consumer di is created and lives on while we respond to the client. As soon as we answered, consumer di is deleted and all private information is cleared. This does not require manual cleaning and deletion of the di container or its dependencies. This work is based on the fact that when responding to the client, the reference to the context and the DI container is lost. Then the GC will delete everything from memory. "},{"title":"Additional material","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#additional-material","content":"Video explaining why DI is needed and why you should use it Part 1Part 2Release of the devshakhta which is dedicated to DI and why is it needed https://www.youtube.com/watch?v=3NgWwzwDeTQ "},{"title":"Module","type":0,"sectionRef":"#","url":"docs/concepts/module","content":"","keywords":""},{"title":"Module life cycle","type":1,"pageTitle":"Module","url":"docs/concepts/module#module-life-cycle","content":""},{"title":"Initializing the application","type":1,"pageTitle":"Module","url":"docs/concepts/module#initializing-the-application","content":"When creating an application, all declared providers are processed, which will fall into the general DI container. "},{"title":"Handling customer requests","type":1,"pageTitle":"Module","url":"docs/concepts/module#handling-customer-requests","content":"The module is instantiated once on the server (and used for all clients), after initializing the application, and once in the browser, after loading the page and initializing the client side. These instances contain instances of the classes that were passed to deps and will be passed to the module's constructor: import { Module } from '@tramvai/core'; @Module({ providers: [], deps: { log: 'log', },})class TestModule { constructor({ log }) { log.info('TestModule created'); }} Copy "},{"title":"Example module","type":1,"pageTitle":"Module","url":"docs/concepts/module#example-module","content":"The main functionality of the module is in the providers list. Each provider either adds new functionality, for example, makes available in all other modules the constant value New under the key Token: import { Module, provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: 'Token', useValue: 'New', }), ],})class TestModule {} Copy Or it uses tokens from other modules, for example, adding a new environment parameter via the ENV_USED_TOKEN token, which will be processed by the EnvModule: import { Module, provide } from '@tramvai/core';import { ENV_USED_TOKEN } from '@tramvai/module-common'; @Module({ providers: [ provide({ provide: ENV_USED_TOKEN, multi: true, useValue: [ { key: 'ENV_VARIABLE', value: 'New', optional: true, }, ], }), ],})class TestModule {} Copy "},{"title":"Import in module third party modules","type":1,"pageTitle":"Module","url":"docs/concepts/module#import-in-module-third-party-modules","content":"Modules can be imported internally by providers of third-party modules. Thus, allowing you to build a chain of interconnected modules. Code example import { Module } from '@tramvai/core';import { LogModule } from '@tramvai/module-log'; @Module({ providers: [], imports: [LogModule],})class TestModule {} Copy In this case, when initializing TestModule, the providers from the ModuleLogger module and nested imports, if present, will be initialized beforehand. "},{"title":"Dynamic modules","type":1,"pageTitle":"Module","url":"docs/concepts/module#dynamic-modules","content":"Modules can be configured in two ways, and both methods can be used simultaneously: passing parameters to modulereturn parameters in the static method forRoot An example of a dynamic module, in which we will add dependencies metaGenerate to the DI in the first way and meta-list in the second, and one of them depends on the other: import { Module, provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: 'metaGenerate', useClass: class MetaGenerate {}, deps: { list: 'meta-list', }, }), ],})export class SeoModule { static forRoot({ metaList }: { metaList?: string[] }) { if (metaList) { return { mainModule: SeoModule, providers: [ provide({ provide: 'meta-list', useValue: metaList, }), ], }; } }} Copy A static method must return an object with an interface: type staticModule = { mainModule: Module; // Link to the main module, from which we will extract all the basic information providers: Provider []; // Providers to be added to DI}; Copy Now this module contains a static method forRoot which adds additional providers to the standard SeoModule module. Without this construct, we would need to explicitly write providers in the application. All data that has been added to the SeoModule will be inherited and expanded. Now we can call our static method in the application or in other modules. And the result of execution of forRoot will be added to DI import { Module } from '@tramvai/core';import { SeoModule } from './SeoModule';import { metaFromConfig } from './metaFromConfig'; @Module({ imports: [SeoModule.forRoot([metaFromConfig])],})export class ApplicationModule {} Copy It should be borne in mind that the forRoot construction should only simplify the use of the module and we should also maintain the functionality of the module through the usual configuration of providers "},{"title":"Recommendations for modules","type":1,"pageTitle":"Module","url":"docs/concepts/module#recommendations-for-modules","content":""},{"title":"Low cohesion","type":1,"pageTitle":"Module","url":"docs/concepts/module#low-cohesion","content":"It is advisable to build modules so that they do not directly depend on other modules. Coupling only needs to be interface-based and replaceable. Otherwise, it will not be possible to simply replace modules and refactor. "},{"title":"Small size","type":1,"pageTitle":"Module","url":"docs/concepts/module#small-size","content":"The larger the module, the more code it contains inside and the more potentially it has connections and reasons for changes. For this reason, the module will be more difficult to change and there will be a greater chance of breaking functionality when changed. It is desirable that the modules implement some small part of the functionality. "},{"title":"Optional dependencies / configuration","type":1,"pageTitle":"Module","url":"docs/concepts/module#optional-dependencies--configuration","content":"It is convenient to use the module if it does not require any configuration and works normally by default. But, if it is clear that for some applications and cases additional behavior setting will be needed, then it is advisable to use optional dependencies that can be defined in the application. It is worth marking non-critical functionality with optional dependencies, which the module does not necessarily need. So that you can not implement interfaces and throw out some of the logic. For example, logging // @todo example of optional dependency Copy "},{"title":"Debugging Modules","type":1,"pageTitle":"Module","url":"docs/concepts/module#debugging-modules","content":"It is recommended to specify in the module documentation the unique identifier / namespace of the logger, which is used in this module. Example module id for @tramvai/module-server: const log = logger ('server'); // get a logger instance by LOGGER_TOKEN token Copy "},{"title":"Additional links","type":1,"pageTitle":"Module","url":"docs/concepts/module#additional-links","content":"About DI containerAbout providers "},{"title":"Introduction to tramvai","type":0,"sectionRef":"#","url":"docs/concepts/overview","content":"","keywords":""},{"title":"Main features","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#main-features","content":"Modular approach - you can extend the functionality of applications using modulesUniversal - Works equally well for browsers and serverБыстрый - lightweight, does not affect the overall performance of the application, maximizes parallelization of actions on the server "},{"title":"Approaches used","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#approaches-used","content":" "},{"title":"Modularity","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#modularity","content":"The architecture tramvai is based on the idea that we have all the functionality divided into various modules and all communication between the modules is based on common interfaces, interacting through DI. This architecture makes it possible to easily add new functionality to the application, and replace existing functionality. "},{"title":"Standardization","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#standardization","content":"tramvai is a framework that allows you to maintain and create applications with the same architecture for many teams with the ability to share code between projects, as it tramvai is a lightweight layer that helps to interact different modules in the application "},{"title":"Performance","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#performance","content":"The core tramvai together with DI weighs 4 kb, everything else is implemented through third-party modules that extend the functionality of the application. This makes it possible to make applications of the minimum size, excluding unnecessary features. The architecture and modules are designed with a concept performance first for maximum parallelization, according to best practice. "},{"title":"Universal","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#universal","content":"tramvai it is an SSR-first framework and takes into account all the features and problems associated with the server, client and the interaction between them: All modules are developed for both the browser and the serverCommon interfaces are usedA chain of commands on the server and the browser is used which allows you to perform actions in determining the lifetime of the applicationThe action system allows you to equally request data on the server and in the browser, using various features (e.g. repetition in the browser of an action that crashed on the server) "},{"title":"Splitting into external libraries","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#splitting-into-external-libraries","content":"When developing tramvai we try to use open source solutions, or create basic libraries that are in no way related to tramvai and can be used in other projects and frameworks. "},{"title":"DI with interface taken from Nest or Angular DI","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#di-with-interface-taken-from-nest-or-angular-di","content":"DI is the core part of tramvai that allows you to reduce code cohesion and separation of functionality into modules. tramvai use a library @tinkoff/dippy that implements the DI container. The internal interface DI repeats the interface Nest, which allows you to conveniently describe the dependencies and implementations of classes. "},{"title":"Soft migration option","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#soft-migration-option","content":"A million + lines of code have already been written on tinkoff.ru and the new solution should not break the existing code, and also require applications from a difficult and long transition "},{"title":"Why was it developed","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#why-was-it-developed","content":""},{"title":"tramvai","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#tramvai","content":"Often, React applications are a constructor from different libraries that have been included in the project. This works well on a small scale, but it does not work well for large applications with 70+ developers, since in this approach it is easy to connect your own and disperse radically in the application architecture. This problem is taken over tramvai and standardized and implemented by a common application architecture that all product teams use. There are not many open source solutions on github that implement the architecture of large applications. Alternatives# next.js# One of the best simple React frameworks that takes care of server-side rendering and routing. At the same time, this is a lightweight framework that does not standardize in any way and does not solve the problems with the modularity of components. Therefore, most of the code that was written on tramvai would have to be written for next.js and try to somehow implement, since in next.js the ability to extend functionality is very limited fusion.js# A similar framework that evolved and emerged at the same time with tramvai. Fusion.js does not have a full-fledged DI, a limited ability to move functionality into modules and the entire architecture is built on the basis of middlewares, and there are difficulties around the hard-coded priorities of plugins and the lack of parallelization of actions nest.js# An excellent backend framework that uses similar DI, but is not completely sharpened for SSR. And when using it, we had to have 2 architectures, one for the backend, the other written by ourselves for the client "},{"title":"@tinkoff/dippy","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#tinkoffdippy","content":"Lightweight DI library with Angular-like interface. In the open source, there are not so many different DI options that allow you to separate class implementations, both basic general and specific for each client. Alternatives# inversify# This is the most popular library for creating DI, with: weighs 11kb, compared to dippy 1.2kba low-level API that requires different wrappers to implement a modular system.ts-nest this is an example of a wrapper over inversify that has weak support and only the wrapper contains about the same code as @tinkoff/dippy "},{"title":"state","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#state","content":"The state management library built into tramvai is almost completely similar to the Redux interface, with few nuances: Allows you to sign components only for updating certain reducers, solving the problem with performanceThere is a lot of code written using the deprecated version of the state and you can't just switch to another solution Alternatives# redux# Moving to pure redux will not solve the problems, it will only add performance-related ones reatom# Very similar to our state manager, a new library that addresses the issue of updates and performance. A good candidate to take some features from. Full transition is very expensive due to the codebase effector# Interesting library that has a focus on the client side and is not very suitable for SSR "},{"title":"Concepts","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#concepts","content":""},{"title":"Module","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#module","content":"The main basic elements of the tramvai architecture that contain the implementation of functionality. At the same time, it is assumed that such modules will not be huge and a large number of different types will appear. Documentation "},{"title":"DI system","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#di-system","content":"tramvai is built on a DI system that stores the implementation of functionality and receiving implementations for tokens and keys. This allows you to implement communications between modules based only on interfaces, while having the ability to change implementations as needed. Documentation "},{"title":"CommandLineRunner","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#commandlinerunner","content":"Runner for a list of actions that modules can attach actions to. There are 2 types of action lists: Application initializationProcessing a request for a client Within the framework of this list of actions, routes, user status, page rendering and html return to the client are received. Documentation "},{"title":"Diagrams","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#diagrams","content":""},{"title":"How it works on the server side","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#how-it-works-on-the-server-side","content":" "},{"title":"Versioning","type":0,"sectionRef":"#","url":"docs/concepts/versioning","content":"","keywords":""},{"title":"Unified versioning","type":1,"pageTitle":"Versioning","url":"docs/concepts/versioning#unified-versioning","content":"Most of the libraries in the tramvai repository are combined into end-to-end versioning - these are core packages, tram modules and tokens, everything that is included in the @tramvai and @tramvai-tinkoff scopes. The release and publication of these libraries occurs at the same time, even if the changes affect only one package from the list. You can see this approach in Angular, and with some restrictions, in monorepositories using Lerna The main advantage of unified versioning is that compatibility between packages of the same version is guaranteed. Previously, the user had only one way to raise the framework version without losing compatibility between packages - to install all packages to their latest version. Now, you can specify a common target version for each tramvai library, or use the tramvai update command. One of the drawbacks of this approach is that any update of a package from the unified list requires raising versions and publishing all these packages from the list, which significantly slows down CI. "},{"title":"Storing versions in release tags","type":1,"pageTitle":"Versioning","url":"docs/concepts/versioning#storing-versions-in-release-tags","content":"One of the reasons for storing a version in release tags is the protected master branch, which we cannot automatically make changes to after the release and update of package versions. Storing versions in release tags does not in itself provide any advantage, and we use it together with stub versions of packages in the source package.json files. Let's say we had a package with dependencies: { \"name\": \"@tramvai/foo\", \"version\": \"0.1.0\", \"dependencies\": { \"@tramvai/bar\": \"^1.1.0\", \"@tramvai/baz\": \"^2.0.0\" } } Copy Previously, every big Merge Request was accompanied by conflicts if package versions were updated in the master branch, and the affected libraries in MR contained changes in dependencies. Now, our package looks like this: { \"name\": \"@tramvai/foo\", \"version\": \"0.0.0-stub\", \"dependencies\": { \"@tramvai/bar\": \"0.0.0-stub\", \"@tramvai/baz\": \"0.0.0-stub\" } } Copy The version 0.0.0-stub will never cause merge conflicts, and the calculation of real versions occurs only in CI - when creating a new release tag and publishing, inside the pvm library. "},{"title":"Contribute","type":0,"sectionRef":"#","url":"docs/contribute/contribute","content":"Contribute Framework tramvai is in the process of incremental migration from our internal repo to open source. Migration consists of several stages: Push synchronization Сurrent stage, automatic mirroring internal releases to Github repository Pull synchronization Next stage, automatic mirroring pull requests from Github repository to our internal repo Full migration Perspective stage, moving source code, and all CI processes (testing, linting, building, publishing, versioning) to Github repository So for now contributors can open any issues and pull requests, but maintainers will need to manually transfer accepted changes to our internal repo.","keywords":""},{"title":"Automatic migrations","type":0,"sectionRef":"#","url":"docs/features/migration","content":"","keywords":""},{"title":"Why migrations are needed","type":1,"pageTitle":"Automatic migrations","url":"docs/features/migration#why-migrations-are-needed","content":"Sometimes in the tram there is a need to make some kind of breaking changes and to simplify such a transition for end users, automatic migrations are used. Migrations allow you to transfer the application codebase to a new version of the interfaces in an automatic mode and practically without the participation of developers. "},{"title":"How to use migrations","type":1,"pageTitle":"Automatic migrations","url":"docs/features/migration#how-to-use-migrations","content":"Migrations are performed automatically when new versions of tram packages are installed. The file .tramvai-migrate-applied.json in the root of the project is used to save information about migrations that have already been performed. All that remains for application developers to do is: study the doc on latest migrations for packagescommit changes in the file .tramvai-migrate-applied.json, because it saves information about completed migrations and it is better to save it so as not to perform migrations againif after migrations package.json has changed, then you need to install packages to update the lock file in the project.review and commit all other changes that have occurred in the project (review is necessary because it is difficult to take into account all use cases in the migration, and also the result after the code transformation may not correspond to the linter settings in the current project).check the application for problems and make changes in accordance with the migration dock "},{"title":"How to disable migrations","type":1,"pageTitle":"Automatic migrations","url":"docs/features/migration#how-to-disable-migrations","content":"Add environment variable SKIP_TRAMVAI_MIGRATIONS before starting package installation. "},{"title":"How migrations work","type":1,"pageTitle":"Automatic migrations","url":"docs/features/migration#how-migrations-work","content":"1.@tramvai/core contains the dependency @tramvai/tools-migrate1.@tramvai/tools-migrate contains a script that runs on 'postinstall' 1.script analyzes tramvai modules in 'node_modules' and find all migrations 1.further the file .tramvai-migrate-applied.json is checked and a list of already selected migrations is taken from it if such a file exists 1.The code of migrations that are not in the list of completed ones is executed. Migrations are performed sequentially 1.in the file .tramvai-migrate-applied.json is added information about the migrations just performed, if the file was before, or this file is created "},{"title":"Q/A","type":1,"pageTitle":"Automatic migrations","url":"docs/features/migration#qa","content":""},{"title":"Do I need to store .tramvai-migrate-applied.json in VCS?","type":1,"pageTitle":"Automatic migrations","url":"docs/features/migration#do-i-need-to-store-tramvai-migrate-appliedjson-in-vcs","content":"Yes, otherwise, during the next migrations, we will not know which migrations have already been performed and repeated migrations will be performed "},{"title":"Provider","type":0,"sectionRef":"#","url":"docs/concepts/provider","content":"","keywords":""},{"title":"Format","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#format","content":"type Provider = { provide: Token | string; // provider id useValue?: any; // implementation of the identifier useFactory?: any; // implementation of the identifier useClass?: any; // implementation of the identifier deps?: Record<string, Token | string>; // list of dependencies that the provider needs to work multi?: boolean; // the ability to register multiple provider implementations, if true, when receiving the value of this identifier, all registered values ​​will come in the scope array scope?: 'request' | 'singleton'; // If a singleton, then the container will register one instance of the provider for all client requests. If request will create its own instance for each client and Request}; Copy "},{"title":"Types of providers","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#types-of-providers","content":""},{"title":"Class","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#class","content":"When the instance is initialized, the class passed to useClass will be created, if deps were specified, then the class will be called with the object of implementations as the first argument import { provide } from '@tramvai/core';const provider = provide({ provide: 'token', useClass: class ImplementClass { constructor({ logger }) {} }, deps: { logger: 'logger', },}); Copy "},{"title":"Factory","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#factory","content":"When the instance is initialized, the function passed to useFactory will be called, if deps were specified, then the function will be called with the object of implementations as the first argument import { provide } from '@tramvai/core';const provider = provide({ provide: 'token', useFactory: ({ logger }) => new Implement(logger), deps: { logger: 'logger', },}); Copy "},{"title":"Value","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#value","content":"Sets the provider's value to the data that was passed in the useValue parameter, no additional initialization will be performed and deps cannot be used import { provide } from '@tramvai/core';const provider = provide({ provide: 'token', useValue: { appName: 'APP' },}); Copy "},{"title":"Multi providers","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#multi-providers","content":"We may need to be able to register multiple implementations for a single token. For example, several actions for one step. To implement this, you need to pass the multi parameter to the provider. In this case, an array of providers is stored in the di container: import { provide } from '@tramvai/core';const providers = [ provide({ provide: 'token', multi: true, useValue: { route: '/' }, }), provide({ provide: 'token', multi: true, useValue: { route: '/cards' }, }),]; Copy "},{"title":"Dependencies (deps)","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#dependencies-deps","content":"Needed to specify the dependencies that are needed for the provider to work. When creating a provider, dependency instances will be created, which are specified in deps and passed to the provider as the first argument. The keys of the deps object will be the implementations that will be sent to the provider. In this case, if the provider is not found in the global DI, an error will be thrown notifying that the current token was not found. "},{"title":"Format","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#format-1","content":"type Provider = { deps: { [key: string]: | Token | { token: Token; optional?: boolean; multi?: boolean; }; };}; Copy "},{"title":"Optional Dependencies","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#optional-dependencies","content":"We don't always need mandatory dependencies to work. And we want to point out that the dependency is not necessary to work and it is not necessary to throw an error. To do this, you can pass the optional parameter, which will disable throwing an error if there is no dependency. Instead of implementing the dependency, the provider will receive the value null. import { provide } from '@tramvai/core';const provider = provide({ provide: 'token', useClass: class A { constructor({ log }) {} }, deps: { log: { token: 'log', optional: true, }, } as const,}); Copy "},{"title":"Multi dependencies","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#multi-dependencies","content":"Some providers are multi-providers and instead of one implementation, we will receive an array of implementations. For correct type inference, we must pass the multi: true parameter, apply as const for the deps block for correct type inference via TS: import { provide } from '@tramvai/core';const provider = provide({ provide: 'token', useClass: class A { constructor({ commands }) { commands.forEach(); } }, deps: { commands: { token: 'commands', multi: true, }, } as const,}); Copy "},{"title":"Circular dependency","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#circular-dependency","content":"DI does not allow declaring dependencies that depend on each other, for example: import { provide } from '@tramvai/core';const providers = [ provide({ provide: 'A', deps: { B: 'B', }, }), provide({ provide: 'B', deps: { A: 'A', }, }),]; Copy In this example, we will not be able to correctly create provider instances and the code will throw an error. Such providers should reconsider and make a common part in a separate class, and provider and used in conjunction A and B "},{"title":"Scope","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#scope","content":"option only affects the operation of the container on the server, only one common container running on the client, in which service providers with a different crowd kept together Allows you to create singleton instances that will be shared between multiple clients. In standard behavior, each declared provider will be automatically deleted and recreated for each new client. This functionality was made in order for us to be able to store both singletons, for example, cache, and various personalized data. For example, user status and personalization. By default, all providers have the value Scope.REQUEST, which means that provider values ​​will be generated for each client. The exception is the useValue providers, which behave like a singleton. "},{"title":"Interface","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#interface","content":"import { provide } from '@tramvai/core';const provider = provide({ provide: 'Cache', useFactory: Cache, scope: Scope.SINGLETON,}); Copy In this case, the Cache provider will be registered as a global singleton, since the scope parameter was passed and a single instance for all users will be used. "},{"title":"Tokens","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#tokens","content":"Tokens are used as an identifier for the provider in DI. By the value of the token, the provider is registered and the implementation is searched. "},{"title":"Interface","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#interface-1","content":"type token = Token | string; Copy A token can be either a string or a specially created using the createToken function into which an interface can be passed. In this case, you can use both a string and createToken at the same time, the main thing is that the identifier is the same "},{"title":"createToken","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#createtoken","content":"import { createToken } from '@tinkoff/dippy';import { provide } from '@tramvai/core'; const loggerToken = createToken<Logger>('logger'); const provider = provide({ provide: loggerToken, useClass: Logger,}); Copy The main difference is that you can pass an implementation interface to createToken, which will then be used for type checking when getting dependencies and creating providers. "},{"title":"Papi introduction","type":0,"sectionRef":"#","url":"docs/features/papi/introduction","content":"","keywords":""},{"title":"Explanation","type":1,"pageTitle":"Papi introduction","url":"docs/features/papi/introduction#explanation","content":"Often, an application needs microservices that can process user requests and return JSON responses. It is to address these cases that PAPIs were developed. PAPi allows you to implement request handlers that clients can request and receive a response in an arbitrary format, for example, JSON. PAPI allows you to quickly and cheaply implement handlers without raising additional microservices. Papi related sections How to get data from papiHow can I get data from DI in papi routesHow to add a new papi route in the application "},{"title":"How to","type":1,"pageTitle":"Papi introduction","url":"docs/features/papi/introduction#how-to","content":""},{"title":"How to get data from papi","type":1,"pageTitle":"Papi introduction","url":"docs/features/papi/introduction#how-to-get-data-from-papi","content":"papi is available at /${appInfo.appName}/papi. This url was chosen because it would divide many different papi services into 1 application domain. For the example above with adding a route, the resulting url will look like this: /${appInfo.appName}/papi/test where appName is the name passed to createApp To make a request, you need to use PAPI_SERVICE from the module @tramvai/module-http-client, which automatically on the client will make an http request to papi and on the server will simply call the handler function "},{"title":"How can I get data from DI in papi routes","type":1,"pageTitle":"Papi introduction","url":"docs/features/papi/introduction#how-can-i-get-data-from-di-in-papi-routes","content":"For the papi handler, it is possible to set the dependencies that it needs to work. Thus for each call a separate child di-container will be created, which will allow using both SIGNLETON and REQUEST dependencies. import { Module, provide } from '@tramvai/core';import { CREATE_CACHE_TOKEN } from '@tramvai/module-common';import { HTTP_CLIENT } from '@tramvai/module-http-client';import { SERVER_MODULE_PAPI_PUBLIC_ROUTE } from '@tramvai/module-server';import { createPapiMethod } from '@tramvai/papi'; @Module({ providers: [ provide({ provide: SERVER_MODULE_PAPI_PUBLIC_ROUTE, multi: true, useFactory: ({ createCache }) => { const cache = createCache(); // cache must be common for all handler calls, so we call it outside of createPapiMethod return createPapiMethod({ path: '/my/papi', method: 'post', async handler({ httpClient }) { // use what was requested in deps from createPapiMethod if (cache.has('test')) { return 'test'; } const { payload } = await httpClient.get('fake'); return payload; }, deps: { httpClient: HTTP_CLIENT, // the same dependency must be recreated for each call and they must be independent }, }); }, deps: { createCache: CREATE_CACHE_TOKEN, // this is a dependency from the root container, which will be created only once }, }), ],})export class PapiTestModule {} Copy "},{"title":"How to add a new papi route in the application","type":1,"pageTitle":"Papi introduction","url":"docs/features/papi/introduction#how-to-add-a-new-papi-route-in-the-application","content":"There are two ways to define routes. 1 - based on the file structure, 2 - task through providers Using the file api approach# The easiest way to create a PAPI route is to create a directory papi in the root of the project in which to put TS files with handlers. The name of the files will be the URL to the route. For example: we want to create a new papi handler that reads the body of the requests and summarizes the received values. To do this, create a file /papi/getSum.ts with the content:  содержимое getSum.ts import { Request, Response } from '@tramvai/papi';import { CREATE_CACHE_TOKEN } from '@tramvai/module-common'; // в tramvai.json мы добавили указание на директорию с файловым апи// \"commands\": {// \"build\": {// \"options\": {// \"server\": \"server-add-file-api/index.ts\",// \"serverApiDir\": \"server-add-file-api/papi\"// }// }// }// и теперь каждый файл в этой директории будет обработчиком какого-то урла в зависимости от имени самого файла// /${appName}/papi/${fileName} т.е. для текушего файла урл будет /server/papi/getSum // экспортируя переменную rootDeps мы можем запросить зависимости из рутового DI на сервере// эти записимости будут переданы в handler третьим параметромexport const rootDeps = { createCache: CREATE_CACHE_TOKEN,}; // если зависимости при этом надо как-то изначально проиницилизировать, то можно использовать// mapDeps который будет вызван один раз, получит в качестве аргумента зависимости из deps, и// результат этой функции будет использован вместо третьего аргумента в handlerexport const mapRootDeps = ({ createCache }: typeof rootDeps) => { return { cache: createCache('memory'), };}; // handler это наш обработчик который будет вызываться на каждый запрос// тоже самое будет если сделать export defaultexport const handler = (req: Request, res: Response, { cache }: ReturnType<typeof mapRootDeps>) => { const { body: { a, b }, method, } = req; if (method !== 'POST') { throw new Error('only post methods'); } if (!a || !b) { return { error: true, message: 'body parameters a and b should be set', }; } const key = `${a},${b}`; if (cache.has(key)) { return { error: false, fromCache: true, result: cache.get(key) }; } const result = +a + +b; cache.set(key, result); return { error: false, fromCache: false, result };}; Copy  This file can be requested using the client papi, or by calling the url /${appName}/papi/getSum Using providers# It is necessary to add a multi provider SERVER_MODULE_PAPI_PUBLIC_ROUTE in which to add new papi routes import { createPapiMethod } from '@tramvai/papi';import { SERVER_MODULE_PAPI_PUBLIC_ROUTE } from '@tramvai/tokens-server';import { provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: SERVER_MODULE_PAPI_PUBLIC_ROUTE, multi: true, useValue: createPapiMethod ({ method: 'get', // method, can be post, all and so on path: '/test', // path where the route will be available async handler(req, res): Promise<any> { // function that will be called if requests for url come return new Promise({ test: true }); }, }), }), ],})export class PapiTestModule {} Copy And after that the test route will be available "},{"title":"Working with React","type":0,"sectionRef":"#","url":"docs/features/react","content":"","keywords":""},{"title":"Install","type":1,"pageTitle":"Working with React","url":"docs/features/react#install","content":"npm i --save @tramvai/react Copy "},{"title":"DI","type":1,"pageTitle":"Working with React","url":"docs/features/react#di","content":"When creating components, you may need to get data from di, for this there is a hook useDi and HoC withDi "},{"title":"useDi","type":1,"pageTitle":"Working with React","url":"docs/features/react#usedi","content":"type useDi = (deps: Record<string, string | Token>) => Record<string, any>; Copy type useDi = (dep: string | Token) => any; Copy A hook into which we can pass both an object with the required dependencies and an object with data will be returned to us, as well as a single token, where the result will be returned to us. When we call useDi, we get data from di and if we don't find data in di, an error will occur. import React from 'react';import { useDi } from '@tramvai/react'; const MyComponent = () => { const { logger } = useDi({ logger: 'logger' }); // pass the object const Region = useDi(regionToken); // pass a single token logger.info('text'); return ( <div> Component <Region /> </div> );}; Copy "},{"title":"withDi","type":1,"pageTitle":"Working with React","url":"docs/features/react#withdi","content":"type withDi = ( deps: Record<string, string | Token>) => (wrapper: React.ReactElement<any>) => React.ReactElement<any>; Copy A HoC that allows you to wrap any components, get data from DI and pass the result with dependencies to the props of the component import React from 'react';import { withDi } from '@tramvai/react'; @withDi({ logger: LOGGER_TOKEN })class BoxyPage extends Component { render() { this.props.logger.info('text'); return <div>Component</div>; }} Copy "},{"title":"useDiContainer","type":1,"pageTitle":"Working with React","url":"docs/features/react#usedicontainer","content":"type useDiContainer = () => DI.Container; Copy Getting an instance of a DI container that has been added to the application context. It is better not to use this hook, as it is very low-level and is intended for developing new hooks "},{"title":"Error","type":1,"pageTitle":"Working with React","url":"docs/features/react#error","content":"To handle errors during rendering, React uses Error Boundary. This package provides its own version of Error Boundary which will log an error through a generic logger and display a stub for the wrapped component if an error occurs. "},{"title":"ErrorBoundary","type":1,"pageTitle":"Working with React","url":"docs/features/react#errorboundary","content":"Error Boundary component that monitors errors down the tree and, in case of a render error, will log an error and display the fallbackComponent component (passed as a props, by default it is a FallbackError from this package) instead of the fallen render subtree. You can override the fallbackComponent through the ERROR_BOUNDARY_FALLBACK_COMPONENT_TOKEN provider. "},{"title":"FallbackError","type":1,"pageTitle":"Working with React","url":"docs/features/react#fallbackerror","content":"Component used by default as a stub for a subtree in which a render error occurred "},{"title":"withError","type":1,"pageTitle":"Working with React","url":"docs/features/react#witherror","content":"Hook wrapping component in ErrorBoundary. "},{"title":"lazy","type":1,"pageTitle":"Working with React","url":"docs/features/react#lazy","content":"To dynamically import components with SSR support, there is a high order lazy component: import { lazy } from '@tramvai/react'; const LazyComponent = lazy(() => import('./components/foo'), { loading: <div>Загрузка...</div>,}); <LazyComponent />; Copy "},{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/features/routing","content":"Introduction At the lowest level, routing is based on the @tinkoff/router library, which provides convenient hooks for all stages of the router lifecycle. Special modules are involved in integrating the router into the application. It is expected that all application routes are described in the admin area, but it is possible to set static routes at the application code level. NoSpaRouterModule creates a router instance, initializes a router for routing and synchronizes it with a router, registers actions, bundles, validators, redirects and other features to the corresponding router hooks. SpaRouterModule switches the router to use the History API on the client. To use all these features in the application, it is enough to install and enable @tramvai/module-router","keywords":""},{"title":"Create event","type":0,"sectionRef":"#","url":"docs/features/state/create-event","content":"","keywords":""},{"title":"Method Description","type":1,"pageTitle":"Create event","url":"docs/features/state/create-event#method-description","content":"createEvent(eventName: string, payloadCreator?: PayloadTransformer): EventCreator eventName - Unique identifier of the eventpayloadCreator - an optional function that allows you to combine multiple arguments into one, In cases where the event was called with multiple arguments. "},{"title":"Examples","type":1,"pageTitle":"Create event","url":"docs/features/state/create-event#examples","content":"Creating an event without parameters# import { createEvent } from '@tramvai/state'; const userLoadingInformation = createEvent('user loading information'); userLoadingInformation(); Copy Creating an event with parameters# import { createEvent } from '@tramvai/state'; const userInformation = createEvent<{ age: number; name: string }>('user information'); userInformation({ age: 42, name: 'Tom' }); Copy Create event with payload conversion# import { createEvent } from '@tramvai/state'; const itemPrice = createEvent('user information', (info: string, price: number) => ({ [info]: price,})); itemPrice('car', 3000); Copy Using Events in Actions# We create an action in which, after loading the information, we create an event and throw it into context.dispatch import { createAction } from '@tramvai/core';import { createEvent } from '@tramvai/state'; const userInformation = createEvent < { age: number, name: string } > 'user information'; const action = createAction({ name: 'userLoadInformation', fn: async (context) => { const result = await tinkoffRequest({ method: 'information' }); context.dispatch(userInformation(result)); },}); Copy "},{"title":"API","type":0,"sectionRef":"#","url":"docs/features/react-query/api","content":"","keywords":""},{"title":"Explanation","type":1,"pageTitle":"API","url":"docs/features/react-query/api#explanation","content":"For the library to work, the module @tramvai/module-react-query must be added to the tramvai application "},{"title":"Api","type":1,"pageTitle":"API","url":"docs/features/react-query/api#api","content":""},{"title":"createQuery","type":1,"pageTitle":"API","url":"docs/features/react-query/api#createquery","content":"Allows you to create a Query object that can later be used in components using useQuery. Used to execute single data retrieval requests. import { createQuery } from '@tramvai/react-query'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get('api/base'); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); Copy Unique query parameters# To create a generic query that takes parameters for a query, you must return a unique key, you can read more about this in the official documentation section Query Keys As a parameter key you can use: a string, such as key: 'query-name'an array where any serializable data can be used as elements, for example key: ['query-name', false, { bar: 'baz }]a function that takes the parameters with which query is called and returns a string - key: (options) => 'query-name'a function that accepts parameters, with which query is called, and returns an array, where any serializable data can be used as elements - key: (options) => ['query-name', options, { bar: 'baz' }] import { createQuery, useQuery } from '@tramvai/react-query'; const query = createQuery({ key: (id: number) => ['user', id], fn: async (id, { apiClient }) => { const { payload } = await apiClient.get(`api/user/${id}`); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); export function Component({ id }) { const { data, isLoading } = useQuery(query, id); return <div>{isLoading ? 'loading...' : data}</div>;} Copy "},{"title":"useQuery","type":1,"pageTitle":"API","url":"docs/features/react-query/api#usequery","content":"React hook for working with Query object Документация из react-query import { useQuery } from '@tramvai/react-query'; export function Component() { const { data, isLoading } = useQuery(query); return <div>{isLoading ? 'loading...' : data}</div>;} Copy "},{"title":"createInfiniteQuery","type":1,"pageTitle":"API","url":"docs/features/react-query/api#createinfinitequery","content":"Creates an InfiniteQuery object that can later be used in components using useInfiniteQuery. It is used to execute queries to obtain a sequence of data that can be loaded as the component runs. import { createInfiniteQuery } from '@tramvai/react-query'; const query = createInfiniteQuery({ key: 'list', fn: async (_, start = 0, { apiClient }) => { const { payload } = await apiClient.get<Response>('api/list', { query: { count: 30, start, }, }); return payload; }, getNextPageParam: (page: Response) => { return page.nextPage; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); Copy "},{"title":"useInfiniteQuery","type":1,"pageTitle":"API","url":"docs/features/react-query/api#useinfinitequery","content":"React hook for working with the InfiniteQuery object Документация из react-query import { useInfiniteQuery } from '@tramvai/react-query'; export function Component() { const { data, isLoading, fetchNextPage, hasNextPage } = useInfiniteQuery(query); if (isLoading) { return 'loading...'; } return ( <div> <div> {data.pages.map((page) => { return page.list.map((entry) => { return <div key={entry}>{entry}</div>; }); })} </div> {hasNextPage && ( <button type=\"button\" onClick={() => fetchNextPage()}> Load more </button> )} </div> );} Copy "},{"title":"createMutation","type":1,"pageTitle":"API","url":"docs/features/react-query/api#createmutation","content":"Creates a Mutation object that can later be used in components using useMutation. Used to send and modify data in the api. import { createMutation } from '@tramvai/react-query'; const mutation = createMutation({ key: 'post', fn: async (_, data: string, { apiClient }) => { const { payload } = await apiClient.post('api/post', { body: { data, }, }); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); Copy "},{"title":"useMutation","type":1,"pageTitle":"API","url":"docs/features/react-query/api#usemutation","content":"React hook for working with the Mutation object Документация из react-query import { useMutation } from '@tramvai/react-query'; export function Component() { const { isLoading, mutate } = useMutation(mutation); if (isLoading) { return 'loading...'; } return ( <button type=\"button\" onClick={() => mutate('test')}> Send data </button> );} Copy "},{"title":"How-to","type":1,"pageTitle":"API","url":"docs/features/react-query/api#how-to","content":"Examples of using @tramvai/react-query "},{"title":"Create reducer","type":0,"sectionRef":"#","url":"docs/features/state/create-reducer","content":"","keywords":""},{"title":"Method Description","type":1,"pageTitle":"Create reducer","url":"docs/features/state/create-reducer#method-description","content":"createReducer(name, initialState) name - unique name of the reducer. Should not overlap with other reducersinitialState - default reducer state "},{"title":"Typing","type":1,"pageTitle":"Create reducer","url":"docs/features/state/create-reducer#typing","content":"By default, the reducer state type and name are displayed automatically: import { createReducer } from '@tramvai/state'; const userReducer = createReducer('user', { name: 'anonymus' }); Copy Why do we need typing for the name of the reducer at all? Then this reducer will be more convenient to use together with useSelector. If you pass the state type manually, it is desirable to specify the name as the second argument of the generic: import { createReducer } from '@tramvai/state'; type UserState = { name: string }; const userReducer = createReducer<UserState, 'user'>('user', { name: 'anonymus' }); Copy But, you can simply set the desired type for initialState: import { createReducer } from '@tramvai/state'; type UserState = { name?: string }; const userReducer = createReducer('user', {} as UserState); Copy "},{"title":"Subscription to events","type":1,"pageTitle":"Create reducer","url":"docs/features/state/create-reducer#subscription-to-events","content":".on(evnet, reducer) When creating a reducer, the .on method becomes available, which allows you to subscribe to events and return a new state event - an event or a string to which the reducer will be subscribedreducer(state, payload) - a pure function that takes the current state, payload from the event and must return the new state of the reducer An example of using the .on method import { createReducer, createEvent } from '@tramvai/state'; export const userLoadInformation = createEvent < { status: string } > 'user load information';export const userAddInformation = createEvent < { name: string, info: {} } > 'user add information'; const userReducer = createReducer('user', { info: {},}) .on(userLoadInformation, (state, info) => ({ info })) .on(userAddInformation, (state, { name, info }) => ({ ...state, state: { ...state.info, [name]: info, }, })); Copy "},{"title":"Automatic creation of events","type":1,"pageTitle":"Create reducer","url":"docs/features/state/create-reducer#automatic-creation-of-events","content":".createEvents(model) method that removes the need to create and explicitly bind events model - an object in which the key is the event identifier, which will then be passed to createEvent, and the value is the reducer function, which will get into the .on() method and will be called when the events are triggered An example of using the .createEvents method import { createReducer } from '@tramvai/state'; const userReducer = createReducer('user', { info: {},});export const { userLoadInformation, userAddInformation } = userReducer.createEvents({ userLoadInformation: (state, info: { status: string }) => ({ info }), userAddInformation: (state, { name, info }: { name: string; info: {} }) => ({ ...state, state: { ...state.info, [name]: info, }, }),}); Copy It is imperative to describe the types of the payload argument in reducers, otherwise type inference for events will not work. "},{"title":"DevTools","type":0,"sectionRef":"#","url":"docs/features/state/dev-tools","content":"","keywords":""},{"title":"Possible problems","type":1,"pageTitle":"DevTools","url":"docs/features/state/dev-tools#possible-problems","content":"For a better user experience, you need to use a separate redux dev tools extension window, not a tab in chrome developer tools, because otherwise the action history is not saved, see issue. "},{"title":"Performance","type":1,"pageTitle":"DevTools","url":"docs/features/state/dev-tools#performance","content":"Since the entire state of the application with all the actions is quite large, there are noticeable brakes when working with devtools when using jumps over states/events and when a large number of actions are triggered simultaneously. That's why: Use customization techniques to set pickState to reduce the size of data in devtools.Increase the value of the latency parameter (passed to connectViaExtension.connect), which essentially debounces sending actions to the extension, see docs "},{"title":"Additional links","type":1,"pageTitle":"DevTools","url":"docs/features/state/dev-tools#additional-links","content":"Devtools repositoryGetting Started with Redux DevTools Extension  "},{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/features/state/overview","content":"","keywords":""},{"title":"Peculiarities","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#peculiarities","content":"Redux-like state managerBuilt-in library similar to redux-act to reduce boilerplate codeContains bindings to react components such as connect and useSelectorDynamic initialization of reducers. You can register a reducer at any time or generate a new one.Point subscriptions to changes in the states of reducers. When data changes, only the affected connect and useSelector are recalculated, not everything.Support for SSR mode. "},{"title":"Basic concepts","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#basic-concepts","content":"Store - A class that contains the state of all reducers, change subscriptions and is created for each clientReducers - entities in which we describe how data will be stored and transformedEvents - events with which you can change the states of reducersActions - functions that allow you to perform side effects and update data in the store. Similar to redux-thunk "},{"title":"Recommendations","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#recommendations","content":"You cannot mutate data in reducers. Otherwise, due to various optimizations, subscribers will not be notified about the changes.Initialize reducers as early as possible and before using it. Otherwise, when calling dispatch(userLoadInformation()), the reducer will not yet track events and will not receive data.Do not store static data in stores. Since this data will be transferred from the server to the client, the data will be duplicated. Better to put in constants.Break into small reducers. Otherwise, we have a huge reducer that contains a large amount of information and any changes will cause recalculations for a large number of components. "},{"title":"Installation","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#installation","content":"npm i --save @tramvai/state Copy "},{"title":"Basic example","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#basic-example","content":"import { createReducer, createEvent } from '@tramvai/state'; export const userLoadInformation = createEvent('user load information');export const userAddInformation = createEvent('user add information'); const userReducer = createReducer('user', { info: {},}) .on(userLoadInformation, (state, info) => ({ info })) .on(userAddInformation, (state, { name, info }) => ({ ...state, state: { ...state.info, [name]: info, }, })); Copy "},{"title":"React hooks","type":0,"sectionRef":"#","url":"docs/features/state/hooks","content":"","keywords":""},{"title":"useActions","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#useactions","content":"Allows to execute tram actions in React components "},{"title":"Interface","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#interface","content":"actions - one or an array of tram actions If you pass an array to useActions, for typing you need to specify as const - useActions([] as const) "},{"title":"Usage","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#usage","content":"import { useActions } from '@tramvai/state';import { loadUserAction, getInformationAction, setInformationAction } from './actions'; export const Component = () => { // if you pass one action, the payload type for loadUser is automatically deduced const loadUser = useActions(loadUserAction); // if you pass a list of actions, `as const` is required for correct type inference const [getInformation, setInformation] = useActions([ getInformationAction, setInformationAction, ] as const); return ( <div> <div onClick={loadUser}>load user</div> <div onClick={getInformation}>get information</div> <div onClick={() => setInformation({ user: 1 })}>set information</div> </div> );}; Copy "},{"title":"useSelector ()","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#useselector-","content":"Receiving data from the store in components "},{"title":"Interface","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#interface-1","content":"stores: [] - a list of tokens that the selector will subscribe to. Will affect which store changes will trigger an update in the componentselector: (state) => any - the selector itself, this is a function that will be called upon initialization and any changes to the stores passed to stores. The function should return data that can be used in the componentequalityFn?: (cur, prev) => boolean - optional function to change the way of comparing past and new values ​​of a selector "},{"title":"Usage","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#usage-1","content":"To get data from a store, you can use a store name, a reference to a store, or an object with an optional store: 'storeName'storeObject{ store: storeObject, optional: true }{ store: 'storeName', optional: true } You can pass an array of keys, then for correct type inference it is better to use as const: useSelector(['fooStoreName', barStoreObject] as const, ({ foo, bar }) => null); import { useSelector } from '@tramvai/state'; export const Component = () => { const isBrowser = useSelector('media', (state) => state.media.isBrowser); return <div>{isBrowser ? <span>Browser</span> : <span>Desktop</span>}</div>;}; Copy "},{"title":"Optimizations","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#optimizations","content":"In order to reduce the number of component redrawings, after each call to selector, the return values ​​are checked against those that were before. If the returned selector data has not changed, then the component will not be redrawn. For this reason, it is better to get small chunks of information in selectors. Then there is less chance that the component will be updated. For example: we need the user's roles, we write a selector that requests all user data (state) => state.user and now any changes to the user reducer will update the component. It is better if we receive only the necessary data (state) => state.user.roles, in which case the component will be redrawn only when the user's roles change "},{"title":"useStoreSelector","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#usestoreselector","content":"A simplified version of the useSelector hook into which only one store can be passed, created via createReducer. It was made to improve the inference of selector types, since useSelector itself cannot do this due to the use of strings, tokens and BaseStore heirs inside string names "},{"title":"Interface","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#interface-2","content":"store: Reducer - Store created through createReducerselector: (state) => any - the selector itself, this is a function that will be called upon initialization and any changes to the store passed to stores. The function should return data that can be used in the component "},{"title":"Usage","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#usage-2","content":"import { useStoreSelector } from '@tramvai/state';import { createReducer } from '@tramvai/state'; const myStore = createReducer('myStore', { id: '123' }); export const Component = () => { const id = useStoreSelector((myStore, (state) => state.id)); // The id type will be correctly inferred as \"string\" return <div>{id}</div>;}; Copy "},{"title":"Optimizations","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#optimizations-1","content":"The hook is a wrapper over useSelector, so the optimizations are the same. The selector function itself is memoized inside "},{"title":"useStore","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#usestore","content":"Hook to get the state of a specific reducer. Peculiarities: automatically displays the type of statere-renders the component only when the reducer is updatedallows you to create reducers \"on the fly\" "},{"title":"Interface","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#interface-3","content":"store: Reducer - Store created by createReducer "},{"title":"Usage","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#usage-3","content":"Basic example: import { useStore } from '@tramvai/state';import { createReducer } from '@tramvai/state'; const userReducer = createReducer('user', { id: '123' }); export const Component = () => { const { id } = useStore(userReducer); return <div>{id}</div>;}; Copy "},{"title":"Static HTML Export","type":0,"sectionRef":"#","url":"docs/features/static-html-export","content":"","keywords":""},{"title":"Explanation","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#explanation","content":"tramvai static <appName> command run production build of the application, then starts application server, and make requests to all application routes. All responses are saved to .html files inside dist/static directory. This feature is suitable for applications where all pages are independent of dynamic server-side data. You can serve exported HTML files without tramvai server by CDN or any static server. "},{"title":"Usage","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#usage","content":""},{"title":"Development","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#development","content":"Run command to export HTML pages with --serve flag: tramvai static <appName> --serve Copy Open server with exported pages at http://localhost:3000/ "},{"title":"Production","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#production","content":"Run command to export HTML pages: tramvai static <appName> Copy Deploy HTML pages to your server and static assets to your CDN "},{"title":"Static Assets","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#static-assets","content":"All static resources (js, css files) will be loaded according to the url specified in ASSETS_PREFIX env variable. "},{"title":"Limitations","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#limitations","content":"Dynamic pages (routes like /foo/bar/:id) is not supported, tramvai static command only show warnings for this pages. "},{"title":"Project structure","type":0,"sectionRef":"#","url":"docs/get-started/app-structure","content":"","keywords":""},{"title":"Repository type","type":1,"pageTitle":"Project structure","url":"docs/get-started/app-structure#repository-type","content":"Multirepo# The repository structure is designed for one application root-directory├── package.json - description of project dependencies├── tramvai.json - project configuration for `@tramvai/cli`├── env.development.js - environment variables used for local builds of the project├── renovate.json - settings for renovatebot, which automatically creates MR in projects when there are fresh major dependency updates├── README.md - project documentation└── src - application code directory └── ...App block Copy Monorepo# The repository structure is designed for the presence of several applications, and separate shared libraries root-directory├── package.json - description of project dependencies├── tramvai.json - project configuration for `@tramvai/cli`├── env.development.js - environment variables used for local builds of the project├── renovate.json - settings for renovatebot, which automatically creates MR in projects when there are fresh major dependency updates├── README.md - project documentation├── apps - directory with applications│ ├── App block│ ├── App block└── packages - a directory with various libraries / modules that will be shared between applications ├── Lib block └── Lib block Copy "},{"title":"Blocks","type":1,"pageTitle":"Project structure","url":"docs/get-started/app-structure#blocks","content":"Application# app-directory├── index.ts - application entry point├── vendor.ts - description of the vendor application dependencies (react and react-dom by default)├── polyfill.ts - polyfills used by the application (absent by default)├── postcss.js - basic set of postcss settings ├── bundles - list of connected bundles in the application├── components - directory with used components by the application│ ├── features - feature components│ └── shared - shared components├── layers│ ├── layout - global wrappers used in routing│ ├── pages - page components that are used in routing├── modules - custom modules written for the application (absent by default)└── reducers - global reducers, events and selectors (absent by default) Copy "},{"title":"Additional links","type":1,"pageTitle":"Project structure","url":"docs/get-started/app-structure#additional-links","content":"The following links provide detailed definitions of terms bundle, module and a description of the settings tramvai.json ModuleBundleTramvai CLI settings "},{"title":"Required modules","type":0,"sectionRef":"#","url":"docs/get-started/core-modules","content":"","keywords":""},{"title":"Connecting a new module","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#connecting-a-new-module","content":"Connecting a module to an application consists of two steps: Installing a module# npm install @tramvai/module-common Copy Adding to application# import { CommonModule } from '@tramvai/module-common'; createApp({ name: 'new-app', modules: [ CommonModule, // ... ], // ...}); Copy "},{"title":"CommonModule","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#commonmodule","content":"The most basic module, which should always be connected and at the same time should be set to the first in the list of modules (the position of the module determines the priority of the providers included in the DI - the lower the module, the higher the priority of its providers, therefore the presence of a CommonModule as the first module will allow other modules to override which one of basic tramvai functionality). Contains: implementation of actionsbundle managerin-app cache managerteam commanderapplication component registercontextbase loggermodule managerpubsubserver request and response managerstate-manager "},{"title":"RenderModule","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#rendermodule","content":"The module responsible for rendering the application. Renders a React app on the server and builds the entire html page. On the client, it hydrates the layout on the first render and updates the render when the application route changes. "},{"title":"RouterModule","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#routermodule","content":"Application routing: allows you to get information about the current route, make spa transitions, etc. Used by other modules for their work (for example, RenderModule uses it to determine which components should be rendered now). Allows you to set fixed routes in the application through the RouterModule.forRoot method. If fixed routes are not specified, then the ApiClientModule will be required to load data from the admin panel. "},{"title":"ServerModule","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#servermodule","content":"The module is a starting server based on express. Also adds work with papi methods "},{"title":"HttpClientModule","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#httpclientmodule","content":"Module for working with HTTP requests. "},{"title":"ErrorIntercepterModule (optional)","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#errorinterceptermodule-optional","content":"Adds interceptions of global errors and logging of such errors. "},{"title":"LogModule (optional)","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#logmodule-optional","content":"This is not required. Replaces the implementation from CommonModule. However, with this module, the logs will be better formatted, filtered and it will be possible to send logs from the client to the api logs. "},{"title":"SeoModule (optional)","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#seomodule-optional","content":"Adds meta tags to the page, based on the route or explicitly given data in the application. "},{"title":"CacheWarmupModule (optional)","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#cachewarmupmodule-optional","content":"A module for warming up caches on the server when launching an application in production. "},{"title":"Additional links","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#additional-links","content":"The following links contain descriptions of terms action, dependency injection и state management ActionDependency InjectionState management "},{"title":"Сreate an application on tramvai","type":0,"sectionRef":"#","url":"docs/get-started/create-app","content":"","keywords":""},{"title":"System setup","type":1,"pageTitle":"Сreate an application on tramvai","url":"docs/get-started/create-app#system-setup","content":"NodeJS version 10+ is required for tramvai and @tramvai/cli to work "},{"title":"Install tramvai CLI","type":1,"pageTitle":"Сreate an application on tramvai","url":"docs/get-started/create-app#install-tramvai-cli","content":"We will use the tramvai CLI to generate a new project and run in development mode npm i @tramvai/cli -g Copy After that, the command will be available in the terminal tramvai "},{"title":"Generate application","type":1,"pageTitle":"Сreate an application on tramvai","url":"docs/get-started/create-app#generate-application","content":"Now we need to generate the application with tramvai tramvai new new-app Copy After starting, you need to select settings - project template, CI settings and package manager. For a quick start, the default settings are fine. Then the command will generate a starter project with basic modules in the new-app directory "},{"title":"Run application","type":1,"pageTitle":"Сreate an application on tramvai","url":"docs/get-started/create-app#run-application","content":"Now we need to run our project in development mode, for easy development and to check that our project is working. To do this, execute the command cd new-app && npm start Copy This command will start a server in dev mode that will monitor the server and client code. After executing the command, you can go to the address http://localhost:3000/ and see the lifted clean application "},{"title":"Project structure and application initialization process","type":1,"pageTitle":"Сreate an application on tramvai","url":"docs/get-started/create-app#project-structure-and-application-initialization-process","content":"The entry point of the project is src/index.ts, which creates an instance of the tramvai application and connects the necessary modules. The project has already connected basic modules that implement the following functionality: Getting routes (from the admin panel or static routes)Rendering the application on the server and clientStarting the server for the applicationProviding services for working with external / internal API In this case, it is not necessary to use modules from the base tramvai set, you can write your own implementations that implement the interfaces of the base modules When the application starts, the modules' dependencies are initialized and the commands from the chain of actions are executed, during which data requests from the API, rendering, etc. occur. "},{"title":"Additional links","type":1,"pageTitle":"Сreate an application on tramvai","url":"docs/get-started/create-app#additional-links","content":"The links provide information on the structure of the project and the basic modules required for the full-fledged operation of the application. Project structureRequired modules "},{"title":"Documentation overview","type":0,"sectionRef":"#","url":"docs/get-started/overview","content":"","keywords":""},{"title":"First steps","type":1,"pageTitle":"Documentation overview","url":"docs/get-started/overview#first-steps","content":"For the first acquaintance with the framework, it is recommended to take a lesson Create tramvai application "},{"title":"Deep dive","type":1,"pageTitle":"Documentation overview","url":"docs/get-started/overview#deep-dive","content":"You can get acquainted with the concepts that underlie the framework in the section Concepts "},{"title":"Features","type":1,"pageTitle":"Documentation overview","url":"docs/get-started/overview#features","content":"You can learn more about the capabilities of the framework in the section Features "},{"title":"Jedi tricks","type":1,"pageTitle":"Documentation overview","url":"docs/get-started/overview#jedi-tricks","content":"Guides and recipes for solving the most popular tasks are located in the section How-to "},{"title":"API references","type":1,"pageTitle":"Documentation overview","url":"docs/get-started/overview#api-references","content":"The framework API reference, documentation for built-in modules and libraries are located in the section API "},{"title":"Tramvai CLI","type":1,"pageTitle":"Documentation overview","url":"docs/get-started/overview#tramvai-cli","content":"Documentation for Tramvai CLI is on the page CLI "},{"title":"Bundle optimization","type":0,"sectionRef":"#","url":"docs/guides/bundle-optimization","content":"","keywords":""},{"title":"Code Splitting","type":1,"pageTitle":"Bundle optimization","url":"docs/guides/bundle-optimization#code-splitting","content":"Providing the client with the minimum required JavaScript code is one of the most important things in optimizing web applications. Separating entry points when building bundles and dynamically importing modules and using these bans based on routing / custom actions are the main mechanisms for splitting code. When assembling many bundles and dynamic chunks, the problem of code duplication between them arises, which allows you to solve SplitChunksPlugin Tramvai applications have a number of features - a single entry point (platform.js at the exit), dynamic import at the level of each bundle, a separate assembly of the vendor chunk. For an application that has several tramvai bundles for different pages, each page will load at least the platform.js chunk with the common framework and modules code, and the {bundleName} .js chunk with the unique code for the page. Duplicates can be in chunks created under tramvai bundles (for example, ui-kit components), and it is desirable to move this code into common chunks. The CLI offers three strategies for splitting code - one common chunk, many granular shared chunks, and disabling the SplitChunksPlugin. "},{"title":"Disabling SplitChunksPlugin","type":1,"pageTitle":"Bundle optimization","url":"docs/guides/bundle-optimization#disabling-splitchunksplugin","content":"For applications that have only one tramvai bundle for all pages, or separate the bundle for the desktop and mobile versions, in most cases, code separation is not required, and it is worth setting the option \"commonChunk\": false: { \"projects\": { \"{appName}\": { \"commands\": { \"build\": { \"configurations\": { \"commonChunk\": false } } } } }} Copy Why not leave the common chunk if it doesn't interfere? The problem is in third-party libraries that can use dynamic import under the hood, while the application may not use this code, but it may end up in the common chunk, which will be loaded on every page. Also, if your application is serving multiple pages and separating the code at the page component level via @tramvai/react lazy, it makes sense to consider other strategies, since duplicates will appear in dynamic chunks of pages. "},{"title":"Common Chunk","type":1,"pageTitle":"Bundle optimization","url":"docs/guides/bundle-optimization#common-chunk","content":"The strategy is included in the CLI by default, all common code from bundles and dynamic chunks is moved to common-chunk.js. The commonChunkSplitNumber parameter allows you to specify the minimum number of chunks this code should use in order to move it to common. For applications with a lot of bundles, common-chunk.js can include a huge amount of code that is not needed on every single page, and it is worth either increasing the commonChunkSplitNumber or using the Granular Chunks strategy. Example configuration to increase the minimum number of chunks using shared code: { \"projects\": { \"{appName}\": { \"commands\": { \"build\": { \"configurations\": { \"commonChunkSplitNumber\": 5 } } } } }} Copy How to choose a suitable number of commonChunkSplitNumber? Alternatively, the number can be calculated using the formulas commonChunkSplitNumber = bundles / 3 or commonChunkSplitNumber = bundles / 2, where bundles is the number of tramvai bundles that are connected to a specific application, but most likely each application will be better viewed separately. "},{"title":"Granular Chunks","type":1,"pageTitle":"Bundle optimization","url":"docs/guides/bundle-optimization#granular-chunks","content":"A detailed description of using the strategy in Next.js and Gatsby.js The strategy is enabled through the granularChunks parameter, allows you to move the common code into many small chunks, for efficient caching of the common code, and loading only the necessary code on each page. The balance is achieved due to the fact that the common code between at least two (default settings) chunks is placed in a separate chunk with a unique name, and there will be such chunks from one for all the others, to one for every two chunks. Disadvantages of this strategy: significantly more js scripts can be loaded on one page, up to several dozen, which does not significantly affect performance when using HTTP / 2; and less efficient gzip / brotli archiving, which is not so noticeable compared to the reduction in the amount of source code. The granularChunksSplitNumber parameter allows you to override the default number of shared chunks (2), if for some reason you need to reduce the number of resulting chunks: { \"projects\": { \"{appName}\": { \"commands\": { \"build\": { \"configurations\": { \"granularChunks\": true, \"granularChunksSplitNumber\": 3 } } } } }} Copy "},{"title":"Application deploy","type":0,"sectionRef":"#","url":"docs/guides/deploy","content":"","keywords":""},{"title":"Introduction","type":1,"pageTitle":"Application deploy","url":"docs/guides/deploy#introduction","content":"Tramvai is a regular node.js application that can be run using standard tools available in the node.js community. Restrictions are only imposed on the file structure and the need to pass ENV variables to the application "},{"title":"List of actions required to deploy the application","type":1,"pageTitle":"Application deploy","url":"docs/guides/deploy#list-of-actions-required-to-deploy-the-application","content":"build the application in production modefill in assetsbuild a docker container with application filesrun by passing ENV variables "},{"title":"Build the project","type":1,"pageTitle":"Application deploy","url":"docs/guides/deploy#build-the-project","content":"To build the project, you must use the command (before installing the dependencies in the project) tramvai build APP_ID Copy in APP_ID, you must pass the application identifier. After executing the command, the dist directory will appear with the build files for the server and client code "},{"title":"Create a docker container","type":1,"pageTitle":"Application deploy","url":"docs/guides/deploy#create-a-docker-container","content":"Recommended Dockerfile FROM node:14-buster-slimWORKDIR /appCOPY dist/server /app/COPY package.json /app/ENV NODE_ENV='production' EXPOSE 3000CMD [ \"node\", \"--max-http-header-size=80000\", \"/app/server.js\" ] Copy FROM - you can put a 14+ version of the node, preferably an alpine version to reduce the size "},{"title":"Deploy static assets","type":1,"pageTitle":"Application deploy","url":"docs/guides/deploy#deploy-static-assets","content":"The recommended way is to upload files to a CDN, since node.js does not do a very good job of serving static content, so there will be a lot of traffic for our infrastructure. Therefore, for production applications that clients will use, you should always use a CDN. To do this, upload the contents of the dist/client folder to the CDN according to the method you choose, you get the URL at which the files will be available and substitute this url into the ENV variable ASSETS_PREFIX for example ASSETS_PREFIX=https://cdn-domain.com/my-awesome-app/ If you do not need a CDN, then you can see below in the paragraph \"Launching an application without a client CDN\", it is worth using for test benches or not loaded applications "},{"title":"Deploy application","type":1,"pageTitle":"Application deploy","url":"docs/guides/deploy#deploy-application","content":"The application is launched as a normal node.js process with the node command; when starting, it is necessary to pass all the necessary ENV variables (the list of ENVs depends on the modules used by the application). If you do not add ENV variables, the application will not start. Don't forget about the variable ASSETS_PREFIX "},{"title":"Explanation","type":1,"pageTitle":"Application deploy","url":"docs/guides/deploy#explanation","content":""},{"title":"Probes","type":1,"pageTitle":"Application deploy","url":"docs/guides/deploy#probes","content":"If you deploy to kubernetes, then for these cases there are special urls for probes that you need to use /healthz - after starting the application, it always response OK/readyz - after starting the application, it always response OK "},{"title":"Launching an application without a client CDN","type":1,"pageTitle":"Application deploy","url":"docs/guides/deploy#launching-an-application-without-a-client-cdn","content":"Tramvai has a built-in static return server. It is better not to do this, for the reason that nodeJS is not the best tool for this and static will affect the application. In general, everything is the same as in a regular deployment, but you need to add copying user assets to the docker image, for this: add copy files COPY dist/client /app/public/staticschange ENV variable ASSETS_PREFIX Dockerfile example FROM node:14-buster-slimWORKDIR /appCOPY dist/server /app/COPY package.json /app/COPY dist/client /app/public/staticsENV NODE_ENV='production' EXPOSE 3000CMD [ \"node\", \"--max-http-header-size=80000\", \"/app/server.js\" ] Copy When starting the application, you must pass ASSETS_PREFIX=/statics/. When the application starts, the server for serving statistics will rise and all files inside the /public/ directory will be available. Thus, the client will be able to receive data on the url /statics/payment.js "},{"title":"Run locally in a docker container","type":1,"pageTitle":"Application deploy","url":"docs/guides/deploy#run-locally-in-a-docker-container","content":"The device must have https://www.docker.com/products/docker-desktop installed and run the command docker run hello-world We build the project in production mode, we will have an artifact in the dist directory# yarn build Copy Build a docker application image# docker build -t test/myapp . Copy Run the created image# docker run --rm -e DANGEROUS_UNSAFE_ENV_FILES='true' -e ASSETS_PREFIX='http://localhost:4000/static/' -v ${PWD}/env.development.js:/app/env.development.js -v ${PWD}/dist/client:/app/static -e DEV_STATIC=true -p 3000:3000 -p 4000:4000 -d test/myapp Copy To stop the container, you need to get the CONTAINER ID, run the docker ps command and then run the command docker stop <CONTAINER ID> To stop all containers# docker kill $(docker ps --quiet) Copy "},{"title":"Tramvai integration","type":0,"sectionRef":"#","url":"docs/features/state/tramvai-integration","content":"","keywords":""},{"title":"Providers","type":1,"pageTitle":"Tramvai integration","url":"docs/features/state/tramvai-integration#providers","content":"The module @tramvai/module-common connects the StateModule, which makes the provider STORE_TOKEN available in the application, which implements all the possibilities of state management: type Store = { dispatch(event); subscribe(listener); subscribe(reducer, listener); getState(); getState(reducer);} Copy "},{"title":"Change of state","type":1,"pageTitle":"Tramvai integration","url":"docs/features/state/tramvai-integration#change-of-state","content":"The store.dispatch() method is used to change state, for example: import { commandLineListTokens } from '@tramvai/core';import { createEvent, createReducer } from '@tramvai/state';import { STORE_TOKEN } from '@tramvai/tokens-common'; const incEvent = createEvent('inc');const countReducer = createReducer('count', 0).on(inc, (state) => state + 1); const provider = { provide: commandLineListTokens.resolveUserDeps, multi: true, useFactory: ({ store }) => { return function updateCountReducer() { store.dispatch(incEvent()); }; }, deps: { store: STORE_TOKEN, },} Copy "},{"title":"Read state","type":1,"pageTitle":"Tramvai integration","url":"docs/features/state/tramvai-integration#read-state","content":"The store.getState() method is used to get the general state, or the state of a particular reducer. Using store.getState(reducer) is not suitable for optional stores - if you are not sure if the store is connected in the application directly or through modules, use const { storeName = defaultValue } = store.getState() Example: import { commandLineListTokens } from '@tramvai/core';import { createEvent, createReducer } from '@tramvai/state';import { STORE_TOKEN } from '@tramvai/tokens-common'; const userReducer = createReducer('user', {}); const provider = { provide: commandLineListTokens.resolveUserDeps, multi: true, useFactory: ({ store }) => { return function readUserState() { // { user: {} } - get all state const state = store.getState(); // user: {} - get the state of a specific reducer const user = store.getState(userReducer); }; }, deps: { store: STORE_TOKEN, },} Copy "},{"title":"Subscription","type":1,"pageTitle":"Tramvai integration","url":"docs/features/state/tramvai-integration#subscription","content":"The store.subscribe() method is used to subscribe to a global state change, for example: import { commandLineListTokens } from '@tramvai/core';import { createEvent, createReducer } from '@tramvai/state';import { STORE_TOKEN } from '@tramvai/tokens-common'; const incEvent = createEvent('inc');const countReducer = createReducer('count', 0).on(inc, (state) => state + 1); const provider = { provide: commandLineListTokens.resolveUserDeps, multi: true, useFactory: ({ store }) => { return function listenCountState() { let currentState = store.getState(countReducer); const unsubscribe = store.subscribe((nextGlobalState) => { const nextState = store.getState(countReducer); if (currentState !== nextState) { console.log('count reducer state is:', currentState); currentState = nextState; } }); setInterval(() => { store.dispatch(incEvent()); }, 1000); }; }, deps: { store: STORE_TOKEN, },} Copy Or to subscribe to a change in the state of a specific reducer: import { commandLineListTokens } from '@tramvai/core';import { createEvent, createReducer } from '@tramvai/state';import { STORE_TOKEN } from '@tramvai/tokens-common'; const incEvent = createEvent('inc');const countReducer = createReducer('count', 0).on(inc, (state) => state + 1); const provider = { provide: commandLineListTokens.resolveUserDeps, multi: true, useFactory: ({ store }) => { return function listenCountState() { const unsubscribe = store.subscribe(countReducer, (nextState) => { console.log('count reducer state is:', nextState); }); setInterval(() => { store.dispatch(incEvent()); }, 1000); }; }, deps: { store: STORE_TOKEN, },} Copy "},{"title":"Actions","type":1,"pageTitle":"Tramvai integration","url":"docs/features/state/tramvai-integration#actions","content":"The module @tramvai/module-common connects the provider CONTEXT_TOKEN in the application, which, in addition to working with state (under the hood, STORE_TOKEN is used), allows you to run actions: type ConsumerContext = { executeAction(action, payload); dispatch(event); subscribe(listener); getState(); getState(reducer);} Copy An example of using context: import { createAction } from '@tramvai/core';import { createEvent, createReducer } from '@tramvai/state'; const loadUser = createEvent('load user');const userReducer = createReducer('user', { name: 'anonymus' }); userReducer.on(loadUser, (state, payload) => payload); const fetchUserAction = createAction({ name: 'fetchUser', fn: async (context, payload, { httpClient }) => { const { name } = context.getState(userReducer); if (name !== 'anonymus') { return; } const response = await httpClient.get('/user'); context.dispatch(loadUser(response.payload)); }, deps: { httpClient: HTTP_CLIENT, },}); Copy "},{"title":"Creating a tramvai library","type":0,"sectionRef":"#","url":"docs/guides/tramvai-library","content":"","keywords":""},{"title":"Prerequisites","type":1,"pageTitle":"Creating a tramvai library","url":"docs/guides/tramvai-library#prerequisites","content":"Let's consider all important cases using the example of creating a new tramvai module. Let's say the module will provide a new HTTP client to work with the Github API. "},{"title":"Package name","type":1,"pageTitle":"Creating a tramvai library","url":"docs/guides/tramvai-library#package-name","content":"It is highly discouraged to use the @tramvai and @tramvai-tinkoff scopes outside the tramvai repository. If our application is called tincoin, you can, for example, select one of these scopes: @tincoin@tramvai-tincoin@tincoin-core For modules, the prefix is ​​usually module-, for example: @tramvai-tincoin/module-github-api-client "},{"title":"Versioning","type":1,"pageTitle":"Creating a tramvai library","url":"docs/guides/tramvai-library#versioning","content":"The choice of a versioning strategy is entirely yours. We definitely recommend following semver, and we can recommend using unified versioning if: you support monorep with core librariesthese libraries can be linkedand these packages are used in applications all together (or most of them) "},{"title":"Dependencies","type":1,"pageTitle":"Creating a tramvai library","url":"docs/guides/tramvai-library#dependencies","content":"Dealing with library dependencies is not an easy task, and there is no ideal solution, but there are a number of tips to make it easier to manage dependencies. The best place to start is by dividing dependencies into different types: Framework# Examples of such dependencies are react and react-dom, @tramvai/* and @tramvai-tinkoff/*. If we write babel or eslint plugin, it can be @babel/core and eslint. Typically, an end user, such as a tramvai application, is required to install a dependency framework, without them it simply won't work. Therefore, our library should set them to peerDependencies, with the most free versions, for example, if the package is tied to the basic functionality of tramvai, and uses React hooks: { \"peerDependencies\": { \"@tramvai/core\": \"*\", \"react\": \">=16.8\", \"react-dom\": \">=16.8\" }} Copy Singleton# A number of dependencies must be strictly one in the application. Any duplicates are a minus. increase the weight of the application bundle, but libraries such as react or @tinkoff/logger require a single copy in our application. For them, the rule applies as with the framework, you need to install them in peerDependencies, with the most free versions: { \"peerDependencies\": { \"@tinkoff/logger\": \"*\" }} Copy Popular# Many packages are popular enough that chances are they are already being used in the final application. An example of such dependencies is - date-fns, lru-cache, @tinkoff/dippy For them, the rule applies as with the framework, you need to install them in peerDependencies, with the most free versions: { \"peerDependencies\": { \"@tinkoff/dippy\": \"*\", \"date-fns\": \">=2\", \"lru-cache\": \"*\" }} Copy Specific# Let's say our new tramvai module delivers unique functionality to the application that requires a third-party library (or even another package in your monorepo) If we are developing a service to work with the Github API, it might be the @octokit/rest package. In this case, you need to put the library in dependencies, and you can leave the standard range using ^: { \"dependencies\": { \"@octokit/rest\": \"^18.0.0\" }} Copy Development# A dependency may be involved in building your package - for example, rollup or @tramvai/build. The dependency is required to run library tests. The dependency contains the taipings required for the build. In all these cases, even if either is already in peerDependencies, it is worth adding a more specific version to devDependencies, for example: { \"devDependencies\": { \"@tramvai/build\": \"^2.5.0\", \"@types/react\": \"^17.0.0\", \"react\": \"^17.0.0\" }} Copy Exclusion# Of course, there are exceptional cases. For example, tramvai provides many test utilities where all the main @tramvai dependencies were in peerDependencies. As soon as these utilities began to be used not in repositories with applications, but in monoreps with core packages, the problem of missing dependencies appeared, and we moved almost everything from peerDependencies to dependencies Proceed according to the situation and always think about the usability of your product :) "},{"title":"Build","type":1,"pageTitle":"Creating a tramvai library","url":"docs/guides/tramvai-library#build","content":"It is assumed that the final assembly of packages in the context of the application will be done by @tramvai/cli. Therefore, to publish packages written in TypeScript, it suffices to use tsc, and publish many compiled .js and .d.ts files. But building packages into bundles before publishing, for example via rollup or @tramvai/build, gives a number of possibilities: preliminary tree-shaking will cut off all unnecessary, this will have a positive effect on the assembly of the applicationyou can make several bundles for different environments, in CJS or ES modules formatsyou can make a separate bundle for the browser build, separate for the server one - top for libraries with SSR support Detailed documentation on using @tramvai/build is available in documentation "},{"title":"Separating code for server and client","type":0,"sectionRef":"#","url":"docs/guides/universal","content":"","keywords":""},{"title":"Application code","type":1,"pageTitle":"Separating code for server and client","url":"docs/guides/universal#application-code","content":"To execute branches of code or in specific environments, several checks can be used: process.env# When building a project, tramvai cli sets two variables indicating the environment - process.env.SERVER and process.env.BROWSER. Webpack will automatically remove code with a condition that does not match the current environment, for example, the following code will not be included in the server bundle: if (process.env.BROWSER) { console.log(window.innerWidth, window.innerHeight);} Copy To exclude code from a production build, regardless of the environment, you can use the variable process.env.NODE_ENV: if (process.env.NODE_ENV === 'development') { console.log('отладочная информация');} Copy To exclude imported libraries from the assembly, you need to replace the top-level import with require inside the condition: if (process.env.BROWSER) { const logger = require('@tinkoff/logger'); const log = logger('debug'); log.info(window.location.href);} Copy typeof window# For additional optimizations, the babel plugin is used, which turns typeof window from the server assembly to 'undefined', and from the client assembly to 'object', which allows webpack to cut out unnecessary code, for example, the following condition works similarly to checking process.env.BROWSER: if (typeof window !== 'undefined') { console.log(window.innerWidth, window.innerHeight);} Copy package.json# If we needed to replace a whole file, and not specific lines of code, we can move it to a separate folder, describe the implementation for all environments, and add package.json: // module.server.jsexport const CONSTANT = 'SERVER_SIDE'; Copy // module.client.jsexport const CONSTANT = 'CLIENT_SIDE'; Copy Next, in package.json, you need to tell the bundler which code to use for different environments. The main field is used for the server bundle, and the browser field is used for the client bundle: { \"main\": \"./module.server.js\", \"browser\": \"./module.client.js\"} Copy "},{"title":"npm packages","type":1,"pageTitle":"Separating code for server and client","url":"docs/guides/universal#npm-packages","content":"To create a library, the implementation of which should be different on the server and the client, you need to maintain a common export interface, and configure package.json in the same way as in the previous example. For example, the library exports the class Library, and the constant LIBRARY_CONSTANT. Let's create two entry points to our library - server.js и client.js: // server.jsexport class Library { constructor() { // ... }} export const LIBRARY_CONSTANT = 'SERVER_SIDE_LIBRARY'; Copy // client.jsexport class Library { constructor() { // ... }} export const LIBRARY_CONSTANT = 'CLIENT_SIDE_LIBRARY'; Copy Next, in package.json, you need to tell the bundler which code to use for different environments. The main field is used for the server bundle, and the browser field is used for the client bundle: { \"name\": \"library\", \"version\": \"0.1.0\", \"main\": \"server.js\", \"browser\": \"client.js\", \"dependencies\": { ... }} Copy After publishing the library, you can import it into the tramvai application, and not worry about which implementation we get: import { LIBRARY_CONSTANT } from 'library'; // when starting the application via tramvai start, we will see 'SERVER_SIDE_LIBRARY' in the terminal, and 'CLIENT_SIDE_LIBRARY' in the browser consoleconsole.log(LIBRARY_CONSTANT); Copy "},{"title":"tramvai modules","type":1,"pageTitle":"Separating code for server and client","url":"docs/guides/universal#tramvai-modules","content":"New functionality in the tramvai application is added using modules, and as a rule, the behavior of these modules is radically different in different environments, for example: Rendering the application to a string on the server and hydrating the real DOM on the clientStart https serverService worker initialization For this reason, in the tramvai repository, the standard tramvai module template generated via the npm run generate: module command immediately separates the module entry points into server.js and client.js using package.json Let's analyze this using the example of creating a module that adds a service to the application for working with cookie: This service should have a common interface: export interface ICookie { get(key); set(key, value);} Copy And different implementations for server and client environments: // src/cookie.server.ts// server-side implementation requires Request and Response objects to work with cookiesexport class Cookie implements ICookie { constructor({ req, res }) { // ... } get(key) { // ... } set(key, value) { // ... }} Copy // src/cookie.client.ts// the client implementation accesses the Window object directlyexport class Cookie implements ICookie { get(key) { // ... } set(key, value) { // ... }} Copy Add a service to DI using modules: // src/server.tsimport { Module, Scope, provide } from '@tramvai/core';import { REQUEST, RESPONSE } from '@tramvai/tokens-common';import { Cookie } from './cookie.server'; @Module({ providers: [ provide({ provide: 'cookie', useClass: Cookie, scope: Scope.REQUEST, deps: { req: REQUEST, res: RESPONSE, }, }), ],})export class CookieModule {} Copy // src/client.tsimport { Module, Scope, provide } from '@tramvai/core';import { Cookie } from './cookie.client'; @Module({ providers: [ provide({ provide: 'cookie', useClass: Cookie, scope: Scope.SINGLETON, }), ],})export class CookieModule {} Copy Configure package.json: { \"name\": \"@tramvai/module-cookie\", \"version\": \"0.1.0\", \"main\": \"lib/server.js\", \"browser\": \"lib/client.js\", \"dependencies\": { ... }} Copy After importing the module into the application, we get universal access to cookies, and do not think about the environment when using: import { createApp, commandLineListTokens, provide } from '@tramvai/core';import { CookieModule } from '@tramvai/module-cookie'; createApp({ name: 'app', modules: [ // ... CookieModule, ], providers: [ // ... provide({ provide: commandLineListTokens.init, useFactory: ({ cookie }) => { console.log('wuid', cookie.get('wuid')); }, deps: { cookie: 'cookie', }, }), ], // ...}); Copy "},{"title":"Execution of actions depending on conditions","type":0,"sectionRef":"#","url":"docs/how-to/actions-conditions","content":"","keywords":""},{"title":"Using preset limits","type":1,"pageTitle":"Execution of actions depending on conditions","url":"docs/how-to/actions-conditions#using-preset-limits","content":"Let's say we want to execute one action only on the server, and one only on the client, for this there are onlyServer and onlyBrowser restrictions:  Create actions import { createAction } from '@tramvai/core';import { set } from '../store'; export const innerAction = createAction({ name: 'innerAction', fn: (context) => { console.log('execute innerAction'); return context.dispatch(set('innerAction')); }, // conditions not set - the action will be executed by default: // if the action is defined as global (in an application, bundle or page), // then the action will first try to execute on the server - if it succeeds, then it will not be executed again on the client // if the action did not manage to be executed within the limit, then it will be launched on the client, // repeated launches when switching to the page with this action will not be executed, because the last successful execution is remembered // if the action is called explicitly through the context, then such an action will always be executed (the execution limit still affects, // and the data may not always be available with ssr, but the action will always try to execute)}); export const innerServerAction = createAction({ name: 'innerServerAction', fn: (context) => { console.log('execute innerServerAction'); return context.dispatch(set('innerServerAction')); }, // this action can only be executed on the server conditions: { onlyServer: true, },}); export const innerBrowserAction = createAction({ name: 'innerBrowserAction', fn: (context) => { console.log('execute innerBrowserAction'); return context.dispatch(set('innerBrowserAction')); }, // this action can only be executed on the browser conditions: { onlyBrowser: true, },}); Copy   Use actions import { createAction } from '@tramvai/core';import { set } from '../store';import { innerAction, innerBrowserAction, innerServerAction } from './inner'; export const pageServerAction = createAction({ name: 'pageServerAction', fn: async (context) => { console.log('execute pageServerAction'); await context.executeAction(innerAction); await context.executeAction(innerServerAction); await context.executeAction(innerBrowserAction); return context.dispatch(set('pageServerAction')); }, conditions: { pageServer: true, },}); export const pageBrowserAction = createAction({ name: 'pageBrowserAction', fn: async (context) => { console.log('execute pageBrowserAction'); await context.executeAction(innerAction); await context.executeAction(innerServerAction); await context.executeAction(innerBrowserAction); return context.dispatch(set('pageBrowserAction')); }, // this action can only be executed on the browser conditions: { onlyBrowser: true, },}); export const pageAlwaysAction = createAction({ name: 'pageAlwaysAction', fn: async (context) => { console.log('execute pageAlwaysAction'); return context.dispatch(set('pageAlwaysAction')); }, conditions: { always: true, },}); // this action is only executed in the browser, on page load and on every SPA transitionexport const pageBrowserAlwaysAction = createAction({ name: 'pageBrowserAlwaysAction', fn: async (context) => { console.log('execute pageBrowserAlwaysAction'); return context.dispatch(set('pageBrowserAlwaysAction')); }, conditions: { always: true, onlyBrowser: true, },}); Copy  "},{"title":"Create your own restrictions","type":1,"pageTitle":"Execution of actions depending on conditions","url":"docs/how-to/actions-conditions#create-your-own-restrictions","content":"To do this, you need to implement the ActionCondition interface, and add a new limiter to the DI, via the ACTION_CONDITIONALS token:  Create a delimiter import { ActionCondition } from '@tramvai/module-common';import { PAGE_SERVICE_TOKEN } from '@tramvai/tokens-router'; export const condition = ({ pageService,}: { pageService: typeof PAGE_SERVICE_TOKEN;}): ActionCondition => { return { key: 'custom', fn: (checker) => { if (checker.conditions.custom) { const { pathname } = pageService.getCurrentUrl(); console.log(pathname); if (pathname !== '/custom/') { checker.forbid(); } } }, };}; Copy   Create an action with this constraint import { createAction } from '@tramvai/core';import { set } from '../store'; export const customAction = createAction({ name: 'customAction', fn: (context) => { console.log('execute customAction'); return context.dispatch(set('customAction')); }, // you can set your own options, which are then used in their conditions checks conditions: { custom: true, },}); Copy  "},{"title":"Execute actions on specific pages only","type":1,"pageTitle":"Execution of actions depending on conditions","url":"docs/how-to/actions-conditions#execute-actions-on-specific-pages-only","content":"To do this, we use the static property actions for the component that is used on these pages:  Page component import reduceObj from '@tinkoff/utils/object/reduce';import React from 'react';import { PAGE_SERVICE_TOKEN } from '@tramvai/tokens-router';import { useSelector } from '@tramvai/state';import { useDi } from '@tramvai/react';import { store } from '../store';import { pageBrowserAction, pageServerAction, pageAlwaysAction, pageBrowserAlwaysAction,} from '../actions/page';import { customAction } from '../actions/custom'; export function Page() { const state = useSelector(store, (x) => x.actionTest); const pageService = useDi(PAGE_SERVICE_TOKEN); return ( <div> <button type=\"button\" onClick={() => pageService.navigate({ url: '/custom/' })}> Navigate To custom </button> {reduceObj( (acc, v, k) => { return acc.concat( <div> {k} loaded from {v} </div> ); }, [], state )} </div> );} Page.actions = [ pageServerAction, pageBrowserAction, pageAlwaysAction, pageBrowserAlwaysAction, customAction,]; Copy  "},{"title":"Connecting actions and restrictions in the application","type":1,"pageTitle":"Execution of actions depending on conditions","url":"docs/how-to/actions-conditions#connecting-actions-and-restrictions-in-the-application","content":"Let's create an application that connects the actions, constraints, and components from the previous examples:  Application entry point import { createApp, createBundle, provide } from '@tramvai/core';import { ACTION_CONDITIONALS } from '@tramvai/module-common';import { PAGE_SERVICE_TOKEN, ROUTES_TOKEN } from '@tramvai/tokens-router'; import { store } from './store';import { modules } from '../common';import { condition } from './conditions/custom';import { Page } from './components/Page'; const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, }, reducers: [store],}); createApp({ name: 'actions-conditions', modules: [...modules], providers: [ provide({ provide: ACTION_CONDITIONALS, multi: true, useFactory: condition, deps: { pageService: PAGE_SERVICE_TOKEN, }, }), provide({ provide: ROUTES_TOKEN, multi: true, useValue: { name: 'custom', path: '/custom/', }, }), ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Copy  "},{"title":"How to create an action?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-action","content":"","keywords":""},{"title":"Create an action","type":1,"pageTitle":"How to create an action?","url":"docs/how-to/how-create-action#create-an-action","content":"Import createAction and write a function to load data from api and send data to store. import { createAction } from '@tramvai/core';import { loadDepositConfig } from './deposit/reducer'; export const loadDepositAction = createAction({ name: 'load-deposit-config', fn: async (context, payload, deps) => { const data = await deps.apiClient.request({ method: 'deposit_config ' }); return context.dispatch(loadDepositConfig(data)); }, deps: { apiClient: 'tinkoffApiClient', },}); Copy We have created an action that requires the tinkoffApiClient provider to work, this action makes a request for the data and saves the received data to the side. "},{"title":"Run action for a specific page","type":1,"pageTitle":"How to create an action?","url":"docs/how-to/how-create-action#run-action-for-a-specific-page","content":"We have created an action and want to connect it to the application. It is important for us that the action is executed on the server, and the server is waiting for execution. In this case, the data is needed only on a specific page, so we add it to the static actions field of the desired page. import react, { Component } from 'react';import { loadDepositAction } from './loadDepositAction';import { DepositInfo } from './DepositInfo'; class DepositPage extends Component { static actions = [loadDepositAction]; render() { return ( <div> <DepositInfo /> </div> ); }} Copy After that, when the user opens the route, the server will automatically launch the action linked to DepositPage and the data will be loaded "},{"title":"What else is worth reading","type":1,"pageTitle":"How to create an action?","url":"docs/how-to/how-create-action#what-else-is-worth-reading","content":"About createActionHow do actions work "},{"title":"Как вынести компонент в асинхронный чанк?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-async-component","content":"","keywords":""},{"title":"Пример компонента","type":1,"pageTitle":"Как вынести компонент в асинхронный чанк?","url":"docs/how-to/how-create-async-component#пример-компонента","content":"Допустим у нас есть тяжелый React компонент, который изредка используется и мы хотим его грузить только при необходимости. Сейчас у нас такой код: // file heavy.tsxexport const Heavy = () => <div>123</div>; Copy // file page.tsximport Heavy from './heavy.tsx'; const Page = () => ( <> <Heavy /> <Footer /> </>); Copy "},{"title":"Подключаем lazy","type":1,"pageTitle":"Как вынести компонент в асинхронный чанк?","url":"docs/how-to/how-create-async-component#подключаем-lazy","content":"Есть несколько способов вынести компонент в асинхронные чанки Добавить в page.tsx новый враппер для heavy.Вынести код heavy в отдельный файл и в heavy.tsx оставить только async враппер Мы пойдем по пути создания нового файла, так как это позволяет не менять импорты в файлах, которые уже использовали Heavy компонент. И в будущем будет сложнее забыть переиспользовать async компонент: // file heavy-component.tsxexport const Heavy = () => <div>123</div>; Copy // file heavy.tsximport { lazy } from '@tramvai/react'; export const Heavy = lazy(() => import('./heavy-component')); Copy // file page.tsximport Heavy from './heavy.tsx'; const Page = () => ( <> <Heavy /> <Footer /> </>); Copy Мы создали новый файл, вынесли туда весь код компонента Heavy, а в старом файле оставили только сам компонент, который обернули в lazy и заимпортили оригинальный компонент с помощью import. Теперь у нас вместо оригинального Heavy компонента будет асинхронная версия, которую мы загрузим только при отрисовки Page компонента. "},{"title":"Итог","type":1,"pageTitle":"Как вынести компонент в асинхронный чанк?","url":"docs/how-to/how-create-async-component#итог","content":"Компонент Heavy будет загружен при необходимости Дальше компонент будет: Автоматически вынесен в отдельный чанк вебпакомПри отрисовки SSR автоматически загрузит файл и сразу-же отрисует на сервереJS и CSS чанка будут вставлены в HTML с максимальным приоритетомБраузер бесшовно продолжит работу Пример работы в тестовом приложении "},{"title":"Выполнение экшенов на отдельных страницах","type":0,"sectionRef":"#","url":"docs/how-to/actions-execution","content":"","keywords":""},{"title":"Привязка экшенов к конкретной странице","type":1,"pageTitle":"Выполнение экшенов на отдельных страницах","url":"docs/how-to/actions-execution#привязка-экшенов-к-конкретной-странице","content":"Для этого можно использовать статичесикое свойство actions у компонентов - страниц:  Создаем экшены import { createAction } from '@tramvai/core';import { ACTION_EXECUTION_LIMIT } from '../constants';import { set } from '../store'; export const pageInLimit = createAction({ name: 'pageInLimit', fn: async (context) => { console.log('execute pageInLimit'); await context.dispatch(set({ name: 'pageInLimit', value: false })); await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT / 2)); await context.dispatch(set({ name: 'pageInLimit', value: true })); },}); export const pageOutLimit = createAction({ name: 'pageOutLimit', fn: async (context) => { console.log('execute pageOutLimit'); await context.dispatch(set({ name: 'pageOutLimit', value: false })); await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT * 2)); await context.dispatch(set({ name: 'pageOutLimit', value: true })); },}); Copy   Подключаем их на страницу import reduceObj from '@tinkoff/utils/object/reduce';import React from 'react';import { useSelector } from '@tramvai/state';import { store } from '../store';import { pageInLimit, pageOutLimit } from '../actions/page'; export function Page() { const state = useSelector(store, (x) => x.actionTest); return ( <div> {reduceObj( (acc, v, k) => { return acc.concat( <div> {k} = {v.toString()} </div> ); }, [], state )} </div> );} // экшены можно задавать как статичное свойство page-компонента - тогда экшены будут выпоолняться только при переходе на// страницы где указан этот конкретный pageComponentPage.actions = [pageInLimit, pageOutLimit]; Copy  "},{"title":"Привязка экшенов к бандлу","type":1,"pageTitle":"Выполнение экшенов на отдельных страницах","url":"docs/how-to/actions-execution#привязка-экшенов-к-бандлу","content":"Бандлы позволяют группировать страницы, к ним можно привязать экшены, которые будут выполняться для каждой страницы бандла:  Создаем экшены import { createAction } from '@tramvai/core';import { ACTION_EXECUTION_LIMIT } from '../constants';import { set } from '../store'; export const bundleInLimit = createAction({ name: 'bundleInLimit', fn: async (context) => { console.log('execute bundleInLimit'); await context.dispatch(set({ name: 'bundleInLimit', value: false })); await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT / 2)); await context.dispatch(set({ name: 'bundleInLimit', value: true })); },}); export const bundleOutLimit = createAction({ name: 'bundleOutLimit', fn: async (context) => { console.log('execute bundleOutLimit'); await context.dispatch(set({ name: 'bundleOutLimit', value: false })); await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT * 2)); await context.dispatch(set({ name: 'bundleOutLimit', value: true })); },}); Copy   Подключаем их к бандлу import { createBundle } from '@tramvai/core';import { store } from '../store';import { bundleInLimit, bundleOutLimit } from '../actions/bundle';import { Page } from '../components/Page'; export const mainDefault = createBundle({ name: 'mainDefault', components: { pageDefault: Page, }, // укажем наш стор, чтобы он сразу проинициализировался и был подписан на свои события диспатча reducers: [store], // экшены можно указать как часть бандла - тогда эти экшены будут выполняться для всех страниц этого бандла actions: [bundleInLimit, bundleOutLimit],}); Copy  "},{"title":"Общие экшены для приложения","type":1,"pageTitle":"Выполнение экшенов на отдельных страницах","url":"docs/how-to/actions-execution#общие-экшены-для-приложения","content":"Экшены, подключенные к приложению, выполняются на всех страницах:  Создаем экшены import { createAction } from '@tramvai/core';import { ACTION_EXECUTION_LIMIT } from '../constants';import { set } from '../store'; export const globalInLimit = createAction({ name: 'globalInLimit', fn: async (context) => { console.log('execute globalInLimit'); await context.dispatch(set({ name: 'globalInLimit', value: false })); // ставим задержку выполнения меньше, чем лимит выполнения на сервере, чтобы этот экшен точно успел выполниться при ssr await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT / 2)); await context.dispatch(set({ name: 'globalInLimit', value: true })); },}); export const globalOutLimit = createAction({ name: 'globalOutLimit', fn: async (context) => { console.log('execute globalOutLimit'); await context.dispatch(set({ name: 'globalOutLimit', value: false })); // ставим задержку выполнения больше, чем лимит выполнения на сервере, чтобы этот экшен точно не успел выполниться при ssr await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT * 2)); await context.dispatch(set({ name: 'globalOutLimit', value: true })); },}); Copy   Подключаем их к приложению import { createApp, provide } from '@tramvai/core';import { ACTION_EXECUTION_LIMIT } from './constants';import { modules } from '../common';import { globalInLimit, globalOutLimit } from './actions/global';import { mainDefault } from './bundles/mainDefault'; createApp({ name: 'actions-execution', modules: [...modules], providers: [ provide({ // в приложении можно указать лимит на выполнение экшенов на сервере (по умолчанию 500мс) provide: 'limitActionGlobalTimeRun', useValue: ACTION_EXECUTION_LIMIT, }), ], // эта экшены будут выполняться для всех страниц приложения actions: [globalInLimit, globalOutLimit], bundles: { mainDefault: () => Promise.resolve({ default: mainDefault }), },}); Copy  "},{"title":"Как создать бандл?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-bundle","content":"","keywords":""},{"title":"Создание бандла","type":1,"pageTitle":"Как создать бандл?","url":"docs/how-to/how-create-bundle#создание-бандла","content":"Используем метод createBundle и создаем пустой бандл, в который записываем поле name, которое является уникальным идентификатором бандла: import { createBundle } from '@tramvai/core'; export default createBundle({ name: 'coin', components: {},}); Copy "},{"title":"Наполнение компонентами","type":1,"pageTitle":"Как создать бандл?","url":"docs/how-to/how-create-bundle#наполнение-компонентами","content":"Следующим этапом мы добавляем компоненты, которые будут доступны в этом бандле. Ключом являет идентификатор компонента, этот идентификатор можно будет привязать к роуту: import { createBundle } from '@tramvai/core'; import MainPage from '../pages/main';import Layout from '../layouts'; export default createBundle({ name: 'coin', components: { 'page/coin-main': MainPage, 'layout/coin-layout': Layout, },}); Copy При этом можно регистрировать любые компоненты и для разных целей. Например, мы можем зарегистрировать в бандле компоненты модальных окон, попапов и так далее. Вся эти компоненты будут доступны в componentRegistry. "},{"title":"Подключение в приложение","type":1,"pageTitle":"Как создать бандл?","url":"docs/how-to/how-create-bundle#подключение-в-приложение","content":"Теперь нам осталось зарегистрировать бандл в приложении. Для этого добавляем в объект bundles у createApp: ключ: идентификатор бандла. Последняя часть должна быть одинаковой с идентификатором бандла, переданого в name, там используется функция видаlast('platform/coin'.split('/')), иначе не будет подзагрузка бандла на стороне сервера.значение: функция, которая должна вернуть промис, результатом которого будет передан объект. Обычно используют асинхронные чанки вебпака, но можно и написать кастомный лоадер обычных js файлов. Из особенностей, название чанка, должно быть синхронизировано с идентификатором name import { createApp } from '@tramvai/core'; createApp({ bundles: { 'platform/coin': () => import(/* webpackChunkName: \"coin\" */ './bundles/coin'), },}); Copy После этого у нас будет доступен в приложении бандл и после его загрузки, станут доступны привязанные компоненты. Дальше мы можем использовать эти компоненты в роутинге Подробная дока по createBundleПодробная дока по createApp "},{"title":"Дефолтный бандл","type":1,"pageTitle":"Как создать бандл?","url":"docs/how-to/how-create-bundle#дефолтный-бандл","content":"Дефолтный бандл позволяет обрабатывать все (созданные через RouterModule.forRoot) урлы, для которых бандл не задан специально. Делается это так: В index.ts import { createApp } from '@tramvai/core'; createApp({ name: 'myApp', modules: [ // ... ], providers: [ // ... ], bundles: { mainDefault: () => import(/* webpackChunkName: \"mainDefault\" */ './bundles/mainDefault'), },}); Copy В файле bundles/mainDefault.ts import { createBundle } from '@tramvai/core' import { MainPage } from '../layers/pages/MainPage'import { Layout } from '../layers/layout/Layout' export default createBundle({ name: 'mainDefault', components: { pageDefault: MainPage, layoutDefault: Layout, },}) Copy "},{"title":"How to create a module?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-module","content":"","keywords":""},{"title":"Create an empty module","type":1,"pageTitle":"How to create a module?","url":"docs/how-to/how-create-module#create-an-empty-module","content":"We create a basic module, to do this we create an empty class SecurityModule and connect the decorator Module which is required for modules and in which we will add integrations with the application. import { Module } from '@tramvai/core'; @Module({ providers: [],})export class SecurityModule {} Copy The module can already be plugged into the application, but it won't do anything. "},{"title":"Adding providers","type":1,"pageTitle":"How to create a module?","url":"docs/how-to/how-create-module#adding-providers","content":"To do this we need to add providers in the providers field. We had the task to add the headers, for that we will use commandLineListTokens to perform actions for each client and we will use responseManager to which we can write the information about the headers. import { Module, commandLineListTokens, RESPONSE_MANAGER_TOKEN, provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: commandLineListTokens.resolvePageDeps, multi: true, useFactory: ({ responseManager }: { responseManager: typeof RESPONSE_MANAGER_TOKEN }) => function securityHeader() { responseManager.setHeader('X-Frame-Options', 'sameorigin'); }, deps: { responseManager: RESPONSE_MANAGER_TOKEN, }, }), ],})export class SecurityModule {} Copy We have implemented a new multi-provider that has dependencies and is created through useFactory After plugging the module into the application, for each client the useFactory function will be executed first with the deps passed and then the securityHeader function will be called, in which we will write the data into the obtained dependency and thus fulfill our goal. "},{"title":"Include our new module in the application","type":1,"pageTitle":"How to create a module?","url":"docs/how-to/how-create-module#include-our-new-module-in-the-application","content":"Now it remains to plug the module into the application so that it can add its implementation: import { createApp } from '@tramvai/core';import { SecurityModule } from '@tramvai/module-security'; createApp({ modules: [SecurityModule],}); Copy We can add the module not only to the application, but also to another module. To do this, we need to pass in the imports block and then when the MyCommonModule is connected, the SecurityModule will also be automatically connected import { Module } from '@tramvai/core';import { SecurityModule } from '@tramvai/module-security'; @Module({ imports: [SecurityModule], providers: [],})export class MyCommonModule {} Copy "},{"title":"Summary","type":1,"pageTitle":"How to create a module?","url":"docs/how-to/how-create-module#summary","content":"A SecurityModule was created, which will be called for each client and will add the necessary headers Documentation about modulesDocumentation about createAppDocumentation about DI "},{"title":"Как дебажить модули?","type":0,"sectionRef":"#","url":"docs/how-to/how-debug-modules","content":"","keywords":""},{"title":"Отображение логов на сервере","type":1,"pageTitle":"Как дебажить модули?","url":"docs/how-to/how-debug-modules#отображение-логов-на-сервере","content":"Настройки серверных логов задаются в переменных окружения LOG_LEVEL и LOG_ENABLE, при необходимости можно поменять эти настройки в рантайме, через papi метод /{appName}/private/papi/logger с дополнительными query параметрами. Подробнее про доступные параметры можно прочитать в документации @tramvai/module-log LOG_ENABLE='router' // отображает все логи для логгера с идентификатором `router` Copy "},{"title":"Отображение логов на клиенте","type":1,"pageTitle":"Как дебажить модули?","url":"docs/how-to/how-debug-modules#отображение-логов-на-клиенте","content":"Настройки клиентских логов регулируются через методы библиотеки logger. Эти настройки сохраняются в localStorage, поэтому для отображения всех клиентских логов с новыми настройками, надо дополнительно перезагрузить страницу, либо очистить localStorage. import logger from '@tinkoff/logger'; logger.enable('router'); // отображает все логи для логгера с идентификатором `router` Copy "},{"title":"How to create a papi handler?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-papi","content":"","keywords":""},{"title":"Automatic handler creation","type":1,"pageTitle":"How to create a papi handler?","url":"docs/how-to/how-create-papi#automatic-handler-creation","content":"Based on the configuration parameter application.commands.build.options.serverApiDir in tramvai.json (by default folder ./src/api) the directory where the papi handlers are stored is determined. Create a new file in this folder with the name of our new handler, i.e. getSum.ts for our example. The default export from the file will be used as a handler, create it: export default () => { return 'hello';}; Copy We restart the server so that the new handler is added to the papi list. The result of the function call will be used as the body of the response, so now if we turn to the address http://localhost:3000/tincoin/papi/getSum, then in the response we will receive an object with the property payload: 'hello'. Next, let's add logic to our handler: import { Req } from '@tramvai/papi'; // import is needed only for typing, you can do without it or use types from express export default (req: Req) => { const { body: { a, b }, method, } = req; // get all the necessary information from the request object if (method !== 'POST') { throw new Error('only post methods'); // throw an error if we want to process only certain http methods } if (!a || !b) { // check that the required request parameters have been passed return { error: true, message: 'body parameters a and b should be set', }; } return { error: false, result: +a + +b }; // return the result, not forgetting to do all conversions on strings}; Copy There is no need to restart the build, @tramvai/cli will rebuild everything itself after saving the changes to disk. Now you can make a POST request to http://localhost:3000/tincoin/papi/getSum, pass the parameters a and b and get the result. "},{"title":"Creating a handler via provider","type":1,"pageTitle":"How to create a papi handler?","url":"docs/how-to/how-create-papi#creating-a-handler-via-provider","content":"If you need to use other application dependencies from di in the handler, you can add a provider with the SERVER_MODULE_PAPI_PUBLIC_ROUTE token: // ...import { createPapiMethod } from '@tramvai/papi';import { SERVER_MODULE_PAPI_PUBLIC_ROUTE } from '@tramvai/tokens-server';import { LOGGER_TOKEN } from '@tramvai/tokens-common';import { provide } from '@tramvai/core'; createApp({ // ... providers: [ // ... provide({ provide: SERVER_MODULE_PAPI_PUBLIC_ROUTE, multi: true, useFactory: ({ logger }: { logger: typeof LOGGER_TOKEN }) => { const log = logger('ping-pong'); return createPapiMethod({ method: 'get', path: '/ping', async handler() { log.error('/ping requested'); // log with the error level to see the log for sure return 'pong'; }, }); }, deps: { logger: LOGGER_TOKEN, }, }), ],}); Copy Now you can make a request to the address http://localhost:3000/tincoin/papi/ping, in the response we will receive an object with the property payload: 'pong', in the terminal with the running process tramvai start ${APP_ID} we will see the error log /ping requested. "},{"title":"Additional links","type":1,"pageTitle":"How to create a papi handler?","url":"docs/how-to/how-create-papi#additional-links","content":"ServerModule documentation "},{"title":"Как включить modern режим для приложения?","type":0,"sectionRef":"#","url":"docs/how-to/how-enable-modern","content":"","keywords":""},{"title":"Проверяем версии","type":1,"pageTitle":"Как включить modern режим для приложения?","url":"docs/how-to/how-enable-modern#проверяем-версии","content":"Для того, что бы modern режим работал, необходимо проверить, что в приложении используются: @tramvai/module-render > 0.17.0 версии@tramvai/cli > 0.7.32 версии либо обновить все зависимости разом (рекомендуемый способ) "},{"title":"Конфигурируем platform.json","type":1,"pageTitle":"Как включить modern режим для приложения?","url":"docs/how-to/how-enable-modern#конфигурируем-platformjson","content":"Теперь нам нужно включить сборку кода под современные версии браузеров. Для этого добавляем параметр modern: true в platform.json: { \"projects\": { \"tincoin\": { \"name\": \"tincoin\", \"root\": \"src\", \"type\": \"application\", \"commands\": { \"build\": { \"options\": { \"vendor\": \"src/vendor.js\", \"polyfill\": \"src/polyfill.ts\", \"server\": \"src/index.ts\" }, \"configurations\": { \"modern\": true } } } } }} Copy После этого, platform-cli будет собирать две версии каждого js файла, ES5 и ES2017 После выполнения этих этапов, у нас будет собираться статика под 2 типа браузеров и RenderModule будет отдавать для современных браузеров код стандарта ES2017. "},{"title":"Как подключить полифиллы?","type":0,"sectionRef":"#","url":"docs/how-to/how-to-enable-polyfills","content":"","keywords":""},{"title":"Настройка","type":1,"pageTitle":"Как подключить полифиллы?","url":"docs/how-to/how-to-enable-polyfills#настройка","content":"Устанавливаем пак полифилов# npm i --save @tinkoff/pack-polyfills Copy Создаем файл polyfill.ts# Необходимо создать файл polyfill.ts внутри вашего проекта, к примеру src/polyfill.ts и подключить полифилы: import '@tinkoff/pack-polyfills'; Copy Настраиваем @tramvai/cli# После этого необходимо сказать @tramvai/cli о том, что в нашем проекте есть полифилы. Для этого в tramvai.json добавляем для нашего проекта строку \"polyfill\": \"src/polyfill.ts\" в projects[APP_ID].commands.build.options.polyfill пример: { \"projects\": { \"pfphome\": { \"name\": \"pfphome\", \"root\": \"src\", \"type\": \"application\", \"commands\": { \"build\": { \"options\": { \"server\": \"src/index.ts\", \"vendor\": \"src/vendor.ts\", \"polyfill\": \"src/polyfill.ts\" } } } } }} Copy "},{"title":"Как работает загрузка полифилов","type":1,"pageTitle":"Как подключить полифиллы?","url":"docs/how-to/how-to-enable-polyfills#как-работает-загрузка-полифилов","content":"На стороне @tramvai/cli настроена сборка полифилов в отдельный файл, что бы не смешивать с основным кодом. И при каждой сборке у нас будет появляться файл с полифилами. module-render если находит в сборке полифилы, то для каждого клиента встраивает inline код, который проверяет доступность фич в браузере и если браузер не поддерживает какую либо из фич, то тогда мы считаем браузер устаревшим и грузим полифилы. Пример проверки: !window.Promise.prototype.finally || !window.URL || !window.URLSearchParams || !window.AbortController || !window.IntersectionObserver || !Object.fromEntries' "},{"title":"Замена проверки загрузки полифилов","type":1,"pageTitle":"Как подключить полифиллы?","url":"docs/how-to/how-to-enable-polyfills#замена-проверки-загрузки-полифилов","content":""},{"title":"Зачем это может понабиться?","type":1,"pageTitle":"Как подключить полифиллы?","url":"docs/how-to/how-to-enable-polyfills#зачем-это-может-понабиться","content":"Если вам не подходит стандартная проверка на поддерживаемые фичи в браузере и полифилы не грузятся в браузерах где должны. То в таком случае лучше написать в канал #tramvai и мы обновим проверку, либо можете заменить проверку на иную. "},{"title":"Необходимо учитывать","type":1,"pageTitle":"Как подключить полифиллы?","url":"docs/how-to/how-to-enable-polyfills#необходимо-учитывать","content":"POLYFILL_CONDITION должен вернуть true, если не поддерживает браузер какие-либо фичиНе стоит грузить полифилы всем браузерамлучше расширять DEFAULT_POLYFILL_CONDITION дополнительными проверками, а не заменять "},{"title":"Замена проверки","type":1,"pageTitle":"Как подключить полифиллы?","url":"docs/how-to/how-to-enable-polyfills#замена-проверки","content":"Для этого нужно задать провайдер POLYFILL_CONDITION, который находится в import { POLYFILL_CONDITION } from '@tramvai/module-render' и передать новую строку. Пример: Это синтетический пример, но допустим мы хотим дополнительно проверять на присутствие window.Promise в браузере, для этого расширяем DEFAULT_POLYFILL_CONDITION строку. Итоговое выражение должно вернуть true, если не поддерживает браузерами фича import { POLYFILL_CONDITION, DEFAULT_POLYFILL_CONDITION } from '@tramvai/module-render';import { provide } from '@tramvai/core'; const provider = provide({ provide: POLYFILL_CONDITION, useValue: `${DEFAULT_POLYFILL_CONDITION} || !window.Promise`,}); Copy "},{"title":"Добавление своего обработчика урла для приложения","type":0,"sectionRef":"#","url":"docs/how-to/server-add-path-handler","content":"Добавление своего обработчика урла для приложения Tramvai предоставляет возможность обработать любой url приложения самостоятельно, через токены WEB_APP_BEFORE_INIT_TOKEN и WEB_APP_INIT_TOKEN Пример добавления обработчиков import { createApp, provide } from '@tramvai/core';import { WEB_APP_BEFORE_INIT_TOKEN, WEB_APP_INIT_TOKEN } from '@tramvai/module-server';import { LOGGER_TOKEN } from '@tramvai/module-common';import { modules } from '../common'; createApp({ name: 'server', modules: [...modules], bundles: {}, providers: [ provide({ // Подписываемся на событие WEB_APP_BEFORE_INIT_TOKEN чтобы подписаться до всех дефолтных обработчиков provide: WEB_APP_BEFORE_INIT_TOKEN, multi: true, useFactory: ({ logger }) => { const log = logger('my-path'); // в di должна попасть функция от веб-приложения return (app) => { app.use('/my-path', (req, res, next) => { // кук в req не будет так как подписались раньше выставления cookieParser в @tramvai/module-server log.error('request start!', !!req.cookies); next(); }); }; }, deps: { logger: LOGGER_TOKEN, }, }), provide({ // Подписываемся на событие WEB_APP_INIT_TOKEN чтобы подписаться до дефолтного обработчика роутов provide: WEB_APP_INIT_TOKEN, multi: true, useFactory: ({ logger }) => { const log = logger('my-path'); return (app) => { app.use('/my-path', (req, res) => { // кук в req тут уже будут так как подписались после выставления cookieParser в @tramvai/module-server log.error('request start!', !!req.cookies); res.send({ hello: 'world', cookies: req.cookies }); }); }; }, deps: { logger: LOGGER_TOKEN, }, }), ],}); Copy","keywords":""},{"title":"SSR при использование асинхронных компонентов","type":0,"sectionRef":"#","url":"docs/how-to/ssr-async-components","content":"SSR при использование асинхронных компонентов При использовании динамического import для загрузки React компонентов, мы теряем возможность отрендерить его не сервере. Эту проблему решает библиотека @tramvai/react lazy Пример подключения lazy компонента в бандл import { createApp, createBundle } from '@tramvai/core';import { lazy } from '@tramvai/react';import { modules } from '../common'; const bundle = createBundle({ name: 'mainDefault', components: { // оборачиваем импорт в вызов lazy чтобы компонент нормально рендерился на сервере // и скрипты\\стили для компонента предзагружались на клиенте pageDefault: lazy(() => import('./pages/page')), },}); createApp({ name: 'ssr-async-components', modules: [...modules], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Copy","keywords":""},{"title":"Tramvai update in application","type":0,"sectionRef":"#","url":"docs/how-to/tramvai-update","content":"","keywords":""},{"title":"Upgrading to a latest version","type":1,"pageTitle":"Tramvai update in application","url":"docs/how-to/tramvai-update#upgrading-to-a-latest-version","content":"tramvai update by default use latest: tramvai update Copy "},{"title":"Upgrading to a specific version","type":1,"pageTitle":"Tramvai update in application","url":"docs/how-to/tramvai-update#upgrading-to-a-specific-version","content":"The --to flag allows you to specify the exact version: tramvai update --to 1.0.0 Copy "},{"title":"Checking tramvai versions in the app","type":1,"pageTitle":"Tramvai update in application","url":"docs/how-to/tramvai-update#checking-tramvai-versions-in-the-app","content":"The utility @tramvai/tools-check-versions has been created to automatically check the synchronization of tramvai versions. To check, you need to run the command: yarn tramvai-check-versions Copy "},{"title":"Installing the new tramvai package in the app","type":1,"pageTitle":"Tramvai update in application","url":"docs/how-to/tramvai-update#installing-the-new-tramvai-package-in-the-app","content":"tramvai add <packageName> by default installs the package to dependencies: tramvai add @tramvai/module-router Copy The --dev flag will install the package to devDependencies: tramvai add @tramvai/test-unit --dev Copy "},{"title":"Using @tramvai/react-query library","type":0,"sectionRef":"#","url":"docs/how-to/react-query-usage","content":"","keywords":""},{"title":"Basic example with createQuery and useQuery","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#basic-example-with-createquery-and-usequery","content":" Expand import React from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get<string>('api/base'); await new Promise((resolve) => setTimeout(resolve, 50)); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); // eslint-disable-next-line import/no-default-exportexport default function Component() { const { data, isLoading } = useQuery(query); return <div>{isLoading ? 'loading...' : data}</div>;} Copy  "},{"title":"Preloading data on the server for useQuery","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#preloading-data-on-the-server-for-usequery","content":" Expand import React from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get<string>('api/base'); await new Promise((resolve) => setTimeout(resolve, 50)); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); // eslint-disable-next-line import/no-default-exportexport default function Component() { const { data, isLoading } = useQuery(query); return <div>{isLoading ? 'loading...' : data}</div>;} Component.actions = [query.prefetchAction()]; Copy  "},{"title":"Sharing useQuery data between components","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#sharing-usequery-data-between-components","content":" Expand import React, { useState, useEffect } from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get<string>('api/base'); await new Promise((resolve) => setTimeout(resolve, 5000)); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); const Child1 = () => { const { isLoading, data } = useQuery(query); return <div>Child1: {isLoading ? 'loading...' : data}</div>;}; const Child2 = () => { const { isLoading, data } = useQuery(query); return <div>Child2: {isLoading ? 'loading...' : data}</div>;}; const Child3 = () => { const { isLoading, data } = useQuery(query); return <div>Child3: {isLoading ? 'loading...' : data}</div>;}; // eslint-disable-next-line import/no-default-exportexport default function Component() { const [child2, setChild2Visible] = useState(false); const [child3, setChild3Visible] = useState(false); useEffect(() => { setTimeout(() => { setChild2Visible(true); }, 3000); setTimeout(() => { setChild3Visible(true); }, 7000); }, []); return ( <> <Child1 /> {child2 && <Child2 />} {child3 && <Child3 />} </> );} Copy  "},{"title":"Passing parameters for the request","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#passing-parameters-for-the-request","content":" Expand import React, { useState, useEffect } from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const query = createQuery({ key: (parameter: string) => ['api-group', parameter], fn: async (parameter, { apiClient }) => { console.log(`request to ${parameter}`); const { payload } = await apiClient.get<string>(`api/group/${parameter}`); await new Promise((resolve) => setTimeout(resolve, 5000)); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); const Child1 = () => { const { isLoading, data } = useQuery(query, 'test-1'); return <div>Child1: {isLoading ? 'loading...' : data}</div>;}; const Child2 = () => { const { isLoading, data } = useQuery(query, 'test-1'); return <div>Child2: {isLoading ? 'loading...' : data}</div>;}; const Child3 = () => { const { isLoading, data } = useQuery(query, 'test-2'); return <div>Child3: {isLoading ? 'loading...' : data}</div>;};// eslint-disable-next-line import/no-default-exportexport default function Component() { const [child2, setChild2Visible] = useState(false); const [child3, setChild3Visible] = useState(false); useEffect(() => { setTimeout(() => { setChild2Visible(true); }, 3000); setTimeout(() => { setChild3Visible(true); }, 7000); }, []); return ( <> <Child1 /> {child2 && <Child2 />} {child3 && <Child3 />} </> );} Copy  "},{"title":"Setting react-query parameters","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#setting-react-query-parameters","content":" Expand import React from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const query = createQuery({ key: 'time', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get<string>('api/time'); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, }, queryOptions: { refetchOnWindowFocus: true, refetchOnMount: true, },});// eslint-disable-next-line import/no-default-exportexport default function Component() { const { data } = useQuery( query.fork({ refetchInterval: 2000, refetchIntervalInBackground: false, }) ); return <div>{data}</div>;} Copy  "},{"title":"Failed requests","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#failed-requests","content":" Expand import React from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get('api/fail'); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, }, queryOptions: { retryDelay: 500, },});// eslint-disable-next-line import/no-default-exportexport default function Component() { const { data, isLoading, isError, error } = useQuery(query); if (isLoading) { return <div>loading...</div>; } if (isError) { return <div>error: {error.message}</div>; } return <div>{data}</div>;} Copy  "},{"title":"Using conditions for query","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#using-conditions-for-query","content":" Expand import React from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients';import { TAPI_ROLES } from '@tinkoff/roles'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get('api/auth'); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, }, conditions: { requiredCoreRoles: [TAPI_ROLES.REGISTERED], },});// eslint-disable-next-line import/no-default-exportexport default function Component() { const { data = 'no-data', isLoading } = useQuery(query); return <div>{isLoading ? 'loading...' : data}</div>;} Copy  "},{"title":"Basic example for createInfiniteQuery and useInfiniteQuery","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#basic-example-for-createinfinitequery-and-useinfinitequery","content":" Expand import React from 'react';import { createInfiniteQuery, useInfiniteQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; interface Response { nextPage?: number; list: string[];} const query = createInfiniteQuery({ key: 'list', fn: async (_, start = 0, { apiClient }) => { const { payload } = await apiClient.get<Response>('api/list', { query: { count: 30, start, }, }); return payload; }, getNextPageParam: (page: Response) => { return page.nextPage; }, deps: { apiClient: TINKOFF_API_SERVICE, }, infiniteQueryOptions: {},}); // eslint-disable-next-line import/no-default-exportexport default function Component() { const { data, isLoading, fetchNextPage, hasNextPage } = useInfiniteQuery(query); if (isLoading) { return <>loading...</>; } return ( <div> <div> {data!.pages.map((page) => { return page.list.map((entry) => { return <div key={entry}>{entry}</div>; }); })} </div> {hasNextPage && ( <button type=\"button\" onClick={() => fetchNextPage()}> Load more </button> )} </div> );} Copy  "},{"title":"Basic example for createMutation and useMutation","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#basic-example-for-createmutation-and-usemutation","content":" Подробнее import React from 'react';import { createMutation, useMutation } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const mutation = createMutation({ key: 'post', fn: async (_, data: string, { apiClient }) => { const { payload } = await apiClient.post('api/post', { body: { data, }, }); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },});// eslint-disable-next-line import/no-default-exportexport default function Component() { const { isLoading, mutate } = useMutation(mutation); if (isLoading) { return <>loading...</>; } return ( <button type=\"button\" onClick={() => mutate('test')}> Send data </button> );} Copy  "},{"title":"Интеграция с browserslist","type":0,"sectionRef":"#","url":"docs/references/cli/browserslist","content":"","keywords":""},{"title":"Виды env для browserslist","type":1,"pageTitle":"Интеграция с browserslist","url":"docs/references/cli/browserslist#виды-env-для-browserslist","content":"В cli используется определённый список возможных env target для работы с browserslist: modern - используется для сборки клиентского кода для современных браузеровnode - используется при сборке серверного кодаdefaults - используется в остальных случаях, т.е. для сборки клиентского кода для устаревших браузеров "},{"title":"Настройка в cli","type":1,"pageTitle":"Интеграция с browserslist","url":"docs/references/cli/browserslist#настройка-в-cli","content":"По умолчанию в cli используются определения из библиотеки @tinkoff/browserslist-config. Чтобы расширить или переопределить настройки по умолчанию можно использовать любой из способов задания конфига browserslist следуя правилам: Менять конфигурацию можно для env из списка, используемого в cli - как задавать. Если какого-то env в конфиге не будет, то будет использован конфиг по умолчанию.Если необходимо расширить списки по умолчанию, то используйте возможность расширения конфига \"browserslist\": { \"modern\": [ \"extends @tinkoff/browserslist-config\", \"chrome > 25\" ], \"node\": [ \"extends @tinkoff/browserslist-config\" ], \"defaults\": [ \"extends @tinkoff/browserslist-config\", \"chrome > 27\" ]} Copy В случае если необходимо сузить список браузеров, то откажитесь от использования extends @tinkoff/browserslist-config и пропишите список всех браузеров самостоятельно, ориентируясь на список в @tinkoff/browserslist-config. При необходимости сделайте это для всех env - те env которые не будут переопределены будут работать по умолчанию "},{"title":"Дебаг","type":1,"pageTitle":"Интеграция с browserslist","url":"docs/references/cli/browserslist#дебаг","content":"Чтобы проверить работу browserslist можно выполнить следующие команды из корня приложения: npx browserslist --env=modern # покажет список браузеров для modernnpx browserslist --env=node # покажет список поддерживаемых версий nodejsnpx browserslist # покажет список браузеров вместе с legacy браузерами Copy "},{"title":"Нюансы","type":1,"pageTitle":"Интеграция с browserslist","url":"docs/references/cli/browserslist#нюансы","content":""},{"title":"autoprefixer","type":1,"pageTitle":"Интеграция с browserslist","url":"docs/references/cli/browserslist#autoprefixer","content":"Из-за особенностей устройства самого autoprefixer при сборке будет использован только defaults конфиг. Если есть серьёзная заинтересованность в раздельной компиляции css, то напишите, пожалуйста, об этом в slack-чате #tramvai "},{"title":"Основная дока","type":0,"sectionRef":"#","url":"docs/references/cli/base","content":"","keywords":""},{"title":"Установка","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#установка","content":"Глобальная установка на машине разработчика. В терминале будет доступна команда tramvai. npm i -g --registry https://registry.npmjs.org/ @tramvai/cli Copy Локальная установка в проекте npm i --save-dev @tramvai/cli Copy "},{"title":"Команды","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#команды","content":"После любой команды можно набрать --help, к примеру tramvai --help или tramvai start --help. После это в консоли появится описание команды и возможные параметры для использования. tramvai new - генерация нового репозитория с tramvai/cli и tramvaitramvai start - запуск приложений в режиме разработкиtramvai start-prod - запуск приложений в режиме разработки, при этом статика собрана в production режимеtramvai build - сборка приложений для сервера и клиентаtramvai analyze - анализ размер приложенияtramvai generate - кодогенерация различных компонентов. К примеру новых проектов, react компонентов, экшенов, сервис и так далееtramvai update - обновление @tramvai/cli и всех @tramvai и @tramvai-tinkoff зависимостей в приложении (делает дедупликацию зависимостей и запускает миграции)tramvai add - добавление @tramvai или @tramvai-tinkoff зависимости в приложении (делает дедупликацию зависимостей и запускает миграции) "},{"title":"Конфигурация","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#конфигурация","content":"Для работы tramvai-cli обязательно должен в корне проекта быть создан конфигурационный файл в формате json, с описанием используемых проектов. tramvai-cli поддерживает следующие названия конфигурационных файлов: platform.jsontramvai.json "},{"title":"Формат файла конфигурации","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#формат-файла-конфигурации","content":"{ \"projects\": { \"react-app\": { \"name\": \"new-app\", \"root\": \"src\", \"type\": \"application\", \"commands\": { \"build\": { \"options\": { ... }, \"configurations\": { ... } }, \"serve\": { \"configurations\": { ... } } } } }} Copy projects - описание всех проектов, которые доступны в этом репозитории. Поддерживает множество различных приложений в одном репозитории. Реализовывая концепцию монорепы. "},{"title":"Поддержка JSON схемы файла конфигурации в IDE","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#поддержка-json-схемы-файла-конфигурации-в-ide","content":"Ссылка на актуальную JSON схему для tramvai.json - ./node_modules/@tramvai/cli/schema.json Самый простой способ добавить валидацию и автокомплит схемы - добавить ссылку в поле $schema для tramvai.json: { \"$schema\": \"./node_modules/@tramvai/cli/schema.json\", \"projects\": {}} Copy Другой способ - добавление схемы в настройках IDE: Как добавить схему в JetBrains IDE можно посмотреть в официальной документации, кроме добавления ссылки на схему, надо добавить tramvai.json как file path pattern. Как добавить схему в VSCode можно посмотреть в официальной документации Новое приложение, созданное через tramvai new, уже содержит поле $schema в tramvai.json. "},{"title":"Настройки для build этапа","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#настройки-для-build-этапа","content":"Общее описание механизма сборки артефактов и их доставки \"options\": { \"vendor\": \"\", // Путь до vendor файла, если не указан, то не генерируется \"polyfill\": \"\", // Путь до полифилов необходимых для работы приложения, если не указан, то не генерируется \"server\": \"src/server\", // Путь до стартвой точки серверного файла, который будет отдельно собран \"outputServer\": \"dist/server\", // Директория, куда после сборки скопируется серверный код \"outputClient\": \"dist/client\" // Директория, куда после сборки скопируется клиенский код},\"configurations\": { \"commonChunk\": true, // включает генерацию js файла с общим кодом между чанками \"commonChunkSplitNumber\": 3, // количество дубликатов, для выноса в common чанк \"sourceMap\": false, // будут ли сгенерированны сорсмапы для клиентских чанков \"sourceMapServer\": false, // будут ли сгенерированны сорсмапы для серверных чанков \"modern\": true, // Включение отдельной сборки для новых браузеров без дополнительной компиляции \"checkAsyncTs\": false, // включает проверку в фоне типов, подробное описание ниже \"terserParallel\": true, // включает параллельное сжатие \"granularChunks\": false, // Включает разбитие common chunk на множество мелких частей. Потенциально может снизить размер js в сборке \"granularChunksSplitNumber\": 2, // количество дубликатов, для выноса в granular чанки \"generateDataQaTag\": false, // автоматическая генерация уникальных id для реакт компонентов. Депрекейтед! \"definePlugin\": { // конфигурация параметров сборки приложения. Позволяет во время сборки заменить значения на преданные ниже \"prod\": {}, \"dev\": {} }, \"threadLoader\": { // конфигурация параметров многопоточной сборки приложения (https://webpack.js.org/loaders/thread-loader/). }, \"postcss\": { // конфигурация postcss лоадера \"cssLocalIdentName\": \"[hash:base64:5]\", // какой будет идентификатор \"config\": \"postcss.config\" // где расположен конфиг для postcss }, \"alias\": {}, // объект с алисами внутри приложения. Документация подробнее о формате можно прочитать в https://www.npmjs.com/package/babel-plugin-module-resolver \"removeTypeofWindow\": true, // настраивает babel плагин transform-define на замену всех конструкций typeof window на 'undefined' или 'object' в зависимости от окружения \"dedupe\": \"equality\" | \"semver\" | false, // подключение плагина для дедупликации зависимостей, с которыми не справился пакетный менеджер \"svgo\": { \"plugins\": [{ \"cleanupIDs\": false }, { \"collapseGroups\": false }], // плагины для svgo (https://github.com/svg/svgo#what-it-can-do) }, \"imageOptimization\": { // конфигурация процесса оптимизации изображений enabled: true, // включение оптимизации изображений options: {} // опции для гибкой настройки оптимизации (https://github.com/tcoopman/image-webpack-loader#options) }} Copy "},{"title":"Добавление новых параметров конфигурации","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#добавление-новых-параметров-конфигурации","content":"Параметры конфигурации CLI описаны в TypeScript интерфейсах, из них автоматически генерируется JSON Schema. Схема используется для валидации конфига, и применения значений по умолчанию, с помощью ajv. Например, если мы хотим добавить параметр для команды build, для приложения: Описываем параметр в интерфейсе ApplicationBuild "},{"title":"Возможности","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#возможности","content":""},{"title":"Генерация кода","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#генерация-кода","content":"Для упрощения жизни разработчиков в tramvai cli доступна возможность кодогенерации, которая позволяет при выполнении команды сгенерировать шаблонный код. Для запуска генератора, введи в консоли npm tramvai generate и выберете из списка то, что нужно сгенерировать: actionbundlereducerpagecomponentmodule После ввода названия, будет сгенерирован шаблонный файл "},{"title":"Генерация нового проекта","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#генерация-нового-проекта","content":"Для быстрого старта нового проекта добавлена команда tramvai new которая позволяет сгенерировать чистый проект с tramvai и tramvai-cli Установите глобального tramvai-cliВведите команду tramvai new NAME_YOUR_APPИ выберете опции: будет ли это монорепа, нужен ли CI и какие используются тестовые фреймворки После выполнения команды и установки зависимостей, для вас сгенерируется проект "},{"title":"Сборка библиотек","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#сборка-библиотек","content":"Команда tramvai build позволяет собирать библиотеки в отдельные бандлы под разные окружения: CommonJS модули + код стандарта ES2015 (для NodeJS без поддержки ES модулей) - поле main в package.jsonES модули + код стандарта ES2015 (для NodeJS с поддержкой ES модулей) - поле module в package.jsonES модули + код стандарта ES5 (для legacy браузеров) - поле browser в package.jsonES модули + код стандарта ES2017 (для современных браузеров) - поле es2017 в package.json Для создания библиотеки в tramvai.json необходимо добавить проект с типом package: { \"projects\": { \"{{packageName}}\": { \"name\": \"{{packageName}}\", \"type\": \"package\", \"root\": \"libs/{{packageName}}\" } }} Copy Все дополнительные настройки необходимо указать в package.json библиотеки: { \"name\": \"{{packageName}}\", \"version\": \"1.0.0\", \"source\": \"src/index.ts\", // точка входа в библиотеку \"browserSource\": \"src/browser.ts\", // опциональное поле, точка входа в библиотеку для браузерного окружения, использовать если требуется разделить реализации для сервера и браузера \"main\": \"dist/index.js\", // название собранного CommonJS + ES2015 бандла \"module\": \"dist/index.es.js\", // название собранного ESM + ES2015 бандла \"browser\": \"dist/browser.js\", // опциональное поле, название собранного CommonJS + ES2015 бандла, использовать вместе с полем `browserSource` \"es2017\": \"dist/browser.es2017.js\", // название собранного ESM + ES2017 бандла, если не указывать, вычисляется из поля `source` \"sideEffects\": false, \"scripts\": { \"start\": \"tramvai build {{packageName}} --watch\", // продакшн сборка в watch режиме \"build\": \"tramvai build {{packageName}}\" // разовая продакшн сборка }} Copy "},{"title":"Hot refresh в dev-режиме","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#hot-refresh-в-dev-режиме","content":"Есть возможность включить обновление react-компонентов на странице без перезагрузки страницы, аналогичный фиче из React Native. Помимо быстрой перезагрузки страницы (hot-reload), в этом режиме сохраняется значение в хуках useState и useRef. Для возможности принудительно сбросить значения, можно добавить комментарий // @refresh reset - он действует на весь файл. При различных синтаксических и рантайм ошибках, fast-refresh плагин ждет исправления ошибки, затем разработка продолжается в обычном режиме. Ограничения режима: state у классовых компонентов не сохраняетсяuseEffect, useMemo, и useCallback обновляются при каждом изменении кода, независимо от списка их зависимостей, в том числе если список пустой, т.е. useEffect(() => {}, []) будет выполняться постоянно - это не ожидаемое поведение, но приучает писать устойчивый к холостым ререндерам код Подключение режима: \"commands\": { \"serve\": { \"configurations\": { \"hotRefresh\": true } }} Copy Конфигурация режима через настройку hotRefreshOptions, подробная конфигурация в доке react-refresh: \"commands\": { \"serve\": { \"configurations\": { \"hotRefresh\": true, \"hotRefreshOptions\": { \"overlay\": false // отключаем overlay с сообщением об ошибках } } }} Copy "},{"title":"Анализ бандлов приложений","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#анализ-бандлов-приложений","content":"Посмотреть что попадает в бандл# Для это существует отличный плагин webpack-bundle-analyzer который позволяет показать наглядно все файлы Для запуска необходимо выполнить команду npx tramvai analyze APP_ID Copy после этого приложение соберется в проде и откроется новая вкладка в браузере Найти причину попадания зависимости в бандл# Для решения этого кейса существует утилита whybundled которая позволяет распарсить stats.json файл webpack и отобразить причину попадения файла Для использования необходимо выполнить команду npx tramvai analyze APP_ID --plugin whybundled Copy После этого сгенерируется json файл сборки который можно будет анализировать с помощью whybundled. Путь до файла будет отображен в терминале # Хочу найти причину попадания зависимости debug в сборкуnpx whybundled ./dist/client/stats.json debug # Хочу узнать что за собой потянула зависимость debug в сборкуnpx whybundled ./dist/client/stats.json --by debug Copy Больше возможностей можно найти в whybundled "},{"title":"Настройка нотификаций при сборке\\пересборке проекта","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#настройка-нотификаций-при-сборкепересборке-проекта","content":"В файле platform.json можно задать настройки для нотификации по пути commands.serve.notifications. Параметры задаются для пакета webpack-build-notifier. Можно задать как общую конфигурацию, так и отдельную для клиента\\сервера. \"commands\": { \"serve\": { \"notifications\": { \"suppressSuccess\": \"always\", \"server\": { \"suppressWarning\": true }, \"client\": { \"activateTerminalOnError\": true } } }} Copy "},{"title":"Включение сорсмапов в дев-режиме","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#включение-сорсмапов-в-дев-режиме","content":"В platform.json \"commands\": { \"serve\": { \"configurations\": { \"sourceMap\": true } }} Copy "},{"title":"Работа modern в дев-режиме","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#работа-modern-в-дев-режиме","content":"В деве возможно работать только с одним режимом: modern или legacy. По умолчанию выставлен legacy. Для включения modern режима в деве необходимо в platform.json добавить опцию modern: true: \"commands\": { \"serve\": { \"configurations\": { \"modern\": true } }} Copy "},{"title":"Настройка генерации имен css классов","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#настройка-генерации-имен-css-классов","content":"Генерация настраивается через свойства cssLocalIdentNameDev и cssLocalIdentNameProd (или общее cssLocalIdentName которое будет использовано если явно не заданы prod или dev). \"commands\": { \"build\": { \"configurations\": { \"postcss\": { \"cssLocalIdentName\": \"[hash:base64:5]\", // значение по умолчанию, переопределит оба нижних параметра (deprecated) \"cssLocalIdentNameDev\": \"[name]__[local]_[minicss]\", // возможные опции смотри в readme для css-loader https://github.com/webpack-contrib/css-loader \"cssLocalIdentNameProd\": \"[minicss]\", // можно дополнительно указать при генерации тег minicss чтобы генерировать минимальные имена css https://dev.to/denisx/reduce-bundle-size-via-one-letter-css-classname-hash-strategy-10g6 }; }; };}; Copy "},{"title":"Полифиллы для страндартных NodeJS модулей","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#полифиллы-для-страндартных-nodejs-модулей","content":"По умолчанию, webpack начиная с 5й версии, больше не добавляет в бандл полифиллы для браузера, при использовании стандартных NodeJS модулей в универсальном коде, пример таких модулей - crypto, path, process, buffer, etc. В @tramvai/cli явно подключены полифиллы для path и process. Эти модули часто используются, а их полифиллы имеют небольшой размер. "},{"title":"Проверка типов checkAsyncTs","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#проверка-типов-checkasyncts","content":"Включается по флагу “checkAsyncTs”: true Copy При запуске tramvai start будет происходить компиляция ts и проверка типов. Можно задать в формате объекта: \"checkAsyncTs\": { \"failOnBuild\": true, // необязательная опция \"pluginOptions\": {} // необязательная опция}, Copy failOnBuild добавит компиляцию ts при работе tramvai build. Таким образом команда build не будет проходить при невалидном ts. pluginOptions – список дополнительных опций плагина fork-ts-checker-webpack-plugin Если вы хотите переопределить путь до конфига в pluginOptions.tsconfig, его нужно рассчитать относительно папки c tramvai cli, т.е. node_modules/@tramvai/cli. По умолчанию конфиг ищется в корне проекта: \\<rootDir>/tsconfig.json "},{"title":"Дедупликация модулей","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#дедупликация-модулей","content":"Параметр commands.build.configurations.dedupe отвечает за подключение плагина, отвечающего за дедупликацию модулей. Возможные значения: \"equality\" - выбран по умолчанию, строгое сравнение версий, схлопывает импорты пакетов одинаковых версий из разных мест Например, импорты node_modules/package/index.js и node_modules/nested-package/node_modules/package/index.js, в обычном случае положили бы в бандл оба модуля. \"semver\" - сравнение версий пакетов по semver, позволяет схлопнуть дополнительно те импорты, у которых отличаются только minor или patch версии. Например, будут схлопнуты пакеты версий 1.14.0 и 1.16.2 до 1.16.2, 0.14.1 и 0.16.5 до 0.16.5, а пакеты версий 0.0.2 и 0.0.5 останутся без изменений. false - отключает плагин дедупликации "},{"title":"Explanation","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#explanation","content":""},{"title":"Debug приложения","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#debug-приложения","content":"При разработке приложения иногда нужно напрямую продебажить node.js приложение, посмотреть потребление CPU, памяти. Для этого в команды start и start-prod добавлен параметр --debug которая: включит сорсмапы для сборки на клиенте и серверезапустит процесс сервера с флагом --inspect. И далее можно открыть отладчик в chrome devtools - chrome://inspect Source Maps# webpack предлагает несколько видов качества кода при генерации source maps, из них основные это: Исходный код - код до транспиляции и бандлинга, слепок наших исходников, разделенный по модулямТрансформированный код - код после транспиляции лоадерами (etc. babel), разделенный по модулямСгенерированный код - код после транспиляции и бандлинга, разделенный по модулям, все импорты и экспорты заменены на webpack-специфичные Для разработки используются source maps для трансформированного или сгенерированного кода, т.к. скорость их сборки выше, и показан именно тот код, который выполняется в целевом окружении, основное отличие от отладки без source map - указаны модули, в которых находится отлаживаемый код. tramvai генерирует большой общий бандл с серверным кодом, поэтому для отладки серверного кода лучше не увеличивать размер этого файла и использовать source maps в отдельном .js.map файле, который генерируется с исходным кодом приложения. Development# По умолчанию, для клиентского кода включены самые быстрые source maps, для серверного кода source-maps отключены. Флаг --debug активирует генерацию source map с исходным кодом для серверного бандла. Параметр commands.serve.configurations.sourceMap активирует генерацию source map с исходным кодом для клиентского и серверного бандлов. Production# По умолчанию, отключены source maps для клиентского и серверного кода. Флаг --debug активирует генерацию source map с исходным кодом для клиентского и серверного бандлов. Параметр commands.build.configurations.sourceMap активирует генерацию source map с исходным кодом для клиентского бандла. Параметр commands.build.configurations.sourceMapServer активирует генерацию source map с исходным кодом для серверного бандла. "},{"title":"How to","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#how-to","content":""},{"title":"Как можно запустить nodejs приложение в debug режиме?","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#как-можно-запустить-nodejs-приложение-в-debug-режиме","content":"Добавить при запуске приложения параметр --debug tramvai start my-app --debug Copy Далее открыть chrome devTools в левом верхнем углу кликнуть на лого Node.js. В итоге у вас откроется отдельный инспекторовщик вашего node.js приложения и вы можете снять снэпшот памяти, продебажить код и провести профилировку приложения "},{"title":"Получить расширенную информацию о deprecated и warnings","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#получить-расширенную-информацию-о-deprecated-и-warnings","content":"Может быть полезно для получения стектрейса различных предупреждений. Запускает сервер приложения с дополнительными опциями. Например, если при работе приложения отображается лог вида (node:2898) DeprecationWarning: ...(Use `node --trace-deprecation ...` to show where the warning was created) Copy Нужно добавить при запуске приложения параметр --trace tramvai start my-app --trace Copy После запуска приложения с такой опцией логи будут отображаться со стеком вызова. "},{"title":"Как протестировать приложение используя browserstack","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#как-протестировать-приложение-используя-browserstack","content":"Получить доступы к browserstack можно написав в слаке команду /bs Запустите приложение как обычно командой tramvai start и используя инструкцию browserstack настройте локальное тестирование на своей машине. Если всё сделано правильно, то теперь в browserstack можно будет получить доступ к localhost и протестировать работу приложения. "},{"title":"Как протестировать приложение на мобилке или другом устройстве в локальной сети","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#как-протестировать-приложение-на-мобилке-или-другом-устройстве-в-локальной-сети","content":"Необходимо чтобы оба устройства на котором запускается приложение и на котором требуется проверить работу находилось в одной сети. Для организации доступа приложения в сети необходимо: узнать ip адрес машины на которой запускается приложение в интересующей сетизапустить команду tramvai start с параметров staticHost равным этому ip адресу (пример tramvai start tincoin --staticHost 192.168.1.3)с тестового устройства теперь можно будет получить доступ к приложению обратившись по адресу хоста = ip При передаче параметров в @tramvai/cli через npm скрипты необходимо перед параметрами для cli добавить --, т.е. команда должна выглядеть примерно так npm start -- --staticHost 192.168.1.3 "},{"title":"Как ускорить сборку приложения при разработке","type":1,"pageTitle":"Основная дока","url":"docs/references/cli/base#как-ускорить-сборку-приложения-при-разработке","content":"Указать только определённые бандлы для разработки# Приложение может содержать несколько бандлов и чем их больше, тем больше кода в приложении, а, следовательно, и дольше сборка и пересборка проекта в процессе разработки. Чтобы ускорить этот процесс при запуске @tramvai/cli можно указать какие бандлы нужны сейчас для разработки и cli будет собирать только их Бандлы должны находиться в папке bundles и импортироваться из главного файла приложения. При попытке запроса бандлов, которые отключены в данный момент, сервер упадёт с 500-ой ошибкой, т.к. это неожидаемое поведение для сервера, что бандла нет # если нужен только один бандл для разработкиtramvai start myapp --onlyBundles=account# если нужно несколько бандловtramvai start myapp --onlyBundle=account,trading Copy "},{"title":"Experimental settings","type":0,"sectionRef":"#","url":"docs/references/cli/experiments","content":"","keywords":""},{"title":"Настройки Webpack","type":1,"pageTitle":"Experimental settings","url":"docs/references/cli/experiments#настройки-webpack","content":"Сам webpack предоставляет список экспериментальных опций, которые можно задать как и описано в доке через experiments.webpack. Обратите особенно внимание на флаг futureDefaults который позволяет включить все экспериментальные опции, которые планируются включить в следующий мажорный релиз по умолчанию "},{"title":"minicss","type":1,"pageTitle":"Experimental settings","url":"docs/references/cli/experiments#minicss","content":"Задаются через experiments.minicss и позволяют включать экспериментальные настройки для mini-css-extract-plugin useImportModule - включает особый способ компиляции модулей css, который должен ускорить время сборки и уменьшить потребление памяти. Подробнее в оф. доке "},{"title":"browser-timings","type":0,"sectionRef":"#","url":"docs/references/libs/browser-timings","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"browser-timings","url":"docs/references/libs/browser-timings#installation","content":"Install npm package npm i --save @tinkoff/browser-timings Copy "},{"title":"How to","type":1,"pageTitle":"browser-timings","url":"docs/references/libs/browser-timings#how-to","content":"import { browserTimings } from '@tinkoff/browser-timings'; window.addEventListener('load', () => { setTimeout(() => { // setTimeout is necessary in order to get metrics about loadEventEnd const perfData = browserTimings(); }, 0);}); Copy After executing perfData will contain client performance metrics which may be send to any external system for further analysis. Call of the library should be executed only after page load in order to get actual data. Otherwise, it may return empty object without data. "},{"title":"Lib interface","type":1,"pageTitle":"browser-timings","url":"docs/references/libs/browser-timings#lib-interface","content":"export interface Timings { /* Connection timing from client to server */ connection: number; /* How much time backend was preparing response */ backend: number; /* Page download to client */ pageDownload: number; /* Timing of first paint for a page */ 'first-paint': number; /* Timing when DOM becomes interactive */ domInteractive: number; /* DOM building is complete */ domComplete: number; /* Page and every resource were loaded */ pageLoadTime: number; /* Common information about resources and its loading time grouped by type */ download: { html: TimingResource; js: TimingResource; css: TimingResource; img: TimingResource; font: TimingResource; other: TimingResource; };} interface TimingResource { /* Timing of resource loading */ duration: number; /* Byte-size measure of data used by resource */ encodedDecodeSize: number; /* Byte-size measure of data transferred by network. Calculating difference between encodedDecodeSize - transferSize may reveal how much data where stored in browser cache */ transferSize: number;} Copy "},{"title":"Вставка inline-кода для клиента на сервере","type":0,"sectionRef":"#","url":"docs/references/cli/serverInline","content":"","keywords":""},{"title":"Решение","type":1,"pageTitle":"Вставка inline-кода для клиента на сервере","url":"docs/references/cli/serverInline#решение","content":"Для клиента с помощью webpack + babel уже и так происходит транспиляция кода для работы в нужных браузерах. Поэтому нам по сути остаётся специальным образом указать, что некий код предназначен для клиента и потому его нужно собрать особым образом. Правила для сборки определённого кода для клиента: код для вставки должен быть вынесен в отдельный файлв самом файле не должно быть импортов других модулей - на клиенте импорты требуют runtime вебпака, который не знает о тех файлах, которые используются на сервересам код должен быть оформлен в виде экспортируемых функций и эти функции могут использовать только переданные ей аргументы, использование внешних переменных вне тела функции запрещеныимя файла должно оканчиваться на .inline(.es)?.[tj]s - это работает как флаг, указывающий что файл надо собрать клиентским конфигомвместо инлайн кода вставляется как строка вызова экспортируемой функции с передачей ей аргументов - благодаря тому, что для функции преобразование в строку вернёт тело этой функции в виде строки, такая вставка будет работать "},{"title":"Пример","type":1,"pageTitle":"Вставка inline-кода для клиента на сервере","url":"docs/references/cli/serverInline#пример","content":"Создадим файл с инлайн кодом test.inline.ts export const test = (arg: string) => { class Test { log() { console.log({ arg, a: 1, }); } } const t = new Test(); t.log();}; Copy Теперь импортируем функцию и вставляем её в начальный html import { Module } from '@tramvai/core';import { RENDER_SLOTS, ResourceType, ResourceSlot } from '@tramvai/module-render';import { test } from './test.inline'; @Module({ providers: [ { provide: RENDER_SLOTS, multi: true, useFactory: () => { const arg = 'Hello'; return { slot: ResourceSlot.HEAD_SCRIPTS, type: ResourceType.inlineScript, // обратите внимание, что добавляем используем функцию как будто пишем iife функцию, только вместо тела функции используем код импорт из модуля // при этом передаваемые строки надо дополнительно заключать в кавычки payload: `(${test})('${arg}')`, }; }, }, ],})export class CustomModule {} Copy После сборки проекта и запуска страницы в браузере должен получить такой код, вместо изначального <script> (function test(arg) { var Test = /*#__PURE__*/ (function () { function Test() {} var _proto = Test.prototype; _proto.log = function log() { console.log({ arg: arg, a: 1, }); }; return Test; })(); var t = new Test(); t.log(); })('Hello');</script> Copy "},{"title":"browserslist-config","type":0,"sectionRef":"#","url":"docs/references/libs/browserslist-config","content":"","keywords":""},{"title":"Api","type":1,"pageTitle":"browserslist-config","url":"docs/references/libs/browserslist-config#api","content":""},{"title":"defaults","type":1,"pageTitle":"browserslist-config","url":"docs/references/libs/browserslist-config#defaults","content":"Contains config for every supported browser "},{"title":"modern","type":1,"pageTitle":"browserslist-config","url":"docs/references/libs/browserslist-config#modern","content":"Contains config for, so called \"modern\" browser. Browser's versions in this list are higher than for defaults and these browsers support more functionality "},{"title":"node","type":1,"pageTitle":"browserslist-config","url":"docs/references/libs/browserslist-config#node","content":"Contains config for nodejs "},{"title":"legacy","type":1,"pageTitle":"browserslist-config","url":"docs/references/libs/browserslist-config#legacy","content":"Config for legacy but still supported browsers. Currently this is equal to defaults "},{"title":"error-handlers","type":0,"sectionRef":"#","url":"docs/references/libs/error-handlers","content":"","keywords":""},{"title":"Api","type":1,"pageTitle":"error-handlers","url":"docs/references/libs/error-handlers#api","content":"globalErrorHandler = (logger: Logger = console) - init logging of global errorsunhandledRejectionHandler = (logger: Logger = console) - init logging of unhandled rejection promise "},{"title":"Parameters","type":1,"pageTitle":"error-handlers","url":"docs/references/libs/error-handlers#parameters","content":"Logger - used for logging errors export interface Logger { warn: Function; error: Function;} Copy "},{"title":"express-terminus","type":0,"sectionRef":"#","url":"docs/references/libs/express-terminus","content":"","keywords":""},{"title":"Особенности","type":1,"pageTitle":"express-terminus","url":"docs/references/libs/express-terminus#особенности","content":"healthChecks обработчики создаются для express приложения, в отличие от исходной библиотеки, где перезаписываются обработчики события request у объекта сервера. Исходное поведение усложняло добавление общей логики для всех запросов в приложение, в том числе на healthChecks, например, было невозможно добавить заголовок X-App-Id в одном месте, для всех запросов. "},{"title":"eslint-plugin-tramvai","type":0,"sectionRef":"#","url":"docs/references/libs/eslint-plugin-tramvai","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"eslint-plugin-tramvai","url":"docs/references/libs/eslint-plugin-tramvai#подключение","content":"Устанавливаем через npm npm i --save-dev @tinkoff/eslint-config @tinkoff/eslint-config-react @tinkoff/eslint-plugin-tramvai Copy Подключаем в .eslintrc рекомендованные настройки: { \"extends\": [ \"@tinkoff/eslint-config/app\", \"@tinkoff/eslint-config-react\", \"plugin:@tinkoff/tramvai/recommended\" ]} Copy Либо подключаем и конфигурируем плагин вручную: { \"extends\": [ \"@tinkoff/eslint-config/app\", \"@tinkoff/eslint-config-react\" ], \"plugins\": [ \"@tinkoff/tramvai\" ], \"rules\": { \"@tinkoff/tramvai/bundle-chunk-name\": \"warn\" }} Copy "},{"title":"Внутренние правила","type":1,"pageTitle":"eslint-plugin-tramvai","url":"docs/references/libs/eslint-plugin-tramvai#внутренние-правила","content":""},{"title":"bundle-chunk-name","type":1,"pageTitle":"eslint-plugin-tramvai","url":"docs/references/libs/eslint-plugin-tramvai#bundle-chunk-name","content":"В tramvai приложении для правильной работы системы бандлов, необходимо для импортов указывать специальные комментарии для динамических импортов. Это правило позволяет проверить, что для динамических импортов бандлов правильно указан управляющий комментарий webpackChunkName: [name]. Также правило позволяет применить автофикс в большинстве случае. Пример неправильно кода: createApp({ bundles: { 'tramvai/bundle-1': () => import(\"./bundles/bundle1\"), 'tramvai/bundle-2': () => import(/* webpackChunkName: \"randomValue\" */ \"./bundles/bundle2\") }}) Copy Пример правильно кода, после автофикса версии выше: createApp({ bundles: { 'tramvai/bundle-1': () => import(/* webpackChunkName: \"bundle-1\" */ \"./bundles/bundle1\"), 'tramvai/bundle-2': () => import(/* webpackChunkName: \"bundle-2\" */ \"./bundles/bundle2\") }}) Copy Опции: propertyNames: задает массив названий свойств объекта, для которых будет производиться анализ. По умолчанию работает для свойств с именем bundles. "},{"title":"hooks","type":0,"sectionRef":"#","url":"docs/references/libs/hooks","content":"","keywords":""},{"title":"Explanation","type":1,"pageTitle":"hooks","url":"docs/references/libs/hooks#explanation","content":"Working with lib consist of two phases: Adding in the target code hook runner call, e.g. runAsyncHooks, with unique event key and additional parameters. It creates a slot for this event that allow to subscribe on the event.Registering hook handler with registerHooks that will be executed when run... function will be called "},{"title":"Caveats","type":1,"pageTitle":"hooks","url":"docs/references/libs/hooks#caveats","content":"There is different types hooks that are not interoperable. So carefully add new registrations with checking expected hook type. Also you should preserve data chain, e.g. return data with same interface from hook, as it otherwise may break other hooks. "},{"title":"API","type":1,"pageTitle":"hooks","url":"docs/references/libs/hooks#api","content":"Hooks# Create new instance of @tinkoff/hook-runner import { Hooks } from '@tinkoff/hook-runner'; const hookRunner = new Hooks(); Copy registerHooks(key, hooks)# Register new hook for a specific key. runHooks(key, context, payload, options)# Execute sync hooks. payload is passed through every hook and will be returned as a result (it may be changed by hooks). runAsyncHooks(key, context, payload, options)# Executes async hooks using setTimeout. payload is passed to every hook with its initial value. runPromiseHooks(key, context, options) => (payload) => Promise# Execute promise-based hooks. payload is passed through every hook and will be returned as a result (it may be changed by hooks) "},{"title":"Hooks","type":1,"pageTitle":"hooks","url":"docs/references/libs/hooks#hooks-1","content":""},{"title":"Types","type":1,"pageTitle":"hooks","url":"docs/references/libs/hooks#types","content":"sync# Accepts (context, payload, options). Hooks are running in order passing previous hook result as input for next hook. async# Accepts (context, payload, options). Hooks are running independently from each other. promise# Accepts (context, payload, options). Hooks are running in order passing previous hook result as input for next hook with wrapping call in promise. "},{"title":"is-modern-lib","type":0,"sectionRef":"#","url":"docs/references/libs/is-modern-lib","content":"","keywords":""},{"title":"Использование","type":1,"pageTitle":"is-modern-lib","url":"docs/references/libs/is-modern-lib#использование","content":"Пример на основе кода из статьи Publish, ship, and install modern JavaScript // webpack.config.jsconst { modernLibsFilter } = require('@tinkoff/is-modern-lib'); module.exports = { module: { rules: [ // Transpile for your own first-party code: { test: /\\.[cm]?js$/i, loader: 'babel-loader', exclude: /node_modules/, }, // Transpile modern dependencies: { test: /\\.[cm]?js$/i, include: modernLibsFilter, use: { loader: 'babel-loader', options: { babelrc: false, configFile: false, presets: ['@babel/preset-env'], }, }, }, ], },}; Copy "},{"title":"http-client","type":0,"sectionRef":"#","url":"docs/references/libs/http-client","content":"","keywords":""},{"title":"API","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#api","content":""},{"title":"HttpClient","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#httpclient","content":"type HttpClient = { // common method for sending HTTP requests request<P = any>(request: HttpClientRequest): Promise<HttpClientResponse<P>>; // method for sending GET requests get<R = any>( path: string, payload?: Pick<HttpClientRequest, 'query' | 'headers'>, config?: Omit<HttpClientRequest, 'url' | 'query' | 'body' | 'headers'> ): Promise<HttpClientResponse<R>>; // method for sending POST requests, uses `requestType: 'json'` by default post<R = any>( path: string, payload?: Pick<HttpClientRequest, 'query' | 'body' | 'headers'>, config?: Omit<HttpClientRequest, 'url' | 'query' | 'body' | 'headers'> ): Promise<HttpClientResponse<R>>; // method for sending PUT requests, uses `requestType: 'json'` by default put<R = any>( path: string, payload?: Pick<HttpClientRequest, 'query' | 'body' | 'headers'>, config?: Omit<HttpClientRequest, 'url' | 'query' | 'body' | 'headers'> ): Promise<HttpClientResponse<R>>; // method for sending DELETE requests delete<R = any>( path: string, payload?: Pick<HttpClientRequest, 'query' | 'headers'>, config?: Omit<HttpClientRequest, 'url' | 'query' | 'body' | 'headers'> ): Promise<HttpClientResponse<R>>; // method for creating a new instance of the HTTP client, based on the settings of the current fork(options?: HttpClientRequest, mergeOptionsConfig?: { replace?: boolean }): HttpClient;} Copy "},{"title":"HttpClientRequest","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#httpclientrequest","content":"type HttpClientRequest = { // absolute url of the request, do not use simultaneously with `path` url?: string; // url of the request, not to be used simultaneously with `url` path?: string; // base url, which is added to all queries before the `path` value baseUrl?: string; // basic HTTP methods are supported - GET, POST, PUT, DELETE method?: HttpMethod; // request data type, `form` by default requestType?: HttpContentType; // response data type, is calculated from the `content-type` header by default responseType?: HttpContentType; // HTTP request headers headers?: Record<string, any>; // request query parameters query?: Record<string, any>; // request body body?: Record<string, any>; // request execution time limit, in ms timeout?: number; // disabling logging inside the HTTP client. It is recommended to use if a request error is logged manually silent?: boolean; // disabling the request cache cache?: boolean; // if `abortPromise` is resolved, the request will be canceled abortPromise?: Promise<void>; // method to modify request data modifyRequest?: (req: HttpClientRequest) => HttpClientRequest; // method to modify response data modifyResponse?: <P = any>(res: HttpClientResponse<P>) => HttpClientResponse<P>; // method to modify the error object modifyError?: (error: HttpClientError, req: HttpClientRequest) => HttpClientError; [key: string]: any;} Copy "},{"title":"HttpClientResponse","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#httpclientresponse","content":"type HttpClientResponse<P = any> = { // response body payload: P; // HTTP response code status: number; // HTTP response headers headers: Record<string, any>;} Copy "},{"title":"HttpClientError","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#httpclienterror","content":"type HttpClientError = Error & { [key: string]: any;} Copy "},{"title":"ApiService","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#apiservice","content":"ApiService - abstract class for easy creation of services for working with API, allows you to override custom logic in the request method, on top of which the rest of the basic methods work. For example, a service that automatically displays a pop-up window when a request error occurs: class CustomApiService extends ApiService { constructor({ httpClient }: { httpClient: HttpClient }) { super(httpClient); } request<R = any>(request: HttpClientRequest): Promise<HttpClientResponse<R>> { return this.httpClient.request(request).catch((error) => { alert(error); }); }} const service = new CustomApiService({ httpClient }); service.request({ path: 'fake' }) // show alertservice.get('fake') // also show alert Copy "},{"title":"Layout factory","type":0,"sectionRef":"#","url":"docs/references/libs/layout-factory","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"Layout factory","url":"docs/references/libs/layout-factory#подключение","content":"Необходимо установить @tinkoff/layout-factory с помощью npm npm i @tinkoff/layout-factory Copy И подключить в проекте import React from 'react';import { createLayout } from '@tinkoff/layout-factory';import { Content, Page, Feedback } from './components';import { layoutWrapper, feedbackWrapper } from './wrappers'; const MyLayout = createLayout({ components: { page: Page, content: Content, feedback: Feedback, }, wrappers: { layout: layoutWrapper, feedback: feedbackWrapper, }}); Copy "},{"title":"Структура лейаута","type":1,"pageTitle":"Layout factory","url":"docs/references/libs/layout-factory#структура-лейаута","content":"Концептуально лейаут имеет следующую структуру <LayoutWrapper> {globalComponents} <ContentWrapper> <HeaderWrapper> <Header /> </HeaderWrapper> <PageWrapper>{page}</PageWrapper> <FooterWrapper> <Footer /> </FooterWrapper> </ContentWrapper></LayoutWrapper> Copy Каждый враппер может быть кастомизирован. По умолчанию все врапперы просто отрисовывают переданные в них children. HeaderWrapper и FooterWrapper отрисовываются только если были переданы компоненты Header и Footer в props полученного лейаут компонента. "},{"title":"Способы кастомизации","type":1,"pageTitle":"Layout factory","url":"docs/references/libs/layout-factory#способы-кастомизации","content":"Кастомизировать создаваемый лейаут можно через опции components и wrappers "},{"title":"Components","type":1,"pageTitle":"Layout factory","url":"docs/references/libs/layout-factory#components","content":"React компоненты header, footer, layout, content, page - это базовые компоненты для врапперов. Должны рендерить переданные в них children. По умолчанию layout, content, page - это \"render children\", а header и footer - \"render prop\"все остальные компоненты - globalComponents. Отрисовываются как компоненты внутри LayoutWrapper "},{"title":"Wrappers","type":1,"pageTitle":"Layout factory","url":"docs/references/libs/layout-factory#wrappers","content":"HOC для components header, footer, layout, content, page - HOC для базовых компонентоввсе остальные wrappers - HOC для соответствующих globalComponents Можно указывать список из HOC, в таком случае очередность выполнения рендера обворачиваемого компонента от конца в начало Такие врапперы нужны чтобы: скрывать/показывать элементы по необходимостинавешивать дополнительные css стиили для компонентоввстраивать дополнительную логику/обработчикипрокидывать дополнительные props Пример такого враппера function layoutWrapper(WrappedComponent) { return (props) => ( <div className=\"ui-layout\"> <WrappedComponent {...props} /> </div> );} Copy "},{"title":"meta-tags-generate","type":0,"sectionRef":"#","url":"docs/references/libs/meta-tags-generate","content":"","keywords":""},{"title":"Api","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#api","content":"Meta({ list: [] }): Meta - объект используемый для конструирования объекта мета-тегов на основании заданных источников.Render(meta: Meta): { render(): string } - рендер конкретного объекта Meta в виде строки (используется для SSR)Update(meta: Meta): { update(): void } - обновляет верстку мета-тегов в браузере (используется в браузере при SPA-переходах) "},{"title":"Пример использования","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#пример-использования","content":"import { Meta, Render, Update } from '@tinkoff/meta-tags-generate'; const list = [ (walker) => walker.updateMeta(10, { title: 'test', tag: { tag: 'meta', attributes: { link: 'link' } }, }),];const meta = new Meta({ list, converters }); const metaContent = new Render(meta).render();console.log(metaContent); // > <title>test</title><meta link=link/> new Update(meta).update(); // Удалит все старые мета теги и заменит новыми Copy "},{"title":"Источники","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#источники","content":"В мета теги можно передать источник данных в параметр list которые будут вызваны в рантайме для сбора итогового результата. Например: const list = [ (walker) => walker.updateMeta(10, { title: 'test', tag: { tag: 'meta', attributes: { link: 'link' } }, }), (walker) => walker.updateMeta(20, { title: 'tinkoff', ogTitle: 'tinkoff', }),];const meta = new Meta({ list, converters }); Copy При генерации мета тегов будет вызваны по порядку функции из list в который будет прокинут класс walker. Внутри функции можно смодифицировать данные вызывая метод updateMeta в который передается приоритет правок и параметры. Элементы с более высоким приоритетом, перезаписывают значения более низких "},{"title":"Параметры","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#параметры","content":"Библиотека принимает параметры с определенным типом, которые позволяют сгенерировать html теги. Для этого нужно передать в значение следующий формат данных { customTag: { tag: 'meta', attributes: { name: 'k', content: 'i' }, innerHtml: '1' }} Copy в итоге после преобразований, получится следующий тег: <meta name=\"k\" content=\"i\">1</meta> Copy "},{"title":"Удаление meta параметров","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#удаление-meta-параметров","content":"Для удаление данных, нам нужно в поле value вставить null значение Например мы хотим удалить keywords свойство: (walker) => walker.updateMeta(30, { keywords: null, }); Copy После выполнения этого источника, мета тег удалится "},{"title":"Конвертеры","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#конвертеры","content":"Для упрощения использования библиотеки, мы можем передать в Meta список конвертеров в параметров converters new Meta({ list, converters: { title: (value) => ({ tag: 'meta', innerHtml: value }) } }); Copy При построения мета тегов, мы будем пытаться получить по ключу в блоке converters функцию для преобразования. И это нам позволяет передавать мета параметры вида { title: 'Тинькофф' } "},{"title":"minicss","type":0,"sectionRef":"#","url":"docs/references/libs/minicss","content":"","keywords":""},{"title":"Установка","type":1,"pageTitle":"minicss","url":"docs/references/libs/minicss#установка","content":"Устанавливаем через package manager yarn add --dev @tinkoff/minicss-class-generator Copy или npm i --save-dev @tinkoff/minicss-class-generator Copy "},{"title":"Подключение","type":1,"pageTitle":"minicss","url":"docs/references/libs/minicss#подключение","content":"В файле конфига для вебпака для лоадера css-loader определяем параметры localIdentName и getLocalIdent: ({ loader: 'css-loader', options: { modules: { getLocalIdent: createGenerator(), localIdentName: '[minicss]' }, },}) Copy В localIdentName можно передать произвольный шаблон и использовать возможности из css-loader. Например: я хочу добавить название оригинального файла и className, для этого могу прописать [name]__[local]_[minicss] "},{"title":"Принцип работы","type":1,"pageTitle":"minicss","url":"docs/references/libs/minicss#принцип-работы","content":"Плагин генерирует уникальный хэш ключ для className по формуле - ${порядок}${contentHash} при этом, contentHash - хэш от контента файла, порядок - инкрементальный ключ порядка внутри файла, каждая генерация ключа увеличивает параметр и тем самым соблюдается уникальность внутри файла. За счет того, что у нас contentHash общий для всего файла, мы меньше генерируем уникальных ключей и gzip/brotli лучше сжимает данные Пример работы: [hash:base64:5]file: Button.css .2hlLi .32BZU Copy [minicss]file: Button.css .abhUzy .bbhUzy Copy "},{"title":"logger","type":0,"sectionRef":"#","url":"docs/references/libs/logger","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#подключение","content":"Устанавливаем npm модуль npm i --save @tinkoff/logger Copy или yarn add @tinkoff/logger Copy "},{"title":"Использование библиотеки","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#использование-библиотеки","content":"import logger from '@tinkoff/logger'; // импорт логгера const log = logger('my-component'); // создаем новый логер с идентификатором my-component. Этот индетификатор будет добавлен к каждому логу в поле name. Стоит задавать уникальные индетификаторы, так как можно будет проще найти логи // мы можем логировать данные с разным уровнем, чем ниже уровень, тем критичней лог.log.trace('trace');log.debug('debug');log.info({ event: 'client-visited', message: 'client visited tinkoff.ru' });log.warn('warn');log.error({ event: 'form-send-error', error: new Error('form') });log.fatal('fatal error'); Copy Про уровни логгирования и что они обозначают можно почитать статью. "},{"title":"Как правильно логгировать","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#как-правильно-логгировать","content":"Для правильного логгирования на клиенте и на сервере, предпочтительно использовать следующий формат: interface Log { event?: string; // уникальный индетификатор события, который можно будет просто найти в системе учетов логов message?: string; // описание лога error?: Error; // ошибка, если она есть [key]: any; // любые другие данные} Copy Если надо просто залогировать некий текст, то склеиваем все сообщение в один аргумент и просто передаем в логгер. В json формате этот текст будет доступен в поле message logger.info('hello logger'); // идентично logger.info({ message: 'hello logger' }); Copy Если необходимо залогировать некий объект или много аргументов, то собираем все в один объект и передаем в логер logger.warn({ message: 'be warn', event: 'my-warning', // event - стандартный ключ для обозначения конкретного события ...obj1, ...obj2, a: 1, b: 2,}); Copy Если необходимо залогировать объект ошибки, то либо передаем саму ошибку под ключом error, либо явно передаем в логгер первым аргументом logger.error({ error: new Error('message'),}); logger.error(new Error('message'));logger.error(new Error('typeError'), 'custom error message'); // специальный формат для переопределения текста ошибки Copy Если в логгер было переданно несколько аргументов, то первый аргумент будет обработается по правилам выше, а остальные аргументы отдельно добавятся в поле args результат logger.debug( { event: 'watch', data: 'some data', }, 'arg2', 'arg3'); Copy Данный формат прежде всего нужен для удобной работы с логами во внешних системах вроде kibana, splunk. Поэтому желательно его придерживаться, иначе возможны сложности с поиском и анализом логов. "},{"title":"Дочерние логгеры","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#дочерние-логгеры","content":"С помощью метода инстанса логгера .child можно создавать дочерние логгеры для данного инстанса, которые будут наследовать конфигурацию родительского логгера и могут эту конфигурацию переопределять. const log = logger({ name: 'test' }); const childLog = log.child('child'); // т.к. логгер дочерний то его итоговое имя будет 'test.child' const childLogWithDefaults = log.child({ name: 'withDefaults', defaults: { // defaults позволяет задать объект все свойства которого будут вмержены в объекты логов залогированных данным логгером child: true, },}); const childLogWithOverrides = log.child({ name: 'override', reporters: [], // позволяет переопределить настройки родительского логгера filters: [], extensions: [],}); Copy "},{"title":"Отображение логов","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#отображение-логов","content":"Библиотека дает возможность установить уровень логгирования, отображать или скрывать логи различных экземпляров логгера, и очищать все настройки. По умолчанию, уровень логгирования выставлен как error для всех логгеров. Добавление отображения уникального логгера с уровнем выше error, например logger.enable('info', 'my-logger'), переопределяет уровень логгирования только для my-logger. Нельзя сделать уровень логгирования для определенного логгера ниже, чем общий уровень, например при установленном по умолчанию уровне error запись logger.enable('fatal', 'my-logger') ничего не изменит в отображаемых логах. Каждое добавление уникальных настроек отображения для нового логгера не влияет на предыдущие, например отдельные вызовы методов logger.enable('info', 'my-logger') и logger.enable('trace', 'yet-another-logger') будут работать независимо друг от друга. "},{"title":"Отображение логов на сервере","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#отображение-логов-на-сервере","content":"Для настройки отображения логов на сервере используются переменные окружения LOG_LEVEL и LOG_ENABLE (параметры можно задавать вместе, тогда сначала проверяется LOG_LEVEL настройка, потом LOG_ENABLE): LOG_LEVEL = trace | debug | info | warn | error | fatal - включает отображение логов для заданного уровня и все уровней выше. Пример: если LOG_LEVEL=info, то будут отображаться все логи уровней info, warn, error, fatal LOG_ENABLE = ${name} | ${level}:${name} - позволяет включить отображение всех логов по определенному имени логгера или по определенному имени и уровню. Несколько вхождений передаются через запятую. Примеры: если LOG_ENABLE=server, то будут отображены логи всех уровней с именем serverесли LOG_ENABLE=trace:server*, то будут отображены только логи для server с уровнем traceесли LOG_ENABLE=info:server,client,trace:shared, то будут включены логи для заданных логгеров по правилам выше "},{"title":"Отображение логов в браузере","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#отображение-логов-в-браузере","content":"В браузере настройки сохраняются в localStorage, поэтому для отображения всех клиентских логов с новыми настройками, надо дополнительно перезагрузить страницу, либо очистить localStorage. Для удобной настройки параметров отображения в window добавляется объект logger через который можно настраивать отображение логов в браузере. logger === window.logger; logger.setLevel('warn'); // отображать логи уровня warn и выше logger.enable('info', 'test'); // также отображать вывод логгера test уровня info logger.enable('my-logger'); // включить полное отображение логгера my-logger logger.enable('perf*'); // включить все логи имя которых начинается с perf logger.disable('my-logger'); // отключить логгирование для заданного пространства имен logger.clear(); // очистить все настройки (отключение отображения логов) Copy "},{"title":"Конфигурация","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#конфигурация","content":"Конфигурация локального логгера# import { logger } from '@tinkoff/logger'; const log = logger({ name: 'my-logger' }); // задание name обязательно для идентификации логгераconst log = logger('my-logger'); // краткая запись, аналогичная предыдущей строке const log = logger({ name: 'remote-logger', defaults: { remote: true, },}); Copy Параметры: name[='log'] - имя нового логгера "},{"title":"Расширение возможностей логгера","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#расширение-возможностей-логгера","content":"@tinkoff/logger можно расширять различными действиями: "},{"title":"Фильтры","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#фильтры","content":"Фильтры позволяют отключать логгирование орпеделенных логов в зависимости от условий import { logger } from '@tinkoff/logger'; interface Filter { filter(logObj: LogObj): boolean;} logger.addFilter(filter as Filter); // добавить фильтр вдобавок к заданными по умолчанию и добавленным ранееlogger.setFilters([filter1, filter2]); // заменить текущие фильтры на переданные (что также позволит переделать поведение по умолчанию) Copy "},{"title":"Расширения данных","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#расширения-данных","content":"Расширения позволяют расширять или переопределять объект лога перед его логгированием import { logger } from '@tinkoff/logger'; interface Extension { extend(logObj: LogObj): LogObj;} logger.addExtension(extension as Extension); // добавить расширение вдобавок к заданными по умолчанию и добавленным ранееlogger.setExtensions([extension1, extension2]); // заменить текущие расшиерния на переданные (что также позволит переделать поведение по умолчанию) Copy "},{"title":"Репортеры","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#репортеры","content":"Репортеры позволяют настраивать вид отображения логов (json, красочные логи для браузера, отправка логов на апи). По умолчанию подключены репортеры для отображения логов в консоли на основании настроек отображения . Такие репортеры зависят от настроек уровня и включенных логгеров, т.е. такие репортеры не вызываются если уровень текущего лога ниже настроек или для данного имени логи не включены. import { logger } from '@tinkoff/logger'; interface Reporter { log(logObj: LogObj): void;} logger.addReporter(reporter as Reporter); // добавить репортер вдобавок к заданными по умолчанию и добавленным ранееlogger.setReporters([reporter1, reporter2]); // заменить текущие репортеры на переданные (что также позволит переделать поведение по умолчанию) Copy "},{"title":"Безусловные репортеры","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#безусловные-репортеры","content":"Тоже самое что и обычные репортеры, но вызываются безусловно для всех логов и до всей остальной логики с фильтрами и расширениями. import { logger } from '@tinkoff/logger'; interface Reporter { log(logObj: LogObj): void;} logger.addBeforeReporter(reporter as Reporter); // добавить репортер вдобавок к заданными по умолчанию и добавленным ранееlogger.setBeforeReporters([reporter1, reporter2]); // заменить текущие репортеры на переданные (что также позволит переделать поведение по умолчанию) Copy "},{"title":"Готовые репортеры","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#готовые-репортеры","content":""},{"title":"BrowserReporter","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#browserreporter","content":"Стандартный логгер для отображения логов в браузере. "},{"title":"NodeDevReporter","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#nodedevreporter","content":"Стандартный логгер для отображения логов в консоли на сервере, цветной и с удобным форматированием. Используется по умолчанию в дев режиме или если задана process.env.DEBUG_PLAIN. "},{"title":"NodeBasicReporter","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#nodebasicreporter","content":"Репортер для отображения логов в консоли на сервере, минималистичный. "},{"title":"JSONReporter","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#jsonreporter","content":"Отображение логов в виде json. "},{"title":"RemoteReporter","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#remotereporter","content":"Репортер для отправки логов на апи. import { logger, RemoteReporter } from '@tinkoff/logger'; const remote = new RemoteReporter({ requestCount: 1, // кол-во запросов которые могут быть отправлено параллельно emitLevels: { error: true, fatal: true }, // уровни которые будут по умолчанию логгироваться на апи async makeRequest(logObj) { // функция которая принимает текущий лог и отправляет запрос на апи return await request(); },}); logger.addReporter(remote); const log = logger({ name: 'test-remote' }); // настройки для remote будут использованы из настроек RemoteReporter log.error('error'); // лог также отправится на апиlog.info('test'); // не отправится на апи т.к. уровень не error и не fatal const remoteLog = logger({ name: 'remote-for-all', remote: true }); // remote перебивает настройки RemoteReporter и отправляет логи в любом случае remoteLog.info('test'); // отправится на апиremoteLog.debug('test'); // отправится const traceLog = logger({ name: 'log-trace', emitLevels: { trace: true } }); // переписать настройки RemoteReporter traceLog.trace('test'); // отправится на апиtraceLog.error('test'); // не отправится Copy "},{"title":"SageReporter","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#sagereporter","content":"Репортер для поддержки формата логов sage. Расширяет функционал JSONReporter: добавляет поле @timestamp;в поле level записывает строковое представление уровня логирования, числовое значение сохраняет в поле levelNumber;делает message массивом содержащим исходный message и записывает в него все строковые и числовые значения из массива args;все массивы и объекты из args выносит в поля лога arrays и objects; Это решает основную массу проблем при индексации логов в sage. "},{"title":"mock","type":0,"sectionRef":"#","url":"docs/references/libs/mock","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"mock","url":"docs/references/libs/mock#подключение","content":"npm i --save-dev @tramvai/mock Copy "},{"title":"Context","type":1,"pageTitle":"mock","url":"docs/references/libs/mock#context","content":"Для мокирования контекста, используемого в React компонентах и экшенах, можно использовать утилиту createMockContext "},{"title":"Интерфейс","type":1,"pageTitle":"mock","url":"docs/references/libs/mock#интерфейс","content":"type createMockContext = ({ initialState, di, providers, stores, actionConditionals }) => { context, store } Copy initialState - объект с изначальным состоянием стейта di - экземпляр DI контейнера providers - список провайдеров, которые будут добавлены в DI. Используется когда нужно замокировать deps stores - список сторов, созданных через createReducer actionConditionals - список с реализациями глобальных ограничений. Используется когда нужно проверить у экшенов различные ограничения mocks - моки, в которые будут обернуты store.dispatch и context.executeAction context - контекст, который можно использовать при запуске экшенов или передавать в React store - экземпляр общего стора, с методами getState, dispatch и subscribe "},{"title":"Тестирование","type":1,"pageTitle":"mock","url":"docs/references/libs/mock#тестирование","content":"const someEvent = createEvent('someEvent');const someAction = createAction({ name: 'someAction', fn() {},}); const { store, context } = createMockContext({ mocks: { dispatchMock: jest.fn, executeActionMock: jest.fn, },}); store.dispatch(someEvent());context.executeAction(someAction); expect(store.dispatch).toHaveBeenCalled();expect(context.executeAction).toHaveBeenCalled(); Copy "},{"title":"papi","type":0,"sectionRef":"#","url":"docs/references/libs/papi","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"papi","url":"docs/references/libs/papi#installation","content":"You need to install @tramvai/papi yarn add @tramvai/module-papi Copy "},{"title":"Usage","type":1,"pageTitle":"papi","url":"docs/references/libs/papi#usage","content":"import { createPapiMethod } from '@tramvai/papi'; export const papi = createPapiMethod({ path: '/my/papi', method: 'post', async handler(deps) { return 'test'; }, deps: { tinkoffApiService: TINKOFF_API_SERVICE, },}); Copy "},{"title":"prettier","type":0,"sectionRef":"#","url":"docs/references/libs/prettier","content":"","keywords":""},{"title":"Установка","type":1,"pageTitle":"prettier","url":"docs/references/libs/prettier#установка","content":"Устанавливаем через package manager npm i --save-dev prettier-config-tinkoff Copy "},{"title":"Подключение","type":1,"pageTitle":"prettier","url":"docs/references/libs/prettier#подключение","content":"Создаем файл в корне проекта .prettierrc.js в котором module.exports = require(\"prettier-config-tinkoff\") Copy То есть, в этом случае мы просто подключаем конфигурацию из нашего модуля и при необходимости можем изменить. Подробнее про это в документации prettier "},{"title":"pubsub","type":0,"sectionRef":"#","url":"docs/references/libs/pubsub","content":"","keywords":""},{"title":"subscribe - подписка на события","type":1,"pageTitle":"pubsub","url":"docs/references/libs/pubsub#subscribe---подписка-на-события","content":"pubsub.subscribe(type, callback) - подписаться на событие type. callback принимает в качестве параметров аргументы переданные при вызове pubsub.publish. callback может вернуть промис, резолв которого будет ожидаться при использовании pubsub.publish. "},{"title":"publish - публикация события","type":1,"pageTitle":"pubsub","url":"docs/references/libs/pubsub#publish---публикация-события","content":"pubsub.publish(type, ...args) - публикация события, все аргументы кроме первого будут переданы как аргументы в функции-подписчики. Возвращает промис, который зарезолвится после резолва всех функций-подписчиков. "},{"title":"Типизированный PubSub","type":1,"pageTitle":"pubsub","url":"docs/references/libs/pubsub#типизированный-pubsub","content":"PubSub поддерживает использование типизированного списка событий. Например: есть общий PubSub, в который много кто отправляет события. Вы пишете функционал, который тоже будет отправлять события в общий PubSub и считывать оттуда события. Вы хотите, чтобы TS проверял, что подписчик правильно подписывается на события из PubSub. В этом случае делаем следующее: Заводим описание событий и требуемые обработчики type MyAwesomeFeatureEvents = { event1: (payload: number) => any; event2: (payload: { prop: boolean }) => any;}; Copy Теперь в месте использования PubSub в рамках нашей фичи делаем тайпкаст. После этого pubsub становится типизированным и дает использовать только события из MyAwesomeFeatureEvents и typescript следит за совместимостью const featurePubSub = (pubSub as any) as PubSub<MyAwesomeFeatureEvents>; // OK! 👍featurePubSub.subscribe('event1', (payload) => console.log(1 + payload));featurePubSub.publish('event1', 2); // Ошибки 👎featurePubSub.subscribe('event3', (payload) => console.log(1 + payload)); // НЕТ ТАКОГО СОБЫТИЯfeaturePubSub.publish('event3', 2); // НЕТ ТАКОГО СОБЫТИЯ featurePubSub.subscribe('event1', (payload) => payload.toLowerCase()); // Там число, а не строка!featurePubSub.publish('event1', 'string'); // ожидается число! Copy "},{"title":"React Hooks","type":0,"sectionRef":"#","url":"docs/references/libs/react-hooks","content":"","keywords":""},{"title":"Api","type":1,"pageTitle":"React Hooks","url":"docs/references/libs/react-hooks#api","content":""},{"title":"useShallowEqual","type":1,"pageTitle":"React Hooks","url":"docs/references/libs/react-hooks#useshallowequal","content":"Makes shallow equal check for passed argument. If current argument is equal to previous then result of the hook will not be changed. Otherwise it will be equal to a current argument. import { useEffect } from 'react';import { useShallowEqual } from '@tinkoff/react-hooks'; export function Cmp({ obj }) { // obj - some object // objRef - reference to object. For example, if reference obj were changed after sequential render, // but it still shallow equals to initial obj then objRef will reference to the initial obj ссылка на объект obj const objRef = useShallowEqual(obj); useEffect(() => { // React checks deps with reference equality that may lead to unnecessary hook call when reference were changed // but we care only about actual changes to object itself not reference // in that case objRef will not lead to effect call in case new reference is shallowly equal to previous }, [objRef]);} Copy "},{"title":"mocker","type":0,"sectionRef":"#","url":"docs/references/libs/mocker","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#подключение","content":"Необходимо установить @tinkoff/mocker: yarn add @tinkoff/mocker Copy Создать первый мок, в файле mocks/first-api.js: module.exports = { api: 'first-api', mocks: { 'GET /endpoint': { status: 200, headers: {}, payload: 'mocked response', }, },}; Copy Затем подключить мокер в проекте: import { Mocker, FileSystemMockRepository } from '@tinkoff/mocker'; // репозиторий будет читать моки из файлов в текущей директории, из папки `mocks`const repository = new FileSystemMockRepository({ cwd: process.cwd(), root: 'mocks' });// все запросы к мокеру на `/first-api/...` либо получают подходящий мок, либо проксируются на оригинальное APIconst options = { apis: { 'first-api': { target: 'https://real-first-api.com/', }, }, passUnhandledRequests: true}; const mocker = new Mocker({ options, repository, logger: console }); (async () => { // на этом этапе мокер загружает моки через репозиторий, и создает соответствующие роуты await mocker.init(); mocker.start(4000, () => { console.log('Mocker running at 4000 port'); });})(); Copy И можем отправить GET запрос к мокеру: (async () => {const response = await fetch('http://localhost:4000/first-api/endpoint');const data = await response.json(); console.log(data); // \"mocked response\"})(); Copy "},{"title":"Explanation","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#explanation","content":"Библиотека работает на основе express, mocker можно использовать как в качестве самостоятельного сервера, так и на существующем сервере через middleware mocker.use(req, res). FileSystemMockRepository поддерживает моки в форматах js и json, js моки позволяют задавать кастомные express обработчики (методы) в качестве мока. При выбора мока для текущего запроса, учитывается method запроса, url и query параметры. Мокер поддерживает проксирование запросов в API, что позволяет мокировать только некоторые эндпоинты, а не весь бэкенд. "},{"title":"Маршрутизация","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#маршрутизация","content":"Если мокер был запущен как отдельный сервер, например на 4000 порту, он будет доступен на http://localhost:4000/. Для каждого api из настроек options.apis будет создан вложенный роутер, для first-api это будет http://localhost:4000/first-api/. Роуты для api создаются на основе моков, у которых ключем является метод + урл запроса, например мок GET /endpoint будет доступен по адресу http://localhost:4000/first-api/endpoint, для GET запросов. "},{"title":"Моки из файловой системы","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#моки-из-файловой-системы","content":"Мокер получает моки через репозиторий, что позволяет хранить моки в файловой системе, памяти, или на другом сервере.FileSystemMockRepository работает с файловой системой, и поддерживает следующие виды моков: mock.json { \"api\": \"first-api\", \"mocks\": { \"GET /foo\": { \"status\": 200, \"headers\": {}, \"payload\": { \"fake\": \"true\" } } }} Copy mock.js module.exports = { api: 'first-api', mocks: { 'GET /bar': { status: 200, headers: {}, payload: { fake: 'true', }, }, 'POST /bar': (req, res) => { res.status(200); res.set('X-Mock-Server', 'true'); res.json({ fake: 'true' }); }, },}; Copy "},{"title":"API","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#api","content":""},{"title":"Mocker","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#mocker","content":"interface Mocker { new (params: { options: MockerOptions; repository: MockRepository; logger: Logger; }): Mocker; init(): Promise<void>; update(): Promise<void>; use(req: IncomingMessage, res: ServerResponse): express.Express; start(port: number, callback?: (...args: any[]) => void): Server;} Copy Mocker.init - получение моков через MockRepository, инициализация роутинга. Необходимо вызывать до запуска сервера или middleware. Mocker.update - получение моков через MockRepository, обновление роутинга. Можно вызывать в рантайме. Mocker.use - express middleware, подходит для запуска на существующем сервере. Mocker.start - запуск мокера на стандартном http сервере. "},{"title":"MockerOptions","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#mockeroptions","content":"interface MockerOptions { apis: Record<string, { target: string }>; passUnhandledRequests?: boolean; apiRoutePrefix?: string;} Copy MockerOptions.apis - список API для мокирования, в target указывается оригинальный урл API. MockerOptions.passUnhandledRequests - при включенной опции, все запросы, для которых не нашлось моков, проксируются на target url, иначе отдается ошибка. MockerOptions.apiRoutePrefix - если мокер запускается в существующем приложении на вложенном роуте, например /mocker, может понадобиться пробросить этот урл в apiRoutePrefix для корректной работы роутера мокера. "},{"title":"MockRepository","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#mockrepository","content":"interface MockRepository { get(api: string, endpoint: string): Promise<Mock>; getAll(api: string): Promise<Record<string, Mock>>; add(api: string, endpoint: string, mock: Mock): Promise<void>; delete(api: string, endpoint: string): Promise<void>;} Copy MockRepository.getAll - получить все моки для указанного api. MockRepository.get - получить конкретный мок для указанного api. MockRepository.add - добавить мок для указанного api. MockRepository.delete - удалить конкретный мок для указанного api. "},{"title":"How to","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#how-to","content":""},{"title":"Как мокать запрос только с определенными query параметрами?","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#как-мокать-запрос-только-с-определенными-query-параметрами","content":"В моках реализованна поддержка сверки query параметров запроса и мока, в примере ниже запрос на /endpoint?foo=bar попадет в первый мок, /endpoint?foo=baz во второй, а все остальные запросы с другими query, или без них, проксируются в оригинальное API (при включенной опции passUnhandledRequests). module.exports = { api: 'api', mocks: { 'GET /endpoint?foo=bar': { status: 200, headers: {}, payload: 'mocked bar response', }, 'GET /endpoint?foo=baz': { status: 200, headers: {}, payload: 'mocked baz response', }, },}; Copy "},{"title":"Как проксировать в оригинальное API определенный запрос?","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#как-проксировать-в-оригинальное-api-определенный-запрос","content":"Это имеет смысл, если отключена опция passUnhandledRequests, достаточно передать свойство pass: true в нужный мок: module.exports = { api: 'api', mocks: { 'ALL /endpoint': { pass: true, }, },}; Copy "},{"title":"safe-strings","type":0,"sectionRef":"#","url":"docs/references/libs/safe-strings","content":"","keywords":""},{"title":"safeParseJSON","type":1,"pageTitle":"safe-strings","url":"docs/references/libs/safe-strings#safeparsejson","content":"Парсит json или возвращает значение по-умолчанию если парсинг неудачный "},{"title":"safeStringify","type":1,"pageTitle":"safe-strings","url":"docs/references/libs/safe-strings#safestringify","content":"Конвертирует json в строку с заменой небезопасных символов, чтобы можно было выполнить eval "},{"title":"safeStringiyfJSON","type":1,"pageTitle":"safe-strings","url":"docs/references/libs/safe-strings#safestringiyfjson","content":"Конвертирует json в строку с обработкой циклических ссылок "},{"title":"removeXss","type":1,"pageTitle":"safe-strings","url":"docs/references/libs/safe-strings#removexss","content":"Удаляет из url xss код "},{"title":"router","type":0,"sectionRef":"#","url":"docs/references/libs/router","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"router","url":"docs/references/libs/router#installation","content":"You need to install @tinkoff/router: yarn add @tinkoff/router Copy And connect in the project: import { Router } from '@tinkoff/router'; const router = new Router(); Copy "},{"title":"Explanation","type":1,"pageTitle":"router","url":"docs/references/libs/router#explanation","content":"Features: The library supports options for working both on the server and on the client.It is possible to use different client transition options: with or without SPA transitions.There are Guards to check the availability of a route under specific conditions.You can subscribe to different stages of the transition through hooksComponents and hooks for easy routing from react "},{"title":"Server and client version","type":1,"pageTitle":"router","url":"docs/references/libs/router#server-and-client-version","content":"It is enough just to import routing from the library itself and, based on the settings, the required version for the server or client will be returned to package.json import { Router } from '@tinkoff/router'; Copy "},{"title":"Client routing with/without SPA transitions","type":1,"pageTitle":"router","url":"docs/references/libs/router#client-routing-withwithout-spa-transitions","content":"By default, routing with SPA transitions enabled is exported on the client. If you need to disable SPA transitions, you need to import a special version of the routing import { Router, SpaHistory } from '@tinkoff/router';import { NoSpaRouter } from '@tinkoff/router'; const spaRouter = new Router({ history: new SpaHistory() });const noSpaRouter = new NoSpaRouter(); Copy "},{"title":"Router Guards","type":1,"pageTitle":"router","url":"docs/references/libs/router#router-guards","content":"Guards allow you to control the availability of a particular route for a specific transition. From the guard, you can block the transition or initiate a redirect. import { NavigationGuard } from '@tinkoff/router'; export const myGuard: NavigationGuard = async ({ to }) => { if (to.config.blocked) { return false; // block this transition } if (to.config.redirect) { return '/login/'; // call a redirect to the specified page } // if nothing is returned, the transition will be performed as usual}; Copy "},{"title":"Transitions hooks","type":1,"pageTitle":"router","url":"docs/references/libs/router#transitions-hooks","content":"Transition hooks allow you to perform your asynchronous actions at different stages of the transition. import { NavigationHook } from '@tinkoff/router'; export const myHook: NavigationHook = async ({ from, to, url, fromUrl }) => { console.log(`navigating from ${from} to route ${to}`);}; Copy "},{"title":"API","type":1,"pageTitle":"router","url":"docs/references/libs/router#api","content":""},{"title":"Getting data about the current route or url","type":1,"pageTitle":"router","url":"docs/references/libs/router#getting-data-about-the-current-route-or-url","content":"router.getCurrentRoute(); // will return the current routerouter.getCurrentUrl(); // will return the parsed version of the url of the current page Copy "},{"title":"Transition initiation","type":1,"pageTitle":"router","url":"docs/references/libs/router#transition-initiation","content":"There are two methods for initializing the navigation and updating the address bar in the browser. The main difference between these two methods is that one of them must launch a full-fledged transition with data updating and starting heavy data loading actions. The second method is mainly used to update the state for the current route: to update the query parameters on the page or change the dynamic parameters of the route itself. navigate# Initiates a full transition, defining the next route and updating the state in the browser. router.navigate('/test');router.navigate({ url: './test', query: { a: '1' } }); Copy Transition hooks: beforeResolvebeforeNavigateafterNavigate updateCurrentRoute# The transition is based on the current route (therefore this method cannot be called on the server) and allows you to simply update some data for the current page router.updateCurrentRoute({ params: { id: 'abc' } });router.updateCurrentRoute({ query: { a: '1' } }); Copy Hooks: beforeUpdateCurrentafterUpdateCurrent "},{"title":"Working with query","type":1,"pageTitle":"router","url":"docs/references/libs/router#working-with-query","content":"query option# Allows you to set a search string for an url as an object via the query option when navigating. The previous query value will be cleared router.getCurrentUrl().query; // { с: 'c' } router.navigate({ query: { a: 'a', b: 'b' } });router.updateCurrentRoute({ query: { a: 'a', b: 'b' } }); router.getCurrentUrl().query; // { a: 'a', b: 'b' } Copy preserveQuery# Allows you to keep the query value from the current navigation and use them in a new transition router.getCurrentUrl().query; // { с: 'c' } router.navigate({ query: { a: 'a' }, preserveQuery: true });router.updateCurrentRoute({ query: { a: 'a' }, preserveQuery: true }); router.getCurrentUrl().query; // { a: 'a', c: 'c' } Copy If you pass undefined as the value for a specific query key, then this value will be cleared in a new query: router.getCurrentUrl().query; // { a: 'a', b: 'b' } router.navigate({ query: { a: undefined, c: 'c' }, preserveQuery: true });router.updateCurrentRoute({ query: { a: undefined, c: 'c' }, preserveQuery: true }); router.getCurrentUrl().query; // { b: 'b', c: 'c' } Copy "},{"title":"Integration with React","type":1,"pageTitle":"router","url":"docs/references/libs/router#integration-with-react","content":"Has some useful React hooks and components for working with routing useRoute# Allows you to get the current active route of the application import React from 'react';import { useRoute } from '@tinkoff/router'; export const Component = () => { const route = useRoute(); return <div>Route path: {route.actualPath}</div>;}; Copy useUrl# Lets get the current active URL of the application import React from 'react';import { useUrl } from '@tinkoff/router'; export const Component = () => { const url = useUrl(); return <div>Url query: {JSON.stringify(url.query)}</div>;}; Copy useNavigate# Creates a callback with a navigation call that can be passed to child components or hung as an event handler export const Cmp = () => { const navigate = useNavigate('/test/'); return <div onClick={navigate}>Test</div>;}; Copy Link# A wrapper for a react component that makes it clickable If the react component is passed to the Link as children, then this passed component will be rendered and the href, onClick props that need to be used to call the navigation will be passed to it. Otherwise, the <a> tag will be rendered with children as a child. import { Link } from '@tinkoff/router';import CustomLink from '@custom-scope/link'; export const Component = () => { return ( <Link url=\"/test/\"> <CustomLink /> </Link> );}; export const WrapLink = () => { return <Link url=\"/test/\">Click me</Link>;}; Copy "},{"title":"tinkoff-request-http-client-adapter","type":0,"sectionRef":"#","url":"docs/references/libs/tinkoff-request-http-client-adapter","content":"","keywords":""},{"title":"API","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#api","content":""},{"title":"createAdapter","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#createadapter","content":"createAdapter - фабрика для создания HTTP клиента, конфигурирует экземпляр @tinkoff/request через createTinkoffRequest, и на его основе создает экземпляр HttpClientAdapter type createAdapter = (options: TinkoffRequestOptions) => HttpClient; Copy "},{"title":"TinkoffRequestOptions","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#tinkoffrequestoptions","content":"interface TinkoffRequestOptions extends HttpClientRequest { // трамвай логгер logger?: typeof LOGGER_TOKEN; // неймспейс для логгера, к нему будет добавлен префикс `request.` name?: string; // отключет кэширование по умолчанию через `@tinkoff/request-plugin-cache-memory` disableCache?: boolean; // фабрика кэшей для `@tinkoff/request-plugin-cache-memory` createCache?: (options: any) => any; // время жизни кэша в `@tinkoff/request-plugin-cache-memory` cacheTime?: number; // ограничение по умолчанию на время выполнения запроса, в ms defaultTimeout?: number; // валидатор ответа для `@tinkoff/request-plugin-validate` validator?: RequestValidator; // валидатор ошибки для `@tinkoff/request-plugin-validate` errorValidator?: RequestValidator; // метод позволяет модифицировать объект ошибки перед отправкой логов из `@tinkoff/request-plugin-log` errorModificator?: RequestValidator;} Copy "},{"title":"createTinkoffRequest","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#createtinkoffrequest","content":"createTinkoffRequest - создает экземпляр @tinkoff/request со всеми необходимыми плагинами type createTinkoffRequest = (options: TinkoffRequestOptions) => MakeRequest; Copy "},{"title":"HttpClientAdapter","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#httpclientadapter","content":"HttpClientAdapter - адаптирует @tinkoff/request к интерфейсу HttpClient. Метод request оборачивает параметры запроса в опцию modifyRequest, и передает их в @tinkoff/request. Затем, полученный ответ модифицируется в HttpClientRequest, и оборачивается в опцию modifyResponse. Если произошла ошибка, то она оборачивается в опцию modifyError. Метод fork создает новый экземпляр HttpClientAdapter, но с тем же самым экземпляром @tinkoff/request. type HttpClientAdapter = HttpClient; Copy "},{"title":"mergeOptions","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#mergeoptions","content":"По умолчанию, mergeOptions производит композицию опций modifyRequest, modifyResponse и modifyError, причем сначала будут выполнены соответствующие опции из параметра options, затем из nextOptions. Если передать третий параметр { replace: true }, все одноименные параметры из options просто будут перезаписаны параметрами из nextOptions type mergeOptions = ( options: HttpClientRequest, nextOptions: HttpClientRequest, config?: { replace?: boolean }) => HttpClientRequest; Copy "},{"title":"user-agent","type":0,"sectionRef":"#","url":"docs/references/libs/user-agent","content":"user-agent Library for parsing and executing check to userAgent string. Based on ua-parser-js","keywords":""},{"title":"url","type":0,"sectionRef":"#","url":"docs/references/libs/url","content":"","keywords":""},{"title":"Api","type":1,"pageTitle":"url","url":"docs/references/libs/url#api","content":""},{"title":"parse","type":1,"pageTitle":"url","url":"docs/references/libs/url#parse","content":"Parses url and returns object of class URL with additional property query which represents searchParams as a simple object. import { parse } from '@tinkoff/url'; const url = parse('https://tinkoff.ru/test/?a=1&b=2#abc'); url.protocol; // => :httpsurl.href; // => https://tinkoff.ru/test/?a=1&b=2#abcurl.origin; // => https://tinkoff.ruurl.pathname; // => /test/url.hash; // => #abcurl.query; // => { a: '1', b: '2' } Copy "},{"title":"rawParse","type":1,"pageTitle":"url","url":"docs/references/libs/url#rawparse","content":"Same as parse but instead of returning wrapper for URL returns raw URL object "},{"title":"resolve","type":1,"pageTitle":"url","url":"docs/references/libs/url#resolve","content":"Computes absolute url for relative url of base value import { resolve } from '@tinkoff/url'; resolve('//tinkoff.ru', './test123'); // => http://tinkoff.ru/test123resolve('//tinkoff.ru/a/b/c/', '../../test'); // => http://tinkoff.ru/a/testresolve('https://tinkoff.ru/a/b/c/?test=123#abc', '.././test/?me=123#123'); // => https://tinkoff.ru/a/b/test/?me=123#123 Copy "},{"title":"resolveUrl","type":1,"pageTitle":"url","url":"docs/references/libs/url#resolveurl","content":"Computes absolute url for relative url of base value. Unlike resolve can accept string or URL and return URL wrapper "},{"title":"rawResolveUrl","type":1,"pageTitle":"url","url":"docs/references/libs/url#rawresolveurl","content":"Same as resolveUrl but instead of returning wrapper for URL returns raw URL object "},{"title":"isAbsoluteUrl","type":1,"pageTitle":"url","url":"docs/references/libs/url#isabsoluteurl","content":"Checks that passed string is absolute url "},{"title":"isInvalidUrl","type":1,"pageTitle":"url","url":"docs/references/libs/url#isinvalidurl","content":"Checks that passed string represents invalid url import { isAbsoluteUrl } from '@tinkoff/url'; isAbsoluteUrl('https://www.exmaple.com'); // true - secure http absolute URLisAbsoluteUrl('//cdn.example.com/lib.js'); // true - protocol-relative absolute URLisAbsoluteUrl('/myfolder/test.txt'); // false - relative URL Copy "},{"title":"convertRawUrl","type":1,"pageTitle":"url","url":"docs/references/libs/url#convertrawurl","content":"Returns handy wrapper for URL in form of plain object with some additional fields "},{"title":"rawAssignUrl","type":1,"pageTitle":"url","url":"docs/references/libs/url#rawassignurl","content":"Allows to set parameters to passed raw URL object (passed URL-object will be changed) "},{"title":"autoscroll","type":0,"sectionRef":"#","url":"docs/references/modules/autoscroll","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"autoscroll","url":"docs/references/modules/autoscroll#подключение","content":"Необходимо установить @tramvai/module-autoscroll yarn add @tramvai/module-autoscroll Copy Подключить в проекте AutoscrollModule import { createApp } from '@tramvai/core';import { AutoscrollModule } from '@tramvai/module-autoscroll'; createApp({ name: 'tincoin', modules: [AutoscrollModule],}); Copy Если нужно отключить подскрол для отдельных страниц - при переходе navigate нужно указать navigateState.disableAutoscroll = true import { useNavigate } from '@tramvai/module-router'; function Component() { const navigateToWithoutScroll = useNavigate({ url: '/url/', navigateState: { disableAutoscroll: true }, }); return <Button onClick={navigateToWithoutScroll} />;} Copy behavior: smooth поддерживается не во всех браузерах (например, плавный подскролл не работает в Safari). При необходимости подключите полифил smoothscroll-polyfill в свое приложение. "},{"title":"cache-warmup","type":0,"sectionRef":"#","url":"docs/references/modules/cache-warmup","content":"","keywords":""},{"title":"Как подключить?","type":1,"pageTitle":"cache-warmup","url":"docs/references/modules/cache-warmup#как-подключить","content":"По умолчанию модуль уже подключается в @tramvai/module-server и при его использовании дополнительных действий не требуется. import { createApp } from '@tramvai/core';import { CacheWarmupModule } from '@tramvai/module-cache-warmup'; createApp({ modules: [CacheWarmupModule],}); Copy "},{"title":"Что делает?","type":1,"pageTitle":"cache-warmup","url":"docs/references/modules/cache-warmup#что-делает","content":"При старте приложения с запрашивает у bundleInfo список урлов приложения. Затем шлет по 2 запроса на каждый из урлов, но не более 2 запросов одновременно. 2 запроса нужны для того, чтобы симулировать запрос с десктопа и мобильного устройства. User-Agentы, которые использует модуль: [ /** Chrome on Mac OS */ 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.87 Safari/537.36', /** Chrome on Mobile */ 'Mozilla/5.0 (Linux; Android 7.0; SM-G930V Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.125 Mobile Safari/537.36',]; Copy Модуль выполняется только при NODE_ENV === production. "},{"title":"Отладка","type":1,"pageTitle":"cache-warmup","url":"docs/references/modules/cache-warmup#отладка","content":"Модуль использует логгер с идентификатором cache-warmup "},{"title":"client-hints","type":0,"sectionRef":"#","url":"docs/references/modules/client-hints","content":"","keywords":""},{"title":"Подключение в проект","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#подключение-в-проект","content":""},{"title":"1. Зависимости","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#1-зависимости","content":"Необходимо установить @tramvai/module-client-hints с помощью npm npm i --save @tramvai/module-client-hints Copy или yarn add @tramvai/module-client-hints Copy "},{"title":"2. Подключение модуля","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#2-подключение-модуля","content":"Нужно передать в список модулей приложения ClientHintsModule import { createApp } from '@tramvai/core';import { ClientHintsModule } from '@tramvai/module-client-hints'; createApp({ modules: [ClientHintsModule],}); Copy "},{"title":"Экспортируемые токены","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#экспортируемые-токены","content":""},{"title":"USER_AGENT_TOKEN","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#user_agent_token","content":"Объект - результат парсинга строки юзер-агента с помощью @tinkoff/user-agent. Парсинг происходит только на сервере, на клиенте - используется инфомация с сервера. "},{"title":"Сторы","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#сторы","content":""},{"title":"userAgent","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#useragent","content":"Стор который хранит результат парсинга юзер-агента. "},{"title":"media","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#media","content":"Стор который хранит медиа-информацию о типе и размере экрана клиента. API для проверки media# Данные в сторе media: type Media = { width: number; height: number; isTouch: boolean; retina: boolean; supposed?: boolean; synchronized?: boolean;}; Copy fromClientHints(media: Media): boolean - возвращает true, когда media синхронизированны на сервере и на клиенте isSupposed(media: Media): boolean - возвращает true, когда media определены на сервере по User-Agent, и могут измениться на клиенте isRetina(media: Media): boolean - вовзращает true, когда плотность пикселей на экране 2 или выше useMedia(): Media - возвращает текущее состояние стора media useFromClientHints(): boolean - вычисляет fromClientHints из стора media useIsSupposed(): boolean - вычисляет isSupposed из стора media useIsRetina(): boolean - вычисляет isRetina из стора media "},{"title":"Особенности работы с media на сервере и клиенте","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#особенности-работы-с-media-на-сервере-и-клиенте","content":"Одна из проблем SSR - рендеринг компонентов, которые зависят от текущего размера экрана, например карусель изображений, которая должна рендерить определенное количество картинок, в зависимости от ширины экрана. По умолчанию, узнать точные размеры мы можем только на стороне клиента, и не имеем возможности отрисовать на сервере контент, идентичный клиенту. Если этот контент не требуется для SEO, можно использовать скелетоны или спиннеры, но это подходит не для всех случаев. Модуль Client Hints позволяет частично решить эту проблему, сохраняя данные об устройстве пользователя в cookies при первом заходе, и используя эти данные на сервере при следующих заходах на страницы приложения. "},{"title":"Механизм работы Client Hints","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#механизм-работы-client-hints","content":"Первый заход на страницу# При первом заходе на страницу, на стороне сервере, модуль определяет тип устройство по User-Agent, и сохраняет предположительные данные об устройстве в стор media. Например, при первом заходе с компьютера, значение стора media будет таким: const state = { width: 1024, height: 768, isTouch: false, retina: false, supposed: true, synchronized: false,}; Copy На клиенте, ориентируясь на значение supposed: true, модуль получает реальные данные об устройстве, и обновляет стор media, вызывая перерендер зависимых компонентов. После этого, для широкоэкранного монитора, значение стора media может быть таким: const state = { width: 1920, height: 1080, isTouch: false, retina: true, supposed: false, synchronized: false,}; Copy Пока мы имеем значение synchronized: false, нельзя полагаться на данные из media для серверного рендеринга компонентов, т.к. это вызовет \"скачок\" при сохранении реальных данных об устройстве. Повторный заход на страницу# При повторном заходе на страницу, данные об устройстве считываются из cookies, значение synchronized выставляется в true. Таким образом, и на сервере, и на клиенте, мы получим одно значение стора media, и отсутствие перерендера на клиенте: const state = { width: 1920, height: 1080, isTouch: false, retina: true, supposed: false, synchronized: true,}; Copy Итоги# Общая информация для компонентов, которые зависят от текущего размера экрана: При первом заходе на страницу, нельзя гарантировать одинаковый результат рендеринга на сервере и на клиенте При первом заходе на страницу, можно показать юзеру скелетон компонента, отображая скелетон при свойстве supposed: true Гарантировать одинаковый результат рендеринга на сервере и на клиенте можно при свойстве synchronized: true Рецепт, который позволит показать скелетон только один раз, при первой загрузке приложения: const App = () => { const isSupposed = useIsSupposed(); if (isSupposed) { return <AdaptiveSliderSkeleton />; } return <AdaptiveSlider />;}; Copy Рецепт, который позволит рендерить общий адаптивный компонент при первой загрузке приложения, и выбирать отдельные под desktop и mobile при повторных загрузках: const App = () => { const media = useMedia(); const fromClientHints = useFromClientHints(); let Block = AdaptiveBlock; if (fromClientHints) { Block = media.width >= 1024 ? DesktopBlock : MobileBlock; } return <Block />;}; Copy "},{"title":"common","type":0,"sectionRef":"#","url":"docs/references/modules/common","content":"","keywords":""},{"title":"Подключение в проект","type":1,"pageTitle":"common","url":"docs/references/modules/common#подключение-в-проект","content":""},{"title":"1. Зависимости","type":1,"pageTitle":"common","url":"docs/references/modules/common#1-зависимости","content":"Необходимо установить @tramvai/module-common с помощью npm npm i @tramvai/module-common Copy "},{"title":"2. Подключение модуля","type":1,"pageTitle":"common","url":"docs/references/modules/common#2-подключение-модуля","content":"Нужно передать в список модулей приложения CommonModule import { createApp } from '@tramvai/core';import { CommonModule } from '@tramvai/module-common'; createApp({ modules: [CommonModule],}); Copy "},{"title":"Включенные модули","type":1,"pageTitle":"common","url":"docs/references/modules/common#включенные-модули","content":""},{"title":"CommandModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#commandmodule","content":"Модуль которые добавляет в проект реализацию commandLineRunner и дефолтных команд Модуль использует логгер с идентификатором command:command-line-runner "},{"title":"StateModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#statemodule","content":"Подключает и инициализирует state-manager в проекте "},{"title":"ActionModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#actionmodule","content":"Реализация системы экшенов Модуль использует логгер с идентификатором action:action-page-runner "},{"title":"CookieModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#cookiemodule","content":"Подключен модуль который позволяет работать с куками, документация "},{"title":"EnvironmentModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#environmentmodule","content":"Модуль для работы с env переменные в приложении на стороне сервера и клиента, документация "},{"title":"PubSub","type":1,"pageTitle":"common","url":"docs/references/modules/common#pubsub","content":"Для отправки событий между модулями используется PubSub который позволяет отправлять сообщения и подписываться на изменения, документация Модуль использует логгер с идентификатором pubsub "},{"title":"LogModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#logmodule","content":"Минимальная реализация логгера для токена LOGGER_TOKEN без фильтров и дополнительных фич "},{"title":"CacheModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#cachemodule","content":"Модуль для работы с кешами. Функции: Создать новый инстанс кеша (на данный момент это lru-cache)Очистить все ранее созданные кешиПодписка на событие очистки кеша для реализации собственного тригера очистки своих кешейДобавляет papi-метод '/clear-cache' который генерирует событе очистки кешей Модуль использует логгер с идентификатором cache:papi-clear-cache Пример# import { provide } from '@tramvai/core'; export const providers = [ provide({ provide: MY_MODULE_PROVIDER_FACTORY, scope: Scope.SINGLETON, useFactory: ({ createCache }) => { const cache = createCache('memory', ...args); // тип кеша и дополнительные аргументы которые будут переданы в конструктор кеша return someFactory({ cache }); }, deps: { createCache: CREATE_CACHE_TOKEN, }, }), provide({ provide: REGISTER_CLEAR_CACHE_TOKEN, scope: Scope.SINGLETON, useFactory: ({ cache }) => { return async () => { await cache.reset(); console.log('my module cache cleared'); }; }, deps: { cache: MY_MODULE_CACHE, }, }), provide({ provide: commandLineListTokens.clear, useFactory: ({ clearCache }) => { return function clear() { clearCache(); // очистить кеши явно в своем провайдере }; }, deps: { clearCache: CLEAR_CACHE_TOKEN, }, }),]; Copy "},{"title":"RequestManagerModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#requestmanagermodule","content":"Модуль для работы с параметрами запроса "},{"title":"ResponseManagerModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#responsemanagermodule","content":"Модуль для работы с параметрами ответа "},{"title":"Экспортируемые токены","type":1,"pageTitle":"common","url":"docs/references/modules/common#экспортируемые-токены","content":"tokens-commoncookieenv "},{"title":"cookie","type":0,"sectionRef":"#","url":"docs/references/modules/cookie","content":"","keywords":""},{"title":"Features","type":1,"pageTitle":"cookie","url":"docs/references/modules/cookie#features","content":"Изоморфный код, работает на сервере и в браузереНа сервере происходит дедубликация одинаковых кук и при добавлении куки, кука будет доступна в методе getПо дефолту мы проставляем secure параметр "},{"title":"Установка","type":1,"pageTitle":"cookie","url":"docs/references/modules/cookie#установка","content":"Уже поставляется внутри @tramvai/module-common и не нужно устанавливать, если подключен module-common. Иначе, нужно подключить @tramvai/module-cookie "},{"title":"Использование","type":1,"pageTitle":"cookie","url":"docs/references/modules/cookie#использование","content":"import { COOKIE_MANAGER, Module, provide } from '@tramvai/core'; @Module({ providers: [ provide({ // Управление куками в приложении provide: 'my_module', useFactory: ({ cookie }) => { cookie.get('sid'); // > ads.api3 }, deps: { cookie: COOKIE_MANAGER, // добавляем в зависимость }, }), ],})class MyModule {} Copy "},{"title":"Интерфейс","type":1,"pageTitle":"cookie","url":"docs/references/modules/cookie#интерфейс","content":"Реализует интерфейс CookieManager и добавляет в di провайдер COOKIE_MANAGER. @tinkoff/core "},{"title":"Экспортируемые токены","type":1,"pageTitle":"cookie","url":"docs/references/modules/cookie#экспортируемые-токены","content":"COOKIE_MANAGER_TOKEN# Сущность для работы с куками interface CookieSetOptions { name: string; value: string; expires?: number | Date | string; domain?: string; path?: string; secure?: boolean; httpOnly?: boolean; sameSite?: boolean | 'lax' | 'strict' | 'none';} interface CookieManager { get(name: any): string; all(): Record<string, string>; set({ name, value, ...options }: CookieSetOptions): void; remove(name: string): void;} Copy "},{"title":"deps-graph","type":0,"sectionRef":"#","url":"docs/references/modules/deps-graph","content":"","keywords":""},{"title":"Установка","type":1,"pageTitle":"deps-graph","url":"docs/references/modules/deps-graph#установка","content":""},{"title":"1. Зависимости","type":1,"pageTitle":"deps-graph","url":"docs/references/modules/deps-graph#1-зависимости","content":"Необходимо установить @tramvai/module-deps-graph с помощью npm/yarn npm i @tramvai/module-deps-graph Copy "},{"title":"2. Подключение модуля","type":1,"pageTitle":"deps-graph","url":"docs/references/modules/deps-graph#2-подключение-модуля","content":"Нужно передать в список модулей приложения CommonModule import { createApp } from '@tramvai/core';import { DepsGraphModule } from '@tramvai/module-deps-graph'; createApp({ modules: [DepsGraphModule],}); Copy "},{"title":"Использование","type":1,"pageTitle":"deps-graph","url":"docs/references/modules/deps-graph#использование","content":"Добавляет папи роут /deps-graph (можно найти по адресу /:appName/papi/deps-graph, где appName - поле name из tramvai.json), по которому выводится граф всех зависимостей с возможностью поиска по токену и имени модуля Описание графа# Синий - обычный провайдерЖелтый - mutli-провайдерКрасный - подпавший под поиск  "},{"title":"error-interceptor","type":0,"sectionRef":"#","url":"docs/references/modules/error-interceptor","content":"","keywords":""},{"title":"Интеграция с tramvai","type":1,"pageTitle":"error-interceptor","url":"docs/references/modules/error-interceptor#интеграция-с-tramvai","content":"Модуль не предоставляет публтичного интерфейса, а только подписывается на события инициализации и подключает @tinkoff/error-handlers который перехватывает ошибки в браузере и клиенте "},{"title":"Принцип работы","type":1,"pageTitle":"error-interceptor","url":"docs/references/modules/error-interceptor#принцип-работы","content":"На сервере подписываемся на события unhandledRejection и внезапные остановки выполнения с помощью библиотеки death, затем ошибку кидает в консоль. "},{"title":"env","type":0,"sectionRef":"#","url":"docs/references/modules/env","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"env","url":"docs/references/modules/env#подключение","content":"Уже поставляется внутри @tramvai/module-common и не нужно устанавливать, если подключен module-common. Иначе, нужно установить @tramvai/module-environment "},{"title":"Explanation","type":1,"pageTitle":"env","url":"docs/references/modules/env#explanation","content":""},{"title":"Динамически генерируемый список используемых ENV переменных","type":1,"pageTitle":"env","url":"docs/references/modules/env#динамически-генерируемый-список-используемых-env-переменных","content":"Все используемые параметры в приложения регистрируются с помощью реализации в DI токена ENV_USED_TOKEN и предполагается, что каждый модуль по отдельности регистрирует только те ENV параметры, которые ему необходимы. В таком случае при подключении модуля, будет автоматическая валидация всех переданных параметров, которые необходимы для работы приложения import { provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: ENV_USED_TOKEN, useValue: [ { key: 'DEBUG_MODULE', optional: true }, { key: 'DEBUG_MODULE_URL', optional: true }, ], multi: true, }), ],})export class MyModule {} Copy В выше примере, модуль регистрирует несколько env токенов, которые будут проинициализированы и будут доступны в environmentManager.get('DEBUG_MODULE'). При этом, был передан параметр optional который указывает, что переменные не обязательные для работы приложения. "},{"title":"Валидация переданных параметров","type":1,"pageTitle":"env","url":"docs/references/modules/env#валидация-переданных-параметров","content":"При старте приложения происходит проверка тех токенов, которые были зарегистрированы в DI и были переданы в ENV при запуске. Если в приложение не были переданы все требуемые ENV переменные, то приложение упадет. Так-же есть возможность написать валидаторы для ENV значений, которые запустятся при инициализации приложения. import { provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: ENV_USED_TOKEN, useValue: [ { key: 'MY_ENV', validator: (env) => { if (!env.includes('https')) { return 'Не правильный формат ссылки. Ссылка должна содержать https'; } }, }, ], multi: true, }), ],})export class MyModule {} Copy "},{"title":"Функциональность работает на сервере и в браузере","type":1,"pageTitle":"env","url":"docs/references/modules/env#функциональность-работает-на-сервере-и-в-браузере","content":"Все ENV переменные будут доступны как на сервере, так и браузере без каких либо дополнительных действий и настроек. В браузер автоматически передаются env переменные, которые имеют dehydrate: true "},{"title":"Приоритет получения значений для env переменных","type":1,"pageTitle":"env","url":"docs/references/modules/env#приоритет-получения-значений-для-env-переменных","content":"Так-как есть возможность перезаписывать значения переменных, то переменные заменятся по определенным правилам Правила замены, расположены в порядке приоритета, от меньшего к высокому: Параметры заданные в токенах { key: 'ENV_PARAM', value: 'env value' }Параметры записанные в файле env.development.jsПередача параметров запуска приложения MY_ENV=j node server.js "},{"title":"API","type":1,"pageTitle":"env","url":"docs/references/modules/env#api","content":" Экспортируемые токены и TS интерфейс import { createToken } from '@tinkoff/dippy'; export interface EnvironmentManager { get(name: string): string; getInt(name: string, def: number): number; getAll(): Record<string, string>; update(result: Record<string, string>): void; clientUsed(): Record<string, string>; updateClientUsed(result: Record<string, string>): void;} /** * @description * Сущность `environmentManager` c помощью которого можно получить данные env переменных на сервере и клиенте */export const ENV_MANAGER_TOKEN = createToken<EnvironmentManager>('environmentManager'); /** * @description * Список токенов которые необходимы модулю или приложению. * Позднее все токены из этого списка будут доступны через `environmentManager` * Формат токена ENV_USED_TOKEN: - `key` - идентификатор env переменной. Под этим ключем будет доступно в `environmentManager` и будет получено из внешних источников - `value` - предустановленное значение для токена `key` с низким приоритетом - `optional` - является ли параметр опциональным для работы приложения. Если `true`, то приложение не будет падать, если не было передано значение - `validator` - функция валидации переданного значения. Если функция вернет текст, то выкинется ошибка - `dehydrate` - если передано `false`, то env параметр не передастся клиенту и можно будет получить значение только на серверной стороне * * @example ```tsx interface EnvParameter { key: string; value?: string; optional?: boolean; validator?: (value: string) => boolean | string; dehydrate?: boolean; } ``` */export interface EnvParameter { key: string; value?: string; optional?: boolean; validator?: (value: string) => boolean | string; dehydrate?: boolean;} export const ENV_USED_TOKEN = createToken<EnvParameter[]>('envUsed', { multi: true }); Copy  "},{"title":"How to","type":1,"pageTitle":"env","url":"docs/references/modules/env#how-to","content":""},{"title":"Как прочитать данные в приложении","type":1,"pageTitle":"env","url":"docs/references/modules/env#как-прочитать-данные-в-приложении","content":"Допустим мы зарегистрировали используемый ENV параметр CONFIG_API с помощью токена ENV_USED_TOKEN, теперь в приложении нужно подключить environmentManager и прочитать данные import { provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: 'MY_SERVICE', useClass: class MyService { constructor({ environmentManager }) { console.log(environmentManager.get('CONFIG_API')); } }, deps: { environmentManager: ENV_MANAGER_TOKEN, }, }), ],})export class MyModule {} Copy Этот код будет работать как на сервере, так и в браузере "},{"title":"Как можно просто передать параметры при локальной разработке","type":1,"pageTitle":"env","url":"docs/references/modules/env#как-можно-просто-передать-параметры-при-локальной-разработке","content":"Для этого создайте файл env.development.js в корне проекта и пропишите все ENV переменные для приложения. При инициализации приложения, будет прочитан этот файл. Особенности использования env.developmen.js в production сборке# Приложение двенадцати факторов хранит конфигурацию в переменных окружения, поэтому по умолчанию при process.env.NODE_ENV === 'production' EnvironmentManger не будет считывать файл env.development.js. Если же необходимо локально протестировать приложение с NODE_ENV=production, можно передать флаг DANGEROUS_UNSAFE_ENV_FILES='true' чтобы EnvironmentManger прочитал файл env.development.js и не пришлось вводить все переменные руками. "},{"title":"Как при деплоях передать ENV параметры приложению","type":1,"pageTitle":"env","url":"docs/references/modules/env#как-при-деплоях-передать-env-параметры-приложению","content":"Для этого при запуске приложения передайте ENV параметры. Например в Docker можно это сделать через параметр -e docker run -e MY_ENV_VAR=/ my-image "},{"title":"http-client","type":0,"sectionRef":"#","url":"docs/references/modules/http-client","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#installation","content":"You need to install @tramvai/module-http-client yarn add @tramvai/module-http-client Copy And connect in the project import { createApp } from '@tramvai/core';import { HttpClientModule } from '@tramvai/module-http-client'; createApp({ name: 'tincoin', modules: [HttpClientModule],}); Copy "},{"title":"Features","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#features","content":"The http-client module adds functionality to the application related to API requests. Available providers allow you to create new services to work with any API and create more specific services with preset settings for specific APIs. The module implements interfaces from the library @tramvai/http-client using a special library - adapter @tramvai/tinkoff-request-http-client-adapter, running on top of @tinkoff/request. "},{"title":"Concepts","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#concepts","content":""},{"title":"HTTP client","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#http-client","content":"HTTP client - implementation of the HttpClient interface, created via the HTTP_CLIENT_FACTORY token. HTTP client accepts general settings, some of which will be used as defult values ​​for all requests. The HTTP client does not provide an opportunity to add additional methods for requests, and to perform side actions when the request is completed or failed. "},{"title":"Services for working with API","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#services-for-working-with-api","content":"The API service inherits from the ApiService class, which is exported from @tramvai/http-client. The API service takes an HTTP client in its constructor and uses it for requests. The API service implements all methods for requests from the HttpClient interface, but allows you to modify them. For example, you can replace the implementation of the request method by adding an error message to the catch request via an HTTP client - this logic will automatically work for all other methods - get, put, post, delete. In the API service, you can add custom methods for requests to certain API endpoints, and specify only the necessary parameters in them, and type responses. Additional reasons to create API services - if you need to use several different HTTP clients to work with a specific API, or you need the ability to add a convenient abstraction on top of the basic methods for sending requests. "},{"title":"Usage","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#usage","content":""},{"title":"Create a new HTTP client","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#create-a-new-http-client","content":"Each new HTTP client must directly or indirectly inherit HTTP_CLIENT_FACTORY. New HTTP clients / API services should not be created with scope: Scope.SINGLETON, because each request is supplemented with default parameters specific to each user, for example - passing the X-Real-Ip header from the request to the application in all requests to the API. Basic HTTP client# The HTTP_CLIENT_FACTORY token - provides a factory for creating new HTTP clients. The options are preinstalled with a logger and a cache factory. Peculiarities# For all requests to the API, headers are added from the list returned by the API_CLIENT_PASS_HEADERS token, and X-Real-Ip from the current request to the application Token interface: type HTTP_CLIENT_FACTORY = (options: HttpClientFactoryOptions) => HttpClient; Copy Token use: import { Scope, provide } from '@tramvai/core';import { ENV_MANAGER_TOKEN } from '@tramvai/tokens-common';import { HTTP_CLIENT_FACTORY } from '@tramvai/tokens-http-client'; const provider = provide({ provide: 'WHATEVER_API_HTTP_CLIENT', useFactory: ({ factory, envManager, }: { factory: typeof HTTP_CLIENT_FACTORY; envManager: typeof ENV_MANAGER_TOKEN; }) => { return factory({ name: 'whatever-api', baseUrl: envManager.get('WHATEVER_API'), }); }, deps: { factory: HTTP_CLIENT_FACTORY, envManager: ENV_MANAGER_TOKEN, },}); Copy "},{"title":"Using existing HTTP clients","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#using-existing-http-clients","content":"Most HTTP clients implement additional logic for requests, and inherit from ApiService. Thus, each service has methods get, post, put, delete and request, but there may be specific methods. Common HTTP client# The HTTP_CLIENT token provides a basic client for sending requests to any URLs, request caching is disabled. Token use: import { createAction } from '@tramvai/core';import { HTTP_CLIENT } from '@tramvai/tokens-http-client'; export const fetchAction = createAction({ name: 'fetch', fn: async (_, __, { httpClient }) => { const { payload, headers, status } = await httpClient.get( 'https://www.domain.com/api/endpoint' ); return payload; }, deps: { httpClient: HTTP_CLIENT, },}); Copy "},{"title":"Adding custom data to requests","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#adding-custom-data-to-requests","content":"Let's consider a case using the abstract service WHATEVER_API_SERVICE as an example. Let's say we want to add an X-Real-Ip header to every request: import { provide } from '@tramvai/core';import { HttpClientRequest, HttpClient } from '@tramvai/http-client';import { REQUEST_MANAGER_TOKEN } from '@tramvai/tokens-common'; const provider = provide({ provide: 'WHATEVER_API_SERVICE', useFactory: ({ factory, requestManager, envManager, }: { factory: typeof HTTP_CLIENT_FACTORY; requestManager: typeof REQUEST_MANAGER_TOKEN; envManager: typeof ENV_MANAGER_TOKEN; }) => { return factory({ name: 'whatever-api', baseUrl: envManager.get('WHATEVER_API'), modifyRequest: (request: HttpClientRequest) => { return { ...request, headers: { ...request.headers, 'X-real-ip': requestManager.getClientIp(), }, }; }, }); }, deps: { factory: HTTP_CLIENT_FACTORY, requestManager: REQUEST_MANAGER_TOKEN, envManager: ENV_MANAGER_TOKEN, },}); Copy "},{"title":"How to","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#how-to","content":""},{"title":"How to disable HTTP request caching?","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#how-to-disable-http-request-caching","content":"To disable caching for all HTTP clients, pass the env variable HTTP_CLIENT_CACHE_DISABLED: true to the application "},{"title":"Testing","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#testing","content":"Testing your api clients# If you have a module or providers that define api-clients, then it will be convenient to use special utilities in order to test them separately import { testApi } from '@tramvai/module-http-client/tests';import { CustomModule } from './module'; describe('testApi', () => { it('test', async () => { const { di, fetchMock, mockJsonResponse } = testApi({ modules: [CustomModule], env: { TEST_API: 'testApi', }, }); const httpClient: typeof HTTP_CLIENT = di.get('CUSTOM_HTTP_CLIENT') as any; mockJsonResponse({ a: 'aaa' }); const { payload } = await httpClient.get('test'); expect(payload).toEqual({ a: 'aaa' }); expect(fetchMock).toHaveBeenCalledWith('http://testApi/test', expect.anything()); });}); Copy "},{"title":"Exported tokens","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#exported-tokens","content":"link "},{"title":"Environment Variables","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#environment-variables","content":"HTTP_CLIENT_CACHE_DISABLED - disable caching for all HTTP clientsHTTP_CLIENT_CIRCUIT_BREAKER_DISABLED - disable plugin https://tinkoffcreditsystems.github.io/tinkoff-request/docs/plugins/circuit-breaker.html "},{"title":"log","type":0,"sectionRef":"#","url":"docs/references/modules/log","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"log","url":"docs/references/modules/log#подключение","content":"Уже входит в @tramvai/module-common и отдельно не нужно подключать "},{"title":"Пример","type":1,"pageTitle":"log","url":"docs/references/modules/log#пример","content":"import { Module, commandLineListToken, provide } from '@tramvai/core';import { LOGGER_TOKEN } from '@tramvai/module-common'; @Module({ providers: [ provide({ provide: commandLineListToken.customerStart, useFactory: ({ logger }) => { logger.debug('customer start'); // логгирование в глобальном пространстве логов const myLogger = logger({ name: 'test', }); myLogger.warn('warning'); // логгирование в пространстве test myLogger.error('error!'); }, deps: { logger: LOGGER_TOKEN, }, }), ],})export class MyModule {} Copy "},{"title":"Отображение логов","type":1,"pageTitle":"log","url":"docs/references/modules/log#отображение-логов","content":"см. @tinkoff/logger "},{"title":"Отправка логов на апи","type":1,"pageTitle":"log","url":"docs/references/modules/log#отправка-логов-на-апи","content":"Предполагается что логи с сервера собираются через отдельный механизм, который имеет доступ к выводу консоли сервера и поэтому в логгировании на внешнее апи нет смысла. В браузере логи на апи отправляются с помощью RemoteReporter. По умолчанию отправляются все логи уровня error и fatal. Урл апи определяется из переменной окружения FRONT_LOG_API. Для индивидуальной настройки смотри документацию к RemoteReporter. "},{"title":"Просмотр логов с сервера в браузере","type":1,"pageTitle":"log","url":"docs/references/modules/log#просмотр-логов-с-сервера-в-браузере","content":"Данная функция доступна в дев режиме и создана для упрощения работы с логами при разработке. В консоли браузера при заходе на страницу приложения появится специальная группа логов, под тегом Tramvai SSR Logs при раскрытии логов будут отображены логи которые были залогированы для даного конретного запроса на сервера, причем будут отображены именно те логи, которые подпадают под настройки отображения для сервера. Если необходимо отобразить все логи с сервера с настройками отображения для клиента, то нужно запустить сервер с переменной окружения DEBUG_FULL_SSR "},{"title":"Просмотр логов для запросов на основе @tinkoff/request","type":1,"pageTitle":"log","url":"docs/references/modules/log#просмотр-логов-для-запросов-на-основе-tinkoffrequest","content":"Логгер и настройки для него должны явно передаваться в плагин логгирования, что уже делается в http-client. В плагине используется генерация тега для логгера в виде request.${name} поэтому чтобы отобразить такие необходимо настроить фильтры для отображения для конкретной фабрики запросов: const logger = di.get(LOGGER_TOKEN);const makeRequest = request([...otherPlugins, logger({ name: 'my-api-name', logger })]); Copy Т.к. имя для логгера равно my-api-name, то для отображения логов необходимо: на сервере дополнить переменную окружения LOG_ENABLE: 'request.my-api-name'на клиенте включить логгирование через вызов logger.enable('request.my-api-name') "},{"title":"Как правильно форматировать логи","type":1,"pageTitle":"log","url":"docs/references/modules/log#как-правильно-форматировать-логи","content":"Смотри Как правильно логгировать "},{"title":"Экспортируемые токены","type":1,"pageTitle":"log","url":"docs/references/modules/log#экспортируемые-токены","content":""},{"title":"LOGGER_TOKEN","type":1,"pageTitle":"log","url":"docs/references/modules/log#logger_token","content":"Сущность логгера. Заменяет стандартную реализацию LOGGER_TOKEN из @tramvai/module-common "},{"title":"Изменение серверных настроек логгера","type":1,"pageTitle":"log","url":"docs/references/modules/log#изменение-серверных-настроек-логгера","content":"По умолчанию, настройки отображения логгера на сервере берутся из переменной окружения LOG_ENABLE, а настройки уровня логирования из переменной окружения LOG_LEVEL Для изменения этих настроек в рантайме существует papi роут {app}/private/papi/logger Отображение логов меняется через query параметр enable, например: https://localhost:3000/{app}/private/papi/logger?enable=request.tinkoff Copy Уровень логгирования меняется через query параметр level, например: https://localhost:3000/{app}/private/papi/logger?level=warn Copy Вернуть настройки по умолчанию, из переменных окружения, можно с параметром mode=default: https://localhost:3000/{app}/private/papi/logger?mode=default Copy "},{"title":"Переменные окружения","type":1,"pageTitle":"log","url":"docs/references/modules/log#переменные-окружения","content":"LOG_LEVEL = trace | debug | info | warn | error | fatal - включает отображение логов для заданного уровня и все уровней выше. Пример: если LOG_LEVEL=info, то будут отображаться все логи уровней info, warn, error, fatal LOG_ENABLE = ${name} | ${level}:${name} - позволяет включить отображение всех логов по определенному имени логгера или по определенному имени и уровню. Несколько вхождений передаются через запятую. Примеры: если LOG_ENABLE=server, то будут отображены логи всех уровней с именем serverесли LOG_ENABLE=trace:server*, то будут отображены только логи для server с уровнем traceесли LOG_ENABLE=info:server,client,trace:shared, то будут включены логи для заданных логгеров по правилам выше "},{"title":"Отладка","type":1,"pageTitle":"log","url":"docs/references/modules/log#отладка","content":"Модуль использует логгер с идентификатором ssr-logger "},{"title":"metrics","type":0,"sectionRef":"#","url":"docs/references/modules/metrics","content":"","keywords":""},{"title":"Как пользоваться","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#как-пользоваться","content":"import { createToken } from '@tinkoff/dippy';import { Module, provide } from '@tramvai/core';import { Counter, Metrics, METRICS_MODULE_TOKEN } from '@tramvai/tokens-metrics'; interface SomeModuleOptions { metrics: Metrics;} class SomeModule { private metricActionCounter: Counter; constructor(options: SomeModuleOptions) { this.metricActionCounter = options.metrics.counter({ name: 'some_actions_total', help: 'Total count of some actions', }); } public action(): void { this.metricActionCounter.inc(); // Do some meaningful action }} export const SOME_MODULE = createToken<SomeModule>('someModule'); @Module({ providers: [ provide({ provide: SOME_MODULE, useFactory: (deps) => new SomeModule(deps), deps: { metrics: METRICS_MODULE_TOKEN, }, }), ],})export class SomeModuleContainer {} Copy "},{"title":"Мониторинг исходящих запросов","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#мониторинг-исходящих-запросов","content":"Для того чтобы мониторить состояние исходящих запросов (количество запросов, количество ошибок, время выполнения) в модуле манкипатчатся методы request и get модулей http и https. Чтобы это заработало необходимо просто подключить модуль метрик в приложение. В метрики попадают лейблы: http методhttp код ответаимя сервиса Метрики определяют имя сервиса сопоставляя урлы со значениями в MetricsServicesRegistry. Изначательно туда загружается инвертированное содержимое env, то есть если урл из env является подстрокой урла запроса, то ключ станет именем сервиса. Если совпадает несколько, то берётся самый длинный урл из env. "},{"title":"Как сделать чтобы для запросов в метриках было имя сервиса вместо адреса хоста","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#как-сделать-чтобы-для-запросов-в-метриках-было-имя-сервиса-вместо-адреса-хоста","content":"Можно подсказать модулю метрик имя сервиса, если урл получается динамически. Для этого нужно: подключить модуль по токену METRICS_SERVICES_REGISTRY_TOKEN;вызвать metricsServicesRegistry.register(\"Часть урла или весь урл\", \"Имя сервиса\") "},{"title":"Использование метрик для профилирования перформанса на стороне браузера","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#использование-метрик-для-профилирования-перформанса-на-стороне-браузера","content":"Для измерения продолжительности события, необходимо использовать метод startTimer у классов Gauge, Histogram и Summary. В dev-режиме эти классы патчатся и методы работы с таймером использует PerformanceApi. "},{"title":"Пример использования","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#пример-использования","content":"Без дополнительных полей const metric = metrics.gauge({ name: 'request_measure', help: 'Request duration measure',}); const endTimer = metric.startTimer(); fetch(url).then(() => { endTimer(); // выводим результат - performance.getEntriesByName('request_measure');}); Copy Добавляем динамические поля const metric = metrics.gauge({ name: 'request_measure', help: 'Request duration measure',}); const endTimer = metric.startTimer({ method: 'GET' }); fetch(url).then(() => { endTimer({ status: 200 }); // выводим результат - performance.getEntriesByName('request_measure{method=\"GET\",status=\"200\"}');}); Copy "},{"title":"Клиентские метрики","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#клиентские-метрики","content":"Модуль реализует в себе возможность собирать метрики с клиента и раздавать их прометеусам с помощью обычного серверного механизма через отправку метрик в papi-роуты. Механика работы заключается в том что заводится counter и специальный папи-роут, дёрнув который по http мы можем инкрементировать этот counter. В модуле уже реализован весь общий для таких случаев функционал. Чтобы создать метрику необходимо создать провайдер с токеном REGISTER_INSTANT_METRIC_TOKEN, провайдер должен возвращать список из двух сущностей где первая это slug papi-роута, а вторая это инстанс счётчика. Например: import { provide } from '@tramvai/core'; provide({ provide: REGISTER_INSTANT_METRIC_TOKEN, multi: true, deps: { metrics: METRICS_MODULE_TOKEN, }, useFactory({ metrics }) { return [ 'page-load', new Counter({ name: 'client_page_load_total', help: 'Загрузки страниц у клиентов' }), ]; },}); Copy Теперь для того чтобы инкрементировать метрику client_page_load_total достаточно дёрнуть papi-роут /metrics/page-load. instantMetricsReporter# На практике выяснилось что часто помимо сбора метрик необходимо отправить логи с подробностями. Эту потребность реализует instantMetricsReporter. При вызове логгера он проверяет наличие метрик со slug аналогичным полю event в логах и если такие метрики существуют, то отправляет запрос на соответствующий papi-роут. Таким образом можно одновременно залогировать событие и инкрементировать серверную метрику. import { provide } from '@tramvai/core';provide({ provide: commandLineListTokens.init, multi: true, deps: { logger: LOGGER_TOKEN, }, useFactory({ logger }) { return () => { window.on('load', () => { logger.info({ event: 'page-load' }); }) }; },}), Copy "},{"title":"Отладка","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#отладка","content":"Модуль использует логгеры с идентификаторами: metrics:perf, metrics:papi "},{"title":"Экспортируемые токены","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#экспортируемые-токены","content":"ссылка "},{"title":"mocker","type":0,"sectionRef":"#","url":"docs/references/modules/mocker","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#подключение","content":"Необходимо установить @tramvai/module-mocker: yarn add @tramvai/module-mocker Copy Создать первый мок, в файле mocks/my-api.js, где свойство api должно содержать env переменную с урлом API, который требуется мокировать, в данном случае MY_API: module.exports = { api: 'MY_API', mocks: { 'GET /endpoint?foo=bar': { status: 200, headers: {}, payload: { result: { type: 'json', value: { a: 'b' }, }, }, }, },}; Copy Подключить модуль в проекте: import { createApp } from '@tramvai/core';import { MockerModule } from '@tramvai/module-module'; createApp({ name: 'tincoin', modules: [ MockerModule ],}); Copy Запустить приложения с env переменной MOCKER_ENABLED, например: MOCKER_ENABLED=\"true\" tramvai start tincoin Copy После этого, все запросы на MY_API и на клиенте и на сервере автоматически будут отправлены в мокер, а если не нашлось подходящих моков, проксируются в оригинальное API. "},{"title":"Explanation","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#explanation","content":"Особенности мокера описаны в документации библиотеки. Модуль подключает middleware мокера на papi роуте /mocker, и заменяет все env переменные мокируемых API ссылками на papi, подходящие для серверного и для клиентского кода. По умолчанию, мокируются все API, которые были найдены в моках, это поведение можно переопределить. Мокер подключается только при наличии env переменной MOCKER_ENABLED=\"true\". "},{"title":"Замена env переменных","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#замена-env-переменных","content":"Допустим, приложение имеет env переменную MY_API: https://www.my-api.com/, и для этого API зарегистрирован мок. Модуль рассчитан на работу локально, на динамических стендах, и в test/stage окружениях, это порождает сложность с определением пути до papi эндпоинта: На сервере мы должны делать запрос по абсолютном пути, и тут приложение всегда доступно на localhost, значит env переменные заменяются на урлы вида http://localhost:3000/tincoin/papi/mocker/MY_API/ На клиенте, на стендах мы не знаем текущий домен приложения, и надо делать запросы по относительным путям, поэтому клиентские env переменные заменяются на урлы вида /tincoin/papi/mocker/MY_API/ Благодаря этой замене, все запросы приложения на мокируемое API, клиентские и серверные, автоматически отправляются в мокер. "},{"title":"How to","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#how-to","content":""},{"title":"У меня есть моки для нескольких API, как мокировать только одно из них?","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#у-меня-есть-моки-для-нескольких-api-как-мокировать-только-одно-из-них","content":"По умолчанию все API считываются из моков при старте приложения. Это поведение можно переопределить, передавая список API для мокирования при инициализации модуля: MockerModule.forRoot({ config: () => ({ apis: ['MY_API'], }),}); Copy "},{"title":"Экспортируемые токены","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#экспортируемые-токены","content":" import { createToken } from '@tinkoff/dippy';import type { Mocker, MockRepository } from '@tinkoff/mocker'; export interface MockerOptions { apis: string[];} export const MOCKER = createToken<Mocker>('MOCKER'); export const MOCKER_REPOSITORY = createToken<MockRepository[]>('MOCKER_REPOSITORY', { multi: true,}); export const MOCKER_CONFIGURATION = createToken<() => Promise<MockerOptions>>( 'MOCKER_CONFIGURATION'); Copy  "},{"title":"react-query","type":0,"sectionRef":"#","url":"docs/references/modules/react-query","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#installation","content":"You need to install @tramvai/module-react-query yarn add @tramvai/module-react-query Copy And connect in the project import { createApp } from '@tramvai/core';import { ReactQueryModule } from '@tramvai/module-react-query'; createApp({ name: 'tincoin', modules: [...ReactQueryModule],}); Copy "},{"title":"Explanation","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#explanation","content":"The module adds an instance react-query QueryClient to the DI и and allows specifying options for creating it. The module also adds React wrappers for react-query to the application renderer, which allow using functions for working with query inside components. "},{"title":"Server","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#server","content":"On the server, the module also additionally performs dehydration of the data preloaded on the server in order to transfer them to the client "},{"title":"Client","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#client","content":"The browser additionally performs rehydration of the data preloaded on the server "},{"title":"API","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#api","content":"The module basically provides the necessary things in DI for the library @tramvai/react-query and itself may be needed only if there is a need to change the settings for QueryClient or use QueryClient directly (but better not to use directly) "},{"title":"Exported tokens токены","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#exported-tokens-токены","content":" import { createToken } from '@tinkoff/dippy';import type { QueryClient, DefaultOptions } from 'react-query';import type { DehydratedState } from 'react-query/hydration'; /** * @description * [Клиент react-query](https://react-query.tanstack.com/reference/QueryClient) */ export const QUERY_CLIENT_TOKEN = createToken<QueryClient>('reactQuery queryClient'); /** * @description * [Дефолтные опции для клиента react-query](https://react-query.tanstack.com/guides/important-defaults) */export const QUERY_CLIENT_DEFAULT_OPTIONS_TOKEN = createToken<DefaultOptions>( 'reactQuery queryClientDefaultOptions'); /** * @description * [Стейт для клиента react-query](https://react-query.tanstack.com/reference/hydration/dehydrate), иницилизированный на сервере */export const QUERY_CLIENT_DEHYDRATED_STATE_TOKEN = createToken<DehydratedState>( 'reactQuery queryClientDehydratedState'); Copy  "},{"title":"render","type":0,"sectionRef":"#","url":"docs/references/modules/render","content":"","keywords":""},{"title":"Быстрый обзор","type":1,"pageTitle":"render","url":"docs/references/modules/render#быстрый-обзор","content":" Модуль который внутри себя содержит логику по генерацию html страницы, начиная от получения текущего компонента, так и заканчивая генерации конечного html c помощью библиотеки htmlpagebuilder. Из особенностей, в этом модуле присутствует код создания верхнеуровнего реакт компонента, получения пэйдж компонента и лайаута из роутинга и создание композиции из провайдеров в приложении "},{"title":"Подключение","type":1,"pageTitle":"render","url":"docs/references/modules/render#подключение","content":"Необходимо установить @tramvai/module-render с помощью npm npm i @tramvai/module-render Copy И подключить в проекте import { createApp } from '@tramvai/core';import { RenderModule } from '@tramvai/module-render'; createApp({ name: 'tincoin', modules: [RenderModule],}); Copy "},{"title":"Explanation","type":1,"pageTitle":"render","url":"docs/references/modules/render#explanation","content":""},{"title":"Разные режимы отрисовки React","type":1,"pageTitle":"render","url":"docs/references/modules/render#разные-режимы-отрисовки-react","content":"Подробнее о режимах рендеринга можете узнать в официальной доке в module-render есть поддержка всех типов и вы можете выбрать для своего приложения актуальный тип Для задания режима, необходимо при инициализации RenderModule передать параметр mode RenderModule.forRoot({ mode: 'concurrent' }); Copy Доступны варианты: 'legacy' | 'strict' | 'blocking' | 'concurrent' Постепенная миграция на concurrent режим "},{"title":"Ассеты в приложении","type":1,"pageTitle":"render","url":"docs/references/modules/render#ассеты-в-приложении","content":"Для работы с ресурсами в tramvai был разработан модуль ассетов который позволяет задать в DI список ресурсов и дальше их отрисовать в определенные слоты. Пример: createApp({ providers: [ { multi: true, useValue: [ { type: ResourceType.inlineScript, // inlineScript обернет payload в тег <script> slot: ResourceSlot.HEAD_CORE_SCRIPTS, // определяет позицию где в html будет вставлен ресурс payload: 'alert(\"render\")', }, { type: ResourceType.asIs, // asIs занчит вставить ресурс как есть. без обработки slot: ResourceSlot.BODY_TAIL, payload: '<div>hello from render slots</div>', }, ], }, ],}); Copy type - тип ресурса, уже есть готовые пресеты которые упрощает добавление кода на страницу, без прокидывания дополнительных параметров и так далееslot - место в html странице, куда будет добавлен этот ресурсpayload - что будет отрисовано  Доступные слоты export const REACT_RENDER = 'react:render';export const HEAD_PERFORMANCE = 'head:performance';export const HEAD_META = 'head:meta';export const HEAD_POLYFILLS = 'head:polyfills';export const HEAD_CORE_STYLES = 'head:core-styles';export const HEAD_CORE_SCRIPTS = 'head:core-scripts';export const HEAD_DYNAMIC_SCRIPTS = 'head:dynamic-scripts';export const HEAD_ANALYTICS = 'head:analytics';export const HEAD_ICONS = 'head:icons';export const BODY_START = 'body:start';export const BODY_END = 'body:end';export const BODY_TAIL_ANALYTICS = 'body:tail:analytics';export const BODY_TAIL = 'body:tail'; Copy   Схема разметки слотов в HTML странице import type { StaticDescriptor, DynamicDescriptor } from '@tinkoff/htmlpagebuilder';import { dynamicRender, staticRender } from '@tinkoff/htmlpagebuilder';import { ResourceSlot } from '@tramvai/tokens-render';import { formatAttributes } from './utils'; const { REACT_RENDER, HEAD_CORE_SCRIPTS, HEAD_DYNAMIC_SCRIPTS, HEAD_META, HEAD_POLYFILLS, HEAD_CORE_STYLES, HEAD_PERFORMANCE, HEAD_ANALYTICS, BODY_START, BODY_END, HEAD_ICONS, BODY_TAIL_ANALYTICS, BODY_TAIL,} = ResourceSlot; export const htmlPageSchemaFactory = ({ htmlAttrs,}): Array<StaticDescriptor | DynamicDescriptor> => { return [ staticRender('<!DOCTYPE html>'), staticRender(`<html ${formatAttributes(htmlAttrs, 'html')}>`), staticRender('<head>'), staticRender('<meta charset=\"UTF-8\">'), dynamicRender(HEAD_META), dynamicRender(HEAD_PERFORMANCE), dynamicRender(HEAD_CORE_STYLES), dynamicRender(HEAD_POLYFILLS), dynamicRender(HEAD_DYNAMIC_SCRIPTS), dynamicRender(HEAD_CORE_SCRIPTS), dynamicRender(HEAD_ANALYTICS), dynamicRender(HEAD_ICONS), staticRender('</head>'), staticRender(`<body ${formatAttributes(htmlAttrs, 'body')}>`), dynamicRender(BODY_START), // react app dynamicRender(REACT_RENDER), dynamicRender(BODY_END), dynamicRender(BODY_TAIL_ANALYTICS), dynamicRender(BODY_TAIL), staticRender('</body>'), staticRender('</html>'), ];}; Copy  Как добавить загрузку ассетов на странице "},{"title":"Автоматический инлайнинг ресурсов","type":1,"pageTitle":"render","url":"docs/references/modules/render#автоматический-инлайнинг-ресурсов","content":"Контекст# Большое количество файлов ресурсов создаёт проблемы при загрузке страницы, т.к. браузеру приходится создавать много соединений на небольшие файлы Решение# Решили добавить возможность включить часть ресурсов прямо в приходящий с сервера HTML. Чтобы не инлайнить вообще всё, добавлена возможность задать верхнюю границу размера файлов. Подключение и конфигурация# С версии 0.60.7 инлайнинг для стилей включен по умолчанию, инлайнятся CSS-файлы размером меньше 40kb до gzip (+-10kb после gzip). Для переопределения этих настроек нужно добавить провайдер с указанием типов ресурсов, которые будут инлайниться (стили и\\или скрипты), а также верхнюю границу размера файлов (в байтах, до gzip): import { RESOURCE_INLINE_OPTIONS } from '@tramvai/tokens-render';import { ResourceType } from '@tramvai/tokens-render';import { provide } from '@tramvai/core'; provide({ provide: RESOURCE_INLINE_OPTIONS, useValue: { types: [ResourceType.script, ResourceType.style], // Включаем для стилей и скриптов threshold: 1024, // 1kb unzipped },}), Copy Особенности# Инлайнятся все скрипты и\\или стили (в зависимости от настроек), зарегистрированные через ResourcesRegistry Загрузка файлов на сервере происходит в lazy-режиме асинхронно. Это означает, что при первой загрузке страницы инлайнинга не будет происходить. Также это означает, что никакого дополнительного ожидания загрузки ресурсов на стороне сервера не происходит. После попадания файла в кэш он будет инлайниться. Кэш имеет TTL 30 минут, сброс кэша не предусмотрен. "},{"title":"Автоматический предзагрузка ассетов приложений","type":1,"pageTitle":"render","url":"docs/references/modules/render#автоматический-предзагрузка-ассетов-приложений","content":"Для ускорения загрузки данных добавлена система подзагрузки данных для ресурсов и асинхронных чанков, которая работает по следующему сценарию: После рендеринга приложения мы получаем информацию о всех используемых в приложении css, js и асинхронных чанкахДальше добавляем все css в прелоад тег и навешиваем onload событие. Нам необходимо максимально быстро загрузить блокирующие ресурсы.При загрузке любого css файла, добавляем в предзагрузку все необходимые js файлы Особенности# Обязательно должен быть синхронизирована последняя часть идентификатора бандла с названием чанка const dashboard = () => require.ensure([], (require) => require('./bundles/dashboard'), 'dashboard');bundles: { 'platform/mvno/dashboard': dashboard,} Copy или если используете import const dashboard = () => import(/* webpackChunkName: \"dashboard\" */ './bundles/dashboard');bundles: { 'platform/mvno/dashboard': dashboard,} Copy В примере выше, 'dashboard' и last('platform/mvno/dashboard'.split('/')) имеют одинаковое значение. Иначе мы не сможем на стороне сервера узнать, какой из списка чанков подходит в бандлу и подзагрузка произойдет только на стороне клиента. "},{"title":"Базовый layout","type":1,"pageTitle":"render","url":"docs/references/modules/render#базовый-layout","content":"В module-render встроен дефолтный базовый layout, который поддерживает различные способы расширения и добавления функциональности Подробнее про лайаут можете почитать на странице библиотеке Добавление базовых header и footer# Можно добавить компоненты header и footer, которые будут отрисовываться по умолчанию для всех страниц Через провайдер# Зарегистрировать компоненты header и footer через провайдеры import { DEFAULT_HEADER_COMPONENT, DEFAULT_FOOTER_COMPONENT } from '@tramvai/tokens-render';import { provide } from '@tramvai/core'; createApp({ providers: [ provide({ provide: DEFAULT_HEADER_COMPONENT, useValue: DefaultHeader, }), provide({ provide: DEFAULT_FOOTER_COMPONENT, useValue: DefaultFooter, }), ],}); Copy Через бандл# Можно зарегистрировать в бандле компонент headerDefault и footerDefault, которые будет отрисовываться для всех роутов, у которых не переопределены headerComponent и footerComponent. createBundle({ name: 'common-bundle', components: { headerDefault: CustomHeader, footerDefault: CustomFooter, },}); Copy Добавление компонентов и враперов# Добавить кастомные компоненты и врапперы для layout можно через токен LAYOUT_OPTIONS import { provide } from '@tramvai/core';@Module({ providers: [ provide({ provide: 'LAYOUT_OPTIONS', multi: true, useValue: { // react компоненты components: { // базовые кастомные компоненты врапперы для отрисовки страницы и контента content: Content, page: Page, // глобальные компоненты alerts: Alerts, feedback: Feedback, }, // HOC для компонентов wrappers: { layout: layoutWrapper, alerts: [alertWrapper1, alertWrapper2], }, }, }), ],})export class MyLayoutModule {} Copy Подробнее про опции components и wrappers можно узнать в @tinkoff/layout-factory Замена базового layout# Если вам не подходит базовый лайаут, вы можете его подменить на любой другой React компонент. При этом вам нужно самостоятельно реализовывать все врапперы и подключать глобальные компоненты, если они вам нужны. Заменить можно двумя способами: Добавить layoutComponent у роута# Вы можете прописать параметр layoutComponent у роута в properties и зарегистрировать компонент в bundle. При отрисовке страницы отобразится зарегистрированный компонент createBundle({ name: 'common-bundle', components: { myCustomLayout: CustomLayout, },}); Copy Переопределить layoutDefault# Вы можете зарегистрировать в бандле компонент layoutDefault который автоматически будет отрисовываться для всех роутов, у которых не переопределен layoutComponent createBundle({ name: 'common-bundle', components: { layoutDefault: CustomLayout, },}); Copy "},{"title":"How to","type":1,"pageTitle":"render","url":"docs/references/modules/render#how-to","content":""},{"title":"Как добавить загрузку ассетов на странице","type":1,"pageTitle":"render","url":"docs/references/modules/render#как-добавить-загрузку-ассетов-на-странице","content":"Присутствует 2 способа, как можно добавить ресурсы в приложение токен RENDER_SLOTS, в который можно передать список ресурсов, например HTML разметка, inline скрипты, тег scriptтокен RESOURCES_REGISTRY для получения менеджера ресурсов, и регистрации нужных ресурсов вручную Пример:  Пример приложения import React from 'react';import { createApp, createBundle, commandLineListTokens } from '@tramvai/core';import { RENDER_SLOTS, RESOURCES_REGISTRY, ResourceType, ResourceSlot,} from '@tramvai/module-render';import { modules } from '../common'; function Page() { return <div>Render</div>;} const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, },}); createApp({ name: 'render-add-resources', modules: [...modules], providers: [ { // Если требуется добавить свои ресурсы (скрипты, стили, картинки) для загрузки, то можно использовать // провайдер RENDER_SLOTS для добавления необходимого, все это потом будет использовано в RenderModule // и вставлено в html provide: RENDER_SLOTS, multi: true, useValue: [ { type: ResourceType.inlineScript, // inlineScript обернет payload в тег <script> slot: ResourceSlot.HEAD_CORE_SCRIPTS, // определяет позицию где в html будет вставлен ресурс payload: 'alert(\"render\")', }, { type: ResourceType.asIs, // asIs занчит вставить ресурс как есть. без обработки slot: ResourceSlot.BODY_TAIL, payload: '<div>hello from render slots</div>', }, ], }, { provide: commandLineListTokens.resolveUserDeps, multi: true, // также ресурсы можно добавить отдельно через di и токен RESOURCES_REGISTRY useFactory: ({ resourcesRegistry }) => { return function addMyScripts() { resourcesRegistry.register({ slot: ResourceSlot.HEAD_ANALYTICS, // место вставки type: ResourceType.script, // script создаст новый тег скрипт с src равном payload payload: './some-script.js', }); }; }, deps: { resourcesRegistry: RESOURCES_REGISTRY, }, }, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Copy  "},{"title":"Как можно перевести приложения на Concurrent render mode","type":1,"pageTitle":"render","url":"docs/references/modules/render#как-можно-перевести-приложения-на-concurrent-render-mode","content":"React позволяет выполнить постепенную миграцию приложения Этапы миграции: Strict Mode - строгий режим, в котором React предупреждает об использовании легаси API Для подключения необходимо сконфигурировать render-module modules: [ RenderModule.forRoot({ mode: 'strict' })] Copy Затем необходимо исправить все новые предупреждения, такие как использование легаси методов жизненного цикла и строковые рефы. Blocking Mode - добавляет часть возможностей Concurrent Mode, например Suspense на сервере. Подходит для постепенной миграции на Concurrent Mode. Для подключения необходимо установить экспериментальную версию React и сконфигурировать render-module npm install react@experimental react-dom@experimental Copy modules: [ RenderModule.forRoot({ mode: 'blocking' })] Copy На этом этапе надо проверить работоспособность приложения, и можно попробовать новые API, например SuspenseList Concurrent Mode Для подключения необходимо установить экспериментальную версию React и сконфигурировать render-module npm install react@experimental react-dom@experimental Copy modules: [ RenderModule.forRoot({ mode: 'concurrent' })] Copy На этом этапе надо проверить работоспособность приложения, и можно попробовать новые API, например useTransition "},{"title":"Тестирование","type":1,"pageTitle":"render","url":"docs/references/modules/render#тестирование","content":"Тестирование расширений рендера через токены RENDER_SLOTS или RESOURCES_REGISTRY# Если у вас имеется модуль или провайдеры которые определяют RENDER_SLOTS или используют RESOURCES_REGISTRY, то удобно будет использовать специальные утилиты для того чтобы протестировать их отдельно import { RENDER_SLOTS, ResourceSlot, RESOURCES_REGISTRY, ResourceType,} from '@tramvai/tokens-render';import { testPageResources } from '@tramvai/module-render/tests';import { CustomModule } from './module';import { providers } from './providers'; describe('testPageResources', () => { it('modules', async () => { const { render } = testPageResources({ modules: [CustomModule], }); const { head } = render(); expect(head).toMatchInlineSnapshot(`\"<meta charset=\\\\\"UTF-8\\\\\"><script>console.log(\\\\\"from module!\\\\\")</script>\"`); }); it('providers', async () => { const { render, runLine } = testPageResources({ providers, }); expect(render().body).toMatchInlineSnapshot(`\"\" `); await runLine(commandLineListTokens.resolvePageDeps); expect(render().body).toMatchInlineSnapshot(`\"<script defer=\\\\\"defer\\\\\" charset=\\\\\"utf-8\\\\\" crossorigin=\\\\\"anonymous\\\\\" src=\\\\\"https://scripts.org/script.js\\\\\"></script><span>I\\`m body!!!</span>\" `); });}); Copy "},{"title":"Экспортируемые токены","type":1,"pageTitle":"render","url":"docs/references/modules/render#экспортируемые-токены","content":"ссылка "},{"title":"sentry","type":0,"sectionRef":"#","url":"docs/references/modules/sentry","content":"","keywords":""},{"title":"Подключение в проект","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#подключение-в-проект","content":""},{"title":"Переменные окружения","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#переменные-окружения","content":"Обязательные: SENTRY_DSN - DSN приложения Опциональные: SENTRY_RELEASE - информация о текущем релизе приложенияSENTRY_ENVIRONMENT - информация об окруженииSENTRY_SDK_URL - URL для загрузки Sentry SDK в браузере, задан по умолчаниюSENTRY_DSN_CLIENT - DSN приложения для использования только в браузере. "},{"title":"Подключение модуля","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#подключение-модуля","content":"SentryModule следует подключать в приложение одним из первых import { SentryModule } from '@tramvai/module-sentry'; createApp({ modules: [SentryModule],}); Copy И обязательно добавьте SENTRY_DSN параметр на стендах. Иначе плагин не будет работать. "},{"title":"Пример отправки кастомных ошибок","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#пример-отправки-кастомных-ошибок","content":"import { createAction } from '@tramvai/core';import { SENTRY_TOKEN } from '@tramvai/module-sentry';import { loadUsers } from './users'; export default createAction({ name: 'loadUsers', fn: async (context, _, { sentry }) => { try { await loadUsers(); } catch (e) { sentry.captureException(e); throw e; } }, deps: { sentry: SENTRY_TOKEN, },}); Copy "},{"title":"Локальный дебаг модуля","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#локальный-дебаг-модуля","content":"Локально Sentry отключен и если вы хотите оддебажить модуль, то необходимо явно включить Sentry SentryModule.forRoot({ enabled: true, debug: true }); Copy И добавить в env.development.js параметр SENTRY_DSN после этого Sentry включится при локальной разработке "},{"title":"Получение DSN","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#получение-dsn","content":"Для этого: Зайдите в UI интерфейс SentryНажмите на таб SettingsВ табе Projects выберите свой проектВыберите Client Keys (DSN)Скопируйте текст с DefaultDSN поля. "},{"title":"Sensitive Data","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#sensitive-data","content":"Прежде чем начать использовать модуль, следует ознакомиться с документаций и в случае необходимости сконфигурировать под свое приложение Sentry старается максимально обогощать контекст ошибки, формируя breadcrumbs и получая информацию от дополнительных интеграций. Все это можно конфигурировать, но следует внимательно следить за тем, какая информация в итоге попадает в Sentry хранилище. "},{"title":"Поведение","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#поведение","content":"Модуль использует universal подход, что позволяет логировать ошибки на клиенте и сервере. Интеграция c Sentry SDK происходит на шаге commandLineListTokens.init. По умолчанию Sentry включается только для production и если имется DSN. "},{"title":"Browser","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#browser","content":"Концептуально используется lazy loaded подход при котором Sentry SDK подключается динамически (возможно по необходимости), то есть @sentry/browser не попадает в итоговый бандл "},{"title":"Node","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#node","content":"Используется @sentry/node и Sentry express middleware "},{"title":"Загрузка sourcemaps","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#загрузка-sourcemaps","content":"Для загрузки sourcemaps в Sentry систему можно использовать @sentry/cli. Важно правильно указать --url-prefix. --rewrite нужен, чтобы сократить размер загружаемых файлов и выполнить проверку валидности сорсмап Пример такого скрипта для загрузки: ci/sentry-upload-sourcemaps:# set -eu -o pipefail -x PACKAGE_VERSION=$(node -p -e \"require('./package.json').version\")VERSION=${SENTRY_RELEASE:-\"${PACKAGE_VERSION}-${CI_COMMIT_SHA}\"}export SENTRY_PROJECT=\"${APP}\"export SENTRY_URL=\"${SENTRY_URL_TEST}\"export SENTRY_AUTH_TOKEN=\"${SENTRY_AUTH_TOKEN_TEST}\"sentry-cli releases files $VERSION upload-sourcemaps --rewrite --url-prefix \"~/\" ./server/ & \\sentry-cli releases files $VERSION upload-sourcemaps --rewrite --url-prefix \"~/platform/\" ./assets/ Copy Чтобы генерировались sourcemaps для сервера, нужно указать \"sourceMapServer\": true в configurations для приложения в platform.json. "},{"title":"Экспортируемые токены","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#экспортируемые-токены","content":"SENTRY_TOKEN# Подготовленный инстанс Sentry на основе Node SDK или Browser SDK "},{"title":"SENTRY_OPTIONS_TOKEN","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#sentry_options_token","content":"Опции для конфигурирования Sentry для Node и Browser окружений "},{"title":"SENTRY_REQUEST_OPTIONS_TOKEN","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#sentry_request_options_token","content":"Опции для конфигурирования парсера данных из запроса для express middleware "},{"title":"SENTRY_FILTER_ERRORS","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#sentry_filter_errors","content":"Позволяет передать функцию для фильтрации ошибок перед отправкой в Sentry. Механизм фильтрации описан в документации Sentry, в функцию передаются аргументы event и hint метода beforeSend. "},{"title":"seo","type":0,"sectionRef":"#","url":"docs/references/modules/seo","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#подключение","content":"Необходимо установить @tramvai/module-seo с помощью npm npm i @tramvai/module-seo Copy И подключить в проекте import { createApp } from '@tramvai/core';import { SeoModule } from '@tramvai/module-seo'; createApp({ name: 'tincoin', modules: [...SeoModule],}); Copy "},{"title":"Интеграция с tramvai","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#интеграция-с-tramvai","content":"Модуль не добавляет публичное api в di для использования. Для рендера seo используется возможности @tramvai/module-render для вставки кода в html-страницу. "},{"title":"Базовые источники данных","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#базовые-источники-данных","content":"default - список базовых пред установленных параметровconfig/meta - список мета параметров, которые были переданы и проставлены в блоке seo в админке "},{"title":"Подключение дополнительных источников данных","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#подключение-дополнительных-источников-данных","content":"Библиотека @tinkoff/meta-tags-generate позволяет подключать дополнительные источники данных для мета тегов с возможностью перезаписать базовые. Для этого необходимо определить мульти провайдер META_UPDATER_TOKEN import { createApp, provide } from '@tramvai/core';import { SeoModule, META_UPDATER_TOKEN, META_PRIORITY_ROUTE } from '@tramvai/module-seo'; const metaSpecial = (meta) => { meta.updateMeta(META_PRIORITY_ROUTE, { // приоритет - 10 title: 'title', // ключ/значение в мете, metaCustom: { // подробная информация о формате [в доке](references/libs/meta-tags-generate.md) tag: 'meta', attributes: { name: 'metaCustomNameAttribute', content: 'metaCustomContent', }, }, });}; createApp({ providers: [ provide({ // либо добавить через провайдер provide: META_UPDATER_TOKEN, multi: true, useValue: metaSpecial, }), ], modules: [ SeoModule.forRoot({ list: [metaSpecial], }), ],}); Copy Каждый источник представляет собой функцию которая принимает meta и позволяет расширять мету через вызов updateMeta. Приоритет представляет собой положительное число, для каждого конкретного ключа меты будет использовано значение с наивысшим приоритетом, значение с приоритетом 0 обозначают значение по умолчанию. Подробнее о формате в доке "},{"title":"Установка seo данных динамически","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#установка-seo-данных-динамически","content":"Если требуется установить seo в страничном экшене или на одном из шагов commandLineRunner, то можно использовать явно сущность MetaWalk из либы @tinkoff/meta-tags-generate import { createAction } from '@tramvai/core';import { META_WALK_TOKEN, META_PRIORITY_APP } from '@tramvai/module-seo'; createAction({ name: 'action', fn: async (context, payload, { meta }) => { meta.updateMeta(META_PRIORITY_APP, { title: 'WoW, such dynamic!', }); }, deps: { meta: META_WALK_TOKEN, }, conditions: { always: true, },}); Copy "},{"title":"Замена default seo данных","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#замена-default-seo-данных","content":"SEO модуль поставляется с default паком seo тегов. Если они вам не подходят, вы можете заменить реализацию провайдера и поставить свои данные: import { createApp } from '@tramvai/core';import { SeoModule, META_DEFAULT_TOKEN } from '@tramvai/module-seo'; createApp({ providers: [ // Изменяем реализацию токена metaDefaultPack { provide: META_DEFAULT_TOKEN, useValue: { title: 'E Corp' }, }, ], modules: [SeoModule],}); Copy После этого у нас будут подставляться другие дефолтные параметры "},{"title":"Meta параметры","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#meta-параметры","content":"В библиотеке уже предопределены часть базовых параметров для удобного использования при конфигурировании роутов. И мы можем использовать мета параметры вида title: 'Тинькофф' Список таких конвертеров, необходимо смотреть в файле src/converters/converters.ts "},{"title":"How to","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#how-to","content":""},{"title":"Тестирование","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#тестирование","content":"Тестирование работы с META_UPDATER_TOKEN и META_DEFAULT_TOKEN# Если у вас имеется модуль или провайдеры которые определяют META_UPDATER_TOKEN или META_DEFAULT_TOKEN, то удобно будет использовать специальные утилиты для того чтобы протестировать их отдельно import { Module, provide } from '@tramvai/core';import { testMetaUpdater } from '@tramvai/module-seo/tests';import { META_PRIORITY_APP, META_DEFAULT_TOKEN, META_UPDATER_TOKEN } from '@tramvai/module-seo'; describe('testMetaUpdater', () => { it('modules', async () => { const metaUpdater = jest.fn< ReturnType<typeof META_UPDATER_TOKEN>, Parameters<typeof META_UPDATER_TOKEN> >((walker) => { walker.updateMeta(META_PRIORITY_APP, { title: 'test title', }); }); @Module({ providers: [ provide({ provide: META_UPDATER_TOKEN, multi: true, useValue: metaUpdater, }), ], }) class CustomModule {} const { renderMeta } = testMetaUpdater({ modules: [CustomModule], }); const { render, metaWalk } = renderMeta(); expect(metaWalk.get('title').value).toBe('test title'); expect(render).toMatch('<title data-meta-dynamic=\"true\">test title</title>'); }); it('providers', async () => { const { renderMeta } = testMetaUpdater({ providers: [ provide({ provide: META_DEFAULT_TOKEN, useValue: { title: 'default title', }, }), ], }); const { render } = renderMeta(); expect(render).toMatch('<title data-meta-dynamic=\"true\">default title</title>'); });}); Copy "},{"title":"router","type":0,"sectionRef":"#","url":"docs/references/modules/router","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"router","url":"docs/references/modules/router#installation","content":"You need to install @tramvai/module-router: yarn add @tramvai/module-router Copy And connect in the project: import { createApp } from '@tramvai/core';import { NoSpaRouterModule, SpaRouterModule } from '@tramvai/module-router'; createApp({ name: 'tincoin', modules: [SpaRouterModule], // modules: [ NoSpaRouterModule ], if you want to disable client SPA transitions}); Copy "},{"title":"Explanation","type":1,"pageTitle":"router","url":"docs/references/modules/router#explanation","content":"The module is based on the library @tinkoff/router "},{"title":"Navigation flow on the server","type":1,"pageTitle":"router","url":"docs/references/modules/router#navigation-flow-on-the-server","content":" "},{"title":"Flow of the first navigation on the client","type":1,"pageTitle":"router","url":"docs/references/modules/router#flow-of-the-first-navigation-on-the-client","content":" "},{"title":"Flow of navigation on the client without SPA transitions","type":1,"pageTitle":"router","url":"docs/references/modules/router#flow-of-navigation-on-the-client-without-spa-transitions","content":" "},{"title":"Flow of navigation on the client with SPA transitions","type":1,"pageTitle":"router","url":"docs/references/modules/router#flow-of-navigation-on-the-client-with-spa-transitions","content":" "},{"title":"API","type":1,"pageTitle":"router","url":"docs/references/modules/router#api","content":""},{"title":"Static routes in the application","type":1,"pageTitle":"router","url":"docs/references/modules/router#static-routes-in-the-application","content":"Route description format: const routes = [ { // the name of the route is required name: 'route1', // the path of the route is required path: '/route/a/', // additional configs for the route config: { // layout component name layoutComponent: 'layout', // page component name pageComponent: 'page', }, },]; Copy You can explicitly transfer a list of routes to routing when adding a router module: import { createApp } from '@tramvai/core';import { SpaRouterModule } from '@tramvai/module-router'; const routes = [ // ...]; createApp({ modules: [ // ..., SpaRouterModule.forRoot(routes), ],}); Copy Or separately with the ROUTES_TOKEN token (you can set it several times): import { ROUTES_TOKEN } from '@tramvai/module-router';import { provide } from '@tramvai/core'; const routesCommon = [ // ...];const routesSpecific = [ // ...]; const providers = [ // ..., provide({ provide: ROUTES_TOKEN, multi: true, useValue: routesCommon, }), provide({ provide: ROUTES_TOKEN, multi: true, useValue: routesSpecific, }),]; Copy "},{"title":"PAGE_SERVICE_TOKEN","type":1,"pageTitle":"router","url":"docs/references/modules/router#page_service_token","content":"Service wrapper for working with routing. Serves to hide routing work and is the preferred way of routing work. Методы: getCurrentRoute() - get the current route,getCurrentUrl() - object-result of parsing the current urlgetConfig() - get the config of the current pagegetContent() - get content for the current pagegetMeta() - get the meta for the current pagenavigate(options) - navigation to a new page moreupdateCurrentRoute(options) - update the current route with new parameters moreback() - go back through historyforward() - go forward through historygo(to) - go to the specified delta by history "},{"title":"RouterStore","type":1,"pageTitle":"router","url":"docs/references/modules/router#routerstore","content":"Store that stores information about the current and previous routes. Properties: currentRoute - current routecurrentUrl - current urlpreviousRoute - previous routepreviousUrl - previous url "},{"title":"ROUTER_GUARD_TOKEN","type":1,"pageTitle":"router","url":"docs/references/modules/router#router_guard_token","content":"Allows you to block or redirect the transition to the page under certain conditions. See @tinkoff/router "},{"title":"Redirects","type":1,"pageTitle":"router","url":"docs/references/modules/router#redirects","content":"Redirects can be done via guards or explicitly via the redirect property in the route. const routes = [ // ..., { name: 'redirect', path: '/from/', redirect: '/to/', },]; Copy "},{"title":"Not Found route","type":1,"pageTitle":"router","url":"docs/references/modules/router#not-found-route","content":"The route used if no matches were found for the current page, can be specified in a special way in the list of routes. const route = [ // ...other routes, { name: 'not-found', path: '*', config: { pageComponent: 'notfoundComponentName', }, },]; Copy "},{"title":"ROUTE_RESOLVE_TOKEN","type":1,"pageTitle":"router","url":"docs/references/modules/router#route_resolve_token","content":"Allows you to define an asynchronous function that returns a route object that will be called if no suitable static route was found in the application. "},{"title":"ROUTE_TRANSFORM_TOKEN","type":1,"pageTitle":"router","url":"docs/references/modules/router#route_transform_token","content":"Transformer function for application routes (set statically and those that will be loaded via ROUTE_RESOLVE_TOKEN) "},{"title":"Method of setting when actions should be performed during SPA transitions","type":1,"pageTitle":"router","url":"docs/references/modules/router#method-of-setting-when-actions-should-be-performed-during-spa-transitions","content":"By default, SPA transitions execute actions after defining the next route, but before the actual transition, which allows the page to be displayed immediately with new data, but can cause a noticeable visual lag if the actions are taken long enough. It is possible to change the behavior and make the execution of actions after the transition itself. Then, when developing components, you will need to take into account that data will be loaded as it becomes available. Configurable explicitly when using the routing module: import { createApp } from '@tramvai/core';import { SpaRouterModule } from '@tramvai/module-router'; createApp({ modules: [ // ..., SpaRouterModule.forRoot([], { spaActionsMode: 'after', // default is 'before' }), ],}); Copy or through token ROUTER_SPA_ACTIONS_RUN_MODE_TOKEN: import { ROUTER_SPA_ACTIONS_RUN_MODE_TOKEN } from '@tramvai/module-router';import { provide } from '@tramvai/core'; const providers = [ // ..., provide({ provide: ROUTER_SPA_ACTIONS_RUN_MODE_TOKEN, useValue: 'after', }),]; Copy "},{"title":"How to","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to","content":""},{"title":"Working with navigation in providers and actions","type":1,"pageTitle":"router","url":"docs/references/modules/router#working-with-navigation-in-providers-and-actions","content":"In this case, it is best to use the PAGE_SERVICE_TOKEN import { provide, createAction } from '@tramvai/core';import { PAGE_SERVICE_TOKEN } from '@tramvai/module-router'; const provider = provide({ provide: 'token', useFactory: ({ pageService }) => { if (pageService().getCurrentUrl().pathname === '/test/') { return pageService.navigate({ url: '/redirect/', replace: true }); } }, deps: { pageService: PAGE_SERVICE_TOKEN, },}); const action = createAction({ name: 'action', fn: (_, __, { pageService }) => { if (pageService.getConfig().pageComponent === 'pageComponent') { return page.updateCurrentRoute({ query: { test: 'true' } }); } }, deps: { pageService: PAGE_SERVICE_TOKEN, },}); Copy "},{"title":"Working with navigation in React components","type":1,"pageTitle":"router","url":"docs/references/modules/router#working-with-navigation-in-react-components","content":"You can work with routing inside React components using hooks and components - useNavigate, useRoute, Link from the @tinkoff/router  An example of working with navigation in the application import React from 'react';import { createApp, createBundle } from '@tramvai/core';import { SpaRouterModule, useNavigate, useUrl, Link } from '@tramvai/module-router';import { modules } from '../common'; const Navigation = ['/1/', '/2/', '/3/']; function Page() { // useUrl allows you to get the current url const { pathname, path } = useUrl(); // useNavigate allows you to get a function with which you can call the navigation const navigate = useNavigate(); // useNavigate also allows you to set properties immediately so that the result can be passed immediately as a callback const navigateToRoot = useNavigate({ url: '/', query: { a: '1', b: '2' } }); return ( <div> <div>Current Path: {path}</div> <div> <button type=\"button\" onClick={navigateToRoot}> Navigate to Root </button> {/* the Link component allows you to create a link with a transition */} <Link url=\"/link/\" replace> <button type=\"button\">Navigate By Link</button> </Link> </div> {Navigation.map((p) => { if (p !== pathname) { return ( <button type=\"button\" onClick={() => navigate({ url: p })}> Navigate to {p} </button> ); } return null; })} </div> );} const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, },}); createApp({ name: 'route-navigate', modules: [ SpaRouterModule.forRoot([ { name: 'root', path: '/', }, { name: 'link', path: '/link/', }, { name: '1', path: '/1/', }, { name: '2', path: '/2/', }, { name: '3', path: '/3/', }, ]), ...modules, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Copy  "},{"title":"How to set static routes","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to-set-static-routes","content":"RouterModule allows you to add new routes when configuring your application. The second way is to pass static routes to DI via the ROUTES_TOKEN token.  An example of adding static routes to an application import React from 'react';import { createApp, createBundle } from '@tramvai/core';import { useSelector } from '@tramvai/state';import { useDi } from '@tramvai/react';import { SpaRouterModule, ROUTES_TOKEN, PAGE_SERVICE_TOKEN } from '@tramvai/module-router'; import { modules } from '../common'; const Navigation = ['/1/', '/2/', '/3/']; function Page() { // useSelector to get the current route // store 'router' is provided by RouterModule const state = useSelector('router', (x) => x.router); // pageService - a wrapper for working with a router, you can get various properties and initiate a transition // but through useDi you cannot subscribe to data changes inside services, so to subscribe to route changes // used by useSelector above const pageService = useDi(PAGE_SERVICE_TOKEN); const { pathname, path } = state.currentUrl; return ( <div> <div>Current Path: {path}</div> {Navigation.map((p) => { if (p !== pathname) { return ( <button type=\"button\" onClick={() => pageService.navigate({ url: p })}> Navigate to {p} </button> ); } return null; })} </div> );} const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, },}); createApp({ name: 'route-static-routes', modules: [ // the static forRoot method allows you to define static routes in the application - // these routes are always available and the config for them is not loaded from the admin panel, but are set right there SpaRouterModule.forRoot([ { name: '1', path: '/1/', }, { name: '2', path: '/2/', }, ]), ...modules, ], providers: [ { // you can also set static routes by a separate provider provide: ROUTES_TOKEN, multi: true, useValue: [ { name: '3', path: '/3/', }, ], }, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Copy  "},{"title":"How to set Route Guard","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to-set-route-guard","content":"ROUTER_GUARD_TOKEN is set as an asynchronous function, which allows you to perform various actions and influence the routing behavior.  Example router guards job in application import React from 'react';import { createReducer, createEvent } from '@tramvai/state';import { createApp, createBundle, createAction } from '@tramvai/core';import { SpaRouterModule, ROUTER_GUARD_TOKEN, useNavigate, useUrl } from '@tramvai/module-router';import { STORE_TOKEN, CONTEXT_TOKEN, COMBINE_REDUCERS } from '@tramvai/module-common';import { modules } from '../common'; const Navigation = ['/1/', '/2/', '/3/', '/redirect/', '/block/']; function Page() { const navigate = useNavigate(); const { pathname, path } = useUrl(); return ( <div> <div>Current Path: {path}</div> {Navigation.map((p) => { if (p !== pathname) { return ( <button type=\"button\" onClick={() => navigate({ url: p })}> Navigate to {p} </button> ); } return null; })} </div> );} const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, },}); const event = createEvent<boolean>('event');const store = createReducer<boolean | void>('store', undefined).on(event, (_, val) => val); const action = createAction({ name: 'action', fn: async (context) => { await new Promise<void>((res) => setTimeout(res, 1200)); return context.dispatch(event(true)); },}); createApp({ name: 'route-navigate', modules: [ SpaRouterModule.forRoot([ { name: 'root', path: '/', }, { name: '1', path: '/1/', }, { name: '2', path: '/2/', }, { name: '3', path: '/3/', }, { name: 'redirect', path: '/redirect/', }, { name: 'block', path: '/block/', }, ]), ...modules, ], providers: [ { provide: COMBINE_REDUCERS, multi: true, useValue: store, }, { provide: ROUTER_GUARD_TOKEN, multi: true, useValue: async ({ to }) => { if (to.path === '/redirect/') { // we can make a redirect from the guard return '/3/'; } }, }, { provide: ROUTER_GUARD_TOKEN, multi: true, useFactory: ({ store: state, context }) => { return async ({ to }) => { if (to.path === '/block/') { if (state.getState().store === undefined) { await context.executeAction(action); } if (state.getState().store) { // we can block navigation return false; } } }; }, deps: { store: STORE_TOKEN, context: CONTEXT_TOKEN, }, }, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Copy  "},{"title":"How to set the Not found route","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to-set-the-not-found-route","content":"The Not found route is used if the corresponding route is not found for the url. Such a route is specified in the list of routes with the special * character in the path property.  An example of setting a Not Found route in an application import React from 'react';import { createApp, createBundle } from '@tramvai/core';import { SpaRouterModule, useNavigate, useUrl } from '@tramvai/module-router';import { modules } from '../common'; const Navigation = [ '/1/', '/2/', '/3/', '/not-found', '/child/1/', '/child/2/', '/child/3/', '/child/not-found',]; function Page() { const navigate = useNavigate(); const { pathname, path } = useUrl(); return ( <div> <div>Current Path: {path}</div> {Navigation.map((p) => { if (p !== pathname) { return ( <button type=\"button\" onClick={() => navigate({ url: p })}> Navigate to {p} </button> ); } return null; })} </div> );} // Defining a separate pageconst NotFoundRoot = () => { return 'not found root';}; const NotFoundChild = () => { return 'not found child';}; const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, notFoundRoot: NotFoundRoot, notFoundChild: NotFoundChild, },}); createApp({ name: 'route-navigate', modules: [ SpaRouterModule.forRoot([ { name: 'root', path: '/', }, { name: '1', path: '/1/', }, { name: '2', path: '/2/', }, { name: '3', path: '/3/', }, { name: 'child-1', path: '/child/1/', }, { name: 'child-2', path: '/child/2/', }, { name: 'child-1', path: '/child/3/', }, { name: 'not-found-root', path: '*', config: { pageComponent: 'notFoundRoot', }, }, { name: 'not-found-child', path: '/child/*', config: { pageComponent: 'notFoundChild', }, }, ]), ...modules, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Copy  "},{"title":"Testing","type":1,"pageTitle":"router","url":"docs/references/modules/router#testing","content":"Testing ROUTER_GUARD_TOKEN extensions# If you have a module or providers that define ROUTER_GUARD_TOKEN, then it will be convenient to use special utilities to test them separately import { ROUTER_GUARD_TOKEN } from '@tramvai/tokens-router';import { testGuard } from '@tramvai/module-router/tests';import { CustomModule } from './module';import { providers } from './providers'; describe('router guards', () => { it('should redirect from guard', async () => { const { router } = testGuard({ providers, }); await router.navigate('/test/'); expect(router.getCurrentUrl()).toMatchObject({ path: '/redirect/', }); }); it('should block navigation', async () => { const { router } = testGuard({ modules: [CustomModule], }); expect(router.getCurrentUrl()).toMatchObject({ path: '/' }); await router.navigate('/test/').catch(() => null); expect(router.getCurrentUrl()).toMatchObject({ path: '/', }); });}); Copy "},{"title":"Exported tokens","type":1,"pageTitle":"router","url":"docs/references/modules/router#exported-tokens","content":"link "},{"title":"server","type":0,"sectionRef":"#","url":"docs/references/modules/server","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"server","url":"docs/references/modules/server#подключение","content":"Необходимо установить @tramvai/module-server с помощью npm npm i --save @tramvai/module-server Copy И подключить в проекте import { createApp } from '@tramvai/core';import { ServerModule } from '@tramvai/module-server'; createApp({ name: 'tincoin', modules: [ServerModule],}); Copy "},{"title":"Explanation","type":1,"pageTitle":"server","url":"docs/references/modules/server#explanation","content":""},{"title":"Обработка запросов пользователей","type":1,"pageTitle":"server","url":"docs/references/modules/server#обработка-запросов-пользователей","content":"Основной функционал модуля заключается в том, что-бы обработать запрос пользователя, запустить commandLine у tramvai приложения и забрать данные страницы с RESPONSE_MANAGER_TOKEN "},{"title":"Проксирование запросов","type":1,"pageTitle":"server","url":"docs/references/modules/server#проксирование-запросов","content":"В server модуле доступна функциональность, которая позволяет настроить проксирование урлов в приложение используя библиотеку http-proxy-middleware. Эта фича работает как в дев режиме, так и на проде Для включения проксирования необходимо в корне проекта создать файл proxy.conf.js или proxy.conf.json который будет экспортировать объект-маппинг запросов, либо можно использовать токен PROXY_CONFIG_TOKEN. Формат прокси-файла# Объект ключ-значение# const testStand = 'https://example.org'; module.exports = { // ключ - path pattern для express который будет передан в app.use // значение может быть строкой, для того чтобы проксировать все урлы начинающиеся с /login/ '/login/': testStand, // или может быть объектом конфига для [http-proxy](https://github.com/chimurai/http-proxy-middleware#http-proxy-options) '/test/': { target: testStand, auth: true, xfwd: true, ... }}; Copy Объект со свойствами context и target# module.exports = { // context - аналогичен опции для [http-proxy-middleware](https://github.com/chimurai/http-proxy-middleware#context-matching) context: ['/login/', '/registration/', '/auth/papi/'], target: 'https://example.org', // разные дополнительные опции changeOrigin: true,}; Copy Массив со свойствами context и target# [ { \"context\": [\"/a/\", \"/b/*/c/\"], \"target\": \"https://example.org\" }] Copy Используя провайдеры с помощью токена PROXY_CONFIG_TOKEN# import { Scope, provide } from '@tramvai/core';import { PROXY_CONFIG_TOKEN } from '@tramvai/tokens-server'; [ provide({ provide: PROXY_CONFIG_TOKEN, scope: Scope.SINGLETON, useValue: { context: ['/a/', '/b/*/c/'], target: 'https://example.org', }, multi: true, }),]; Copy "},{"title":"Раздача статических файлов","type":1,"pageTitle":"server","url":"docs/references/modules/server#раздача-статических-файлов","content":"В module-server встроен статический сервер, который позволяет раздавать статичные файлы пользователям. Для раздачи файлов, необходимо в корне проекта создать директорию public в который поместить необходимые файлы. После этого все файлы будут доступны для запроса браузерами К примеру, мы хотим раздать sw.js файл из корня проекта: для этого создаем папку public в которой закидываем файл sw.js. Теперь на стороне клиента, мы сможем запросить данные с урла http://localhost:3000/sw.js. Так-же скорее всего нужны будут доработки на стороне CD, для того что бы скопировать папаку public на стенды. Эта функция доступна так-же и на продакшене. Для этого необходимо в докер контейнер скопировать папку public "},{"title":"PAPI","type":1,"pageTitle":"server","url":"docs/references/modules/server#papi","content":"Papi - API роуты для tramvai приложения. Подробная информация доступна в разделе Papi "},{"title":"Эмуляция проблем с сетью/бэкендами в приложении","type":1,"pageTitle":"server","url":"docs/references/modules/server#эмуляция-проблем-с-сетьюбэкендами-в-приложении","content":"(функционал доступен только в dev режиме) На сервере есть возможность увеличить время ответа всех запросов. Для этого необходимо: стартануть приложениеотправить post-запрос на /private/papi/debug-http-request с указанием задержки для запроса: curl --location --request POST 'http://localhost:3000/tincoin/private/papi/debug-http-request' \\--header 'Content-Type: application/x-www-form-urlencoded' \\--data-urlencode 'delay=2000' Copy проверить работу приложения. Внимание! после каждого перезапуска сервера настройки сбрасываются, поэтому после каждой пересборки надо обращаться к papi снова.отключить таймаут можно обратившись к тому же papi методом delete curl --location --request DELETE 'http://localhost:3000/tincoin/private/papi/debug-http-request' Copy "},{"title":"Логгирование запросов отправленных на сервере","type":1,"pageTitle":"server","url":"docs/references/modules/server#логгирование-запросов-отправленных-на-сервере","content":"В дев режиме все запросы отправленные через стандартные библиотеки http и https для nodejs логгируются под специальным ключом node-debug.request. Это позволяет увидеть все запросы которые были отправлены на сервере, даже если для запросов не было определено логгирование явно. Чтобы включить такие логи, достаточно добавить в переменную окружения DEBUG_ENABLE ключ node-debug.request "},{"title":"Health checks","type":1,"pageTitle":"server","url":"docs/references/modules/server#health-checks","content":"/healthz - после старта приложения всегда отдает ответ OK/readyz - после старта приложения всегда отдает OK "},{"title":"Метрики","type":1,"pageTitle":"server","url":"docs/references/modules/server#метрики","content":"В модуль сервера автоматически подключен модуль метрик. Подробную информацию по метрикам, можете почитать в документации метрик "},{"title":"Прогрев кэшей приложения","type":1,"pageTitle":"server","url":"docs/references/modules/server#прогрев-кэшей-приложения","content":"В модуль сервера автоматически подключен модуль прогрева кэшей. Подробную информацию по прогреву кэшей, можете почитать в документации cache-warmup "},{"title":"Специальные заголовки","type":1,"pageTitle":"server","url":"docs/references/modules/server#специальные-заголовки","content":"Информация о сборке и деплое# В модуле проставляются особые заголовки, которые помогают определить точную информацию о версии собранного приложения, коммите, ветке и т.п.: x-app-id - имя приложения указанного в createApp. Указывается в коде приложения.x-host - hostname сервера на котором запущено текущее приложение. Вычисляется в рантайме.x-app-version - версия запущенного приложения. Передаётся через переменную окружения APP_VERSION (внутри tinkoff проставляется в рамках стандартных пайплайнов gitlab ci).x-deploy-branch - ветка с которой был собран текущий образ приложения. Передаётся через переменную окружения DEPLOY_BRANCH (внутри tinkoff проставляется с помощью unic).x-deploy-commit - sha коммита с которого был собран текущий образ приложения. Передаётся через переменную окружения DEPLOY_COMMIT (внутри tinkoff проставляется с помощью unic).x-deploy-version - номер ревизии деплоя в k8s. Передаётся через переменную окружения DEPLOY_VERSION (внутри tinkoff проставляется с помощью unic).x-deploy-repository - ссылка на репозиторий приложения. Передаётся через переменную окружения DEPLOY_REPOSITORY (внутри tinkoff проставляется с помощью unic). Для всех заголовков выше, которые передаются через переменные окружения, чтобы они были доступны, необходимо чтобы внешняя инфраструктура передавала их при сборке и деплое образа приложения (внутри tinkoff это делается автоматически). "},{"title":"Отладка","type":1,"pageTitle":"server","url":"docs/references/modules/server#отладка","content":"Модуль использует логгеры с идентификаторами: server, server:static, server:webapp, server:node-debug:request "},{"title":"Экспортируемые токены","type":1,"pageTitle":"server","url":"docs/references/modules/server#экспортируемые-токены","content":"ссылка "},{"title":"Integration tests","type":0,"sectionRef":"#","url":"docs/references/test/test-integration","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"Integration tests","url":"docs/references/test/test-integration#подключение","content":"npm i --save-dev @tramvai/test-integration Copy "},{"title":"How To","type":1,"pageTitle":"Integration tests","url":"docs/references/test/test-integration#how-to","content":""},{"title":"Тестирование запросов к tramvai приложению без запуска в браузере (aka curl)","type":1,"pageTitle":"Integration tests","url":"docs/references/test/test-integration#тестирование-запросов-к-tramvai-приложению-без-запуска-в-браузере-aka-curl","content":"Для тестирования полноценных запросов к tramvai приложению используется библиотеки superagent и node-html-parser При вызове метода app.request отправляются запросы в приложение, и доступны все возможности superagent. При вызове метода app.render можно получить доступ к HTML разметке, которую вернул запрос в приложение. import { startCli } from '@tramvai/test-integration';import { initPuppeteer, wrapPuppeteerPage } from '@tramvai/test-puppeteer'; beforeAll(async () => { app = await startCli('bootstrap', { env: { SOME_ENV: 'test', }, });}, 80000); afterAll(() => { return app.close();}); it('request to main page return status 200', async () => { return app.request('/').expect(200);}); it('main page HTML snapshot', async () => { const parsed = await app.render('/'); const applicationInnerHtml = parsed.application; expect(parsed.application).toMatchInlineSnapshot();}); Copy "},{"title":"Тестирование приложения в браузере с помощью Puppeteer","type":1,"pageTitle":"Integration tests","url":"docs/references/test/test-integration#тестирование-приложения-в-браузере-с-помощью-puppeteer","content":"Для запуска полноценных браузерных тестов можно использовать библиотеку @tramvai/test-puppeteer "},{"title":"Использование @tinkoff/mocker в тестах","type":1,"pageTitle":"Integration tests","url":"docs/references/test/test-integration#использование-tinkoffmocker-в-тестах","content":"Для использования мокера в интеграционных тестах необходимо добавить модуль @tramvai/module-mocker в список модулей для приложения Затем мокер подтянет файловые моки как описано в доке к самому мокеру и есть возможность добавлять моки динамически в тестах: it('should work with mocker', async () => { await app.mocker.addMocks('CONFIG_API', { 'GET /test/': { status: 200, payload: { status: 'OK', response: 'smth', }, }, }); await app.request('/api/').expect(200); await app.papi.clearCache(); await app.mocker.removeMocks('CONFIG_API', ['GET /test/']); await app.request('/api/').expect(500);}); Copy "},{"title":"Jest integration","type":0,"sectionRef":"#","url":"docs/references/test/test-integration-jest","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"Jest integration","url":"docs/references/test/test-integration-jest#подключение","content":"npm i --save-dev @tramvai/test-integration-jest Copy "},{"title":"How To","type":1,"pageTitle":"Jest integration","url":"docs/references/test/test-integration-jest#how-to","content":""},{"title":"Дебаг и разработка интеграционных тестов в Jest","type":1,"pageTitle":"Jest integration","url":"docs/references/test/test-integration-jest#дебаг-и-разработка-интеграционных-тестов-в-jest","content":"Используя наш пресет для jest можно запускать в watch режиме интеграционные тесты, при этом само приложение запустится только один раз и будет работать в фоне. Добавляем в jest.integration.config.js пресет @tramvai/test-integration-jest module.exports = { preset: '@tramvai/test-integration-jest',}; Copy Добавляем в package.json отдельный скрипт для запуска в watch-режиме: { \"scripts\": { \"test:integration\": \"jest -w=3 --config ./jest.integration.config.js\", \"test:integration:watch\": \"jest --runInBand --watch --config ./jest.integration.config.js\" }} Copy Запускаем интересующий тест через yarn test:integration:watch <path_to_test>. При этом можно будет зайти на стандартный урл http://localhost:3000 и посмотреть приложение во время работы. "},{"title":"Окружение для запуска Jest","type":1,"pageTitle":"Jest integration","url":"docs/references/test/test-integration-jest#окружение-для-запуска-jest","content":"Минимальный набор зависимостей для запуска jest: npm i --save-dev jest @types/jest jest-circus Copy "},{"title":"JSDom tests","type":0,"sectionRef":"#","url":"docs/references/test/test-jsdom","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"JSDom tests","url":"docs/references/test/test-jsdom#подключение","content":"npm i --save-dev @tramvai/test-jsdom Copy "},{"title":"Api","type":1,"pageTitle":"JSDom tests","url":"docs/references/test/test-jsdom#api","content":""},{"title":"waitRaf","type":1,"pageTitle":"JSDom tests","url":"docs/references/test/test-jsdom#waitraf","content":"Позволяет подождать выполнения requestAnimationFrame калбеков в тесте import { waitRaf } from '@tramvai/test-jsdom'; describe('test', () => { it('test', async () => { // some code with raf usage await waitRaf(); });}); Copy "},{"title":"Puppeteer tests","type":0,"sectionRef":"#","url":"docs/references/test/test-puppeteer","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"Puppeteer tests","url":"docs/references/test/test-puppeteer#подключение","content":"npm i --save-dev @tramvai/test-puppeteer Copy "},{"title":"How To","type":1,"pageTitle":"Puppeteer tests","url":"docs/references/test/test-puppeteer#how-to","content":""},{"title":"Тестирование приложения в браузере с помощью Puppeteer","type":1,"pageTitle":"Puppeteer tests","url":"docs/references/test/test-puppeteer#тестирование-приложения-в-браузере-с-помощью-puppeteer","content":"Puppeteer запускает тесты в headless Chrome браузере, документация доступна на официальном сайте import { startCli } from '@tramvai/test-integration';import { initPuppeteer, wrapPuppeteerPage } from '@tramvai/test-puppeteer'; beforeAll(async () => { app = await startCli('bootstrap', { env: { SOME_ENV: 'test', }, });}, 80000); afterAll(() => { return app.close();}); it('puppeteer', async () => { const browser = await initPuppeteer(app.serverUrl); const page = await browser.newPage(); const wrapper = wrapPuppeteerPage(page); await page.goto(app.serverUrl); expect( await page.$eval('.application', (node) => (node as HTMLElement).innerText) ).toMatchInlineSnapshot(`\"Main Page click link\"`); await wrapper.router.navigateWithReload('./second'); expect( await page.$eval('.application', (node) => (node as HTMLElement).innerText) ).toMatchInlineSnapshot(`\"Second Page click link\"`); await browser.close();}); Copy "},{"title":"Mocks","type":0,"sectionRef":"#","url":"docs/references/test/test-mocks","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#подключение","content":"npm i --save-dev @tramvai/test-mocks Copy "},{"title":"Api","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#api","content":""},{"title":"STORE_TOKEN","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#store_token","content":"Creates mock instance for token STORE_TOKEN which used in app as a common storage for store Empty State# import { createMockStore } from '@tramvai/test-mocks'; const store = createMockStore();const state = store.getState(); store.dispatch('event'); Copy Initial State# import { createMockStore } from '@tramvai/test-mocks'; const initialState = { a: 1, b: 2 };const reducerC = createReducer('c', 3);const store = createMockStore({ stores: [reducerC], initialState }); const state = store.getState(); Copy  More examples import { createReducer, createEvent } from '@tramvai/state';import { createMockStore } from './store'; describe('test/unit/mocks/store', () => { it('should create empty store', () => { const store = createMockStore(); const spyGetState = jest.spyOn(store, 'getState'); expect(store.getState()).toEqual({}); expect(spyGetState).toHaveBeenCalled(); }); it('should update stores with dispatch', () => { const event = createEvent<string>('testEvent'); const reducer = createReducer('test', { a: 'test' }).on(event, (_, data) => { return { a: data, }; }); const store = createMockStore({ stores: [reducer] }); expect(store.getState()).toEqual({ test: { a: 'test' } }); store.dispatch(event('dispatched')); expect(store.getState()).toEqual({ test: { a: 'dispatched' } }); }); it('should create store by initialState', () => { const initialState = { a: 1, b: 2 }; const reducerA = createReducer('a', {}); const reducerB = createReducer('b', {}); const store = createMockStore({ stores: [reducerA, reducerB], initialState }); expect(store.getState()).toEqual(initialState); }); it('should create fake reducer stores for every key in initialState', () => { const initialState = { a: 1, b: 2 }; const reducerC = createReducer('c', 3); const store = createMockStore({ stores: [reducerC], initialState }); expect(store.getState()).toEqual({ a: 1, b: 2, c: 3, }); });}); Copy  "},{"title":"DI","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#di","content":"Creates mock instance of DI-container import { createMockDi } from '@tramvai/test-mocks'; const di = createMockDi(); const dep = di.get(SOME_TOKEN); Copy "},{"title":"Context","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#context","content":"Creates mock instance for CONTEXT_TOKEN import { createMockContext } from '@tramvai/test-mocks'; it('test', async () => { const context = createMockContext(); await context.dispatch('event'); await context.executeAction(action); const spyExecuteAction = jest.spyOn(context, 'executeAction'); expect(spyExecuteAction).toHaveBeenCalled();}); Copy  More examples import { createEvent, createReducer } from '@tramvai/state';import { createMockContext } from './context'; describe('test/unit/mocks/context', () => { it('should create consumer context', () => { const context = createMockContext(); expect(context.executeAction).toBeInstanceOf(Function); expect(context.getState).toBeInstanceOf(Function); expect(context.dispatch).toBeInstanceOf(Function); expect(context.getState()).toEqual({}); }); it('should dispatch data', async () => { const event = createEvent<string>('mockEvent'); const reducer = createReducer('a', 'data').on(event, (_, data) => data); const context = createMockContext({ stores: [reducer], }); const spyDispatch = jest.spyOn(context, 'dispatch'); await context.dispatch(event('mock1')); expect(spyDispatch).toHaveBeenCalledWith(event('mock1')); expect(context.getState()).toEqual({ a: 'mock1' }); });}); Copy  "},{"title":"Router","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#router","content":"Creates mock instance for @tinkoff/router import { createMockRouter } from '@tramvai/test-mocks'; describe('test', () => { it('should create router mock', () => { const router = createMockRouter(); expect(router.getCurrentRoute()).toMatchObject({ path: '/' }); expect(router.getCurrentUrl()).toMatchObject({ path: '/' }); }); it('should allow to specify currentRoute', () => { const router = createMockRouter({ currentRoute: { name: 'page', path: '/page/test/' } }); expect(router.getCurrentRoute()).toMatchObject({ path: '/page/test/' }); expect(router.getCurrentUrl()).toMatchObject({ path: '/page/test/' }); });}); Copy "},{"title":"React tests","type":0,"sectionRef":"#","url":"docs/references/test/test-react","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"React tests","url":"docs/references/test/test-react#подключение","content":"npm i --save-dev @tramvai/test-react Copy "},{"title":"How to","type":1,"pageTitle":"React tests","url":"docs/references/test/test-react#how-to","content":""},{"title":"Тестирование компонентов","type":1,"pageTitle":"React tests","url":"docs/references/test/test-react#тестирование-компонентов","content":"Для тестирования компонентов под капотом используется библиотека @testing-library/react /** * @jest-environment jsdom */import { testComponent } from '@tramvai/test-react'; describe('test', () => { it('render', async () => { const { render, context, act, fireEvent } = testComponent(<Cmp />); // проверить рендер компонента expect(render.getByTestId('test').textContent).toBe('Content'); // проверить рендер после обновления данных в сторе act(() => { context.dispatch(event('data')); }); // Взаимодействовать с компонентом fireEvent.click(render.getByText('Button')); });}); Copy  Больше примеров /** * @jest-environment jsdom */ import React from 'react';import { createReducer, createEvent, useStore } from '@tramvai/state';import { useDi } from '@tramvai/react';import { useRoute } from '@tinkoff/router';import { testComponent } from './testComponent'; describe('test/unit/react/testComponent', () => { it('should render simple component', async () => { const Cmp = () => { return ( <div> <div>Root</div> <div data-testid=\"test\">Content</div> </div> ); }; const { render } = testComponent(<Cmp />); expect(render.getByTestId('test').textContent).toBe('Content'); }); it('should rerender component on store updates', async () => { const event = createEvent<void>('evnt'); const store = createReducer('store', { a: 1 }).on(event, (state) => ({ a: state.a + 1 })); const Cmp = () => { const { a } = useStore(store); return ( <div> <span data-testid=\"content\">Counter: {a}</span> </div> ); }; const { context, render, act } = testComponent(<Cmp />, { stores: [store] }); expect(render.getByTestId('content').textContent).toBe('Counter: 1'); act(() => { context.dispatch(event()); }); expect(render.getByTestId('content').textContent).toBe('Counter: 2'); }); it('should work with di', async () => { const Cmp = () => { const { provider } = useDi({ provider: 'provider' }); return <span role=\"text\">{provider}</span>; }; const { render } = testComponent(<Cmp />, { providers: [ { provide: 'provider', useValue: 'test', }, ], }); expect(render.getByRole('text')).toMatchInlineSnapshot(` <span role=\"text\" > test </span> `); }); it('should work with routing', async () => { const Cmp = () => { const route = useRoute(); return ( <div> <div data-testid=\"route\"> <div data-testid=\"route-path\">{route.actualPath}</div> <div data-testid=\"route-name\">{route.name}</div> </div> </div> ); }; const { render } = testComponent(<Cmp />, { currentRoute: { name: 'test', path: '/test/' } }); expect(render.getByTestId('route-path').textContent).toBe('/test/'); expect(render.getByTestId('route-name').textContent).toBe('test'); });}); Copy  "},{"title":"Тестирование React-хуков","type":1,"pageTitle":"React tests","url":"docs/references/test/test-react#тестирование-react-хуков","content":"Для тестирования компонентов под капотом используется библиотека @testing-library/react-hooks /** * @jest-environment jsdom */import { testHooks } from '@tramvai/test-react'; describe('test', () => { it('hook', async () => { const { result, context, act } = testHook(() => useHook()); // проверить результат вызова хука expect(result.current).toBe('result'); // проверить результат после обновления данных в сторе act(() => { context.dispatch(event('data')); }); });}); Copy  Больше примеров /** * @jest-environment jsdom */ import { createReducer, createEvent, useStore } from '@tramvai/state';import { useDi } from '@tramvai/react';import { useRoute } from '@tinkoff/router';import { waitRaf } from '@tramvai/test-jsdom';import { testHook } from './testHook'; describe('test/unit/react/testHook', () => { it('should render simple hook', async () => { const useHook = jest.fn((p: string) => 'result'); const { result } = testHook(() => useHook('test')); expect(result.current).toBe('result'); expect(useHook).toHaveBeenCalledWith('test'); }); it('should rerender hook', async () => { const event = createEvent<void>('evnt'); const store = createReducer('store', { a: 1 }).on(event, (state) => ({ a: state.a + 1 })); const useHook = () => { return useStore(store).a; }; const { context, result, act } = testHook(() => useHook(), { stores: [store] }); expect(result.current).toBe(1); await act(async () => { await context.dispatch(event()); await waitRaf(); }); expect(result.current).toBe(2); }); it('should work with di', async () => { const useHook = () => { return useDi({ provider: 'provider' }).provider; }; const { result } = testHook(() => useHook(), { providers: [ { provide: 'provider', useValue: 'test', }, ], }); expect(result.current).toEqual('test'); }); it('should work with routing', async () => { const useHook = () => { const route = useRoute(); return [route.actualPath, route.name]; }; const { result } = testHook(() => useHook(), { currentRoute: { name: 'test', path: '/test/' }, }); expect(result.current).toEqual(['/test/', 'test']); });}); Copy  "},{"title":"Jest unit","type":0,"sectionRef":"#","url":"docs/references/test/test-unit-jest","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"Jest unit","url":"docs/references/test/test-unit-jest#installation","content":"Install package: npm i --save-dev @tramvai/test-unit-jest Copy Add new preset to your jest.config: module.exports = { preset: '@tramvai/test-unit-jest',}; Copy "},{"title":"Explanation","type":1,"pageTitle":"Jest unit","url":"docs/references/test/test-unit-jest#explanation","content":"This presets implements next settings: use jest-circus as testRunnerdefault testEnvironment is nodeuses babel-jest for transformationcss files are mapped with identity-obj-proxyimage files are mapped to empty string "},{"title":"How To","type":1,"pageTitle":"Jest unit","url":"docs/references/test/test-unit-jest#how-to","content":""},{"title":"Override testEnvironment for file","type":1,"pageTitle":"Jest unit","url":"docs/references/test/test-unit-jest#override-testenvironment-for-file","content":"Based on jest doc Just add at the start of test file following comment: /** * @jest-environment your-environment */ Copy "},{"title":"Unit tests","type":0,"sectionRef":"#","url":"docs/references/test/test-unit","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#installation","content":"npm i --save-dev @tramvai/test-unit Copy "},{"title":"How to","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#how-to","content":""},{"title":"Testing reducers","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#testing-reducers","content":"import { testReducer } from '@tramvai/test-unit'; it('test', async () => { const { dispatch, getState } = testReducer(reducer); expect(getState()).toEqual([]); dispatch(event(1)); expect(getState()).toEqual([1]);}); Copy  More examples import { createEvent, createReducer } from '@tramvai/state';import { testReducer } from './testReducer'; describe('test/unit/testReducer', () => { it('should handle state change', () => { const handle = jest.fn((state: number[], payload: number) => { return [...state, payload]; }); const event = createEvent<number>('push'); const reducer = createReducer('test', [] as number[]).on(event, handle); const { dispatch, getState } = testReducer(reducer); expect(getState()).toEqual([]); expect(handle).not.toHaveBeenCalled(); dispatch(event(1)); expect(getState()).toEqual([1]); expect(handle).toHaveBeenCalledWith([], 1); dispatch(event(3)); expect(getState()).toEqual([1, 3]); expect(handle).toHaveBeenCalledWith([1], 3); }); it('should handle several tests reducers at separate', () => { const event = createEvent<number>('push'); const reducer = createReducer('test', [] as number[]).on(event, (state, payload) => { return [...state, payload]; }); const test1 = testReducer(reducer); const test2 = testReducer(reducer); expect(test1.getState()).toEqual([]); expect(test2.getState()).toEqual([]); test1.dispatch(event(1)); expect(test1.getState()).toEqual([1]); expect(test2.getState()).toEqual([]); test2.dispatch(event(2)); expect(test1.getState()).toEqual([1]); expect(test2.getState()).toEqual([2]); });}); Copy  "},{"title":"Testing actions","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#testing-actions","content":"import { testAction } from '@tramvai/test-unit'; it('test', async () => { const { run } = testAction(action); expect(await run(true)).toBe('hello'); expect(await run(false)).toBe('world');}); Copy  More examples import { createAction } from '@tramvai/core';import { createEvent } from '@tramvai/state';import { createMockContext } from '@tramvai/test-mocks';import { testAction } from './testAction'; describe('test/unit/state/testAction', () => { it('should call action', async () => { const action = createAction({ name: 'test', fn: (context, payload: boolean) => { if (payload) { return 'hello'; } return 'world'; }, }); const { run } = testAction(action); expect(await run(true)).toBe('hello'); expect(await run(false)).toBe('world'); }); it('should call action with custom context', async () => { const context = createMockContext(); const event = createEvent<string>('test'); const action = createAction({ name: 'dispatch', fn: (ctx, payload: string) => { return ctx.dispatch(event(`action${payload}`)); }, }); const spyDispatch = jest.spyOn(context, 'dispatch'); const { run } = testAction(action, { context }); await run('ping'); expect(spyDispatch).toHaveBeenCalledWith({ payload: 'actionping', type: 'test' }); await run('pong'); expect(spyDispatch).toHaveBeenCalledWith({ payload: 'actionpong', type: 'test' }); }); it('should not require payload', async () => { const action = createAction({ name: 'no-payload', fn: () => { return 'empty'; }, }); const { run } = testAction(action); await expect(run()).resolves.toBe('empty'); });}); Copy  "},{"title":"Testing tramvai module","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#testing-tramvai-module","content":"Testing module in isolation# import { testModule } from '@tramvai/test-unit'; it('test', async () => { const { di, module, runLine } = testModule(TestModule); expect(module).toBeInstanceOf(TestModule); expect(di.get('testToken')).toEqual({ a: 1 }); // Run only specific command line in order to execute handlers for this line inside module await runLine(commandLineListTokens.generatePage);}); Copy Testing module in conjunction with other modules# import { createTestApp } from '@tramvai/test-unit'; it('test', async () => { const { app } = await createTestApp({ modules: [TestModule, DependentModule] }); // get tokens from di implemented by module expect(app.di.get('testToken')).toEqual({ a: 1 });}); Copy  More examples import { commandLineListTokens, DI_TOKEN, Module } from '@tramvai/core';import { Container } from '@tinkoff/dippy';import { testModule } from './testModule'; describe('test/unit/module/testModule`', () => { it('should test module', () => { const mockConstructor = jest.fn(); @Module({ providers: [ { provide: 'testToken', useFactory: () => { return { a: 1 }; }, }, ], deps: { di: DI_TOKEN, optToken: { token: 'optional_token', optional: true }, }, }) class TestModule { constructor(deps: any) { mockConstructor(deps); } } const { di, module } = testModule(TestModule); expect(module).toBeInstanceOf(TestModule); expect(mockConstructor).toHaveBeenCalledWith({ di: expect.any(Container), optToken: null }); expect(di.get('testToken')).toEqual({ a: 1 }); }); it('should test command line', async () => { const mock = jest.fn(); @Module({ providers: [ { provide: commandLineListTokens.generatePage, multi: true, useFactory: () => { return mock; }, }, ], }) class TestModule {} const { runLine } = testModule(TestModule); expect(() => runLine(commandLineListTokens.customerStart)).toThrow(); expect(mock).not.toHaveBeenCalled(); await runLine(commandLineListTokens.generatePage); expect(mock).toHaveBeenCalledWith(); });}); Copy  "},{"title":"Testing app","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#testing-app","content":"Testing app works only in node-environment. See jest docs import { testApp } from '@tramvai/test-unit'; it('test', async () => { const { request, render } = await testApp(app); const response = await request('/').expect(200).expect('X-App-Id', 'unit-app'); expect(response.text).toMatch('<html class=\"no-js\" lang=\"ru\">'); expect(response.text).toMatch('<div class=\"application\">rootPage</div>'); expect(response.text).toMatch('<script>var initialState ='); const rootPage = await render('/'); expect(rootPage.application).toEqual('rootPage'); const secondPage = await render('/second/'); expect(secondPage.application).toEqual('secondPage'); expect(secondPage.initialState).toEqual({ stores: expect.objectContaining({ environment: { FRONT_LOG_API: 'test', }, router: expect.objectContaining({ currentUrl: expect.objectContaining({ path: '\\\\u002Fsecond\\\\u002F', }), }), }), });}); Copy  More examples import { NoSpaRouterModule } from '@tramvai/module-router';import { commandLineListTokens, createApp, createBundle } from '@tramvai/core';import { CommonModule, ENV_USED_TOKEN } from '@tramvai/module-common';import { LogModule } from '@tramvai/module-log';import { RenderModule } from '@tramvai/module-render';import { ServerModule } from '@tramvai/module-server';import { testApp } from './testApp'; type ThenArg<T> = T extends PromiseLike<infer U> ? U : T; const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: () => 'rootPage', pageSecond: () => 'secondPage', },}); describe('test/unit/app/testApp', () => { let testEnv: ThenArg<ReturnType<typeof testApp>>; describe('normal', () => { beforeAll(async () => { const app = createApp({ name: 'unit-app', bundles: { mainDefault: () => Promise.resolve({ default: bundle }), }, modules: [ CommonModule, LogModule, RenderModule, ServerModule, NoSpaRouterModule.forRoot([ { name: 'root', path: '/', }, { name: 'other', path: '/second/', config: { pageComponent: 'pageSecond', }, }, ]), ], providers: [ { provide: ENV_USED_TOKEN, multi: true, useValue: { key: 'FRONT_LOG_API', value: 'test' }, }, ], }); testEnv = await testApp(app); }); afterAll(() => { return testEnv.close(); }); it('should request to server', async () => { const { request } = testEnv; const response = await request('/').expect(200).expect('X-App-Id', 'unit-app'); expect(response.text).toMatch('<html class=\"no-js\" lang=\"ru\">'); expect(response.text).toMatch('<div class=\"application\">rootPage</div>'); expect(response.text).toMatch('<script>var initialState ='); }); it('should return render of page', async () => { const { render } = testEnv; const rootPage = await render('/'); expect(rootPage.application).toEqual('rootPage'); const secondPage = await render('/second/'); expect(secondPage.application).toEqual('secondPage'); expect(secondPage.initialState).toEqual({ stores: expect.objectContaining({ environment: { FRONT_LOG_API: 'test', }, router: expect.objectContaining({ currentUrl: expect.objectContaining({ path: '/second/', }), }), }), }); }); it('should return mocker instance', async () => { const { mocker } = testEnv; expect(mocker).toBeDefined(); }); }); describe('fail', () => { beforeAll(async () => { const app = createApp({ name: 'unit-app', bundles: { mainDefault: () => Promise.resolve({ default: bundle }), }, modules: [CommonModule, LogModule, RenderModule, ServerModule], providers: [ { provide: commandLineListTokens.resolveUserDeps, multi: true, useFactory: ({ wrong }) => { return wrong.test(); }, deps: { wrong: '_unknown_provider', }, }, ], }); testEnv = await testApp(app); }); afterAll(() => { return testEnv.close(); }); it('render with 500 status should fail', async () => { const { render } = testEnv; await expect(render('/')).rejects.toThrowError( 'Error: Token not found _unknown_provider at resolve_user_deps' ); }); });}); Copy  "},{"title":"Adding providers to DI","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#adding-providers-to-di","content":"Most of the helpers accepts option providers which allows to redefine already existing providers or add new. For example, passing providers to helper testAction allows to access this provider inside action itself: import { createAction } from '@tramvai/core';import { testAction } from '@tramvai/test-unit'; const action = createAction({ name: 'action', fn: (_, __, { test }) => { console.log(test); // token value }, deps: { test: 'token name', },}); it('test', async () => { const { run } = testAction(action, { providers: [ { provide: 'token name', useValue: 'token value', }, ], });}); Copy "},{"title":"Create app only for testing","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#create-app-only-for-testing","content":"import { createTestApp } from '@tramvai/test-unit'; it('test', async () => { const { app } = await createTestApp({ modules: [TestModule, DependentModule] }); // get tokens from di implemented by module expect(app.di.get('testToken')).toEqual({ a: 1 });}); Copy  More examples import http from 'http';import { ENV_MANAGER_TOKEN } from '@tramvai/tokens-common';import { SERVER_TOKEN } from '@tramvai/tokens-server';import { CommonModule } from '@tramvai/module-common';import { createTestApp } from './createTestApp'; describe('test/unit/app/createTestApp', () => { it('should return app', async () => { const { app, close } = await createTestApp(); const envManager = app.di.get(ENV_MANAGER_TOKEN); expect(envManager.get('FRONT_LOG_API')).toBe('test'); expect(envManager.get('TEST_ENV')).toBeUndefined(); expect(app.di.get(SERVER_TOKEN)).toBeInstanceOf(http.Server); return close(); }); it('should specify env', async () => { const { app, close } = await createTestApp({ env: { TEST_ENV: '1234', }, }); const envManager = app.di.get(ENV_MANAGER_TOKEN); expect(envManager.get('FRONT_LOG_API')).toBe('test'); expect(envManager.get('TEST_ENV')).toBe('1234'); return close(); }); it('should ignore default modules', async () => { const { app } = await createTestApp({ excludeDefaultModules: true, modules: [CommonModule], }); expect(() => app.di.get(SERVER_TOKEN)).toThrow('Token not found'); }); it('should return mocker instance', async () => { const { mocker, close } = await createTestApp(); expect(mocker).toBeDefined(); return close(); });}); Copy  "},{"title":"http-client-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/http-client-tokens","content":"","keywords":""},{"title":"Список токенов","type":1,"pageTitle":"http-client-tokens","url":"docs/references/tokens/http-client-tokens#список-токенов","content":" import { createToken } from '@tinkoff/dippy';import type { ApiService, HttpClient } from '@tramvai/http-client';import type { TinkoffRequestOptions } from '@tramvai/tinkoff-request-http-client-adapter'; export type HttpClientFactoryOptions = TinkoffRequestOptions & { name: string }; /** * @description * Фабрика HTTP клиентов с минимальными базовыми настройками */export const HTTP_CLIENT_FACTORY = createToken<(options: HttpClientFactoryOptions) => HttpClient>( 'HTTP_CLIENT_FACTORY'); /** * @description * Универсальный HTTP клиент для произвольных запросов */export const HTTP_CLIENT = createToken<HttpClient>('HTTP_CLIENT'); /** * @description * Список headers, которые проксируются из запроса в приложение во все запросы в API */export const API_CLIENT_PASS_HEADERS = createToken<string[]>('apiClientPassHeaders', { multi: true,}); /** * @description * Работа с внутренним апи текущего сервера. * Использует значение `APP_INFO_TOKEN` из di для определения адреса для запросов */export const PAPI_SERVICE = createToken<ApiService>('papi service'); Copy  "},{"title":"common-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/common-tokens","content":"","keywords":""},{"title":"Список action токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-action-токенов","content":" import { createToken } from '@tinkoff/dippy';import type { Action } from '@tramvai/core'; /** * @description * Регистр для хранения экшенов по типам */export const ACTION_REGISTRY_TOKEN = createToken<ActionsRegistry>('actionRegistry'); /** * @description * Сущность для исполнения экшенов */export const ACTION_EXECUTION_TOKEN = createToken<ActionExecution>('actionExecution'); /** * @description * Сушность для выполнения экшенов при переходах */export const ACTION_PAGE_RUNNER_TOKEN = createToken<ActionPageRunner>('actionPageRunner'); /** * @description * Позволяет добавлять условия на возможность исполнения экшенов */export const ACTION_CONDITIONALS = createToken<ActionCondition[]>('actionConditionals', { multi: true,}); export interface ActionsRegistry { add(type: string, actions: Action | Action[]): void; get(type: string, addingActions?: Action[]): Action[]; getGlobal(): Action[]; remove(type: string, actions?: Action | Action[]): void;} export interface ActionExecution { execution: Map<string, any[]>; run(action: Action, payload: any): Promise<any>;} export interface ActionPageRunner { runActions(actions: Action[], stopRunAtError?: (error: Error) => boolean): Promise<any>;} export interface ActionConditionChecker<State = any> { payload: any; parameters: any; conditions: Record<string, any>; type: 'global' | 'local'; allow(): void; setState(value: State): void; getState(): State; forbid(): void;} export type ActionCondition = { key: string; fn: (checker: ActionConditionChecker) => void;}; Copy  "},{"title":"Список bundle токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-bundle-токенов","content":" import { createToken } from '@tinkoff/dippy';import type { Bundle } from '@tramvai/core'; /** * @description * Хранилище бандлов. При получении бандла дополнительно добавляем экшены и компоненты из бандла в соответсвующие хранилища */export const BUNDLE_MANAGER_TOKEN = createToken<BundleManager>('bundleManager'); /** * @description * Токен для предоставления дополнительных бандлов в приложение. * Важно! Не перезаписывает существующие бандлы. */export const ADDITIONAL_BUNDLE_TOKEN = createToken<{ [key: string]: Bundle }>('additional bundle', { multi: true,}); export interface BundleManager { bundles: Record<string, any>; get(name: string, pageComponent: string): Promise<any>; has(name: string): boolean;} Copy  "},{"title":"Список componentRegistry токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-componentregistry-токенов","content":" import { createToken } from '@tinkoff/dippy'; /** * @description * Хранилище react-компонентов. * Хранилище разделено на бандлы, поэтому при задании\\получении компонента нужно указывать ключ компонента и название бандла. * Также сущность позволяет получать статические параметры компонентов через метод _getComponentParam_ */export const COMPONENT_REGISTRY_TOKEN = createToken<ComponentRegistry>('componentRegistry'); export interface ComponentRegistry { components: Record<string, any>; add(name: string, component: any, bundle?: string): void; get(name: string, bundle?: string): any; getComponentParam<T>(param: string, defaultValue: T, component: string, bundle?: string): T;} Copy  "},{"title":"Список env токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-env-токенов","content":" import { createToken } from '@tinkoff/dippy'; export interface EnvironmentManager { get(name: string): string; getInt(name: string, def: number): number; getAll(): Record<string, string>; update(result: Record<string, string>): void; clientUsed(): Record<string, string>; updateClientUsed(result: Record<string, string>): void;} /** * @description * Сущность `environmentManager` c помощью которого можно получить данные env переменных на сервере и клиенте */export const ENV_MANAGER_TOKEN = createToken<EnvironmentManager>('environmentManager'); /** * @description * Список токенов которые необходимы модулю или приложению. * Позднее все токены из этого списка будут доступны через `environmentManager` * Формат токена ENV_USED_TOKEN: - `key` - идентификатор env переменной. Под этим ключем будет доступно в `environmentManager` и будет получено из внешних источников - `value` - предустановленное значение для токена `key` с низким приоритетом - `optional` - является ли параметр опциональным для работы приложения. Если `true`, то приложение не будет падать, если не было передано значение - `validator` - функция валидации переданного значения. Если функция вернет текст, то выкинется ошибка - `dehydrate` - если передано `false`, то env параметр не передастся клиенту и можно будет получить значение только на серверной стороне * * @example ```tsx interface EnvParameter { key: string; value?: string; optional?: boolean; validator?: (value: string) => boolean | string; dehydrate?: boolean; } ``` */export interface EnvParameter { key: string; value?: string; optional?: boolean; validator?: (value: string) => boolean | string; dehydrate?: boolean;} export const ENV_USED_TOKEN = createToken<EnvParameter[]>('envUsed', { multi: true }); Copy  "},{"title":"Список context токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-context-токенов","content":" import type { Container } from '@tinkoff/dippy';import { createToken } from '@tinkoff/dippy';import type { ConsumerContext as BaseConsumerContext } from '@tramvai/types-actions-state-context';import type { PUBSUB_TOKEN } from './pubsub'; export { PlatformAction } from '@tramvai/types-actions-state-context'; /** * @description * Реализация контекста */export const CONTEXT_TOKEN = createToken<ConsumerContext>('context'); export interface ConsumerContext extends BaseConsumerContext { readonly di: Container; readonly pubsub: typeof PUBSUB_TOKEN; dehydrate: () => { dispatcher: { stores: Record<string, any>; }; };} Copy  "},{"title":"Список hook токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-hook-токенов","content":" import { createToken } from '@tinkoff/dippy'; /** * @description * В некоторых случаях нам нужно встроиться в функционал и это позволяют сделать хуки, [документация](https://tramvai.dev/docs/references/libs/hooks) */export const HOOK_TOKEN = createToken<Hooks>('hooks'); type Hook<TPayload> = (context: any, payload?: TPayload, options?: any) => TPayload; export interface Hooks { /** * Регистрация хуков */ registerHooks<TPayload>(name: string, list: Hook<TPayload>[] | Hook<TPayload>): void; /** * Запуск синхронных хуков, payload проходит через все хуки и будет результатом выполнения */ runHooks<TPayload>(name: string, context: any, payload?: TPayload, options?: any): TPayload; /** * Запуск ассихронных хуков */ runAsyncHooks<TPayload>(name: string, context: any, payload: TPayload, options?: any): TPayload; /** * Запуск проммис хуков */ runPromiseHooks( name: string, context: any, options?: any ): <TPayload>(payload: TPayload) => Promise<TPayload> | Promise<never>;} Copy  "},{"title":"Список logger токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-logger-токенов","content":" import type { Logger } from '@tinkoff/logger';import { createToken } from '@tinkoff/dippy'; /** * @description * Реализация логгера */export const LOGGER_TOKEN = createToken<LoggerFactory>('logger'); /** * @description * Дает возможность модифицировать логгер на этапе реализации */export const LOGGER_INIT_HOOK = createToken<LoggerInitHook>('loggerHook'); type Config = { name: string; [key: string]: any;}; export type LoggerFactory = Logger & ((configOrName: string | Config) => Logger); type LoggerInitHook = (logger: LoggerFactory) => void; export type { Logger, LogFn, LogArg } from '@tinkoff/logger'; Copy  "},{"title":"Список pubsub токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-pubsub-токенов","content":" import { createToken } from '@tinkoff/dippy'; /** * @description * Фабрика для создания инстанса pubsub */export const PUBSUB_FACTORY_TOKEN = createToken<() => PubSub>('pubsubFactory'); /** * @description * Глобальный инстанс pubsub который живет все время */export const PUBSUB_TOKEN = createToken<PubSub>('pubsub'); /** * @description * Инстанс pubsub который создается для каждого клиента */export const ROOT_PUBSUB_TOKEN = createToken<PubSub>('rootPubsub'); export interface PubSub { subscribe(event: string, fn: (payload?: any) => void): () => boolean; publish(event: string, ...args: unknown[]): any;} Copy  "},{"title":"Список requestManager токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-requestmanager-токенов","content":" import { createToken } from '@tinkoff/dippy';import type { Request } from 'express'; // Это костыль чтобы обойти инлайнинг Request'а и выставление наружу внутренних зависимостей express'аtype RequestExt = Request;/** * @description * Прямая ссылка на объект запроса */export const REQUEST = createToken<RequestExt>('request'); /** * @description * Сущность для работы с инстансами запроса (заголовки запросов, query-параметры, куки). * В основном используется только на сервере, но на клиенте есть обрезанный функционал, для упрощения реализации изоморфного приложения */export const REQUEST_MANAGER_TOKEN = createToken<RequestManager>('requestManager'); export interface RequestManager { getBody(): unknown; getUrl(): string; getMethod(): string; getCookie(key: string): string; getCookies(): Record<string, string>; getHeader(key: string): string | string[]; getHeaders(): Record<string, string | string[]>; getClientIp(): string; getHost(): string;} Copy  "},{"title":"Список responseManager токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-responsemanager-токенов","content":" import { createToken } from '@tinkoff/dippy';import type { Response } from 'express'; /** * @description * Прямая ссылка на объект ответа */export const RESPONSE = createToken<Response>('response'); /** * @description * Сущность для работы с инстансами ответа (заголовки ответа, куки, тело ответа). * В основном используется только на сервере, но на клиенте есть обрезанный функционал, для упрощения реализации изоморфного приложения */export const RESPONSE_MANAGER_TOKEN = createToken<ResponseManager>('responseManager'); export interface ResponseManager { getBody(): string; setBody(value: string): void; getHeader(key: string): string | string[]; getHeaders(): Record<string, string | string[]>; setHeader(key: string, value: string): void; getCookie(key: string): string; getCookies(): Record<string, string>; setCookie(key: string, value: string): void; getStatus(): number; setStatus(status: number): void;} Copy  "},{"title":"Список state токенов","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#список-state-токенов","content":" import { createToken } from '@tinkoff/dippy';import type { DispatcherContext, Event, Middleware, Reducer } from '@tramvai/state'; /** * @description * Реализация dispatcher */export const DISPATCHER_TOKEN = createToken('dispatcher'); /** * @description * Реализция dispatcher context */export const DISPATCHER_CONTEXT_TOKEN = createToken<DispatcherContext<any>>('dispatcherContext'); /** * @description * Позволяет добавлять свои сторы созданные через createReducer */export const COMBINE_REDUCERS = createToken('combineReducers', { multi: true }); /** * @description * Общий стор приложения */export const STORE_TOKEN = createToken<Store>('store'); /** * @description * Позволяет задавать свои middlewares для работы со стейтом */export const STORE_MIDDLEWARE = createToken<Middleware>('storeMiddleware', { multi: true }); export interface Store<State = Record<string, any>> { dispatch: <Payload>(actionOrNameEvent: string | Event<Payload>, payload?: Payload) => Payload; subscribe(callback: (state: Record<string, any>) => void): () => void; subscribe<S>(reducer: Reducer<S>, callback: (state: S) => void): () => void; getState(): State; getState<S>(reducer: Reducer<S>): S;} Copy  "},{"title":"metrics-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/metrics-tokens","content":"","keywords":""},{"title":"Список токенов","type":1,"pageTitle":"metrics-tokens","url":"docs/references/tokens/metrics-tokens#список-токенов","content":" import { createToken } from '@tinkoff/dippy';import type { Counter, CounterConfiguration, Gauge, GaugeConfiguration, Histogram, HistogramConfiguration, Summary, SummaryConfiguration,} from 'prom-client'; interface Metrics { counter<T extends string = string>(opt: CounterConfiguration<T>): Counter<T>; gauge<T extends string = string>(opt: GaugeConfiguration<T>): Gauge<T>; histogram<T extends string = string>(opt: HistogramConfiguration<T>): Histogram<T>; summary<T extends string = string>(opt: SummaryConfiguration<T>): Summary<T>;} export { Counter, Gauge, Histogram, Summary, Metrics }; /** * @description * Реализация модуля метрик */export const METRICS_MODULE_TOKEN = createToken<Metrics>('metricsModule'); export interface MetricsServicesRegistryInterface { register(url: string, serviceName: string): void; registerEnv(env: Record<string, unknown>): void; getServiceName(url: string): string | void;} /** * @description * Утилита для того чтобы указать модулю метрик какое имя сервиса подставлять для разных запросов */export const METRICS_SERVICES_REGISTRY_TOKEN = createToken<MetricsServicesRegistryInterface>( 'metricsServicesRegistry'); /** * @description * Токен для регистрации counter-метрик которые затем можно будет инктерементировать через POST * запрос papi роута */export const REGISTER_INSTANT_METRIC_TOKEN = createToken<[string, Counter<string>]>( 'registerInstantMetric'); Copy  "},{"title":"router-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/router-tokens","content":"","keywords":""},{"title":"Список токенов","type":1,"pageTitle":"router-tokens","url":"docs/references/tokens/router-tokens#список-токенов","content":" import { createToken } from '@tinkoff/dippy';import type { AbstractRouter, NavigationGuard, Route, Navigation, NavigationRoute, NavigateOptions, UpdateCurrentRouteOptions, HistoryOptions,} from '@tinkoff/router'; /** * @description * Токен для доступа к объекту роутера */export const ROUTER_TOKEN = createToken<AbstractRouter>('router router'); /** * @description * Токен для определения статичных роутов */export const ROUTES_TOKEN = createToken<Route>('router routes', { multi: true });/** * @description * Токен для передачи guard-обработчиков для роутов при переходах */export const ROUTER_GUARD_TOKEN = createToken<NavigationGuard>('router guard', { multi: true }); /** * @description * Инкапсулирует логику работы с роутером - содержит методы для получения конфига роута и выполнения навигации */export const PAGE_SERVICE_TOKEN = createToken<PageService>('router pageService'); /** * @description * Хук для разрешения роута динамически */export const ROUTE_RESOLVE_TOKEN = createToken<RouteResolve>('router routeResolve'); /** * @description * Токен для трансформации конфига роута */export const ROUTE_TRANSFORM_TOKEN = createToken<RouteTransform>('router routeTransform', { multi: true,}); /** * @description * Флаг для спа-переходов, указывающий что экшены должны выполняться до или после обновления роута в сторе */export const ROUTER_SPA_ACTIONS_RUN_MODE_TOKEN = createToken<'before' | 'after'>( 'router spaRunMode'); export interface PageService { getCurrentRoute(): NavigationRoute; getCurrentUrl(): ReturnType<AbstractRouter['getCurrentUrl']>; getConfig(): Route['config']; getContent(): Record<string, any>; getMeta(): { seo: Record<string, string>; analytics: Record<string, string> }; navigate(options: string | NavigateOptions): Promise<void>; updateCurrentRoute(options: UpdateCurrentRouteOptions): Promise<void>; back(options?: HistoryOptions): Promise<void>; forward(): Promise<void>; go(to: number, options?: HistoryOptions): Promise<void>;} export type RouteResolve = (navigation: Navigation) => Promise<Route | void>; export type RouteTransform = (route: Route) => Route; Copy  "},{"title":"render-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/render-tokens","content":"","keywords":""},{"title":"Список токенов","type":1,"pageTitle":"render-tokens","url":"docs/references/tokens/render-tokens#список-токенов","content":" import type { ReactElement, ComponentType } from 'react';import { createToken } from '@tinkoff/dippy';import { StorageRecord } from '@tinkoff/htmlpagebuilder';import * as ResourceSlot from './slots'; /** * @description * Позволяет добавлять ресурсы в определенные слоты при рендере приложения. * Используется только на сервере, эквивалентно использованию RESOURCES_REGISTRY. * * [Пример использования](https://tramvai.dev/docs/how-to/render-add-resources) */export const RENDER_SLOTS = createToken<PageResource | PageResource[]>('RENDER_SLOTS', { multi: true,}); /** * @description * Позволяет переопределять атрибуты для html, body и контейнера приложения. Имейте в виду, что: - это именно html атрибуты, а не реакт (т.е. должен быть не className, а class). - новые атрибуты затирают старые - поддерживаются только текстовые значения * * @example ```tsx { provide: HTML_ATTRS, useValue: { target: 'body', attrs: { class: 'custom-class', }, }, multi: true, }, ``` */export const HTML_ATTRS = createToken<HtmlAttrs>('HTML_ATTRS', { multi: true }); /** * @description * Позволяет повесить Node-style колбэк на событие рендеринга в браузере. * Первым аргументом отправляет ошибку, если таковая имелась */export const RENDERER_CALLBACK = createToken<((e?: Error) => void)[]>('RENDERER_CALLBACK', { multi: true,}); /** * @description * Позволяет задать функцию-обертку для рендера и переопределить параметры или результат рендера */export const CUSTOM_RENDER = createToken('CUSTOM_RENDER'); /** * @description * Регистр ресурсов - используется на сервере для регистрации дополнительных ресурсов (скриптов, стилей, верстки) которые должны быть вставлены в итоговую html-страницу */export const RESOURCES_REGISTRY = createToken<ResourcesRegistry>('resourcesRegistry'); /** * @description * Строка отвечающая за проверку требуется ли загрузить файл полифиллов в конкретном браузере. * Полифиллы грузятся всегда для браузеров без поддержки модулей, а в браузерах с поддержкой будет выполняться данная проверка * (по умолчанию проверяет на Promise.prototype.finally и реализацию URL, URLSearchParams) * * [Документация по полифилам](https://tramvai.dev/docs/how-to/how-to-enable-polyfills) */export const POLYFILL_CONDITION = createToken<string>('POLYFILL_CONDITION'); /** * @description * Позволяет включить разные режимы работы React приложения - `strict`, `blocking`, `concurrent`, по умолчанию используется `legacy` - обычный режим работы * * [Подробнее в документации к module-render](https://tramvai.dev/docs/references/modules/render) */export const RENDER_MODE = createToken<RenderMode>('RENDER_MODE'); /** * @description * Позволяет сделать обертку для текущего провайдера. * Позволяет добавлять, например, свои React.Context.Provider для разного функционала */export const EXTEND_RENDER = createToken<Array<(current: ReactElement) => ReactElement>>( 'EXTEND_RENDER', { multi: true, }); /** * @description * Токен инициализации лайаута по умолчанию для страниц */export const DEFAULT_LAYOUT_COMPONENT = createToken('defaultLayoutComponent'); /** * @description * Токен инициализации шапки по умолчанию для страниц */export const DEFAULT_HEADER_COMPONENT = createToken('defaultHeaderComponent'); /** * @description * Токен инициализации футера по умолчанию для страниц */export const DEFAULT_FOOTER_COMPONENT = createToken('defaultFooterComponent'); /** * @description * Токен для кастомизации дефолтного лейаута страниц */export const LAYOUT_OPTIONS = createToken<LayoutOptions[]>('layoutOptions', { multi: true }); type ReactComponent = ComponentType<any>; type Wrapper = (WrappedComponent: ReactComponent) => ReactComponent; export interface LayoutOptions { components?: Record<string, ReactComponent>; wrappers?: Record<string, Wrapper | Wrapper[]>;} export interface PageResource { type: keyof typeof StorageRecord; slot: typeof ResourceSlot[keyof typeof ResourceSlot]; payload: string | null; attrs?: Record<string, string | null>;} export interface ResourcesRegistry { register(resource: PageResource | PageResource[]): void; getPageResources(): PageResource[];} export type HtmlAttrs = { target: 'html' | 'body' | 'app'; attrs: { [name: string]: string | boolean | Record<string, any> | number };}; export type RenderMode = 'legacy' | 'strict' | 'blocking' | 'concurrent'; type ResourceInlineOptions = { threshold: number; types: (keyof typeof StorageRecord)[];}; /** * @description * Настройки инлайнинга ресурсов в HTML-страницу * * threshold Максимальное значение (в байтах) размера файла, до которого он инлайнится в HTML-страницу * * types Типы ресурсов, которые нужно инлайнить */export const RESOURCE_INLINE_OPTIONS = createToken<ResourceInlineOptions>( 'resourceInlineThreshold'); export { ResourceSlot };export { StorageRecord as ResourceType }; Copy  "},{"title":"Список доступных слотов для ассетов","type":1,"pageTitle":"render-tokens","url":"docs/references/tokens/render-tokens#список-доступных-слотов-для-ассетов","content":" export const HEAD_META = 'head:meta';export const HEAD_PERFORMANCE = 'head:performance';export const HEAD_CORE_STYLES = 'head:core-styles';export const HEAD_POLYFILLS = 'head:polyfills';export const HEAD_CORE_SCRIPTS = 'head:core-scripts';export const HEAD_DYNAMIC_SCRIPTS = 'head:dynamic-scripts';export const HEAD_ANALYTICS = 'head:analytics';export const HEAD_ICONS = 'head:icons';export const BODY_START = 'body:start';export const REACT_RENDER = 'react:render';export const BODY_END = 'body:end';export const BODY_TAIL_ANALYTICS = 'body:tail:analytics';export const BODY_TAIL = 'body:tail'; Copy  "},{"title":"server-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/server-tokens","content":"","keywords":""},{"title":"Список токенов","type":1,"pageTitle":"server-tokens","url":"docs/references/tokens/server-tokens#список-токенов","content":" import type { Server } from 'http';import type { Application } from 'express';import { createToken } from '@tinkoff/dippy';import type { Papi } from '@tramvai/papi'; /** * @description * Позволяет задавать базовый урл для публичных папи обработчиков. По умолчанию это `/[appName]/papi` */export const SERVER_MODULE_PAPI_PUBLIC_URL = createToken<string>('serverModulePapiPublicUrl'); /** * @description * Позволяет задавать базовый урл для приватных папи обработчиков. По умолчанию это `/[appName]/private/papi` */export const SERVER_MODULE_PAPI_PRIVATE_URL = createToken<string>('serverModulePapiPrivateUrl'); /** * @description * Позволяет задавать приватные роуты для papi */export const SERVER_MODULE_PAPI_PRIVATE_ROUTE = createToken<Papi>('serverModulePapiPrivateRoute', { multi: true,}); /** * @description * Позволяет задавать публичные роуты для papi */export const SERVER_MODULE_PAPI_PUBLIC_ROUTE = createToken<Papi>('serverModulePapiPublicRoute', { multi: true,}); /** * @description * Настройки для работы статики */export const SERVER_MODULE_STATICS_OPTIONS = createToken<ServerModuleStaticsOptions>( 'serverModuleStaticsOptions'); /** * @description * Инстанс node-сервера `http.Server`. * Позволяет добавлять логику для расширения работы сервера (обработка ошибок, настройки соединений) * * @example ```tsx { provide: commandLineListTokens.init, multi: true, useFactory: ({ server }) => { return function serverListen() { createTerminus(server, {}); }; }, deps: { SERVER_TOKEN, }, }, ``` */export const SERVER_TOKEN = createToken<Server>('server'); /** * @description * Инстанс текущего приложения. По умолчанию предполагается что это `express` приложения. * Позволяет настраивать обработку запросов и добавлять свои роуты * * @example ```tsx { provide: SERVER_TOKEN, useFactory: ({ webApp }) => { const server = https.createServer(); server.on('request', webApp); return server; }, deps: { WEB_APP_TOKEN, } } ``` */export const WEB_APP_TOKEN = createToken<Application>('webApp'); /** * @description * Подписка на инициализацию веб-приложения. Вызывается перед заданием любых стандартных обработчиков * * @example ```tsx { provide: WEB_APP_BEFORE_INIT_TOKEN, multi: true, useValue: (app) => { app.use(cookieParser()) } } ``` */export const WEB_APP_BEFORE_INIT_TOKEN = createToken<APP_INIT_HANDLER>('webAppBeforeInit', { multi: true,}); /** * @description * Подписка на инициализацию веб-приложения. * Вызывается после глобальных обработчиков запросов, но до обработчика для рендера страниц приложения * * @example ```tsx { provide: WEB_APP_INIT_TOKEN, multi: true, useValue: (app) => { app.use('mm.css', proxyCss()); app.use('mm.js', proxyClientJs()); } } ``` */export const WEB_APP_INIT_TOKEN = createToken<APP_INIT_HANDLER>('webAppInit', { multi: true }); /** * @description * Подписка на инициализацию веб-приложения. Вызывается после задания всех других обработчиков * * @example ```tsx { provide: WEB_APP_AFTER_INIT_TOKEN, multi: true, useValue: (app) => { app.use(logMiddleware()) } } ``` */export const WEB_APP_AFTER_INIT_TOKEN = createToken<APP_INIT_HANDLER>('webAppAfterInit', { multi: true,}); /** * @description * Добавляет ресурсы для проксирования запросов в приложение через `http-proxy-middleware` */export const PROXY_CONFIG_TOKEN = createToken<ProxyConfig[]>('proxyConfigToken', { multi: true,}); /** * @description * Позволяет переопределить функцию фильтрации при обращении к papi-методу `/dependenciesVersion` */export const DEPENDENCIES_VERSION_FILTER_TOKEN = createToken<DepsFilter>( 'dependenciesVersionFilter'); /** * @description * Позволяет задавать список специальных URL'ов на сервере (например, healthz и readyz) * Матчинг осущствляется при помощи библиотеки `path-to-regexp`. */export const SPECIAL_SERVER_PATHS = createToken<string>('specialServerPaths', { multi: true }); export interface ServerModuleStaticsOptions { path: string;} export type APP_INIT_HANDLER = Array<(app?: Application) => Promise<never> | never>; export type ProxyConfig = | { [key: string]: | string | { target: string; [key: string]: any; }; } | { context: string | string[]; target: string; [key: string]: any; }; export type DepsFilter = ( deps: Record<string, string>) => Record<string, string> | Promise<Record<string, string>>; Copy  "},{"title":"@tramvai/tools-check-versions","type":0,"sectionRef":"#","url":"docs/references/tools/check-versions","content":"","keywords":""},{"title":"Prerelease версии","type":1,"pageTitle":"@tramvai/tools-check-versions","url":"docs/references/tools/check-versions#prerelease-версии","content":"Инструмент позволяет устанавливать prerelease версии tramvai зависимостей для тестирования нового функционала, пример валидного списка зависимостей: \"dependencies\": { \"@tramvai/core\": \"0.5.0-rc.2\", // release candidate версия, выше по SemVer чем остальные зависимости, ошибок не будет \"@tramvai/module-common\": \"0.4.2\", \"@tramvai/module-router\": \"0.4.2\", \"@tramvai/state\": \"0.4.2\",} Copy "},{"title":"Паттерны связанных зависимостей","type":1,"pageTitle":"@tramvai/tools-check-versions","url":"docs/references/tools/check-versions#паттерны-связанных-зависимостей","content":"/^@tramvai\\/core$//^@tramvai\\/module-//^@tramvai-tinkoff\\/module-//^@tramvai\\/tokens-/ "},{"title":"@tramvai/build","type":0,"sectionRef":"#","url":"docs/references/tools/build","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#подключение","content":"Необходимо установить @tramvai/build: yarn add @tramvai/build Copy Заполнить необходимые поля в package.json: { \"main\": \"lib/index.js\", \"typings\": \"src/index.ts\"} Copy \"main\": \"lib/index.js\" на основе этого поля вычисляется, что точка входа для сборки должна называться \"src/index.ts\" \"typings\": \"src/index.ts\" желательно должен указывать на точку входа, это удобно для монореп, т.к. не требует сборки пакета для его использования в других пакетах. После сборки для публикации это поле заменится на файл с собранными типами, в данном случае - \"typings\": \"lib/index.d.ts\" И в tsconfig.json: { \"compilerOptions\": { \"moduleResolution\": \"node\", \"target\": \"ES5\", \"module\": \"CommonJS\", \"declaration\": true, \"importHelpers\": true, \"skipLibCheck\": true, \"rootDir\": \"./src\", \"outDir\": \"./lib\", \"declarationDir\": \"./lib\" }, \"include\": [ \"./src\" ]} Copy Добавить в dependencies библиотеку tslib: yarn add tslib Copy Собрать пакет через команду tramvai-build: tramvai-build --forPublish Copy с флагом --forPublish tramvai-build заменяет некоторые поля в package.json на необходимые для корректного использования библиотеки в приложениях, например \"typings\": \"src/index.ts\" заменяется на \"typings\": \"lib/index.d.ts\" "},{"title":"Explanation","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#explanation","content":"Основное предназначение библиотеки - эффективная production сборка TypeScript пакетов с помощью rollup, также поддерживается watch режим. Такие сборки, особенно при наличии большого количества пакетов в монорепозитории, могут занимать слишком много времени, и не подойдут для эффективной и удобной разработки. По этой причине, для development окружения рекомендуется использовать tsc, с фичами project references и incremental build. Рекомендуемый и автоматически генерируемый package.json для @tramvai/build позволяет приложениям использовать пакеты собранные и через tsc, и через @tramvai/build, без дополнительных действий. Все собранные бандлы содержат код стандарта ES2019, ожидается то их будет резолвить бандлер (Webpac, etc.), для которого уже настроена транспиляция через babel пакетов в node_modules, написанных на современном JS, в код стандарта ES5. "},{"title":"Бандл под NodeJS в CommonJS формате","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#бандл-под-nodejs-в-commonjs-формате","content":"NodeJS до 12 версии не поддерживает ES модули, либо поддерживает их под специальным флагом.@tramvai/build генерирует бандл с кодом стандарта ES2019, в формате CommonJS, автоматически, название итогового бандла берется из поля main в package.json, например lib/index.js. При сборке нашего пакета в приложении через webpack с опцией target: 'node', этот бандл скорее всего не будет использован, т.к. в приоритете будет бандл из поля module. Ожидается, что этот бандл, из поля \"main\", будет резолвить только NodeJS, а бандлеры (Webpac, etc.) предпочтут бандл из поля \"module\" "},{"title":"Бандл под бандлеры (Webpack, etc.) в формате ES modules","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#бандл-под-бандлеры-webpack-etc-в-формате-es-modules","content":"Современные бандлеры (Webpac, etc.) поддерживают ES модули, и нестандартное поле \"module\" в package.json.@tramvai/build генерирует бандл с кодом стандарта ES2019, в формате ES modules, автоматически, название итогового бандла вычисляется из поля main в package.json, и добавляется суффикс .es например lib/index.es.js. Если сборка произведена через tramvai-build --forPublish, в package.json добавится поле \"module\": \"lib/index.es.js\". При сборке нашего пакета в приложении через webpack с опцией target: 'node', бандл из поля module будет иметь больший приоритет, чем поле main. Генерируется код стандарта ES2019, т.к. ожидается, что этот бандл, из поля \"module\", будут резолвить бандлер (Webpac, etc.), для которого уже настроена транспиляция через babel пакетов в node_modules, написанных на современном JS, в код стандарта ES5. Почему мы не советуем оставлять ES2019 код? Оказалось, что код в ES5 работает заметно быстрее на NodeJS сервере. При этом, размер итогового бандла на сервере не имеет значения. "},{"title":"Бандл для браузеров","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#бандл-для-браузеров","content":"Современные бандлеры (Webpac, etc.) поддерживают ES модули, и нестандартное поле \"browser\" в package.json. При наличии поля browser в package.json, @tramvai/build генерирует бандл с кодом стандарта ES2019, в формате ES modules. Если поле browser в package.json является строкой, то из этого файла вычисляется точка входа для browser бандла, и его новое название. Например, при \"browser\": \"lib/browser.js\", точкой входа будет src/browser.ts, а бандл будет называться lib/browser.js. Иначе, если поле browser является объектом и сборка произведена через tramvai-build --forPublish, название вычисляется из поля main в package.json, и добавляется суффикс .browser, например lib/index.browser.js. Далее в поле browser добавится свойство, указывающее сборщикам приложений, какой бандл резолвить для браузерной сборки, вместо поля module: { \"browser\": { ..., \"./index.es.js\": \"./index.browser.js\" }} Copy Спецификация поля browserГенерируется код стандарта ES2019, т.к. ожидается, что этот бандл, из поля \"browser\", будут резолвить бандлер (Webpac, etc.), для которого уже настроена транспиляция через babel пакетов в node_modules, написанных на современном JS, в код согласно актуальному browserslist конфигу. При сборке нашего пакета в приложении через webpack с опцией target: 'web', бандл из поля browser будет иметь больший приоритет, чем поле module. "},{"title":"Копирование статических файлов","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#копирование-статических-файлов","content":"При каждом билде автоматически копируются все файлы, кроме JS/TS скриптов и JSON, например CSS, изображения, шрифты, и сохраняются исходные пути до файлов (src/css/style.css -> lib/css/style.css). Копирование можно отключить, собирая пакет с флагом copyStaticAssets: tramvai-build --copyStaticAssets false Copy "},{"title":"Сборка и копирование миграций","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#сборка-и-копирование-миграций","content":"При наличии файлов в папке migrations, они считаются исходниками миграций. Эти файлы компилируются в .js и копируются в папку __migrations__. "},{"title":"CLI","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#cli","content":""},{"title":"Разовая сборка","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#разовая-сборка","content":"tramvai-build Copy "},{"title":"Сборка в watch режиме","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#сборка-в-watch-режиме","content":"tramvai-build --watch Copy "},{"title":"Копирование статических файлов","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#копирование-статических-файлов-1","content":"tramvai-copy Copy "},{"title":"Доступные флаги","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#доступные-флаги","content":"tramvai-build --help Copy "},{"title":"JavaScript API","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#javascript-api","content":""},{"title":"TramvaiBuild","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#tramvaibuild","content":"TramvaiBuild позволяет конфигурировать утилиту для дальнейшего использования. import { TramvaiBuild } from '@tramvai/build'; new TramvaiBuild(options); Copy Доступные опции:  export type Options = { sourceDir?: string; watchMode?: boolean; copyStaticAssets?: boolean; forPublish?: boolean;}; Copy  "},{"title":"Сборка","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#сборка","content":"Метод TramvaiBuild.start позволяет собрать пакет, разово или в watch режиме, в зависимости от конфигурации экземпляра TramvaiBuild: import { TramvaiBuild } from '@tramvai/build'; new TramvaiBuild(options).start(); Copy "},{"title":"Копирование статических файлов","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#копирование-статических-файлов-2","content":"Метод TramvaiBuild.copy позволяет разово копировать статические файлы в output директорию: import { TramvaiBuild } from '@tramvai/build'; new TramvaiBuild(options).copy(); Copy "},{"title":"How to","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#how-to","content":""},{"title":"Как собрать отдельный бандл для браузерной сборки?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-собрать-отдельный-бандл-для-браузерной-сборки","content":"Допустим, у нас есть две точки входа, серверная - src/server.ts, и клиентская - src/browser.ts. В таком случае, необходимо настроить поле browser в package.json таким образом: { \"main\": \"lib/server.js\", \"browser\": \"lib/browser.js\"} Copy После сборки для публикации мы получим такой package.json: { \"main\": \"lib/server.js\", \"browser\": \"lib/browser.js\", \"typings\": \"lib/server.d.ts\", \"module\": \"lib/server.es.js\"} Copy "},{"title":"Как заменить отдельный модуль для браузерной сборки?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-заменить-отдельный-модуль-для-браузерной-сборки","content":"Допустим, у нас есть одна точка входа - src/index.ts, а модуль src/external.ts мы хотим заменить на src/external.browser.ts. В таком случае, необходимо настроить поле browser в package.json таким образом: { \"main\": \"lib/index.js\", \"browser\": { \"./lib/external.js\": \"./lib/external.browser.js\" }} Copy После сборки для публикации мы получим такой package.json: { \"main\": \"lib/index.js\", \"browser\": { \"./lib/external.js\": \"./lib/external.browser.js\", \"./lib/index.es.js\": \"./lib/index.browser.js\", }, \"typings\": \"lib/index.d.ts\", \"module\": \"lib/index.es.js\"} Copy "},{"title":"Как собирать все пакеты в монорепе при разработке, в watch режиме?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-собирать-все-пакеты-в-монорепе-при-разработке-в-watch-режиме","content":"@TODO + ссылка на @tinkoff/fix-ts-references "},{"title":"Как сделать чтобы модуль импортировался только при определенных условиях, а иначе игнорировался при сборке?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-сделать-чтобы-модуль-импортировался-только-при-определенных-условиях-а-иначе-игнорировался-при-сборке","content":"Вместо статичных импортов можно использовать динамический import или require. В этом случае, импортированный модуль будет собран в отдельный чанк и будет добавлен в сборку вебпаком при необходимости, причем при использовании динамического импорта также будет создан отдельный чанк после сборки вебпака, при использовании require отдельного чанка не будет. let func = noop; if (process.env.NODE_ENV !== 'production') { func = require('./realFunc').func;} export { func }; Copy "},{"title":"Как использовать json файлы в пакете?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-использовать-json-файлы-в-пакете","content":"По умолчанию в корневом tsconfig.json включена опция resolveJsonModule которая позволяет импортировать json-файлы также как и обычный код используя import, причем всё будет работать с типизацией и tree-shaking при публикации пакета. Для того чтобы ts не ругался на такие импорты необходимо в tsconfig.json пакета добавить новое вхождение в поле includes: { \"includes\": [\"./src\", \"./src/**/*.json\"]} Copy "},{"title":"Как использовать файлы других расширений в пакете (например .css)?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-использовать-файлы-других-расширений-в-пакете-например-css","content":"Такие файлы не используются в сборке или явно в коде, и ts такие файлы игнорирует. Для правильной работы пакета потребуется дополнительная настройка, а именно прописать в package.json пакета скрипт tramvai-copy: { \"scripts\": { \"copy-static-assets\": \"tramvai-copy\" }} Copy Цель этого скрипта в копировании файлов не относящихся к исходному коду в директорию сборки. Само копирование происходит либо при установке зависимостей в корне репозитория, либо при непосредственной публикации пакетов. Так как в некоторых кейсах по какой-либо причине директория сборки может быть удалена то возможно потребуется перезапуск команды tramvai-copy для данных пакетов. "},{"title":"Как использовать css-модули в пакете?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-использовать-css-модули-в-пакете","content":"Для того, чтобы typescript не ругался на импорты css-модулей, в папку src внутри пакета нужно добавить файл typings.d.ts с определением: declare module '*.css' { const value: any; export default value;} Copy Для копирования css во время dev-сборки нужно изменить команду: \"watch\": \"tramvai-copy && tsc -w\" Copy Такие импорты никак не преобразуются, для правильной сборки нужно использовать @tramvai/cli или другие решения для css-модулей. При сборке корректность импортов не проверяется, так что проверяйте пакет перед публикацией. "},{"title":"@tramvai/tools-migrate","type":0,"sectionRef":"#","url":"docs/references/tools/migrate","content":"","keywords":""},{"title":"Отключение выполнения миграций","type":1,"pageTitle":"@tramvai/tools-migrate","url":"docs/references/tools/migrate#отключение-выполнения-миграций","content":"Для отключения миграций можно проставить переменную окружения SKIP_TRAMVAI_MIGRATIONS. "},{"title":"Добавление новой миграции","type":1,"pageTitle":"@tramvai/tools-migrate","url":"docs/references/tools/migrate#добавление-новой-миграции","content":"Добавить новую миграцию можно с помощью команды yarn generate:migration после чего потребуется указать имя пакета для которого предназначена миграция и имя новой миграции. Также для этого пакета потребуется добавить в package.json в поле files папку с собранными миграциями, если они не были указаны ранее: \"files\": [ \"lib\", \"__migrations__\"], Copy "},{"title":"Реализация миграции","type":1,"pageTitle":"@tramvai/tools-migrate","url":"docs/references/tools/migrate#реализация-миграции","content":"Миграция представляет собой функцию, принимающую специальное апи с помощью которого можно осуществлять изменения кода или конфигов. export interface Api { packageJSON: PackageJSON; // объект-представление корневого package.json tramvaiJSON: TramvaiJSON; // объект-представление файла tramvai.json или platform.json transform: (transformer: Transform, pathTransformer?: PathTransformer) => Promise<void>; // функция принимающая функцию-траснформер для jscodeshift и функцию-трансформер для переименования файлов} Copy Трансформация кода осуществляется с помощью jscodeshift "},{"title":"How to","type":1,"pageTitle":"@tramvai/tools-migrate","url":"docs/references/tools/migrate#how-to","content":""},{"title":"Write migration","type":1,"pageTitle":"@tramvai/tools-migrate","url":"docs/references/tools/migrate#write-migration","content":"Transformation# Rules: Prefer to return null | undefined or original source from the transform function in cases when migration doesn't change source code. Otherwise it will lead to unnecessary fs writing.Prefer to use embedded methods of collections returned by call j(source) to make searches and transforms "},{"title":"@tinkoff-monorepo/fix-ts-references","type":0,"sectionRef":"#","url":"docs/references/tools/monorepo-tools/fix-ts-references","content":"","keywords":""},{"title":"Install","type":1,"pageTitle":"@tinkoff-monorepo/fix-ts-references","url":"docs/references/tools/monorepo-tools/fix-ts-references#install","content":"yarn add fix-ts-references Copy "},{"title":"Usage","type":1,"pageTitle":"@tinkoff-monorepo/fix-ts-references","url":"docs/references/tools/monorepo-tools/fix-ts-references#usage","content":"npx fix-ts-references --fix Copy Соответственно скрипт выполняет: С флагом --fix: Удаление ссылки из references модуля если зависимость убрана из package.jsonДобавление ссылки в references модуля если зависимость добавлена в package.jsonПростановка tsconfig.compilerOptions.rootDir=./src если не поставленаУдаление ссылки из reference solution'а проекта если модуль удален из репозиторияДобавление ссылки в reference solution'а проекта если модуль добавлен в репозиторий Без флага --fix выводит список неисправленных ошибок "},{"title":"@tinkoff-monorepo/depscheck","type":0,"sectionRef":"#","url":"docs/references/tools/monorepo-tools/depscheck","content":"","keywords":""},{"title":"Параметры конфига для .depscheckrc.yml и cli","type":1,"pageTitle":"@tinkoff-monorepo/depscheck","url":"docs/references/tools/monorepo-tools/depscheck#параметры-конфига-для-depscheckrcyml-и-cli","content":"Все доступные параметры для depcheck можно посмотреть в доке, но есть проблема с недопубликованностью. Поэтому параметры ниже работают, но с оговорками (см --ignore-patterns), а остальные нужно проверять. > yarn depscheck -h collector --collector Модуль, отвечающий за сбор пакетов для проверки и реализующий интерфейс @tinkoff-monorepo/pkgs-collector -> CollectorInterface (сейчас используется @tinkoff-monorepo/pkgs-collector-pvm) [required] [default: {\"name\":\"@tinkoff-monorepo/pkgs-collector-workspaces\"}] --collector-config-strategy [string] [choices: \"about-to-update\", \"update\", \"changed\", \"changed-since-release\", \"affected\", \"released\", \"updated\", \"all\"] [default: [\"affected\"]] depcheck --depcheck-ignore-matches Список паттернов имен модулей отсутствие которых в зависимостях не должно приводить к ошибке [array] [default: []] --depcheck-ignore-dirs Список имен директорий, которые не нужно проверять на не описанные зависимости [array] [default: []] --depcheck-skip-missing Вообще не проверять на не описанные зависимости [boolean] [default: false] --depcheck-ignore-bin-package Не делать проверок в bin файлах пакета [boolean] [default: false] Options: --version Show version number [boolean] --config false если конфиг не нужен совсем и можно задать путь до файла конфига. Иначе отработает логика cosmiconfig [default: \"auto\"] --fix Включает режим исправления ошибок. В данный момент исправляет только unused ошибки. [boolean] [default: false] --ignore-patterns Список паттернов файлов, в которых не нужно делать проверку на missing deps [array] [default: []] --ignore-peer-dependencies Список паттернов модулей из peerDependencies, отсутствие которых в dependencies не должно приводить к ошибке [array] [default: []] -h Show help [boolean] Copy "},{"title":"Пример конфига","type":1,"pageTitle":"@tinkoff-monorepo/depscheck","url":"docs/references/tools/monorepo-tools/depscheck#пример-конфига","content":"ignore-patterns: ['**/*.spec.{ts,tsx}', '**/*.test.{ts,tsx}', '**/dynamic-components/*/shared/externals.{js,ts}']depcheck-ignore-dirs: ['__integration__', 'examples', '__tests__']depcheck-ignore-matches: ['@platform/cli', '@tramvai/tools-migrate'] Copy "},{"title":"@tinkoff-monorepo/pkgs-collector-workspaces","type":0,"sectionRef":"#","url":"docs/references/tools/monorepo-tools/pkgs-collector-workspaces","content":"@tinkoff-monorepo/pkgs-collector-workspaces Получает все пакеты, описанные в package.json -> workspaces","keywords":""},{"title":"@tinkoff-monorepo/pkgs-collector-dir","type":0,"sectionRef":"#","url":"docs/references/tools/monorepo-tools/pkgs-collector-dir","content":"","keywords":""},{"title":"Конфиг","type":1,"pageTitle":"@tinkoff-monorepo/pkgs-collector-dir","url":"docs/references/tools/monorepo-tools/pkgs-collector-dir#конфиг","content":""},{"title":"pkgDirs","type":1,"pageTitle":"@tinkoff-monorepo/pkgs-collector-dir","url":"docs/references/tools/monorepo-tools/pkgs-collector-dir#pkgdirs","content":"Список паттернов путей до пакетов в формате glob "},{"title":"createAction","type":0,"sectionRef":"#","url":"docs/references/tramvai/create-action","content":"","keywords":""},{"title":"createAction({ name, fn, deps, conditions })","type":1,"pageTitle":"createAction","url":"docs/references/tramvai/create-action#createaction-name-fn-deps-conditions-","content":"name - The name of the action, a unique identifier is expectedfn(context, payload, deps) - Implementation of the action, this function will be called when the action is used, maybe async context - ConsumerContextpayload - data passed to actiondeps - provider instances from deps deps - List of providers that are needed for the action to workconditions - List of restrictions for the execution of the action "},{"title":"Usage example","type":1,"pageTitle":"createAction","url":"docs/references/tramvai/create-action#usage-example","content":"import { createAction } from '@tramvai/core'; createAction({ name: 'action log error', fn: (context, payload, deps) => { deps.logger.error('ERROR'); }, deps: { logger: 'logger', }, conditions: { requiredCoreRoles: ['god'], },}); Copy "},{"title":"createApp","type":0,"sectionRef":"#","url":"docs/references/tramvai/create-app","content":"","keywords":""},{"title":"createApp({ modules, bundles, providers })","type":1,"pageTitle":"createApp","url":"docs/references/tramvai/create-app#createapp-modules-bundles-providers-","content":"modules - массив с используемыми модулями в приложенииbundles - объект с подключаемыми бандлами с данными в приложении. Ключ - индетификатор бандла, значение - Promise, который возвращает bundleproviders - массив с провайдерами приложения, которые будут добавлены в последнюю очередь в DI (после провайдеров модулей) и тем самым можно будет перезаписать реализацию токеновactions - массив с глобальными экшенами, которые будут зарегистрированы для всех бандлов и страниц "},{"title":"Пример использования","type":1,"pageTitle":"createApp","url":"docs/references/tramvai/create-app#пример-использования","content":"import { createApp, provide } from '@tramvai/core';import { RouterModule } from '@tramvai/module-router';import { RenderModule } from '@tramvai/module-render';import { ServerModule } from '@tramvai/module-server'; createApp({ name: 'my-awesome-app', modules: [RouterModule, RenderModule, ServerModule], providers: [ provide({ provide: 'options', useValue: {}, }), ], bundles: { mainDefault: () => import(/* webpackChunkName: \"mainDefault\" */ './bundles/mainDefault'), }, actions: [loadDepositConfig],}); Copy После создания createApp запускается СommandLineRunner который выполняет цепочку действий, необходимых для инициализации приложения. "},{"title":"createBundle","type":0,"sectionRef":"#","url":"docs/references/tramvai/create-bundle","content":"","keywords":""},{"title":"Свойства BundleOptions","type":1,"pageTitle":"createBundle","url":"docs/references/tramvai/create-bundle#свойства-bundleoptions","content":"name - Название бандла. Значение будет использоваться как индетификатор бандла.components: {} - Объект с зарегистрированными компонентами для бандла. Которые можно использовать и получать для отображения страницыpresets?: [] - Список модификаторов для текущего бандла. Этот список объединяется с текущим бандлом и получается итоговая конфигурация. Нужно для выделения общих частей, например пак с компонентами для авторизации. Похожая реализация реализована в пресетах babelactions?: [] - Список экшенов которые будут зарегистрированы глобально для бандлаreducers?: [] - Список редьюсеров, которые необходимо зарегистрировать с загрузкой бандла "},{"title":"Пример использования","type":1,"pageTitle":"createBundle","url":"docs/references/tramvai/create-bundle#пример-использования","content":"import { createBundle } from '@tramvai/core';import { lazy } from '@tramvai/react'; createBundle({ name: 'platform/account/profile', presets: [actionPackProfile], components: { 'platform/pages/profile/ProfilePage': lazy(() => import('../pages/ProfileSettingsPage')), 'platform/pages/profile/ProfilePurchasesPage': lazy( () => import('../pages/ProfilePurchasesPage') ), }, actions: [variationLoadAction, platformAsyncBundle], reducers: [formReducer],}); Copy "},{"title":"module","type":0,"sectionRef":"#","url":"docs/references/tramvai/module","content":"","keywords":""},{"title":"@Module({ providers, deps, imports })(class)","type":1,"pageTitle":"module","url":"docs/references/tramvai/module#module-providers-deps-imports-class","content":"providers - Провайдеры, которые будут добавлены в общий DI контейнер и станут доступны в других модуляхdeps - Список зависимостей из DI контейнера, необходимые для инициализации модуляimports - Список модулей, из которых будут получены провайдеры и добавлены в DI. Позволяет создавать модули, которые объединяют множество других модулей "},{"title":"Пример использования","type":1,"pageTitle":"module","url":"docs/references/tramvai/module#пример-использования","content":"import { Module, provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: 'token', useValue: 'value-in-token', }), ], deps: { logger: 'logger', }, imports: [ModuleLogger],})class ModulePubSub { constructor({ logger }) { logger.info('Module create'); }} Copy "}]