[{"title":"Bundle","type":0,"sectionRef":"#","url":"docs/concepts/bundle","content":"","keywords":""},{"title":"Dynamic bundle import​","type":1,"pageTitle":"Bundle","url":"docs/concepts/bundle#dynamic-bundle-import","content":"To highlight unnecessary code on each page, each bundle passed to createApp must have the signature () => Promise<{default: Bundle}>. All the code shared with the modules plugged into the application will remain in the main chunk of the application, and many bundles will weigh only a few KB, but as soon as one of the components of the bundle includes a heavy dependency, for example, a library with forms, it will completely fall into the corresponding bundle. It is recommended to use dynamic import with the magic comment webpackChunkName to specify the name of the new chunk, for example: () => import(/* webpackChunkName: \"mainDefault\" */ './bundles/mainDefault') Copy "},{"title":"Default bundle​","type":1,"pageTitle":"Bundle","url":"docs/concepts/bundle#default-bundle","content":"Each route must have properties bundle with the name of the bundle, pageComponent and layoutComponent with the names of the corresponding components. The default values ​​are as follows: bundle: 'mainDefault'pageComponent: 'pageDefault'layoutComponent: 'layoutDefault' When using the standard RenderModule, the LayoutModule is included, which will provide the layoutDefault and a separate mechanism for extending and overriding layout in the application, so there is no need to add the layoutDefault property to the components list of the bundle. To create a bundle that will run on all application pages that do not have specific route settings, two steps are enough: Create a bundle​ import { createBundle } from '@tramvai/core'; import { MainPage } from './pages/MainPage'; export default createBundle({ name: 'mainDefault', components: { pageDefault: MainPage, }, }); Copy Connect the bundle​ import { createApp } from '@tramvai/core'; createApp({ name: 'myApp', modules: [ // ... ], providers: [ // ... ], bundles: { mainDefault: () => import(/* webpackChunkName: \"mainDefault\" */ './bundles/mainDefault'), }, }); Copy "},{"title":"Action","type":0,"sectionRef":"#","url":"docs/concepts/action","content":"","keywords":""},{"title":"Example action​","type":1,"pageTitle":"Action","url":"docs/concepts/action#example-action","content":"import { createAction } from '@tramvai/core'; // create an action const actionFetchData = createAction({ name: 'fetch-data', fn: (context, payload) => fetch(payload.url), }); // execute the action context .executeAction(actionFetchData, { url: 'https://tinkoff.ru' }) .then((data) => context.dispatch(loadData(data))); Copy "},{"title":"Global Actions​","type":1,"pageTitle":"Action","url":"docs/concepts/action#global-actions","content":"Applications can add global actions in the application that need to be executed before rendering the page, in these actions they usually load the information necessary to display the page, for example, information about deposits. Before rendering the page, the different types of actions are collected into a single list and executed in parallel. In short, an action is global if added via createApp, createBundle, or a static property of a page component, such as PageComponent.actions. By default, global actions are executed once, on the server, and pass the status and result of the action to the client. "},{"title":"Execution Deadline​","type":1,"pageTitle":"Action","url":"docs/concepts/action#execution-deadline","content":"Servers must respond quickly, so we must reduce the number of cases when global actions cause a delay in page loading, for example, if an API fails. To do this, there is a time limit on the server for executing global actions, and if this time passes, then waiting for actions ends and these actions must be executed on the client side. "},{"title":"Synchronizing actions between server and client​","type":1,"pageTitle":"Action","url":"docs/concepts/action#synchronizing-actions-between-server-and-client","content":"Information about all successfully executed actions will be transferred to the client, which will start the execution of global actions based on this information. At the same time, if an action, for example, fell out of the deadline or fell by mistake, then it will be re-executed on the client side. "},{"title":"Errors in actions​","type":1,"pageTitle":"Action","url":"docs/concepts/action#errors-in-actions","content":"By default, errors in actions only logged with event action-execution-error, but they do not stop the page rendering pipeline. The only exceptions are actions that throw NotFoundError or RedirectFoundError errors from @tinkoff/errors library. When new RedirectFoundError({ nextUrl }) is thrown, the page request will be redirected to nextUrl with 301 status (default). When new NotFoundError() is thrown, the page request will have a status of 404 (default), and if your application has not-found route, that route will not be render. "},{"title":"Types of global actions​","type":1,"pageTitle":"Action","url":"docs/concepts/action#types-of-global-actions","content":"Application-wide global actions​ To register within the application, we must pass an array of actions to createApp, after that all these actions will be executed for each page and any bundles: Connection​ createApp({ name: 'myApp', actions: [loadDepositConfig], }); Copy You can also register actions with providers: import { ACTIONS_LIST_TOKEN } from '@tramvai/core'; import { provide } from '@tramvai/core'; const provider = provide({ provide: ACTIONS_LIST_TOKEN, multi: true, useValue: [loadDepositConfig], }); Copy Global actions for the bundle​ To register inside a bundle, we must pass to createBundle a list of actions that will then be executed for all pages that are present and used in the bundle. Connection​ createBundle({ name: 'bundle', actions: [loadDepositConfig], }); Copy Global actions linked to the page​ This is the lowest level of adding global actions, for a separate Page component, we can bind a list of actions that need to be performed before rendering the page. Connection​ To do this, you need to add a static property to the page of the actions component and pass the list of required actions class PageComponent extends Copmponent { static actions = [loadDepositConfig]; } Copy "},{"title":"Restrictions​","type":1,"pageTitle":"Action","url":"docs/concepts/action#restrictions","content":"Not all actions can be executed under all circumstances, we can have actions that should be executed only on the server, others only in the browser, and having any other restrictions. There is a conditions property to solve this problem: createAction({ name: 'fetch-data', fn: (context, payload) => fetch(payload.url), conditions: { requiredCoreRoles: ['client'], onlyBrowser: true, }, }); Copy In the example above, we create an action that will be executed only in the browser and only when we have the user role of the main core API equal to client. "},{"title":"Adding new restrictions to the application​","type":1,"pageTitle":"Action","url":"docs/concepts/action#adding-new-restrictions-to-the-application","content":"You can implement your own constraints in an application or module. To do this, we must create an object with an interface: interface Condition { key: string; fn(checker: ActionConditionChecker): void; } Copy key - restriction identifierfn - a validation function that will be called for each action The function will receive in the argument checker, which has an interface interface ActionConditionChecker { payload: any; parameters: any; type: 'global' | 'local'; conditions: Record<string, any>; forbid(): void; setState(value: any): void; getState(): any; allow(): void; } Copy payload - data that was transferred with the actionparameters - parameters that were passed when creating the actionconditions - restrictions for the current actiontype - type of the executed action, can be global or simple execution via executeActionforbid - prohibits the execution of the action. If at least one checker calls this function, the action execution will be stoppedsetState - allows you to write the check data. It is necessary for cases when we need to know with what data it was executed before and whether it needs to be repeated, for example, restrictions on the authorization rolegetState - getting the previously recorded stateallow - tell the action to be executed again. The action will execute unless execution is forbidden via forbid "},{"title":"Example of a constraint​","type":1,"pageTitle":"Action","url":"docs/concepts/action#example-of-a-constraint","content":"const isServer = typeof window === 'undefined'; export const onlyServer: ActionCondition = { key: 'onlyServer', fn: (checker) => { if (checker.conditions.onlyServer && !isServer) { checker.forbid(); } }, }; Copy After connecting, the constraint will look if the action has a onlyServer field in conditions, and if so, it will change the action's behavior "},{"title":"Connecting restrictions to the application​","type":1,"pageTitle":"Action","url":"docs/concepts/action#connecting-restrictions-to-the-application","content":"To do this, you need to add the multi provider ACTION_CONDITIONALS and pass a function that will have an interface import { provide } from '@tramvai/core'; const provider = provide({ provide: ACTION_CONDITIONALS, multi: true, useValue: [onlyServer], }); Copy "},{"title":"Preset limits available for each action​","type":1,"pageTitle":"Action","url":"docs/concepts/action#preset-limits-available-for-each-action","content":"always - the action is executed on the server, then in the browser and on each SPA transition within the applicationonlyBrowser - the action is executed only in the browseronlyServer - the action is executed only on the serverpageBrowser - the global action is executed only in the browserpageServer - the global action is executed only on the serveralways + onlyBrowser - the action is executed in the browser and for each SPA transition within the application "},{"title":"Peculiarities​","type":1,"pageTitle":"Action","url":"docs/concepts/action#peculiarities","content":"Keep in mind that actions are cached by default and are only executed once during the life cycle of the application. The following feature follows from this. Let's assume the following situation: we have a page of the concert venue at the url /concertvenue-[objectId] - where objectId is a parameter that corresponds to the concert venue identifier;on this page we have one component ConcertVenuePage and one page action preparePageAction;objectId in the url of the page is used to get data in preparePageAction, as well as to fetch data for rendering the page;we have a concert page /concert on which there are links to concert venues -/concertvenue-1, /concertvenue-2, /concertvenue-1. We can navigate to all these links with a SPA transition;Transitions between pages are client-side (SPA), not server-side; Sequencing: On the concert page we click on /concertvenue-1, the page of the concert venue opens, the page action is performed for the first time.We go back to the SPA concert page by transition.Click on /concertvenue-2.We get to an empty page, since the page action has already been executed, new data has not been requested, and the data selection for drawing the page was made according to ID from url - 2. If you want a page action to be executed every time you visit the page, you need to pass it the appropriate condition: const preparePageAction = creareAction({ name: 'preparePageAction', fn: () => { // ... }, conditions: { // with always: true, the action will always be called and not cached always: true, }, }); ConcertVenuePage.actions = [preparePageAction]; Copy "},{"title":"Actions chain","type":0,"sectionRef":"#","url":"docs/concepts/command-line-runner","content":"","keywords":""},{"title":"Usage example​","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#usage-example","content":"We have registered a new provider that will be called when commandLineRunner reaches the commandLineListTokens.generatePage token and the render function is executed: import { provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: commandLineListTokens.generatePage, useFactory: ({ responseManager }) => { return function render() { responseManager.setBody(ReactDOM.renderToString(<App />)); }; }, deps: { responseManager: RESPONSE_MANAGER_TOKEN, }, multi: true, }), ], }) export class RenderModule {} Copy "},{"title":"Action blocks​","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#action-blocks","content":"A number of basic actions are predefined in the tramvai, which are performed at certain stages of the application. Based on these stages, the work of the basic tram modules is built and actions can be added to custom modules. "},{"title":"Initialization (init)​","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#initialization-init","content":"When tramvai starts, a chain of actions is launched in which you can initialize asynchronous services (if necessary) and add basic functionality. These actions are performed only once and are not available to providers who need a custom context.  "},{"title":"Handling customer requests​","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#handling-customer-requests","content":"For each client, we run a list of actions in which the user context and data are available. For each client, we create our own di context in which the implementations will live only while we process the client's request.  "},{"title":"SPA transitions (spa)​","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#spa-transitions-spa","content":"For SPA transitions in the browser, routing triggers a list of actions  "},{"title":"Shutdown (close)​","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#shutdown-close","content":"Before exiting the application, this list of actions is launched  "},{"title":"Tokens​","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#tokens","content":""},{"title":"init​","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#init","content":"Initializing Asynchronous Services For what: If you need to initialize global singletons asynchronously "},{"title":"listen​","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#listen","content":"Subscribing to global events by the application For what: If you need to subscribe to global events or a port "},{"title":"customer_start​","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#customer_start","content":"The starting token in the client request processing chain. Required to initialize custom asynchronous constructors. It is not advised to do any lengthy asynchronous tasks at this stage, as only synchronous actions are expected. For what: To initialize asynchronous services for each client "},{"title":"resolve_user_deps​","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#resolve_user_deps","content":"The main goal of this stage is to find out all the necessary information about the client we are currently processing. Since all actions within one stage are performed in parallel with us, it is at this stage that you can efficiently and quickly request all the necessary information, for example, simultaneously with the request for customer data, you can find out about the status of the customer's authorization, get analytical information about the customer and similar actions. For what: To request any global customer information "},{"title":"resolve_page​","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#resolve_page","content":"The main goal of this stage is to find out all the necessary information about the page the client visited. For what: To request information about the page "},{"title":"resolve_page_deps​","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#resolve_page_deps","content":"At this stage, we already know about the client, about what this page is. But, we have not requested the necessary data for the page. For example: request resources from the admin panel, get a list of regions, load the necessary page blocks. And all the information that will be needed when generating the page. At this stage, it is not worth doing long asynchronous actions and it is supposed to be cached or moved to resolveUserDeps to achieve the maximum speed of response to clients. At this stage, action is executed and perhaps they will suit you better, as there are many additional functionality For what: To get the information needed to render the page "},{"title":"generate_page​","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#generate_page","content":"At this stage, we already know the current route, which client and all actions for the page have already been loaded. And at this stage, according to the information from the previous stages, we generate an html page and give it to the client For what: this is more of an internal stage and should not be used in ordinary cases. Since race condition with application rendering "},{"title":"clear​","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#clear","content":"This stage will be called after we have responded to the client, but some modules or libraries need to delete client data For what: The method is needed if you need to perform actions after a successful response to the user "},{"title":"spa_transition​","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#spa_transition","content":"Tasks registered at this stage are executed on SPA transitions in the application For what: To update meta information on the current page "},{"title":"close​","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#close","content":"Before closing the application, some modules may need to perform special actions, for example, close connections, send data and similar activities. In order not to duplicate the application closure tracking code in each module, this stage was made. For what: If you need to perform actions before closing the application. for example close connections, send logs and so on "},{"title":"Errors in stages​","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#errors-in-stages","content":"On the server side, you can intercept errors from commandLineRunner stages by adding express error middleware with a multi token WEB_APP_AFTER_INIT_TOKEN. In this middleware you can change the response status, headers and body, and end the response. For example, exceptions when rendering React components from current page, get into this handler (Error Boundary not working at server-side). Middleware example: { provide: WEB_APP_AFTER_INIT_TOKEN, multi: true, useFactory: (deps) => { return (app) => { app.use((err, req: Request, res: Response, next) => { next(err); }); }; }, deps: {}, }, Copy "},{"title":"Customization​","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#customization","content":"The application can override the standard list of actions, for example, delete unnecessary ones or add new ones. To do this, you need to define a provider in the application or module that will rewrite the base list import { provide } from '@tramvai/core'; [ provide({ provide: COMMAND_LINES_TOKEN, scope: 'singleton', useValue: customLines, }), ]; Copy Caution: do not delete stages, as this may cause some modules to stop working correctly. In this case, the best solution would be to delete the module that is being linked to an unnecessary stage. "},{"title":"Dependency Injection","type":0,"sectionRef":"#","url":"docs/concepts/di","content":"","keywords":""},{"title":"Concepts​","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#concepts","content":"Provider - Token implementation in DITokens - provider identifier in DI system and at the same time its interfaceContainer - storage with all providers and their implementations "},{"title":"Features​","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#features","content":""},{"title":"Dynamic Initialization​","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#dynamic-initialization","content":"Providers are initialized only if the code got an instance using the get method from the di container or if the provider was specified as a deps dependency on module. In other cases, the provider will not be created and initialized. This feature allows us to register providers in any order and replace implementations. "},{"title":"Replacing implementations​","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#replacing-implementations","content":"In some cases, the basic implementation of the functionality may not be suitable for us, and to solve this problem, we can override the implementation of the providers. For example, the current logger from the common-module is not suitable for us and we want to replace it, for this we need to drop a new implementation for the token into the providers. import { provide } from '@tramvai/core'; createApp({ modules: [CommonModule], providers: [ provide({ provide: LOGGER_TOKEN, useValue: console, }), ], }); Copy After that, we will replace the implementation of LOGGER_TOKEN, which was declared in CommonModule, with a native object console "},{"title":"Checking the availability of the implementation of all dependencies​","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#checking-the-availability-of-the-implementation-of-all-dependencies","content":"When initializing the provider, the availability of all dependencies is automatically checked if no dependency was found and the provider is not optional, an exception is thrown in development mode. "},{"title":"Using DI​","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#using-di","content":""},{"title":"In modules​","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#in-modules","content":"Passing an array to the providers parameter that will be added when the application is initialized in DI. More about modules @Module({ providers: [ // ... ], }) export class MyModule {} Copy "},{"title":"In createApp​","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#in-createapp","content":"You can pass the providers array to createApp, which will have the highest priority and will overwrite the implementations of the modules and core interfaces: createApp({ providers: [ // ... ], }); Copy "},{"title":"In actions​","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#in-actions","content":"To get provider implementations, you can pass a deps object when creating an action: createAction({ name: 'action', fn: (context, payload, deps) => { deps.logger.error('ERROR'); }, deps: { logger: 'logger', }, }); Copy "},{"title":"Container A​","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#container-a","content":"container that stores a list of registered providers in the application, as well as instances of provider implementations that have already been created. "},{"title":"Root container​","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#root-container","content":"Top-level global container that contains all registered providers and global singletons that live as long as the application lives. "},{"title":"Container is a child​","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#container-is-a-child","content":"A DI instance created for each client (user who sent a request to the server) that inherits from the container root. But it allows you to create and store your own class instances. Which can contain private information about the client and at the same time, this information will not leak to other clients, for example, a link to the actual Request object. Consumer di is created and lives on while we respond to the client. As soon as we answered, consumer di is deleted and all private information is cleared. This does not require manual cleaning and deletion of the di container or its dependencies. This work is based on the fact that when responding to the client, the reference to the context and the DI container is lost. Then the GC will delete everything from memory. "},{"title":"Additional material​","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#additional-material","content":"Video explaining why DI is needed and why you should use it Part 1Part 2Release of the devshakhta which is dedicated to DI and why is it needed https://www.youtube.com/watch?v=3NgWwzwDeTQ "},{"title":"Introduction to tramvai","type":0,"sectionRef":"#","url":"docs/concepts/overview","content":"","keywords":""},{"title":"Main features​","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#main-features","content":"Modular approach - you can extend the functionality of applications using modulesUniversal - Works equally well for browsers and serverFast - lightweight, does not affect the overall performance of the application, maximizes parallelization of actions on the server "},{"title":"Approaches used​","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#approaches-used","content":" "},{"title":"Modularity​","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#modularity","content":"The architecture tramvai is based on the idea that we have all the functionality divided into various modules and all communication between the modules is based on common interfaces, interacting through DI. This architecture makes it possible to easily add new functionality to the application, and replace existing functionality. "},{"title":"Standardization​","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#standardization","content":"tramvai is a framework that allows you to maintain and create applications with the same architecture for many teams with the ability to share code between projects, as it tramvai is a lightweight layer that helps to interact different modules in the application "},{"title":"Performance​","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#performance","content":"The core tramvai together with DI weighs 4 kb, everything else is implemented through third-party modules that extend the functionality of the application. This makes it possible to make applications of the minimum size, excluding unnecessary features. The architecture and modules are designed with a concept performance first for maximum parallelization, according to best practice. "},{"title":"Universal​","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#universal","content":"tramvai it is an SSR-first framework and takes into account all the features and problems associated with the server, client and the interaction between them: All modules are developed for both the browser and the serverCommon interfaces are usedA chain of commands on the server and the browser is used which allows you to perform actions in determining the lifetime of the applicationThe action system allows you to equally request data on the server and in the browser, using various features (e.g. repetition in the browser of an action that crashed on the server) "},{"title":"Splitting into external libraries​","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#splitting-into-external-libraries","content":"When developing tramvai we try to use open source solutions, or create basic libraries that are in no way related to tramvai and can be used in other projects and frameworks. "},{"title":"DI with interface taken from Nest or Angular DI​","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#di-with-interface-taken-from-nest-or-angular-di","content":"DI is the core part of tramvai that allows you to reduce code cohesion and separation of functionality into modules. tramvai use a library @tinkoff/dippy that implements the DI container. The internal interface DI repeats the interface Nest, which allows you to conveniently describe the dependencies and implementations of classes. "},{"title":"Soft migration option​","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#soft-migration-option","content":"A million + lines of code have already been written on tinkoff.ru and the new solution should not break the existing code, and also require applications from a difficult and long transition "},{"title":"Why was it developed​","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#why-was-it-developed","content":""},{"title":"tramvai​","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#tramvai","content":"Often, React applications are a constructor from different libraries that have been included in the project. This works well on a small scale, but it does not work well for large applications with 70+ developers, since in this approach it is easy to connect your own and disperse radically in the application architecture. This problem is taken over tramvai and standardized and implemented by a common application architecture that all product teams use. There are not many open source solutions on github that implement the architecture of large applications. Alternatives​ next.js​ One of the best simple React frameworks that takes care of server-side rendering and routing. At the same time, this is a lightweight framework that does not standardize in any way and does not solve the problems with the modularity of components. Therefore, most of the code that was written on tramvai would have to be written for next.js and try to somehow implement, since in next.js the ability to extend functionality is very limited fusion.js​ A similar framework that evolved and emerged at the same time with tramvai. Fusion.js does not have a full-fledged DI, a limited ability to move functionality into modules and the entire architecture is built on the basis of middlewares, and there are difficulties around the hard-coded priorities of plugins and the lack of parallelization of actions nest.js​ An excellent backend framework that uses similar DI, but is not completely sharpened for SSR. And when using it, we had to have 2 architectures, one for the backend, the other written by ourselves for the client "},{"title":"@tinkoff/dippy​","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#tinkoffdippy","content":"Lightweight DI library with Angular-like interface. In the open source, there are not so many different DI options that allow you to separate class implementations, both basic general and specific for each client. Alternatives​ inversify​ This is the most popular library for creating DI, with: weighs 11kb, compared to dippy 1.2kba low-level API that requires different wrappers to implement a modular system.ts-nest this is an example of a wrapper over inversify that has weak support and only the wrapper contains about the same code as @tinkoff/dippy "},{"title":"state​","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#state","content":"The state management library built into tramvai is almost completely similar to the Redux interface, with few nuances: Allows you to sign components only for updating certain reducers, solving the problem with performanceThere is a lot of code written using the deprecated version of the state and you can't just switch to another solution Alternatives​ redux​ Moving to pure redux will not solve the problems, it will only add performance-related ones reatom​ Very similar to our state manager, a new library that addresses the issue of updates and performance. A good candidate to take some features from. Full transition is very expensive due to the codebase effector​ Interesting library that has a focus on the client side and is not very suitable for SSR "},{"title":"Concepts​","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#concepts","content":""},{"title":"Module​","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#module","content":"The main basic elements of the tramvai architecture that contain the implementation of functionality. At the same time, it is assumed that such modules will not be huge and a large number of different types will appear. Documentation "},{"title":"DI system​","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#di-system","content":"tramvai is built on a DI system that stores the implementation of functionality and receiving implementations for tokens and keys. This allows you to implement communications between modules based only on interfaces, while having the ability to change implementations as needed. Documentation "},{"title":"CommandLineRunner​","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#commandlinerunner","content":"Runner for a list of actions that modules can attach actions to. There are 2 types of action lists: Application initializationProcessing a request for a client Within the framework of this list of actions, routes, user status, page rendering and html return to the client are received. Documentation "},{"title":"Diagrams​","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#diagrams","content":""},{"title":"How it works on the server side​","type":1,"pageTitle":"Introduction to tramvai","url":"docs/concepts/overview#how-it-works-on-the-server-side","content":" "},{"title":"Module","type":0,"sectionRef":"#","url":"docs/concepts/module","content":"","keywords":""},{"title":"Module life cycle​","type":1,"pageTitle":"Module","url":"docs/concepts/module#module-life-cycle","content":""},{"title":"Initializing the application​","type":1,"pageTitle":"Module","url":"docs/concepts/module#initializing-the-application","content":"When creating an application, all declared providers are processed, which will fall into the general DI container. "},{"title":"Handling customer requests​","type":1,"pageTitle":"Module","url":"docs/concepts/module#handling-customer-requests","content":"The module is instantiated once on the server (and used for all clients), after initializing the application, and once in the browser, after loading the page and initializing the client side. These instances contain instances of the classes that were passed to deps and will be passed to the module's constructor: import { Module } from '@tramvai/core'; @Module({ providers: [], deps: { log: 'log', }, }) class TestModule { constructor({ log }) { log.info('TestModule created'); } } Copy "},{"title":"Example module​","type":1,"pageTitle":"Module","url":"docs/concepts/module#example-module","content":"The main functionality of the module is in the providers list. Each provider either adds new functionality, for example, makes available in all other modules the constant value New under the key Token: import { Module, provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: 'Token', useValue: 'New', }), ], }) class TestModule {} Copy Or it uses tokens from other modules, for example, adding a new environment parameter via the ENV_USED_TOKEN token, which will be processed by the EnvModule: import { Module, provide } from '@tramvai/core'; import { ENV_USED_TOKEN } from '@tramvai/module-common'; @Module({ providers: [ provide({ provide: ENV_USED_TOKEN, multi: true, useValue: [ { key: 'ENV_VARIABLE', value: 'New', optional: true, }, ], }), ], }) class TestModule {} Copy "},{"title":"Import in module third party modules​","type":1,"pageTitle":"Module","url":"docs/concepts/module#import-in-module-third-party-modules","content":"Modules can be imported internally by providers of third-party modules. Thus, allowing you to build a chain of interconnected modules. Code example import { Module } from '@tramvai/core'; import { LogModule } from '@tramvai/module-log'; @Module({ providers: [], imports: [LogModule], }) class TestModule {} Copy In this case, when initializing TestModule, the providers from the ModuleLogger module and nested imports, if present, will be initialized beforehand. "},{"title":"Dynamic modules​","type":1,"pageTitle":"Module","url":"docs/concepts/module#dynamic-modules","content":"Modules can be configured in two ways, and both methods can be used simultaneously: passing parameters to modulereturn parameters in the static method forRoot An example of a dynamic module, in which we will add dependencies metaGenerate to the DI in the first way and meta-list in the second, and one of them depends on the other: import { Module, provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: 'metaGenerate', useClass: class MetaGenerate {}, deps: { list: 'meta-list', }, }), ], }) export class SeoModule { static forRoot({ metaList }: { metaList?: string[] }) { if (metaList) { return { mainModule: SeoModule, providers: [ provide({ provide: 'meta-list', useValue: metaList, }), ], }; } } } Copy A static method must return an object with an interface: type staticModule = { mainModule: Module; // Link to the main module, from which we will extract all the basic information providers: Provider []; // Providers to be added to DI }; Copy Now this module contains a static method forRoot which adds additional providers to the standard SeoModule module. Without this construct, we would need to explicitly write providers in the application. All data that has been added to the SeoModule will be inherited and expanded. Now we can call our static method in the application or in other modules. And the result of execution of forRoot will be added to DI import { Module } from '@tramvai/core'; import { SeoModule } from './SeoModule'; import { metaFromConfig } from './metaFromConfig'; @Module({ imports: [SeoModule.forRoot([metaFromConfig])], }) export class ApplicationModule {} Copy It should be borne in mind that the forRoot construction should only simplify the use of the module and we should also maintain the functionality of the module through the usual configuration of providers "},{"title":"Recommendations for modules​","type":1,"pageTitle":"Module","url":"docs/concepts/module#recommendations-for-modules","content":""},{"title":"Low cohesion​","type":1,"pageTitle":"Module","url":"docs/concepts/module#low-cohesion","content":"It is advisable to build modules so that they do not directly depend on other modules. Coupling only needs to be interface-based and replaceable. Otherwise, it will not be possible to simply replace modules and refactor. "},{"title":"Small size​","type":1,"pageTitle":"Module","url":"docs/concepts/module#small-size","content":"The larger the module, the more code it contains inside and the more potentially it has connections and reasons for changes. For this reason, the module will be more difficult to change and there will be a greater chance of breaking functionality when changed. It is desirable that the modules implement some small part of the functionality. "},{"title":"Optional dependencies / configuration​","type":1,"pageTitle":"Module","url":"docs/concepts/module#optional-dependencies--configuration","content":"It is convenient to use the module if it does not require any configuration and works normally by default. But, if it is clear that for some applications and cases additional behavior setting will be needed, then it is advisable to use optional dependencies that can be defined in the application. It is worth marking non-critical functionality with optional dependencies, which the module does not necessarily need. So that you can not implement interfaces and throw out some of the logic. For example, logging // @todo example of optional dependency Copy "},{"title":"Debugging Modules​","type":1,"pageTitle":"Module","url":"docs/concepts/module#debugging-modules","content":"It is recommended to specify in the module documentation the unique identifier / namespace of the logger, which is used in this module. Example module id for @tramvai/module-server: const log = logger ('server'); // get a logger instance by LOGGER_TOKEN token Copy "},{"title":"Additional links​","type":1,"pageTitle":"Module","url":"docs/concepts/module#additional-links","content":"About DI containerAbout providers "},{"title":"Versioning","type":0,"sectionRef":"#","url":"docs/concepts/versioning","content":"","keywords":""},{"title":"Unified versioning​","type":1,"pageTitle":"Versioning","url":"docs/concepts/versioning#unified-versioning","content":"Most of the libraries in the tramvai repository are combined into end-to-end versioning - these are core packages, tram modules and tokens, everything that is included in the @tramvai and @tramvai-tinkoff scopes. The release and publication of these libraries occurs at the same time, even if the changes affect only one package from the list. You can see this approach in Angular, and with some restrictions, in monorepositories using Lerna The main advantage of unified versioning is that compatibility between packages of the same version is guaranteed. Previously, the user had only one way to raise the framework version without losing compatibility between packages - to install all packages to their latest version. Now, you can specify a common target version for each tramvai library, or use the tramvai update command. One of the drawbacks of this approach is that any update of a package from the unified list requires raising versions and publishing all these packages from the list, which significantly slows down CI. "},{"title":"Storing versions in release tags​","type":1,"pageTitle":"Versioning","url":"docs/concepts/versioning#storing-versions-in-release-tags","content":"One of the reasons for storing a version in release tags is the protected master branch, which we cannot automatically make changes to after the release and update of package versions. Storing versions in release tags does not in itself provide any advantage, and we use it together with stub versions of packages in the source package.json files. Let's say we had a package with dependencies: { \"name\": \"@tramvai/foo\", \"version\": \"0.1.0\", \"dependencies\": { \"@tramvai/bar\": \"^1.1.0\", \"@tramvai/baz\": \"^2.0.0\" } } Copy Previously, every big Merge Request was accompanied by conflicts if package versions were updated in the master branch, and the affected libraries in MR contained changes in dependencies. Now, our package looks like this: { \"name\": \"@tramvai/foo\", \"version\": \"0.0.0-stub\", \"dependencies\": { \"@tramvai/bar\": \"0.0.0-stub\", \"@tramvai/baz\": \"0.0.0-stub\" } } Copy The version 0.0.0-stub will never cause merge conflicts, and the calculation of real versions occurs only in CI - when creating a new release tag and publishing, inside the pvm library. "},{"title":"Contribute","type":0,"sectionRef":"#","url":"docs/contribute/","content":"Contribute Framework tramvai is in the process of incremental migration from our internal repo to open source. Migration consists of several stages: Push synchronization Сurrent stage, automatic mirroring internal releases to Github repository Pull synchronization Next stage, automatic mirroring pull requests from Github repository to our internal repo Full migration Perspective stage, moving source code, and all CI processes (testing, linting, building, publishing, versioning) to Github repository So for now contributors can open any issues and pull requests, but maintainers will need to manually transfer accepted changes to our internal repo.","keywords":""},{"title":"Provider","type":0,"sectionRef":"#","url":"docs/concepts/provider","content":"","keywords":""},{"title":"Format​","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#format","content":"type Provider = { provide: Token | string; // provider id useValue?: any; // implementation of the identifier useFactory?: any; // implementation of the identifier useClass?: any; // implementation of the identifier deps?: Record<string, Token | string>; // list of dependencies that the provider needs to work multi?: boolean; // the ability to register multiple provider implementations, if true, when receiving the value of this identifier, all registered values ​​will come in the scope array scope?: 'request' | 'singleton'; // If a singleton, then the container will register one instance of the provider for all client requests. If request will create its own instance for each client and Request }; Copy "},{"title":"Types of providers​","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#types-of-providers","content":""},{"title":"Class​","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#class","content":"When the instance is initialized, the class passed to useClass will be created, if deps were specified, then the class will be called with the object of implementations as the first argument import { provide } from '@tramvai/core'; const provider = provide({ provide: 'token', useClass: class ImplementClass { constructor({ logger }) {} }, deps: { logger: 'logger', }, }); Copy "},{"title":"Factory​","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#factory","content":"When the instance is initialized, the function passed to useFactory will be called, if deps were specified, then the function will be called with the object of implementations as the first argument import { provide } from '@tramvai/core'; const provider = provide({ provide: 'token', useFactory: ({ logger }) => new Implement(logger), deps: { logger: 'logger', }, }); Copy "},{"title":"Value​","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#value","content":"Sets the provider's value to the data that was passed in the useValue parameter, no additional initialization will be performed and deps cannot be used import { provide } from '@tramvai/core'; const provider = provide({ provide: 'token', useValue: { appName: 'APP' }, }); Copy "},{"title":"Multi providers​","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#multi-providers","content":"We may need to be able to register multiple implementations for a single token. For example, several actions for one step. To implement this, you need to pass the multi parameter to the provider. In this case, an array of providers is stored in the di container: import { provide } from '@tramvai/core'; const providers = [ provide({ provide: 'token', multi: true, useValue: { route: '/' }, }), provide({ provide: 'token', multi: true, useValue: { route: '/cards' }, }), ]; Copy "},{"title":"Dependencies (deps)​","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#dependencies-deps","content":"Needed to specify the dependencies that are needed for the provider to work. When creating a provider, dependency instances will be created, which are specified in deps and passed to the provider as the first argument. The keys of the deps object will be the implementations that will be sent to the provider. In this case, if the provider is not found in the global DI, an error will be thrown notifying that the current token was not found. "},{"title":"Format​","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#format-1","content":"type Provider = { deps: { [key: string]: | Token | { token: Token; optional?: boolean; multi?: boolean; }; }; }; Copy "},{"title":"Optional Dependencies​","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#optional-dependencies","content":"We don't always need mandatory dependencies to work. And we want to point out that the dependency is not necessary to work and it is not necessary to throw an error. To do this, you can pass the optional parameter, which will disable throwing an error if there is no dependency. Instead of implementing the dependency, the provider will receive the value null. import { provide } from '@tramvai/core'; const provider = provide({ provide: 'token', useClass: class A { constructor({ log }) {} }, deps: { log: { token: 'log', optional: true, }, } as const, }); Copy "},{"title":"Multi dependencies​","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#multi-dependencies","content":"Some providers are multi-providers and instead of one implementation, we will receive an array of implementations. For correct type inference, we must pass the multi: true parameter, apply as const for the deps block for correct type inference via TS: import { provide } from '@tramvai/core'; const provider = provide({ provide: 'token', useClass: class A { constructor({ commands }) { commands.forEach(); } }, deps: { commands: { token: 'commands', multi: true, }, } as const, }); Copy "},{"title":"Circular dependency​","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#circular-dependency","content":"DI does not allow declaring dependencies that depend on each other, for example: import { provide } from '@tramvai/core'; const providers = [ provide({ provide: 'A', deps: { B: 'B', }, }), provide({ provide: 'B', deps: { A: 'A', }, }), ]; Copy In this example, we will not be able to correctly create provider instances and the code will throw an error. Such providers should reconsider and make a common part in a separate class, and provider and used in conjunction A and B "},{"title":"Scope​","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#scope","content":"option only affects the operation of the container on the server, only one common container running on the client, in which service providers with a different crowd kept together Allows you to create singleton instances that will be shared between multiple clients. In standard behavior, each declared provider will be automatically deleted and recreated for each new client. This functionality was made in order for us to be able to store both singletons, for example, cache, and various personalized data. For example, user status and personalization. By default, all providers have the value Scope.REQUEST, which means that provider values ​​will be generated for each client. The exception is the useValue providers, which behave like a singleton. "},{"title":"Interface​","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#interface","content":"import { provide } from '@tramvai/core'; const provider = provide({ provide: 'Cache', useFactory: Cache, scope: Scope.SINGLETON, }); Copy In this case, the Cache provider will be registered as a global singleton, since the scope parameter was passed and a single instance for all users will be used. "},{"title":"Tokens​","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#tokens","content":"Tokens are used as an identifier for the provider in DI. By the value of the token, the provider is registered and the implementation is searched. "},{"title":"Interface​","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#interface-1","content":"type token = Token | string; Copy A token can be either a string or a specially created using the createToken function into which an interface can be passed. In this case, you can use both a string and createToken at the same time, the main thing is that the identifier is the same "},{"title":"createToken​","type":1,"pageTitle":"Provider","url":"docs/concepts/provider#createtoken","content":"import { createToken } from '@tinkoff/dippy'; import { provide } from '@tramvai/core'; const loggerToken = createToken<Logger>('logger'); const provider = provide({ provide: loggerToken, useClass: Logger, }); Copy The main difference is that you can pass an implementation interface to createToken, which will then be used for type checking when getting dependencies and creating providers. "},{"title":"Child App","type":0,"sectionRef":"#","url":"docs/features/child-app","content":"","keywords":""},{"title":"Features​","type":1,"pageTitle":"Child App","url":"docs/features/child-app#features","content":"Child app can be developed independently from main apps in another repoHigh integration with DI, including isolated di-container and child-root communicationChild app is isolated from root app and can only communicate with root app through special channels (mainly through di) "},{"title":"Automatic migrations","type":0,"sectionRef":"#","url":"docs/features/migration","content":"","keywords":""},{"title":"Why migrations are needed​","type":1,"pageTitle":"Automatic migrations","url":"docs/features/migration#why-migrations-are-needed","content":"Sometimes in the tram there is a need to make some kind of breaking changes and to simplify such a transition for end users, automatic migrations are used. Migrations allow you to transfer the application codebase to a new version of the interfaces in an automatic mode and practically without the participation of developers. "},{"title":"How to use migrations​","type":1,"pageTitle":"Automatic migrations","url":"docs/features/migration#how-to-use-migrations","content":"Migrations are performed automatically when new versions of tram packages are installed. The file .tramvai-migrate-applied.json in the root of the project is used to save information about migrations that have already been performed. All that remains for application developers to do is: study the doc on latest migrations for packagescommit changes in the file .tramvai-migrate-applied.json, because it saves information about completed migrations and it is better to save it so as not to perform migrations againif after migrations package.json has changed, then you need to install packages to update the lock file in the project.review and commit all other changes that have occurred in the project (review is necessary because it is difficult to take into account all use cases in the migration, and also the result after the code transformation may not correspond to the linter settings in the current project).check the application for problems and make changes in accordance with the migration dock "},{"title":"How to disable migrations​","type":1,"pageTitle":"Automatic migrations","url":"docs/features/migration#how-to-disable-migrations","content":"Add environment variable SKIP_TRAMVAI_MIGRATIONS before starting package installation. "},{"title":"How migrations work​","type":1,"pageTitle":"Automatic migrations","url":"docs/features/migration#how-migrations-work","content":"1.@tramvai/core contains the dependency @tramvai/tools-migrate1.@tramvai/tools-migrate contains a script that runs on 'postinstall' 1.script analyzes tramvai modules in 'node_modules' and find all migrations 1.further the file .tramvai-migrate-applied.json is checked and a list of already selected migrations is taken from it if such a file exists 1.The code of migrations that are not in the list of completed ones is executed. Migrations are performed sequentially 1.in the file .tramvai-migrate-applied.json is added information about the migrations just performed, if the file was before, or this file is created "},{"title":"Q/A​","type":1,"pageTitle":"Automatic migrations","url":"docs/features/migration#qa","content":""},{"title":"Do I need to store .tramvai-migrate-applied.json in VCS?​","type":1,"pageTitle":"Automatic migrations","url":"docs/features/migration#do-i-need-to-store-tramvai-migrate-appliedjson-in-vcs","content":"Yes, otherwise, during the next migrations, we will not know which migrations have already been performed and repeated migrations will be performed "},{"title":"Papi introduction","type":0,"sectionRef":"#","url":"docs/features/papi/introduction","content":"","keywords":""},{"title":"Explanation​","type":1,"pageTitle":"Papi introduction","url":"docs/features/papi/introduction#explanation","content":"Often, an application needs microservices that can process user requests and return JSON responses. It is to address these cases that PAPIs were developed. PAPi allows you to implement request handlers that clients can request and receive a response in an arbitrary format, for example, JSON. PAPI allows you to quickly and cheaply implement handlers without raising additional microservices. Papi related sections How to get data from papiHow can I get data from DI in papi routesHow to add a new papi route in the application "},{"title":"How to​","type":1,"pageTitle":"Papi introduction","url":"docs/features/papi/introduction#how-to","content":""},{"title":"How to get data from papi​","type":1,"pageTitle":"Papi introduction","url":"docs/features/papi/introduction#how-to-get-data-from-papi","content":"papi is available at /${appInfo.appName}/papi. This url was chosen because it would divide many different papi services into 1 application domain. For the example above with adding a route, the resulting url will look like this: /${appInfo.appName}/papi/test where appName is the name passed to createApp To make a request, you need to use PAPI_SERVICE from the module @tramvai/module-http-client, which automatically on the client will make an http request to papi and on the server will simply call the handler function "},{"title":"How can I get data from DI in papi routes​","type":1,"pageTitle":"Papi introduction","url":"docs/features/papi/introduction#how-can-i-get-data-from-di-in-papi-routes","content":"For the papi handler, it is possible to set the dependencies that it needs to work. Thus for each call a separate child di-container will be created, which will allow using both SIGNLETON and REQUEST dependencies. import { Module, provide } from '@tramvai/core'; import { CREATE_CACHE_TOKEN } from '@tramvai/module-common'; import { HTTP_CLIENT } from '@tramvai/module-http-client'; import { SERVER_MODULE_PAPI_PUBLIC_ROUTE } from '@tramvai/module-server'; import { createPapiMethod } from '@tramvai/papi'; @Module({ providers: [ provide({ provide: SERVER_MODULE_PAPI_PUBLIC_ROUTE, multi: true, useFactory: ({ createCache }) => { const cache = createCache(); // cache must be common for all handler calls, so we call it outside of createPapiMethod return createPapiMethod({ path: '/my/papi', method: 'post', async handler({ httpClient }) { // use what was requested in deps from createPapiMethod if (cache.has('test')) { return 'test'; } const { payload } = await httpClient.get('fake'); return payload; }, deps: { httpClient: HTTP_CLIENT, // the same dependency must be recreated for each call and they must be independent }, }); }, deps: { createCache: CREATE_CACHE_TOKEN, // this is a dependency from the root container, which will be created only once }, }), ], }) export class PapiTestModule {} Copy "},{"title":"How to add a new papi route in the application​","type":1,"pageTitle":"Papi introduction","url":"docs/features/papi/introduction#how-to-add-a-new-papi-route-in-the-application","content":"There are two ways to define routes. 1 - based on the file structure, 2 - task through providers Using the file api approach​ The easiest way to create a PAPI route is to create a directory papi in the root of the project in which to put TS files with handlers. The name of the files will be the URL to the route. For example: we want to create a new papi handler that reads the body of the requests and summarizes the received values. To do this, create a file /papi/getSum.ts with the content:  содержимое getSum.ts import { Request, Response } from '@tramvai/papi'; import { CREATE_CACHE_TOKEN } from '@tramvai/module-common'; // в tramvai.json мы добавили указание на директорию с файловым апи // \"commands\": { // \"build\": { // \"options\": { // \"server\": \"server-add-file-api/index.ts\", // \"serverApiDir\": \"server-add-file-api/papi\" // } // } // } // и теперь каждый файл в этой директории будет обработчиком какого-то урла в зависимости от имени самого файла // /${appName}/papi/${fileName} т.е. для текушего файла урл будет /server/papi/getSum // экспортируя переменную rootDeps мы можем запросить зависимости из рутового DI на сервере // эти записимости будут переданы в handler третьим параметром export const rootDeps = { createCache: CREATE_CACHE_TOKEN, }; // если зависимости при этом надо как-то изначально проиницилизировать, то можно использовать // mapDeps который будет вызван один раз, получит в качестве аргумента зависимости из deps, и // результат этой функции будет использован вместо третьего аргумента в handler export const mapRootDeps = ({ createCache }: typeof rootDeps) => { return { cache: createCache('memory'), }; }; // handler это наш обработчик который будет вызываться на каждый запрос // тоже самое будет если сделать export default export const handler = (req: Request, res: Response, { cache }: ReturnType<typeof mapRootDeps>) => { const { body: { a, b }, method, } = req; if (method !== 'POST') { throw new Error('only post methods'); } if (!a || !b) { return { error: true, message: 'body parameters a and b should be set', }; } const key = `${a},${b}`; if (cache.has(key)) { return { error: false, fromCache: true, result: cache.get(key) }; } const result = +a + +b; cache.set(key, result); return { error: false, fromCache: false, result }; }; Copy  This file can be requested using the client papi, or by calling the url /${appName}/papi/getSum Using providers​ It is necessary to add a multi provider SERVER_MODULE_PAPI_PUBLIC_ROUTE in which to add new papi routes import { createPapiMethod } from '@tramvai/papi'; import { SERVER_MODULE_PAPI_PUBLIC_ROUTE } from '@tramvai/tokens-server'; import { provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: SERVER_MODULE_PAPI_PUBLIC_ROUTE, multi: true, useValue: createPapiMethod ({ method: 'get', // method, can be post, all and so on path: '/test', // path where the route will be available async handler(req, res): Promise<any> { // function that will be called if requests for url come return new Promise({ test: true }); }, }), }), ], }) export class PapiTestModule {} Copy And after that the test route will be available "},{"title":"File-System Pages","type":0,"sectionRef":"#","url":"docs/features/file-system-pages","content":"","keywords":""},{"title":"Explanation​","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#explanation","content":""},{"title":"Motivation​","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#motivation","content":"By default, you need to provide page components with bundles, then register this components for the corresponding routes, for example: Create bundle with component (used lazy for granular code splitting): const commentsBundle = createBundle({ name: 'comments', components: { 'comments-list': lazy(() => import('./pages/CommentsList')), }, }); Copy Create static route with this bundle and component: const routes = [ { name: 'comments', path: '/comments/', config: { bundle: 'comments', pageComponent: 'comments-list', }, }, ]; Copy File-System Pages is designed to remove the first step, or even both steps, and make it easier to add new pages to the application. "},{"title":"File-System Pages​","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#file-system-pages","content":"The first option is to automatically read page components from the file system and register them inside an application, without need to specify bundle. You can use this components by unique name in route.config.pageComponent property, and the component to be rendered for that route will be automatically wrapped in lazy. Thus, all routes with file-system pages will load only neccesary JS and CSS chunks. For example, you create page components with this file structure: src └── pages ├── index.tsx └── comments.tsx Copy This components will be available in the application with these names: @/pages/index @/pages/comments Copy and you can create few static pages from them: const routes = [ { name: 'main', path: '/', config: { pageComponent: '@/pages/index', }, }, { name: 'comments', path: '/comments/', config: { pageComponent: '@/pages/comments', }, }, ]; Copy Example application "},{"title":"File-System Routing​","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#file-system-routing","content":"Second option is less flexible, but fully automates the creation of routes in the application. Static routes will be generated from file-system pages, and paths for this routes will be created based on paths to components, strictly conforming to naming conventions. For example, you want to handle this urls by your application: / /login/ /comments/ /comments/:id/ Copy In that case you need to create components with this file structure: src └── pages ├── index.tsx ├── login └── index.tsx └── comments ├── index.tsx └── [id] └── index.tsx Copy Where path with square brackets relates to dynamic parts of url. File for /login/ page must be named login/index.tsx instead of login.tsx, because we must have strictly one way to convert url back to page component name. Example application "},{"title":"Usage​","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#usage","content":"Experimental feature File-System Pages hidden behind the flag commands.build.configurations.experiments.fileSystemPages.enable in tramvai.json configuration file: { \"projects\": { \"your-app-name\" : { \"commands\": { \"build\": { \"configurations\": { \"experiments\": { \"fileSystemPages\": { \"enable\": true, \"pagesDir\": \"pages\", \"routesDir\": \"routes\" } } } } } } } } Copy \"enable\": true - activates the feature \"pagesDir\": \"pages\" - default directory for File-System Pages \"routesDir\": \"routes\" - default directory for File-System Routing "},{"title":"Pages​","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#pages","content":"You need to use default export in page components, e.g.: const CommentsPage = () => <h1>Comments</h1>; export default CommentsPage; Copy "},{"title":"Actions​","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#actions","content":"Page components support global actions in actions static property, these actions will work as bundles actions: const CommentsPage = () => <h1>Comments</h1>; CommentsPage.actions = [fetchCommentsListAction]; export default CommentsPage; Copy This actions will be code-splitted with page component code. "},{"title":"Reducers​","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#reducers","content":"Page components support reducers in reducers static property, these reducers will be registered in application store: const CommentsPage = () => <h1>Comments</h1>; CommentsPage.reducers = [CommentsStore]; export default CommentsPage; Copy This reducers will be code-splitted with page component code. "},{"title":"Components​","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#components","content":"Page components support additional React components in components static property, this components will be registered in the application: const CommentsPage = () => <h1>Comments</h1>; CommentsPage.components = { 'modal-box': () => <dialog>Modal Box</dialog>, }; export default CommentsPage; Copy This components will be code-splitted with page component code. You can directly access these components with PAGE_SERVICE: import { useDi } from '@tramvai/react'; import { PAGE_SERVICE } from '@tramvai/tokens-router'; const CommentsPage = () => { const pageService = useDi(PAGE_SERVICE); const ModalBox = pageService.getComponent('modal-box'); return ( <> <h1>Comments</h1> <ModalBox /> </> ) } Copy "},{"title":"How to​","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#how-to","content":""},{"title":"How to change layout component​","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#how-to-change-layout-component","content":"When use File-System Pages, at first, add layout component to page components: const CommentsPage = () => <h1>Comments</h1>; CommentsPage.components = { 'comments-layout': CommentsLayout, }; export default CommentsPage; Copy then, add this layout to layoutComponent property of appropriate route: const routes = [ { name: 'comments', path: '/comments/', config: { pageComponent: '@/pages/comments', layoutComponent: 'comments-layout', }, }, ]; Copy When use File-System Routing, at this moment you can't change the page layout. "},{"title":"How to create static route with dynamic parameters​","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#how-to-create-static-route-with-dynamic-parameters","content":"File-System Routing example Wrap dynamic part of url in square brackets in file path. For /comments/:id/ create page component with this path pages/comments/[id]/index.tsx: src └── pages └── comments └── [id] └── index.tsx Copy Dynamic parameter available in current route params. In react components, use useRoute hook: import { useRoute } from '@tramvai/module-router'; const Comment = () => { const route = useRoute(); return ( <li> Current comment id: {route.params.id} </li> ); } Copy In actions, use PAGE_SERVICE_TOKEN: import { createAction } from '@tramvai/core'; const someAction = createAction({ name: 'someAction', fn: (_, __, { pageService }) => { const route = pageService.getCurrentRoute(); console.log(`Current comment id: ${route.params.id}`); }, deps: { pageService: PAGE_SERVICE_TOKEN, }, }); Copy "},{"title":"Migration​","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#migration","content":"If you want to migrate from bundles to file-system pages, there is few steps: Enable experiments.fileSystemPages.enable option in tramvai.json, and change default folders for safety: { \"fileSystemPages\": { \"enable\": true, \"pagesDir\": \"new-fs-pages\", // file-system pages directory \"routesDir\": false // force disable file-system routing } } Copy Split your bundles to components from this bundle src/bundles/someBundle.ts: import { createBundle } from '@tramvai/core'; import { lazy } from '@tramvai/react'; import { actionFoo, actionBar } from '../actions'; import { StoreFoo, StoreBar } from '../reducers'; import { CommonComponent } from '../components'; const someBundle = createBundle({ name: 'someBundle', components: { 'pages/foo-page': lazy(() => import('../pages/Foo')), 'pages/bar-page': lazy(() => import('../pages/Bar')), 'components/common': CommonComponent, }, actions: [actionFoo, actionBar], reducers: [StoreFoo, StoreBar], }); export default someBundle; Copy you need to create two page components, src/new-fs-pages/foo.tsx and src/new-fs-pages/bar.tsx, with this content: import { lazy } from '@tramvai/react'; import { actionFoo, actionBar } from '../actions'; import { StoreFoo, StoreBar } from '../reducers'; import { CommonComponent } from '../components'; // the same for src/new-fs-pages/bar.tsx const FooPage = () => { return <h1>Foo Page</h1>; } FooPage.components = { 'components/common': CommonComponent, }; FooPage.actions = [actionFoo, actionBar]; FooPage.reducers = [StoreFoo, StoreBar]; export default FooPage; Copy then update your routes config from: const routes = [ { name: 'foo', path: '/foo/', config: { bundle: 'sameBundle', pageComponent: 'pages/foo-page', }, }, { name: 'bar', path: '/bar/', config: { bundle: 'sameBundle', pageComponent: 'pages/bar-page', }, }, ] Copy to this: const routes = [ { name: 'foo', path: '/foo/', config: { pageComponent: '@/new-fs-pages/foo', }, }, { name: 'bar', path: '/bar/', config: { pageComponent: '@/new-fs-pages/bar', }, }, ] Copy and remove bundle property from createApp "},{"title":"Working with React","type":0,"sectionRef":"#","url":"docs/features/react","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"Working with React","url":"docs/features/react#install","content":"npm i --save @tramvai/react Copy "},{"title":"DI​","type":1,"pageTitle":"Working with React","url":"docs/features/react#di","content":"When creating components, you may need to get data from di, for this there is a hook useDi and HoC withDi "},{"title":"useDi​","type":1,"pageTitle":"Working with React","url":"docs/features/react#usedi","content":"type useDi = (deps: Record<string, string | Token>) => Record<string, any>; Copy type useDi = (dep: string | Token) => any; Copy A hook into which we can pass both an object with the required dependencies and an object with data will be returned to us, as well as a single token, where the result will be returned to us. When we call useDi, we get data from di and if we don't find data in di, an error will occur. import React from 'react'; import { useDi } from '@tramvai/react'; const MyComponent = () => { const { logger } = useDi({ logger: 'logger' }); // pass the object const Region = useDi(regionToken); // pass a single token logger.info('text'); return ( <div> Component <Region /> </div> ); }; Copy "},{"title":"withDi​","type":1,"pageTitle":"Working with React","url":"docs/features/react#withdi","content":"type withDi = ( deps: Record<string, string | Token> ) => (wrapper: React.ReactElement<any>) => React.ReactElement<any>; Copy A HoC that allows you to wrap any components, get data from DI and pass the result with dependencies to the props of the component import React from 'react'; import { withDi } from '@tramvai/react'; @withDi({ logger: LOGGER_TOKEN }) class BoxyPage extends Component { render() { this.props.logger.info('text'); return <div>Component</div>; } } Copy "},{"title":"useDiContainer​","type":1,"pageTitle":"Working with React","url":"docs/features/react#usedicontainer","content":"type useDiContainer = () => DI.Container; Copy Getting an instance of a DI container that has been added to the application context. It is better not to use this hook, as it is very low-level and is intended for developing new hooks "},{"title":"Error​","type":1,"pageTitle":"Working with React","url":"docs/features/react#error","content":"To handle errors during rendering, React uses Error Boundary. This package provides its own version of Error Boundary which will log an error through a generic logger and display a stub for the wrapped component if an error occurs. "},{"title":"ErrorBoundary​","type":1,"pageTitle":"Working with React","url":"docs/features/react#errorboundary","content":"Error Boundary component that monitors errors down the tree and, in case of a render error, will log an error and display the fallbackComponent component (passed as a props, by default it is a FallbackError from this package) instead of the fallen render subtree. You can override the fallbackComponent through the ERROR_BOUNDARY_FALLBACK_COMPONENT_TOKEN provider. "},{"title":"FallbackError​","type":1,"pageTitle":"Working with React","url":"docs/features/react#fallbackerror","content":"Component used by default as a stub for a subtree in which a render error occurred "},{"title":"withError​","type":1,"pageTitle":"Working with React","url":"docs/features/react#witherror","content":"Hook wrapping component in ErrorBoundary. "},{"title":"lazy​","type":1,"pageTitle":"Working with React","url":"docs/features/react#lazy","content":"To dynamically import components with SSR support, there is a high order lazy component: import { lazy } from '@tramvai/react'; const LazyComponent = lazy(() => import('./components/foo'), { loading: <div>Загрузка...</div>, }); <LazyComponent />; Copy "},{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/features/routing","content":"","keywords":""},{"title":"Base modules​","type":1,"pageTitle":"Introduction","url":"docs/features/routing#base-modules","content":"NoSpaRouterModule - creates a router instance, initializes a router for routing and synchronizes it with a router, registers actions, bundles, validators, redirects and other features to the corresponding router hooks.SpaRouterModule - same as previous plus switches the router to use the History API on the client. "},{"title":"Additional features​","type":1,"pageTitle":"Introduction","url":"docs/features/routing#additional-features","content":"File-System Pages - file-based routing with strict naming conventionsStatic HTML Export - static HTML pages creation at build time "},{"title":"Create event","type":0,"sectionRef":"#","url":"docs/features/state/create-event","content":"","keywords":""},{"title":"Method Description​","type":1,"pageTitle":"Create event","url":"docs/features/state/create-event#method-description","content":"createEvent(eventName: string, payloadCreator?: PayloadTransformer): EventCreator eventName - Unique identifier of the eventpayloadCreator - an optional function that allows you to combine multiple arguments into one, In cases where the event was called with multiple arguments. "},{"title":"Examples​","type":1,"pageTitle":"Create event","url":"docs/features/state/create-event#examples","content":"Creating an event without parameters​ import { createEvent } from '@tramvai/state'; const userLoadingInformation = createEvent('user loading information'); userLoadingInformation(); Copy Creating an event with parameters​ import { createEvent } from '@tramvai/state'; const userInformation = createEvent<{ age: number; name: string }>('user information'); userInformation({ age: 42, name: 'Tom' }); Copy Create event with payload conversion​ import { createEvent } from '@tramvai/state'; const itemPrice = createEvent('user information', (info: string, price: number) => ({ [info]: price, })); itemPrice('car', 3000); Copy Using Events in Actions​ We create an action in which, after loading the information, we create an event and throw it into context.dispatch import { createAction } from '@tramvai/core'; import { createEvent } from '@tramvai/state'; const userInformation = createEvent < { age: number, name: string } > 'user information'; const action = createAction({ name: 'userLoadInformation', fn: async (context) => { const result = await tinkoffRequest({ method: 'information' }); context.dispatch(userInformation(result)); }, }); Copy "},{"title":"API","type":0,"sectionRef":"#","url":"docs/features/react-query/api","content":"","keywords":""},{"title":"Explanation​","type":1,"pageTitle":"API","url":"docs/features/react-query/api#explanation","content":"For the library to work, the module @tramvai/module-react-query must be added to the tramvai application "},{"title":"Api​","type":1,"pageTitle":"API","url":"docs/features/react-query/api#api","content":""},{"title":"Query​","type":1,"pageTitle":"API","url":"docs/features/react-query/api#query","content":"A wrapper around react-query options with tramvai integration. fork​ Create new Query from an existing query with option to override settings. import { createQuery } from '@tramvai/react-query'; const query = createQuery(); const newQuery = query.fork({ refetchInterval: 2000, refetchIntervalInBackground: false, }); Copy prefetchAction​ Return a tramvai action that can be used to prefetch current query export default function PageComponent() { const { data, isLoading } = useQuery(query); return <div>{isLoading ? 'loading...' : data}</div>; } Component.actions = [query.prefetchAction()]; Copy fetchAction​ Return a tramvai action that can be used to fetch current query const action = createAction({ name: 'action', fn: async (context) => { const result = await context.executeAction(query.fetchAction()); console.log('__action__', result); }, }); Copy raw​ Might be used when the raw query options is needed. The result can be passed to the underlying methods of react-query lib in cases when @tramvai/react-query doesn't provide appropriate wrapper. This method is used internally in the lib to redirect calls to react-query. "},{"title":"createQuery​","type":1,"pageTitle":"API","url":"docs/features/react-query/api#createquery","content":"Allows you to create a Query object that can later be used in components using useQuery. Used to execute single data retrieval requests. import { createQuery } from '@tramvai/react-query'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get('api/base'); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, }, }); Copy Unique query parameters​ To create a generic query that takes parameters for a query, you must return a unique key, you can read more about this in the official documentation section Query Keys As a parameter key you can use: a string, such as key: 'query-name'an array where any serializable data can be used as elements, for example key: ['query-name', false, { bar: 'baz }]a function that takes the parameters with which query is called and returns a string - key: (options) => 'query-name'a function that accepts parameters, with which query is called, and returns an array, where any serializable data can be used as elements - key: (options) => ['query-name', options, { bar: 'baz' }] import { createQuery, useQuery } from '@tramvai/react-query'; const query = createQuery({ key: (id: number) => ['user', id], fn: async (id, { apiClient }) => { const { payload } = await apiClient.get(`api/user/${id}`); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, }, }); export function Component({ id }) { const { data, isLoading } = useQuery(query, id); return <div>{isLoading ? 'loading...' : data}</div>; } Copy "},{"title":"useQuery​","type":1,"pageTitle":"API","url":"docs/features/react-query/api#usequery","content":"React hook for working with Query object react-query docs import { useQuery } from '@tramvai/react-query'; export function Component() { const { data, isLoading } = useQuery(query); return <div>{isLoading ? 'loading...' : data}</div>; } Copy "},{"title":"useQueries​","type":1,"pageTitle":"API","url":"docs/features/react-query/api#usequeries","content":"React Hook for working with the list of Query objects react-query docs import { useQueries } from '@tramvai/react-query'; export function Component() { const [ { data: data1, isLoading: isLoading1 }, { data: data2, isLoading: isLoading2 }, ] = useQueries([query1, query2]); return ( <div> <div>{isLoading1 ? 'loading1...' : data1}</div> <div>{isLoading2 ? 'loading2...' : data2}</div> </div> ); } Copy "},{"title":"createInfiniteQuery​","type":1,"pageTitle":"API","url":"docs/features/react-query/api#createinfinitequery","content":"Creates an InfiniteQuery object that can later be used in components using useInfiniteQuery. It is used to execute queries to obtain a sequence of data that can be loaded as the component runs. import { createInfiniteQuery } from '@tramvai/react-query'; const query = createInfiniteQuery({ key: 'list', fn: async (_, start = 0, { apiClient }) => { const { payload } = await apiClient.get<Response>('api/list', { query: { count: 30, start, }, }); return payload; }, getNextPageParam: (page: Response) => { return page.nextPage; }, deps: { apiClient: TINKOFF_API_SERVICE, }, }); Copy "},{"title":"useInfiniteQuery​","type":1,"pageTitle":"API","url":"docs/features/react-query/api#useinfinitequery","content":"React hook for working with the InfiniteQuery object react-query docs import { useInfiniteQuery } from '@tramvai/react-query'; export function Component() { const { data, isLoading, fetchNextPage, hasNextPage } = useInfiniteQuery(query); if (isLoading) { return 'loading...'; } return ( <div> <div> {data.pages.map((page) => { return page.list.map((entry) => { return <div key={entry}>{entry}</div>; }); })} </div> {hasNextPage && ( <button type=\"button\" onClick={() => fetchNextPage()}> Load more </button> )} </div> ); } Copy "},{"title":"createMutation​","type":1,"pageTitle":"API","url":"docs/features/react-query/api#createmutation","content":"Creates a Mutation object that can later be used in components using useMutation. Used to send and modify data in the api. import { createMutation } from '@tramvai/react-query'; const mutation = createMutation({ key: 'post', fn: async (_, data: string, { apiClient }) => { const { payload } = await apiClient.post('api/post', { body: { data, }, }); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, }, }); Copy "},{"title":"useMutation​","type":1,"pageTitle":"API","url":"docs/features/react-query/api#usemutation","content":"React hook for working with the Mutation object react-query docs import { useMutation } from '@tramvai/react-query'; export function Component() { const { isLoading, mutate } = useMutation(mutation); if (isLoading) { return 'loading...'; } return ( <button type=\"button\" onClick={() => mutate('test')}> Send data </button> ); } Copy "},{"title":"How-to​","type":1,"pageTitle":"API","url":"docs/features/react-query/api#how-to","content":"Examples of using @tramvai/react-query "},{"title":"Use react-query directly​","type":1,"pageTitle":"API","url":"docs/features/react-query/api#use-react-query-directly","content":"Prefer to use methods from the @tramvai/react-query as it is can work both with the Query wrapper and the query options to react-query itself ::: You can get QueryClient from di by token QUERY_CLIENT_TOKEN or using method useQueryClient in React-components. To convert wrapped Query object to object acceptable by react-query use method raw of the Query instance. "},{"title":"Create reducer","type":0,"sectionRef":"#","url":"docs/features/state/create-reducer","content":"","keywords":""},{"title":"Method Description​","type":1,"pageTitle":"Create reducer","url":"docs/features/state/create-reducer#method-description","content":"createReducer(name, initialState) name - unique name of the reducer. Should not overlap with other reducersinitialState - default reducer state "},{"title":"Typing​","type":1,"pageTitle":"Create reducer","url":"docs/features/state/create-reducer#typing","content":"By default, the reducer state type and name are displayed automatically: import { createReducer } from '@tramvai/state'; const userReducer = createReducer('user', { name: 'anonymus' }); Copy Why do we need typing for the name of the reducer at all? Then this reducer will be more convenient to use together with useSelector. If you pass the state type manually, it is desirable to specify the name as the second argument of the generic: import { createReducer } from '@tramvai/state'; type UserState = { name: string }; const userReducer = createReducer<UserState, 'user'>('user', { name: 'anonymus' }); Copy But, you can simply set the desired type for initialState: import { createReducer } from '@tramvai/state'; type UserState = { name?: string }; const userReducer = createReducer('user', {} as UserState); Copy "},{"title":"Subscription to events​","type":1,"pageTitle":"Create reducer","url":"docs/features/state/create-reducer#subscription-to-events","content":".on(evnet, reducer) When creating a reducer, the .on method becomes available, which allows you to subscribe to events and return a new state event - an event or a string to which the reducer will be subscribedreducer(state, payload) - a pure function that takes the current state, payload from the event and must return the new state of the reducer An example of using the .on method import { createReducer, createEvent } from '@tramvai/state'; export const userLoadInformation = createEvent < { status: string } > 'user load information'; export const userAddInformation = createEvent < { name: string, info: {} } > 'user add information'; const userReducer = createReducer('user', { info: {}, }) .on(userLoadInformation, (state, info) => ({ info })) .on(userAddInformation, (state, { name, info }) => ({ ...state, state: { ...state.info, [name]: info, }, })); Copy "},{"title":"Automatic creation of events​","type":1,"pageTitle":"Create reducer","url":"docs/features/state/create-reducer#automatic-creation-of-events","content":".createEvents(model) method that removes the need to create and explicitly bind events model - an object in which the key is the event identifier, which will then be passed to createEvent, and the value is the reducer function, which will get into the .on() method and will be called when the events are triggered An example of using the .createEvents method import { createReducer } from '@tramvai/state'; const userReducer = createReducer('user', { info: {}, }); export const { userLoadInformation, userAddInformation } = userReducer.createEvents({ userLoadInformation: (state, info: { status: string }) => ({ info }), userAddInformation: (state, { name, info }: { name: string; info: {} }) => ({ ...state, state: { ...state.info, [name]: info, }, }), }); Copy It is imperative to describe the types of the payload argument in reducers, otherwise type inference for events will not work. "},{"title":"DevTools","type":0,"sectionRef":"#","url":"docs/features/state/dev-tools","content":"","keywords":""},{"title":"Possible problems​","type":1,"pageTitle":"DevTools","url":"docs/features/state/dev-tools#possible-problems","content":"For a better user experience, you need to use a separate redux dev tools extension window, not a tab in chrome developer tools, because otherwise the action history is not saved, see issue. "},{"title":"Performance​","type":1,"pageTitle":"DevTools","url":"docs/features/state/dev-tools#performance","content":"Since the entire state of the application with all the actions is quite large, there are noticeable brakes when working with devtools when using jumps over states/events and when a large number of actions are triggered simultaneously. That's why: Use customization techniques to set pickState to reduce the size of data in devtools.Increase the value of the latency parameter (passed to connectViaExtension.connect), which essentially debounces sending actions to the extension, see docs "},{"title":"Additional links​","type":1,"pageTitle":"DevTools","url":"docs/features/state/dev-tools#additional-links","content":"Devtools repositoryGetting Started with Redux DevTools Extension  "},{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/features/state/overview","content":"","keywords":""},{"title":"Peculiarities​","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#peculiarities","content":"Redux-like state managerBuilt-in library similar to redux-act to reduce boilerplate codeContains bindings to react components such as connect and useSelectorDynamic initialization of reducers. You can register a reducer at any time or generate a new one.Point subscriptions to changes in the states of reducers. When data changes, only the affected connect and useSelector are recalculated, not everything.Support for SSR mode. "},{"title":"Basic concepts​","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#basic-concepts","content":"Store - A class that contains the state of all reducers, change subscriptions and is created for each clientReducers - entities in which we describe how data will be stored and transformedEvents - events with which you can change the states of reducersActions - functions that allow you to perform side effects and update data in the store. Similar to redux-thunk "},{"title":"Recommendations​","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#recommendations","content":"You cannot mutate data in reducers. Otherwise, due to various optimizations, subscribers will not be notified about the changes.Initialize reducers as early as possible and before using it. Otherwise, when calling dispatch(userLoadInformation()), the reducer will not yet track events and will not receive data.Do not store static data in stores. Since this data will be transferred from the server to the client, the data will be duplicated. Better to put in constants.Break into small reducers. Otherwise, we have a huge reducer that contains a large amount of information and any changes will cause recalculations for a large number of components. "},{"title":"Installation​","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#installation","content":"npm i --save @tramvai/state Copy "},{"title":"Explanation​","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#explanation","content":""},{"title":"schedule​","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#schedule","content":"Some of the functions that deals with state (e.g. connect, useStoreSelector) will use some sort of batching (using requestAnimationFrame or SetTimeout) in browser. So any updates to state are not synchronous and happens after some time. Most of the time this is not an issue or noticeable thing. But in tests that might be unexpected. In order to take into account scheduling while testing use waitRaf helper or act from test-unit "},{"title":"How to​","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#how-to","content":""},{"title":"Basic example​","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#basic-example","content":"import { createReducer, createEvent } from '@tramvai/state'; export const userLoadInformation = createEvent('user load information'); export const userAddInformation = createEvent('user add information'); const userReducer = createReducer('user', { info: {}, }) .on(userLoadInformation, (state, info) => ({ info })) .on(userAddInformation, (state, { name, info }) => ({ ...state, state: { ...state.info, [name]: info, }, })); Copy "},{"title":"React hooks","type":0,"sectionRef":"#","url":"docs/features/state/hooks","content":"","keywords":""},{"title":"useActions​","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#useactions","content":"Allows to execute tram actions in React components "},{"title":"Interface​","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#interface","content":"actions - one or an array of tram actions If you pass an array to useActions, for typing you need to specify as const - useActions([] as const) "},{"title":"Usage​","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#usage","content":"import { useActions } from '@tramvai/state'; import { loadUserAction, getInformationAction, setInformationAction } from './actions'; export const Component = () => { // if you pass one action, the payload type for loadUser is automatically deduced const loadUser = useActions(loadUserAction); // if you pass a list of actions, `as const` is required for correct type inference const [getInformation, setInformation] = useActions([ getInformationAction, setInformationAction, ] as const); return ( <div> <div onClick={loadUser}>load user</div> <div onClick={getInformation}>get information</div> <div onClick={() => setInformation({ user: 1 })}>set information</div> </div> ); }; Copy "},{"title":"useSelector ()​","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#useselector-","content":"Receiving data from the store in components "},{"title":"Interface​","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#interface-1","content":"stores: [] - a list of tokens that the selector will subscribe to. Will affect which store changes will trigger an update in the componentselector: (state) => any - the selector itself, this is a function that will be called upon initialization and any changes to the stores passed to stores. The function should return data that can be used in the componentequalityFn?: (cur, prev) => boolean - optional function to change the way of comparing past and new values ​​of a selector "},{"title":"Usage​","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#usage-1","content":"To get data from a store, you can use a store name, a reference to a store, or an object with an optional store: 'storeName'storeObject{ store: storeObject, optional: true }{ store: 'storeName', optional: true } You can pass an array of keys, then for correct type inference it is better to use as const: useSelector(['fooStoreName', barStoreObject] as const, ({ foo, bar }) => null); import { useSelector } from '@tramvai/state'; export const Component = () => { const isBrowser = useSelector('media', (state) => state.media.isBrowser); return <div>{isBrowser ? <span>Browser</span> : <span>Desktop</span>}</div>; }; Copy "},{"title":"Optimizations​","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#optimizations","content":"In order to reduce the number of component redrawings, after each call to selector, the return values ​​are checked against those that were before. If the returned selector data has not changed, then the component will not be redrawn. For this reason, it is better to get small chunks of information in selectors. Then there is less chance that the component will be updated. For example: we need the user's roles, we write a selector that requests all user data (state) => state.user and now any changes to the user reducer will update the component. It is better if we receive only the necessary data (state) => state.user.roles, in which case the component will be redrawn only when the user's roles change "},{"title":"useStoreSelector​","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#usestoreselector","content":"A simplified version of the useSelector hook into which only one store can be passed, created via createReducer. It was made to improve the inference of selector types, since useSelector itself cannot do this due to the use of strings, tokens and BaseStore heirs inside string names "},{"title":"Interface​","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#interface-2","content":"store: Reducer - Store created through createReducerselector: (state) => any - the selector itself, this is a function that will be called upon initialization and any changes to the store passed to stores. The function should return data that can be used in the component "},{"title":"Usage​","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#usage-2","content":"import { useStoreSelector } from '@tramvai/state'; import { createReducer } from '@tramvai/state'; const myStore = createReducer('myStore', { id: '123' }); export const Component = () => { const id = useStoreSelector((myStore, (state) => state.id)); // The id type will be correctly inferred as \"string\" return <div>{id}</div>; }; Copy "},{"title":"Optimizations​","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#optimizations-1","content":"The hook is a wrapper over useSelector, so the optimizations are the same. The selector function itself is memoized inside "},{"title":"useStore​","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#usestore","content":"Hook to get the state of a specific reducer. Peculiarities: automatically displays the type of statere-renders the component only when the reducer is updatedallows you to create reducers \"on the fly\" "},{"title":"Interface​","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#interface-3","content":"store: Reducer - Store created by createReducer "},{"title":"Usage​","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#usage-3","content":"Basic example: import { useStore } from '@tramvai/state'; import { createReducer } from '@tramvai/state'; const userReducer = createReducer('user', { id: '123' }); export const Component = () => { const { id } = useStore(userReducer); return <div>{id}</div>; }; Copy "},{"title":"Static HTML Export","type":0,"sectionRef":"#","url":"docs/features/static-html-export","content":"","keywords":""},{"title":"Explanation​","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#explanation","content":"tramvai static <appName> command run production build of the application, then starts application server, and make requests to all application routes. All responses are saved to .html files inside dist/static directory. This feature is suitable for applications where all pages are independent of dynamic server-side data. You can serve exported HTML files without tramvai server by CDN or any static server. "},{"title":"Usage​","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#usage","content":""},{"title":"Development​","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#development","content":"Run command to export HTML pages with --serve flag: tramvai static <appName> --serve Copy Open server with exported pages at http://localhost:3000/ "},{"title":"Production​","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#production","content":"Run command to export HTML pages: tramvai static <appName> Copy Deploy HTML pages to your server and static assets to your CDN "},{"title":"Static Assets​","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#static-assets","content":"All static resources (js, css files) will be loaded according to the url specified in ASSETS_PREFIX env variable. "},{"title":"Limitations​","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#limitations","content":"Dynamic pages (routes like /foo/bar/:id) is not supported, tramvai static command only show warnings for this pages. "},{"title":"Tramvai integration","type":0,"sectionRef":"#","url":"docs/features/state/tramvai-integration","content":"","keywords":""},{"title":"Providers​","type":1,"pageTitle":"Tramvai integration","url":"docs/features/state/tramvai-integration#providers","content":"The module @tramvai/module-common connects the StateModule, which makes the provider STORE_TOKEN available in the application, which implements all the possibilities of state management: type Store = { dispatch(event); subscribe(listener); subscribe(reducer, listener); getState(); getState(reducer); }; Copy "},{"title":"Change of state​","type":1,"pageTitle":"Tramvai integration","url":"docs/features/state/tramvai-integration#change-of-state","content":"The store.dispatch() method is used to change state, for example: import { commandLineListTokens } from '@tramvai/core'; import { createEvent, createReducer } from '@tramvai/state'; import { STORE_TOKEN } from '@tramvai/tokens-common'; const incEvent = createEvent('inc'); const countReducer = createReducer('count', 0).on(inc, (state) => state + 1); const provider = { provide: commandLineListTokens.resolveUserDeps, multi: true, useFactory: ({ store }) => { return function updateCountReducer() { store.dispatch(incEvent()); }; }, deps: { store: STORE_TOKEN, }, }; Copy "},{"title":"Read state​","type":1,"pageTitle":"Tramvai integration","url":"docs/features/state/tramvai-integration#read-state","content":"The store.getState() method is used to get the general state, or the state of a particular reducer. Using store.getState(reducer) is not suitable for optional stores - if you are not sure if the store is connected in the application directly or through modules, use const { storeName = defaultValue } = store.getState() Example: import { commandLineListTokens } from '@tramvai/core'; import { createEvent, createReducer } from '@tramvai/state'; import { STORE_TOKEN } from '@tramvai/tokens-common'; const userReducer = createReducer('user', {}); const provider = { provide: commandLineListTokens.resolveUserDeps, multi: true, useFactory: ({ store }) => { return function readUserState() { // { user: {} } - get all state const state = store.getState(); // user: {} - get the state of a specific reducer const user = store.getState(userReducer); }; }, deps: { store: STORE_TOKEN, }, }; Copy "},{"title":"Subscription​","type":1,"pageTitle":"Tramvai integration","url":"docs/features/state/tramvai-integration#subscription","content":"The store.subscribe() method is used to subscribe to a global state change, for example: import { commandLineListTokens } from '@tramvai/core'; import { createEvent, createReducer } from '@tramvai/state'; import { STORE_TOKEN } from '@tramvai/tokens-common'; const incEvent = createEvent('inc'); const countReducer = createReducer('count', 0).on(inc, (state) => state + 1); const provider = { provide: commandLineListTokens.resolveUserDeps, multi: true, useFactory: ({ store }) => { return function listenCountState() { let currentState = store.getState(countReducer); const unsubscribe = store.subscribe((nextGlobalState) => { const nextState = store.getState(countReducer); if (currentState !== nextState) { console.log('count reducer state is:', currentState); currentState = nextState; } }); setInterval(() => { store.dispatch(incEvent()); }, 1000); }; }, deps: { store: STORE_TOKEN, }, }; Copy Or to subscribe to a change in the state of a specific reducer: import { commandLineListTokens } from '@tramvai/core'; import { createEvent, createReducer } from '@tramvai/state'; import { STORE_TOKEN } from '@tramvai/tokens-common'; const incEvent = createEvent('inc'); const countReducer = createReducer('count', 0).on(inc, (state) => state + 1); const provider = { provide: commandLineListTokens.resolveUserDeps, multi: true, useFactory: ({ store }) => { return function listenCountState() { const unsubscribe = store.subscribe(countReducer, (nextState) => { console.log('count reducer state is:', nextState); }); setInterval(() => { store.dispatch(incEvent()); }, 1000); }; }, deps: { store: STORE_TOKEN, }, }; Copy "},{"title":"Actions​","type":1,"pageTitle":"Tramvai integration","url":"docs/features/state/tramvai-integration#actions","content":"The module @tramvai/module-common connects the provider CONTEXT_TOKEN in the application, which, in addition to working with state (under the hood, STORE_TOKEN is used), allows you to run actions: type ConsumerContext = { executeAction(action, payload); dispatch(event); subscribe(listener); getState(); getState(reducer); }; Copy An example of using context: import { createAction } from '@tramvai/core'; import { createEvent, createReducer } from '@tramvai/state'; const loadUser = createEvent('load user'); const userReducer = createReducer('user', { name: 'anonymus' }); userReducer.on(loadUser, (state, payload) => payload); const fetchUserAction = createAction({ name: 'fetchUser', fn: async (context, payload, { httpClient }) => { const { name } = context.getState(userReducer); if (name !== 'anonymus') { return; } const response = await httpClient.get('/user'); context.dispatch(loadUser(response.payload)); }, deps: { httpClient: HTTP_CLIENT, }, }); Copy "},{"title":"Project structure","type":0,"sectionRef":"#","url":"docs/get-started/app-structure","content":"","keywords":""},{"title":"Repository type​","type":1,"pageTitle":"Project structure","url":"docs/get-started/app-structure#repository-type","content":"Multirepo​ The repository structure is designed for one application root-directory ├── tramvai.json - project configuration for `@tramvai/cli` ├── env.development.js - environment variables used for local builds of the project └── src - application code directory └── App block Copy Monorepo​ The repository structure is designed for the presence of several applications, and separate shared libraries root-directory ├── tramvai.json - project configuration for `@tramvai/cli` ├── env.development.js - environment variables used for local builds of the project ├── apps - directory with applications │ ├── App block │ ├── App block └── packages - a directory with various libraries / modules that will be shared between applications ├── Lib block └── Lib block Copy "},{"title":"Blocks​","type":1,"pageTitle":"Project structure","url":"docs/get-started/app-structure#blocks","content":"Application​ app-directory ├── index.ts - application entry point, where all tramvai modules are connected ├── vendor.ts - file with vendor dependencies, will be extracted into a separate js chunk ├── polyfill.ts - polyfills used by the application (absent by default) ├── postcss.js - postcss configuration object ├── shared - reused modules of the application └── routes - application pages Copy "},{"title":"Additional links​","type":1,"pageTitle":"Project structure","url":"docs/get-started/app-structure#additional-links","content":"The following links provide detailed definitions of terms bundle, module and a description of the settings tramvai.json ModuleBundleTramvai CLI settings "},{"title":"Required modules","type":0,"sectionRef":"#","url":"docs/get-started/core-modules","content":"","keywords":""},{"title":"Connecting a new module​","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#connecting-a-new-module","content":"Connecting a module to an application consists of two steps: Installing a module​ npm install @tramvai/module-common Copy Adding to application​ import { CommonModule } from '@tramvai/module-common'; createApp({ name: 'new-app', modules: [ CommonModule, // ... ], // ... }); Copy "},{"title":"CommonModule​","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#commonmodule","content":"The most basic module, which should always be connected and at the same time should be set to the first in the list of modules (the position of the module determines the priority of the providers included in the DI - the lower the module, the higher the priority of its providers, therefore the presence of a CommonModule as the first module will allow other modules to override which one of basic tramvai functionality). Contains: implementation of actionsbundle managerin-app cache managerteam commanderapplication component registercontextbase loggermodule managerpubsubserver request and response managerstate-manager "},{"title":"RenderModule​","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#rendermodule","content":"The module responsible for rendering the application. Renders a React app on the server and builds the entire html page. On the client, it hydrates the layout on the first render and updates the render when the application route changes. "},{"title":"RouterModule​","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#routermodule","content":"Application routing: allows you to get information about the current route, make spa transitions, etc. Used by other modules for their work (for example, RenderModule uses it to determine which components should be rendered now). Allows you to set fixed routes in the application through the RouterModule.forRoot method. If fixed routes are not specified, then the ApiClientModule will be required to load data from the admin panel. "},{"title":"ServerModule​","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#servermodule","content":"The module is a starting server based on express. Also adds work with papi methods "},{"title":"HttpClientModule​","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#httpclientmodule","content":"Module for working with HTTP requests. "},{"title":"ErrorIntercepterModule (optional)​","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#errorinterceptermodule-optional","content":"Adds interceptions of global errors and logging of such errors. "},{"title":"LogModule (optional)​","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#logmodule-optional","content":"This is not required. Replaces the implementation from CommonModule. However, with this module, the logs will be better formatted, filtered and it will be possible to send logs from the client to the api logs. "},{"title":"SeoModule (optional)​","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#seomodule-optional","content":"Adds meta tags to the page, based on the route or explicitly given data in the application. "},{"title":"CacheWarmupModule (optional)​","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#cachewarmupmodule-optional","content":"A module for warming up caches on the server when launching an application in production. "},{"title":"Additional links​","type":1,"pageTitle":"Required modules","url":"docs/get-started/core-modules#additional-links","content":"The following links contain descriptions of terms action, dependency injection и state management ActionDependency InjectionState management "},{"title":"Documentation overview","type":0,"sectionRef":"#","url":"docs/get-started/overview","content":"","keywords":""},{"title":"First steps​","type":1,"pageTitle":"Documentation overview","url":"docs/get-started/overview#first-steps","content":"For the first acquaintance with the framework, it is recommended to take a lesson Create tramvai application "},{"title":"Deep dive​","type":1,"pageTitle":"Documentation overview","url":"docs/get-started/overview#deep-dive","content":"You can get acquainted with the concepts that underlie the framework in the section Concepts "},{"title":"Features​","type":1,"pageTitle":"Documentation overview","url":"docs/get-started/overview#features","content":"You can learn more about the capabilities of the framework in the section Features "},{"title":"Jedi tricks​","type":1,"pageTitle":"Documentation overview","url":"docs/get-started/overview#jedi-tricks","content":"Guides and recipes for solving the most popular tasks are located in the section How-to "},{"title":"API references​","type":1,"pageTitle":"Documentation overview","url":"docs/get-started/overview#api-references","content":"The framework API reference, documentation for built-in modules and libraries are located in the section API "},{"title":"Tramvai CLI​","type":1,"pageTitle":"Documentation overview","url":"docs/get-started/overview#tramvai-cli","content":"Documentation for Tramvai CLI is on the page CLI "},{"title":"Сreate an application on tramvai","type":0,"sectionRef":"#","url":"docs/get-started/create-app","content":"","keywords":""},{"title":"System setup​","type":1,"pageTitle":"Сreate an application on tramvai","url":"docs/get-started/create-app#system-setup","content":"NodeJS version 10+ is required for tramvai and @tramvai/cli to work "},{"title":"Install tramvai CLI​","type":1,"pageTitle":"Сreate an application on tramvai","url":"docs/get-started/create-app#install-tramvai-cli","content":"We will use the tramvai CLI to generate a new project and run in development mode npm i @tramvai/cli -g Copy After that, the command will be available in the terminal tramvai "},{"title":"Generate application​","type":1,"pageTitle":"Сreate an application on tramvai","url":"docs/get-started/create-app#generate-application","content":"Now we need to generate the application with tramvai tramvai new new-app Copy After starting, you need to select settings - project template, CI settings and package manager. For a quick start, the default settings are fine. Then the command will generate a starter project with basic modules in the new-app directory "},{"title":"Run application​","type":1,"pageTitle":"Сreate an application on tramvai","url":"docs/get-started/create-app#run-application","content":"Now we need to run our project in development mode, for easy development and to check that our project is working. To do this, execute the command cd new-app && npm start Copy This command will start a server in dev mode that will monitor the server and client code. After executing the command, you can go to the address http://localhost:3000/ and see the lifted clean application "},{"title":"Project structure and application initialization process​","type":1,"pageTitle":"Сreate an application on tramvai","url":"docs/get-started/create-app#project-structure-and-application-initialization-process","content":"The entry point of the project is src/index.ts, which creates an instance of the tramvai application and connects the necessary modules. The project has already connected basic modules that implement the following functionality: Getting routes (from the admin panel or static routes)Rendering the application on the server and clientStarting the server for the applicationProviding services for working with external / internal API In this case, it is not necessary to use modules from the base tramvai set, you can write your own implementations that implement the interfaces of the base modules When the application starts, the modules' dependencies are initialized and the commands from the chain of actions are executed, during which data requests from the API, rendering, etc. occur. "},{"title":"Additional links​","type":1,"pageTitle":"Сreate an application on tramvai","url":"docs/get-started/create-app#additional-links","content":"The links provide information on the structure of the project and the basic modules required for the full-fledged operation of the application. Project structureRequired modules "},{"title":"Deployment","type":0,"sectionRef":"#","url":"docs/guides/deploy","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Deployment","url":"docs/guides/deploy#introduction","content":"Tramvai is a regular node.js application that can be run using standard tools available in the node.js community. Restrictions are only imposed on the file structure and the need to pass ENV variables to the application "},{"title":"List of actions required to deploy the application​","type":1,"pageTitle":"Deployment","url":"docs/guides/deploy#list-of-actions-required-to-deploy-the-application","content":"build the application in production modefill in assetsbuild a docker container with application filesrun by passing ENV variables "},{"title":"Build the project​","type":1,"pageTitle":"Deployment","url":"docs/guides/deploy#build-the-project","content":"To build the project, you must use the command (before installing the dependencies in the project) tramvai build APP_ID Copy in APP_ID, you must pass the application identifier. After executing the command, the dist directory will appear with the build files for the server and client code "},{"title":"Create a docker container​","type":1,"pageTitle":"Deployment","url":"docs/guides/deploy#create-a-docker-container","content":"Recommended Dockerfile FROM node:14-buster-slim WORKDIR /app COPY dist/server /app/ COPY package.json /app/ ENV NODE_ENV='production' EXPOSE 3000 CMD [ \"node\", \"--max-http-header-size=80000\", \"/app/server.js\" ] Copy FROM - you can put a 14+ version of the node, preferably an alpine version to reduce the size "},{"title":"Deploy static assets​","type":1,"pageTitle":"Deployment","url":"docs/guides/deploy#deploy-static-assets","content":"The recommended way is to upload files to a CDN, since node.js does not do a very good job of serving static content, so there will be a lot of traffic for our infrastructure. Therefore, for production applications that clients will use, you should always use a CDN. To do this, upload the contents of the dist/client folder to the CDN according to the method you choose, you get the URL at which the files will be available and substitute this url into the ENV variable ASSETS_PREFIX for example ASSETS_PREFIX=https://cdn-domain.com/my-awesome-app/ If you do not need a CDN, then you can see below in the paragraph \"Launching an application without a client CDN\", it is worth using for test benches or not loaded applications "},{"title":"Deploy application​","type":1,"pageTitle":"Deployment","url":"docs/guides/deploy#deploy-application","content":"The application is launched as a normal node.js process with the node command; when starting, it is necessary to pass all the necessary ENV variables (the list of ENVs depends on the modules used by the application). If you do not add ENV variables, the application will not start. Don't forget about the variable ASSETS_PREFIX "},{"title":"Explanation​","type":1,"pageTitle":"Deployment","url":"docs/guides/deploy#explanation","content":""},{"title":"Probes​","type":1,"pageTitle":"Deployment","url":"docs/guides/deploy#probes","content":"If you deploy to kubernetes, then for these cases there are special urls for probes that you need to use /healthz - after starting the application, it always response OK/readyz - after starting the application, it always response OK "},{"title":"Launching an application without a client CDN​","type":1,"pageTitle":"Deployment","url":"docs/guides/deploy#launching-an-application-without-a-client-cdn","content":"Tramvai has a built-in static return server. It is better not to do this, for the reason that nodeJS is not the best tool for this and static will affect the application. In general, everything is the same as in a regular deployment, but you need to add copying user assets to the docker image, for this: add copy files COPY dist/client /app/public/staticschange ENV variable ASSETS_PREFIX Dockerfile example FROM node:14-buster-slim WORKDIR /app COPY dist/server /app/ COPY package.json /app/ COPY dist/client /app/public/statics ENV NODE_ENV='production' EXPOSE 3000 CMD [ \"node\", \"--max-http-header-size=80000\", \"/app/server.js\" ] Copy When starting the application, you must pass ASSETS_PREFIX=/statics/. When the application starts, the server for serving statistics will rise and all files inside the /public/ directory will be available. Thus, the client will be able to receive data on the url /statics/payment.js "},{"title":"Run locally in a docker container​","type":1,"pageTitle":"Deployment","url":"docs/guides/deploy#run-locally-in-a-docker-container","content":"The device must have https://www.docker.com/products/docker-desktop installed and run the command docker run hello-world We build the project in production mode, we will have an artifact in the dist directory​ yarn build Copy Build a docker application image​ docker build -t test/myapp . Copy Run the created image​ docker run --rm -e DANGEROUS_UNSAFE_ENV_FILES='true' -e ASSETS_PREFIX='http://localhost:4000/static/' -v ${PWD}/env.development.js:/app/env.development.js -v ${PWD}/dist/client:/app/static -e DEV_STATIC=true -p 3000:3000 -p 4000:4000 -d test/myapp Copy To stop the container, you need to get the CONTAINER ID, run the docker ps command and then run the command docker stop <CONTAINER ID> To stop all containers​ docker kill $(docker ps --quiet) Copy "},{"title":"Bundle optimization","type":0,"sectionRef":"#","url":"docs/guides/bundle-optimization","content":"","keywords":""},{"title":"Code Splitting​","type":1,"pageTitle":"Bundle optimization","url":"docs/guides/bundle-optimization#code-splitting","content":"Providing the client with the minimum required JavaScript code is one of the most important things in optimizing web applications. Separating entry points when building bundles and dynamically importing modules and using these bans based on routing / custom actions are the main mechanisms for splitting code. When assembling many bundles and dynamic chunks, the problem of code duplication between them arises, which allows you to solve SplitChunksPlugin Tramvai applications have a number of features - a single entry point (platform.js at the exit), dynamic import at the level of each bundle, a separate assembly of the vendor chunk. For an application that has several tramvai bundles for different pages, each page will load at least the platform.js chunk with the common framework and modules code, and the {bundleName} .js chunk with the unique code for the page. Duplicates can be in chunks created under tramvai bundles (for example, ui-kit components), and it is desirable to move this code into common chunks. The CLI offers three strategies for splitting code - one common chunk, many granular shared chunks, and disabling the SplitChunksPlugin. "},{"title":"Disabling SplitChunksPlugin​","type":1,"pageTitle":"Bundle optimization","url":"docs/guides/bundle-optimization#disabling-splitchunksplugin","content":"For applications that have only one tramvai bundle for all pages, or separate the bundle for the desktop and mobile versions, in most cases, code separation is not required, and it is worth setting the option \"commonChunk\": false: { \"projects\": { \"{appName}\": { \"commands\": { \"build\": { \"configurations\": { \"commonChunk\": false } } } } } } Copy Why not leave the common chunk if it doesn't interfere? The problem is in third-party libraries that can use dynamic import under the hood, while the application may not use this code, but it may end up in the common chunk, which will be loaded on every page. Also, if your application is serving multiple pages and separating the code at the page component level via @tramvai/react lazy, it makes sense to consider other strategies, since duplicates will appear in dynamic chunks of pages. "},{"title":"Common Chunk​","type":1,"pageTitle":"Bundle optimization","url":"docs/guides/bundle-optimization#common-chunk","content":"The strategy is included in the CLI by default, all common code from bundles and dynamic chunks is moved to common-chunk.js. The commonChunkSplitNumber parameter allows you to specify the minimum number of chunks this code should use in order to move it to common. For applications with a lot of bundles, common-chunk.js can include a huge amount of code that is not needed on every single page, and it is worth either increasing the commonChunkSplitNumber or using the Granular Chunks strategy. Example configuration to increase the minimum number of chunks using shared code: { \"projects\": { \"{appName}\": { \"commands\": { \"build\": { \"configurations\": { \"commonChunkSplitNumber\": 5 } } } } } } Copy How to choose a suitable number of commonChunkSplitNumber? Alternatively, the number can be calculated using the formulas commonChunkSplitNumber = bundles / 3 or commonChunkSplitNumber = bundles / 2, where bundles is the number of tramvai bundles that are connected to a specific application, but most likely each application will be better viewed separately. "},{"title":"Granular Chunks​","type":1,"pageTitle":"Bundle optimization","url":"docs/guides/bundle-optimization#granular-chunks","content":"A detailed description of using the strategy in Next.js and Gatsby.js The strategy is enabled through the granularChunks parameter, allows you to move the common code into many small chunks, for efficient caching of the common code, and loading only the necessary code on each page. The balance is achieved due to the fact that the common code between at least two (default settings) chunks is placed in a separate chunk with a unique name, and there will be such chunks from one for all the others, to one for every two chunks. Disadvantages of this strategy: significantly more js scripts can be loaded on one page, up to several dozen, which does not significantly affect performance when using HTTP / 2; and less efficient gzip / brotli archiving, which is not so noticeable compared to the reduction in the amount of source code. The granularChunksSplitNumber parameter allows you to override the default number of shared chunks (2), if for some reason you need to reduce the number of resulting chunks: { \"projects\": { \"{appName}\": { \"commands\": { \"build\": { \"configurations\": { \"granularChunks\": true, \"granularChunksSplitNumber\": 3 } } } } } } Copy "},{"title":"Creating a tramvai library","type":0,"sectionRef":"#","url":"docs/guides/tramvai-library","content":"","keywords":""},{"title":"Prerequisites​","type":1,"pageTitle":"Creating a tramvai library","url":"docs/guides/tramvai-library#prerequisites","content":"Let's consider all important cases using the example of creating a new tramvai module. Let's say the module will provide a new HTTP client to work with the Github API. "},{"title":"Package name​","type":1,"pageTitle":"Creating a tramvai library","url":"docs/guides/tramvai-library#package-name","content":"It is highly discouraged to use the @tramvai and @tramvai-tinkoff scopes outside the tramvai repository. If our application is called tincoin, you can, for example, select one of these scopes: @tincoin@tramvai-tincoin@tincoin-core For modules, the prefix is ​​usually module-, for example: @tramvai-tincoin/module-github-api-client "},{"title":"Versioning​","type":1,"pageTitle":"Creating a tramvai library","url":"docs/guides/tramvai-library#versioning","content":"The choice of a versioning strategy is entirely yours. We definitely recommend following semver, and we can recommend using unified versioning if: you support monorep with core librariesthese libraries can be linkedand these packages are used in applications all together (or most of them) "},{"title":"Dependencies​","type":1,"pageTitle":"Creating a tramvai library","url":"docs/guides/tramvai-library#dependencies","content":"Dealing with library dependencies is not an easy task, and there is no ideal solution, but there are a number of tips to make it easier to manage dependencies. The best place to start is by dividing dependencies into different types: Framework​ Examples of such dependencies are react and react-dom, @tramvai/* and @tramvai-tinkoff/*. If we write babel or eslint plugin, it can be @babel/core and eslint. Typically, an end user, such as a tramvai application, is required to install a dependency framework, without them it simply won't work. Therefore, our library should set them to peerDependencies, with the most free versions, for example, if the package is tied to the basic functionality of tramvai, and uses React hooks: { \"peerDependencies\": { \"@tramvai/core\": \"*\", \"react\": \">=16.8\", \"react-dom\": \">=16.8\" } } Copy Singleton​ A number of dependencies must be strictly one in the application. Any duplicates are a minus. increase the weight of the application bundle, but libraries such as react or @tinkoff/logger require a single copy in our application. For them, the rule applies as with the framework, you need to install them in peerDependencies, with the most free versions: { \"peerDependencies\": { \"@tinkoff/logger\": \"*\" } } Copy Popular​ Many packages are popular enough that chances are they are already being used in the final application. An example of such dependencies is - date-fns, lru-cache, @tinkoff/dippy For them, the rule applies as with the framework, you need to install them in peerDependencies, with the most free versions: { \"peerDependencies\": { \"@tinkoff/dippy\": \"*\", \"date-fns\": \">=2\", \"lru-cache\": \"*\" } } Copy Specific​ Let's say our new tramvai module delivers unique functionality to the application that requires a third-party library (or even another package in your monorepo) If we are developing a service to work with the Github API, it might be the @octokit/rest package. In this case, you need to put the library in dependencies, and you can leave the standard range using ^: { \"dependencies\": { \"@octokit/rest\": \"^18.0.0\" } } Copy Development​ A dependency may be involved in building your package - for example, rollup or @tramvai/build. The dependency is required to run library tests. The dependency contains the taipings required for the build. In all these cases, even if either is already in peerDependencies, it is worth adding a more specific version to devDependencies, for example: { \"devDependencies\": { \"@tramvai/build\": \"^2.5.0\", \"@types/react\": \"^17.0.0\", \"react\": \"^17.0.0\" } } Copy Exclusion​ Of course, there are exceptional cases. For example, tramvai provides many test utilities where all the main @tramvai dependencies were in peerDependencies. As soon as these utilities began to be used not in repositories with applications, but in monoreps with core packages, the problem of missing dependencies appeared, and we moved almost everything from peerDependencies to dependencies Proceed according to the situation and always think about the usability of your product :) "},{"title":"Build​","type":1,"pageTitle":"Creating a tramvai library","url":"docs/guides/tramvai-library#build","content":"It is assumed that the final assembly of packages in the context of the application will be done by @tramvai/cli. Therefore, to publish packages written in TypeScript, it suffices to use tsc, and publish many compiled .js and .d.ts files. But building packages into bundles before publishing, for example via rollup or @tramvai/build, gives a number of possibilities: preliminary tree-shaking will cut off all unnecessary, this will have a positive effect on the assembly of the applicationyou can make several bundles for different environments, in CJS or ES modules formatsyou can make a separate bundle for the browser build, separate for the server one - top for libraries with SSR support Detailed documentation on using @tramvai/build is available in documentation "},{"title":"Separating code for server and client","type":0,"sectionRef":"#","url":"docs/guides/universal","content":"","keywords":""},{"title":"Application code​","type":1,"pageTitle":"Separating code for server and client","url":"docs/guides/universal#application-code","content":"To execute branches of code or in specific environments, several checks can be used: process.env​ When building a project, tramvai cli sets two variables indicating the environment - process.env.SERVER and process.env.BROWSER. Webpack will automatically remove code with a condition that does not match the current environment, for example, the following code will not be included in the server bundle: if (process.env.BROWSER) { console.log(window.innerWidth, window.innerHeight); } Copy To exclude code from a production build, regardless of the environment, you can use the variable process.env.NODE_ENV: if (process.env.NODE_ENV === 'development') { console.log('отладочная информация'); } Copy To exclude imported libraries from the assembly, you need to replace the top-level import with require inside the condition: if (process.env.BROWSER) { const logger = require('@tinkoff/logger'); const log = logger('debug'); log.info(window.location.href); } Copy typeof window​ For additional optimizations, the babel plugin is used, which turns typeof window from the server assembly to 'undefined', and from the client assembly to 'object', which allows webpack to cut out unnecessary code, for example, the following condition works similarly to checking process.env.BROWSER: if (typeof window !== 'undefined') { console.log(window.innerWidth, window.innerHeight); } Copy package.json​ If we needed to replace a whole file, and not specific lines of code, we can move it to a separate folder, describe the implementation for all environments, and add package.json: // module.server.js export const CONSTANT = 'SERVER_SIDE'; Copy // module.client.js export const CONSTANT = 'CLIENT_SIDE'; Copy Next, in package.json, you need to tell the bundler which code to use for different environments. The main field is used for the server bundle, and the browser field is used for the client bundle: { \"main\": \"./module.server.js\", \"browser\": \"./module.client.js\" } Copy "},{"title":"npm packages​","type":1,"pageTitle":"Separating code for server and client","url":"docs/guides/universal#npm-packages","content":"To create a library, the implementation of which should be different on the server and the client, you need to maintain a common export interface, and configure package.json in the same way as in the previous example. For example, the library exports the class Library, and the constant LIBRARY_CONSTANT. Let's create two entry points to our library - server.js и client.js: // server.js export class Library { constructor() { // ... } } export const LIBRARY_CONSTANT = 'SERVER_SIDE_LIBRARY'; Copy // client.js export class Library { constructor() { // ... } } export const LIBRARY_CONSTANT = 'CLIENT_SIDE_LIBRARY'; Copy Next, in package.json, you need to tell the bundler which code to use for different environments. The main field is used for the server bundle, and the browser field is used for the client bundle: { \"name\": \"library\", \"version\": \"0.1.0\", \"main\": \"server.js\", \"browser\": \"client.js\", \"dependencies\": { ... } } Copy After publishing the library, you can import it into the tramvai application, and not worry about which implementation we get: import { LIBRARY_CONSTANT } from 'library'; // when starting the application via tramvai start, we will see 'SERVER_SIDE_LIBRARY' in the terminal, and 'CLIENT_SIDE_LIBRARY' in the browser console console.log(LIBRARY_CONSTANT); Copy "},{"title":"tramvai modules​","type":1,"pageTitle":"Separating code for server and client","url":"docs/guides/universal#tramvai-modules","content":"New functionality in the tramvai application is added using modules, and as a rule, the behavior of these modules is radically different in different environments, for example: Rendering the application to a string on the server and hydrating the real DOM on the clientStart https serverService worker initialization For this reason, in the tramvai repository, the standard tramvai module template generated via the npm run generate: module command immediately separates the module entry points into server.js and client.js using package.json Let's analyze this using the example of creating a module that adds a service to the application for working with cookie: This service should have a common interface: export interface ICookie { get(key); set(key, value); } Copy And different implementations for server and client environments: // src/cookie.server.ts // server-side implementation requires Request and Response objects to work with cookies export class Cookie implements ICookie { constructor({ req, res }) { // ... } get(key) { // ... } set(key, value) { // ... } } Copy // src/cookie.client.ts // the client implementation accesses the Window object directly export class Cookie implements ICookie { get(key) { // ... } set(key, value) { // ... } } Copy Add a service to DI using modules: // src/server.ts import { Module, Scope, provide } from '@tramvai/core'; import { REQUEST, RESPONSE } from '@tramvai/tokens-common'; import { Cookie } from './cookie.server'; @Module({ providers: [ provide({ provide: 'cookie', useClass: Cookie, scope: Scope.REQUEST, deps: { req: REQUEST, res: RESPONSE, }, }), ], }) export class CookieModule {} Copy // src/client.ts import { Module, Scope, provide } from '@tramvai/core'; import { Cookie } from './cookie.client'; @Module({ providers: [ provide({ provide: 'cookie', useClass: Cookie, scope: Scope.SINGLETON, }), ], }) export class CookieModule {} Copy Configure package.json: { \"name\": \"@tramvai/module-cookie\", \"version\": \"0.1.0\", \"main\": \"lib/server.js\", \"browser\": \"lib/client.js\", \"dependencies\": { ... } } Copy After importing the module into the application, we get universal access to cookies, and do not think about the environment when using: import { createApp, commandLineListTokens, provide } from '@tramvai/core'; import { CookieModule } from '@tramvai/module-cookie'; createApp({ name: 'app', modules: [ // ... CookieModule, ], providers: [ // ... provide({ provide: commandLineListTokens.init, useFactory: ({ cookie }) => { console.log('wuid', cookie.get('wuid')); }, deps: { cookie: 'cookie', }, }), ], // ... }); Copy "},{"title":"Executing actions on different pages","type":0,"sectionRef":"#","url":"docs/how-to/actions-execution","content":"","keywords":""},{"title":"Binding actions to a specific page​","type":1,"pageTitle":"Executing actions on different pages","url":"docs/how-to/actions-execution#binding-actions-to-a-specific-page","content":"To do this, you can use the static property actions of page components:  Creating actions import { createAction } from '@tramvai/core'; import { ACTION_EXECUTION_LIMIT } from '../constants'; import { set } from '../store'; export const pageInLimit = createAction({ name: 'pageInLimit', fn: async (context) => { console.log('execute pageInLimit'); await context.dispatch(set({ name: 'pageInLimit', value: false })); await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT / 2)); await context.dispatch(set({ name: 'pageInLimit', value: true })); }, }); export const pageOutLimit = createAction({ name: 'pageOutLimit', fn: async (context) => { console.log('execute pageOutLimit'); await context.dispatch(set({ name: 'pageOutLimit', value: false })); await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT * 2)); await context.dispatch(set({ name: 'pageOutLimit', value: true })); }, }); Copy   Connecting actions to the page import reduceObj from '@tinkoff/utils/object/reduce'; import React from 'react'; import { useSelector } from '@tramvai/state'; import { store } from '../store'; import { pageInLimit, pageOutLimit } from '../actions/page'; export function Page() { const state = useSelector(store, (x) => x.actionTest); return ( <div> {reduceObj( (acc, v, k) => { return acc.concat( <div> {k} = {v.toString()} </div> ); }, [], state )} </div> ); } // actions can be specified as a static property of a page component // in this case actions will be executed only on pages with this particular pageComponent Page.actions = [pageInLimit, pageOutLimit]; Copy  "},{"title":"Binding actions to a bundle​","type":1,"pageTitle":"Executing actions on different pages","url":"docs/how-to/actions-execution#binding-actions-to-a-bundle","content":"Bundles allow you to group pages, you can bind actions to them, which will be executed for each page of the bundle:  Creating actions import { createAction } from '@tramvai/core'; import { ACTION_EXECUTION_LIMIT } from '../constants'; import { set } from '../store'; export const bundleInLimit = createAction({ name: 'bundleInLimit', fn: async (context) => { console.log('execute bundleInLimit'); await context.dispatch(set({ name: 'bundleInLimit', value: false })); await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT / 2)); await context.dispatch(set({ name: 'bundleInLimit', value: true })); }, }); export const bundleOutLimit = createAction({ name: 'bundleOutLimit', fn: async (context) => { console.log('execute bundleOutLimit'); await context.dispatch(set({ name: 'bundleOutLimit', value: false })); await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT * 2)); await context.dispatch(set({ name: 'bundleOutLimit', value: true })); }, }); Copy   Connecting actions to the bundle import { createBundle } from '@tramvai/core'; import { store } from '../store'; import { bundleInLimit, bundleOutLimit } from '../actions/bundle'; import { Page } from '../components/Page'; export const mainDefault = createBundle({ name: 'mainDefault', components: { pageDefault: Page, }, // let's specify our store, so that it will immediately initialize and subscribe to its dispatch events reducers: [store], // the actions can be specified as part of the bundle - then these actions will be executed for all pages of the bundle actions: [bundleInLimit, bundleOutLimit], }); Copy  "},{"title":"Common actions for the application​","type":1,"pageTitle":"Executing actions on different pages","url":"docs/how-to/actions-execution#common-actions-for-the-application","content":"Actions connected to application are executed on all pages:  Creating actions import { createAction } from '@tramvai/core'; import { ACTION_EXECUTION_LIMIT } from '../constants'; import { set } from '../store'; export const globalInLimit = createAction({ name: 'globalInLimit', fn: async (context) => { console.log('execute globalInLimit'); await context.dispatch(set({ name: 'globalInLimit', value: false })); // set the execution delay less than the server's execution limit, so that this action will be executed in time to ssr await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT / 2)); await context.dispatch(set({ name: 'globalInLimit', value: true })); }, }); export const globalOutLimit = createAction({ name: 'globalOutLimit', fn: async (context) => { console.log('execute globalOutLimit'); await context.dispatch(set({ name: 'globalOutLimit', value: false })); // set an execution delay higher than the server's execution limit, so that this action will not be executed in time with ssr await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT * 2)); await context.dispatch(set({ name: 'globalOutLimit', value: true })); }, }); Copy   Connecting actions into the application import { createApp, provide } from '@tramvai/core'; import { ACTION_EXECUTION_LIMIT } from './constants'; import { modules } from '../common'; import { globalInLimit, globalOutLimit } from './actions/global'; import { mainDefault } from './bundles/mainDefault'; createApp({ name: 'actions-execution', modules: [...modules], providers: [ provide({ // in the application you can specify a limit on the execution of actions on the server (by default 500ms) provide: 'limitActionGlobalTimeRun', useValue: ACTION_EXECUTION_LIMIT, }), ], // these actions will be executed for all pages of the application actions: [globalInLimit, globalOutLimit], bundles: { mainDefault: () => Promise.resolve({ default: mainDefault }), }, }); Copy  "},{"title":"Execution of actions depending on conditions","type":0,"sectionRef":"#","url":"docs/how-to/actions-conditions","content":"","keywords":""},{"title":"Using preset limits​","type":1,"pageTitle":"Execution of actions depending on conditions","url":"docs/how-to/actions-conditions#using-preset-limits","content":"Let's say we want to execute one action only on the server, and one only on the client, for this there are onlyServer and onlyBrowser restrictions:  Create actions import { createAction } from '@tramvai/core'; import { set } from '../store'; export const innerAction = createAction({ name: 'innerAction', fn: (context) => { console.log('execute innerAction'); return context.dispatch(set('innerAction')); }, // conditions not set - the action will be executed by default: // if the action is defined as global (in an application, bundle or page), // then the action will first try to execute on the server - if it succeeds, then it will not be executed again on the client // if the action did not manage to be executed within the limit, then it will be launched on the client, // repeated launches when switching to the page with this action will not be executed, because the last successful execution is remembered // if the action is called explicitly through the context, then such an action will always be executed (the execution limit still affects, // and the data may not always be available with ssr, but the action will always try to execute) }); export const innerServerAction = createAction({ name: 'innerServerAction', fn: (context) => { console.log('execute innerServerAction'); return context.dispatch(set('innerServerAction')); }, // this action can only be executed on the server conditions: { onlyServer: true, }, }); export const innerBrowserAction = createAction({ name: 'innerBrowserAction', fn: (context) => { console.log('execute innerBrowserAction'); return context.dispatch(set('innerBrowserAction')); }, // this action can only be executed on the browser conditions: { onlyBrowser: true, }, }); Copy   Use actions import { createAction } from '@tramvai/core'; import { set } from '../store'; import { innerAction, innerBrowserAction, innerServerAction } from './inner'; export const pageServerAction = createAction({ name: 'pageServerAction', fn: async (context) => { console.log('execute pageServerAction'); await context.executeAction(innerAction); await context.executeAction(innerServerAction); await context.executeAction(innerBrowserAction); return context.dispatch(set('pageServerAction')); }, conditions: { pageServer: true, }, }); export const pageBrowserAction = createAction({ name: 'pageBrowserAction', fn: async (context) => { console.log('execute pageBrowserAction'); await context.executeAction(innerAction); await context.executeAction(innerServerAction); await context.executeAction(innerBrowserAction); return context.dispatch(set('pageBrowserAction')); }, // this action can only be executed on the browser conditions: { onlyBrowser: true, }, }); export const pageAlwaysAction = createAction({ name: 'pageAlwaysAction', fn: async (context) => { console.log('execute pageAlwaysAction'); return context.dispatch(set('pageAlwaysAction')); }, conditions: { always: true, }, }); // this action is only executed in the browser, on page load and on every SPA transition export const pageBrowserAlwaysAction = createAction({ name: 'pageBrowserAlwaysAction', fn: async (context) => { console.log('execute pageBrowserAlwaysAction'); return context.dispatch(set('pageBrowserAlwaysAction')); }, conditions: { always: true, onlyBrowser: true, }, }); Copy  "},{"title":"Create your own restrictions​","type":1,"pageTitle":"Execution of actions depending on conditions","url":"docs/how-to/actions-conditions#create-your-own-restrictions","content":"To do this, you need to implement the ActionCondition interface, and add a new limiter to the DI, via the ACTION_CONDITIONALS token:  Create a delimiter import { ActionCondition } from '@tramvai/module-common'; import { PAGE_SERVICE_TOKEN } from '@tramvai/tokens-router'; export const condition = ({ pageService, }: { pageService: typeof PAGE_SERVICE_TOKEN; }): ActionCondition => { return { key: 'custom', fn: (checker) => { if (checker.conditions.custom) { const { pathname } = pageService.getCurrentUrl(); console.log(pathname); if (pathname !== '/custom/') { checker.forbid(); } } }, }; }; Copy   Create an action with this constraint import { createAction } from '@tramvai/core'; import { set } from '../store'; export const customAction = createAction({ name: 'customAction', fn: (context) => { console.log('execute customAction'); return context.dispatch(set('customAction')); }, // you can set your own options, which are then used in their conditions checks conditions: { custom: true, }, }); Copy  "},{"title":"Execute actions on specific pages only​","type":1,"pageTitle":"Execution of actions depending on conditions","url":"docs/how-to/actions-conditions#execute-actions-on-specific-pages-only","content":"To do this, we use the static property actions for the component that is used on these pages:  Page component import reduceObj from '@tinkoff/utils/object/reduce'; import React from 'react'; import { PAGE_SERVICE_TOKEN } from '@tramvai/tokens-router'; import { useSelector } from '@tramvai/state'; import { useDi } from '@tramvai/react'; import { store } from '../store'; import { pageBrowserAction, pageServerAction, pageAlwaysAction, pageBrowserAlwaysAction, } from '../actions/page'; import { customAction } from '../actions/custom'; export function Page() { const state = useSelector(store, (x) => x.actionTest); const pageService = useDi(PAGE_SERVICE_TOKEN); return ( <div> <button type=\"button\" onClick={() => pageService.navigate({ url: '/custom/' })}> Navigate To custom </button> {reduceObj( (acc, v, k) => { return acc.concat( <div> {k} loaded from {v} </div> ); }, [], state )} </div> ); } Page.actions = [ pageServerAction, pageBrowserAction, pageAlwaysAction, pageBrowserAlwaysAction, customAction, ]; Copy  "},{"title":"Connecting actions and restrictions in the application​","type":1,"pageTitle":"Execution of actions depending on conditions","url":"docs/how-to/actions-conditions#connecting-actions-and-restrictions-in-the-application","content":"Let's create an application that connects the actions, constraints, and components from the previous examples:  Application entry point import { createApp, createBundle, provide } from '@tramvai/core'; import { ACTION_CONDITIONALS } from '@tramvai/module-common'; import { PAGE_SERVICE_TOKEN, ROUTES_TOKEN } from '@tramvai/tokens-router'; import { store } from './store'; import { modules } from '../common'; import { condition } from './conditions/custom'; import { Page } from './components/Page'; const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, }, reducers: [store], }); createApp({ name: 'actions-conditions', modules: [...modules], providers: [ provide({ provide: ACTION_CONDITIONALS, multi: true, useFactory: condition, deps: { pageService: PAGE_SERVICE_TOKEN, }, }), provide({ provide: ROUTES_TOKEN, multi: true, useValue: { name: 'custom', path: '/custom/', }, }), ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), }, }); Copy  "},{"title":"How to create an action?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-action","content":"","keywords":""},{"title":"Create an action​","type":1,"pageTitle":"How to create an action?","url":"docs/how-to/how-create-action#create-an-action","content":"Import createAction and write a function to load data from api and send data to store. import { createAction } from '@tramvai/core'; import { loadDepositConfig } from './deposit/reducer'; export const loadDepositAction = createAction({ name: 'load-deposit-config', fn: async (context, payload, deps) => { const data = await deps.apiClient.request({ method: 'deposit_config ' }); return context.dispatch(loadDepositConfig(data)); }, deps: { apiClient: 'tinkoffApiClient', }, }); Copy We have created an action that requires the tinkoffApiClient provider to work, this action makes a request for the data and saves the received data to the side. "},{"title":"Run action for a specific page​","type":1,"pageTitle":"How to create an action?","url":"docs/how-to/how-create-action#run-action-for-a-specific-page","content":"We have created an action and want to connect it to the application. It is important for us that the action is executed on the server, and the server is waiting for execution. In this case, the data is needed only on a specific page, so we add it to the static actions field of the desired page. import react, { Component } from 'react'; import { loadDepositAction } from './loadDepositAction'; import { DepositInfo } from './DepositInfo'; class DepositPage extends Component { static actions = [loadDepositAction]; render() { return ( <div> <DepositInfo /> </div> ); } } Copy After that, when the user opens the route, the server will automatically launch the action linked to DepositPage and the data will be loaded "},{"title":"What else is worth reading​","type":1,"pageTitle":"How to create an action?","url":"docs/how-to/how-create-action#what-else-is-worth-reading","content":"About createActionHow do actions work "},{"title":"How to split a component into an asynchronous chunk?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-async-component","content":"","keywords":""},{"title":"Component example​","type":1,"pageTitle":"How to split a component into an asynchronous chunk?","url":"docs/how-to/how-create-async-component#component-example","content":"Let's say we have a heavy React component that we use occasionally and we want to load it only when needed. Right now we have the following code: // file heavy.tsx export const Heavy = () => <div>123</div>; Copy // file page.tsx import Heavy from './heavy.tsx'; const Page = () => ( <> <Heavy /> <Footer /> </> ); Copy "},{"title":"Connecting the lazy​","type":1,"pageTitle":"How to split a component into an asynchronous chunk?","url":"docs/how-to/how-create-async-component#connecting-the-lazy","content":"There are several ways to split the component into asynchronous chunks Add new wrapper for heavy into page.tsx.Put heavy code into a separate file and leave only async wrapper in heavy.tsx. We'll create a new file, as this allows us not to change imports in files that have already used the Heavy component. And it will be harder to forget to reuse the async component in the future: // file heavy-component.tsx export const Heavy = () => <div>123</div>; Copy // file heavy.tsx import { lazy } from '@tramvai/react'; export const Heavy = lazy(() => import('./heavy-component')); Copy // file page.tsx import Heavy from './heavy.tsx'; const Page = () => ( <> <Heavy /> <Footer /> </> ); Copy We created a new file, put all the code of the Heavy component there, and left only the component itself in the old file, which we wrapped in lazy and imported the original component with import. Now instead of the original Heavy component we will have an asynchronous version which we will load only when rendering the Page component. "},{"title":"Result​","type":1,"pageTitle":"How to split a component into an asynchronous chunk?","url":"docs/how-to/how-create-async-component#result","content":"The Heavy component will be loaded by demand Next, the component will be: Automatically put in a separate webpack chunkWhen rendering, SSR will automatically download the file and immediately render it on the serverJS and CSS of the chunk will be inserted into the HTML with maximum priorityIt will work seamlessly in the browser Example of work in a test application "},{"title":"How to create a bundle?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-bundle","content":"","keywords":""},{"title":"Creating a bundle​","type":1,"pageTitle":"How to create a bundle?","url":"docs/how-to/how-create-bundle#creating-a-bundle","content":"We use the createBundle method and create an empty bundle, in which we write the name field, which is the unique identifier of the bundle: import { createBundle } from '@tramvai/core'; export default createBundle({ name: 'coin', components: {}, }); Copy "},{"title":"Adding components​","type":1,"pageTitle":"How to create a bundle?","url":"docs/how-to/how-create-bundle#adding-components","content":"The next step is to add the components that will be available in this bundle. We recommended to use lazy and dynamic import page components for effective code splitting. The key is the identifier of the component, this identifier can be bound to the router: import { createBundle } from '@tramvai/core'; import { lazy } from '@tramvai/react'; const MainPage = lazy(() => import('../pages/main')); import Layout from '../layouts'; export default createBundle({ name: 'coin', components: { 'page/coin-main': MainPage, 'layout/coin-layout': Layout, }, }); Copy You can register any components for different purposes. For example, we can register components of modal windows, popups and so on in the bundle. All these components will be available in the componentRegistry. "},{"title":"Connecting in the application​","type":1,"pageTitle":"How to create a bundle?","url":"docs/how-to/how-create-bundle#connecting-in-the-application","content":"Now we have to register the bundle in the application. To do this we add to the bundles object of createApp: key: the identifier of the bundle. The last part must be the same as the bundle ID passed to name, a function of the form last('platform/coin'.split('/')) is used there, otherwise, there will be no loading of the bundle on the server side.value: the function that should return the promise wrapped bundle object. Usually, asynchronous webpack chunks are used, but you can also write a custom loader of regular js files. The important thing is that the name of the chunk, must be synchronized with the name identifier import { createApp } from '@tramvai/core'; createApp({ bundles: { 'platform/coin': () => import(/* webpackChunkName: \"coin\" */ './bundles/coin'), }, }); Copy After that, we will have a bundle available in the application and after downloading it, the linked components will be available. Then we can use these components in routing Complete documentation about createBundleComplete documentation about createApp "},{"title":"Defaul bundle​","type":1,"pageTitle":"How to create a bundle?","url":"docs/how-to/how-create-bundle#defaul-bundle","content":"The default bundle allows you to handle all (created via RouterModule.forRoot) urls for which no bundle is specifically set. It is done like this: Inside index.ts import { createApp } from '@tramvai/core'; createApp({ name: 'myApp', modules: [ // ... ], providers: [ // ... ], bundles: { mainDefault: () => import(/* webpackChunkName: \"mainDefault\" */ './bundles/mainDefault'), }, }); Copy In file bundles/mainDefault.ts import { createBundle } from '@tramvai/core' import { MainPage } from '../layers/pages/MainPage' import { Layout } from '../layers/layout/Layout' export default createBundle({ name: 'mainDefault', components: { pageDefault: MainPage, layoutDefault: Layout, }, }) Copy "},{"title":"How to create Child App?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-child-app","content":"","keywords":""},{"title":"Initialization​","type":1,"pageTitle":"How to create Child App?","url":"docs/how-to/how-create-child-app#initialization","content":""},{"title":"@tramvai/cli​","type":1,"pageTitle":"How to create Child App?","url":"docs/how-to/how-create-child-app#tramvaicli","content":"Run in your shell tramvai new [name] Copy Choose Microfrontend implemented by tramvai child-appFollow next steps of setup based on your needs After that in directory [name] will be generated new child-app from template with all necessary setup. You can use commands tramvai start/tramvai build to start/build your new child-app. "},{"title":"Step By Step​","type":1,"pageTitle":"How to create Child App?","url":"docs/how-to/how-create-child-app#step-by-step","content":"Create new repo Init package-manager Add necessarily package for child app yarn add --dev @tramvai/cli yarn add @tramvai/child-app-core Copy Create new file tramvai.json in the root with following content { \"$schema\": \"./node_modules/@tramvai/cli/schema.json\", \"projects\": { \"[name]\": { \"name\": \"[name]\", \"root\": \"src\", \"type\": \"child-app\" } } } Copy Add scripts to package.json for run child in dev and prod mode: { \"scripts\": { \"start\": \"tramvai start [name]\", \"build\": \"tramvai build [name]\" } } Copy Implement your React-component wrapper (for example in ./src/component.tsx) Add new file ./src/entry.ts for you app with following content: import { createChildApp } from '@tramvai/child-app-core'; import { ChildAppComponent } from './component'; // eslint-disable-next-line import/no-default-export export default createChildApp({ name: '[name]', modules: [], render: ChildAppComponent, }); Copy "},{"title":"Development​","type":1,"pageTitle":"How to create Child App?","url":"docs/how-to/how-create-child-app#development","content":""},{"title":"Add new functionality​","type":1,"pageTitle":"How to create Child App?","url":"docs/how-to/how-create-child-app#add-new-functionality","content":"Child App should mostly reuse functionality from root app through di inheritance (it happens automatically) in cases when it is appropriate. But in order to properly work, some of the modules need a special wrapper module for child app (usually such a wrapper is needed when module functionality in used in React). In this case check interested module documentation on presence of such a wrapper module for a child app. If your child app has some specific functionality you may implement it the way you want: through module, provider, actions or inside React-component. Just make sure you are reusing as much functionality from root app as possible and you are adding as little code as needed to produce smallest possible child-app script. "},{"title":"Testing​","type":1,"pageTitle":"How to create Child App?","url":"docs/how-to/how-create-child-app#testing","content":"Unit​ You may use helper library @tramvai/test-child-app that creates mock application in order to test child-app behaviour in the app. Integration Tests​ Full testing requires to run standalone app that will reuse your app. Create test app in your repository. Also you may use @tramvai/test-trandapp for generating simple app without hassle (not yet available in open-source).Using @tramvai/test-integration and @tramvai/test-puppeteer you may perform any kind of tests including testing in browser. "},{"title":"Deploy​","type":1,"pageTitle":"How to create Child App?","url":"docs/how-to/how-create-child-app#deploy","content":"Build your child-app with command tramvai build [name]Copy generated files from ./dist/child-app (by default) to the external cdnProvide link to the cdn itself through token CHILD_APP_RESOLVE_BASE_URL_TOKEN or env CHILD_APP_EXTERNAL_URL "},{"title":"How to create a papi handler?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-papi","content":"","keywords":""},{"title":"Automatic handler creation​","type":1,"pageTitle":"How to create a papi handler?","url":"docs/how-to/how-create-papi#automatic-handler-creation","content":"Based on the configuration parameter application.commands.build.options.serverApiDir in tramvai.json (by default folder ./src/api) the directory where the papi handlers are stored is determined. Create a new file in this folder with the name of our new handler, i.e. getSum.ts for our example. The default export from the file will be used as a handler, create it: export default () => { return 'hello'; }; Copy We restart the server so that the new handler is added to the papi list. The result of the function call will be used as the body of the response, so now if we turn to the address http://localhost:3000/tincoin/papi/getSum, then in the response we will receive an object with the property payload: 'hello'. Next, let's add logic to our handler: import { Req } from '@tramvai/papi'; // import is needed only for typing, you can do without it or use types from express export default (req: Req) => { const { body: { a, b }, method, } = req; // get all the necessary information from the request object if (method !== 'POST') { throw new Error('only post methods'); // throw an error if we want to process only certain http methods } if (!a || !b) { // check that the required request parameters have been passed return { error: true, message: 'body parameters a and b should be set', }; } return { error: false, result: +a + +b }; // return the result, not forgetting to do all conversions on strings }; Copy There is no need to restart the build, @tramvai/cli will rebuild everything itself after saving the changes to disk. Now you can make a POST request to http://localhost:3000/tincoin/papi/getSum, pass the parameters a and b and get the result. "},{"title":"Creating a handler via provider​","type":1,"pageTitle":"How to create a papi handler?","url":"docs/how-to/how-create-papi#creating-a-handler-via-provider","content":"If you need to use other application dependencies from di in the handler, you can add a provider with the SERVER_MODULE_PAPI_PUBLIC_ROUTE token: // ... import { createPapiMethod } from '@tramvai/papi'; import { SERVER_MODULE_PAPI_PUBLIC_ROUTE } from '@tramvai/tokens-server'; import { LOGGER_TOKEN } from '@tramvai/tokens-common'; import { provide } from '@tramvai/core'; createApp({ // ... providers: [ // ... provide({ provide: SERVER_MODULE_PAPI_PUBLIC_ROUTE, multi: true, useFactory: ({ logger }: { logger: typeof LOGGER_TOKEN }) => { const log = logger('ping-pong'); return createPapiMethod({ method: 'get', path: '/ping', async handler() { log.error('/ping requested'); // log with the error level to see the log for sure return 'pong'; }, }); }, deps: { logger: LOGGER_TOKEN, }, }), ], }); Copy Now you can make a request to the address http://localhost:3000/tincoin/papi/ping, in the response we will receive an object with the property payload: 'pong', in the terminal with the running process tramvai start ${APP_ID} we will see the error log /ping requested. "},{"title":"Additional links​","type":1,"pageTitle":"How to create a papi handler?","url":"docs/how-to/how-create-papi#additional-links","content":"ServerModule documentation "},{"title":"How to create a module?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-module","content":"","keywords":""},{"title":"Create an empty module​","type":1,"pageTitle":"How to create a module?","url":"docs/how-to/how-create-module#create-an-empty-module","content":"We create a basic module, to do this we create an empty class SecurityModule and connect the decorator Module which is required for modules and in which we will add integrations with the application. import { Module } from '@tramvai/core'; @Module({ providers: [], }) export class SecurityModule {} Copy The module can already be plugged into the application, but it won't do anything. "},{"title":"Adding providers​","type":1,"pageTitle":"How to create a module?","url":"docs/how-to/how-create-module#adding-providers","content":"To do this we need to add providers in the providers field. We had the task to add the headers, for that we will use commandLineListTokens to perform actions for each client and we will use responseManager to which we can write the information about the headers. import { Module, commandLineListTokens, RESPONSE_MANAGER_TOKEN, provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: commandLineListTokens.resolvePageDeps, multi: true, useFactory: ({ responseManager }: { responseManager: typeof RESPONSE_MANAGER_TOKEN }) => function securityHeader() { responseManager.setHeader('X-Frame-Options', 'sameorigin'); }, deps: { responseManager: RESPONSE_MANAGER_TOKEN, }, }), ], }) export class SecurityModule {} Copy We have implemented a new multi-provider that has dependencies and is created through useFactory After plugging the module into the application, for each client the useFactory function will be executed first with the deps passed and then the securityHeader function will be called, in which we will write the data into the obtained dependency and thus fulfill our goal. "},{"title":"Include our new module in the application​","type":1,"pageTitle":"How to create a module?","url":"docs/how-to/how-create-module#include-our-new-module-in-the-application","content":"Now it remains to plug the module into the application so that it can add its implementation: import { createApp } from '@tramvai/core'; import { SecurityModule } from '@tramvai/module-security'; createApp({ modules: [SecurityModule], }); Copy We can add the module not only to the application, but also to another module. To do this, we need to pass in the imports block and then when the MyCommonModule is connected, the SecurityModule will also be automatically connected import { Module } from '@tramvai/core'; import { SecurityModule } from '@tramvai/module-security'; @Module({ imports: [SecurityModule], providers: [], }) export class MyCommonModule {} Copy "},{"title":"Summary​","type":1,"pageTitle":"How to create a module?","url":"docs/how-to/how-create-module#summary","content":"A SecurityModule was created, which will be called for each client and will add the necessary headers Documentation about modulesDocumentation about createAppDocumentation about DI "},{"title":"How to debug modules?","type":0,"sectionRef":"#","url":"docs/how-to/how-debug-modules","content":"","keywords":""},{"title":"Displaying logs on the server​","type":1,"pageTitle":"How to debug modules?","url":"docs/how-to/how-debug-modules#displaying-logs-on-the-server","content":"The server log settings are set in the LOG_LEVEL and LOG_ENABLE environment variables, if needed, you can change these settings in runtime, through the papi method /{appName}/private/papi/logger with additional query parameters. You can read more about the available parameters in the documentation @tramvai/module-log LOG_ENABLE='router' // displays all logs for the logger with the ID `router` Copy "},{"title":"Displaying logs on the browser​","type":1,"pageTitle":"How to debug modules?","url":"docs/how-to/how-debug-modules#displaying-logs-on-the-browser","content":"Client logs settings are controlled by methods of the @tinkoff/logger library. These settings are stored in the localStorage, so to display all client logs with new settings, you must additionally reload the page, or clear the localStorage. import logger from '@tinkoff/logger'; logger.enable('router'); // displays all logs for the logger with the ID `router` Copy "},{"title":"How to enable modern mode for an application?","type":0,"sectionRef":"#","url":"docs/how-to/how-enable-modern","content":"","keywords":""},{"title":"Configuring tramvai.json​","type":1,"pageTitle":"How to enable modern mode for an application?","url":"docs/how-to/how-enable-modern#configuring-tramvaijson","content":"We need to enable building code for modern versions of browsers. To do this, add the modern: true parameter to tramvai.json: { \"projects\": { \"tincoin\": { \"name\": \"tincoin\", \"root\": \"src\", \"type\": \"application\", \"commands\": { \"build\": { \"options\": { \"vendor\": \"src/vendor.js\", \"polyfill\": \"src/polyfill.ts\", \"server\": \"src/index.ts\" }, \"configurations\": { \"modern\": true } } } } } } Copy After that, @tramvai/cli will build two versions of each js file: ES5 and ES2017 After these steps, we will build statics for 2 packs of browsers and RenderModule will give the ES2017-compatible code for modern browsers. "},{"title":"How to enable polyfills?","type":0,"sectionRef":"#","url":"docs/how-to/how-to-enable-polyfills","content":"","keywords":""},{"title":"Setup​","type":1,"pageTitle":"How to enable polyfills?","url":"docs/how-to/how-to-enable-polyfills#setup","content":"Install polyfills pack​ npm i --save @tinkoff/pack-polyfills Copy Create a file polyfill.ts​ You need to create a file polyfill.ts inside your project, for example src/polyfill.ts and connect the polyfills inside: import '@tinkoff/pack-polyfills'; Copy Set up @tramvai/cli​ After that, we need to tell @tramvai/cli that our project has polyfills. To do this, in tramvai.json we add for our project the line \"polyfill: \"src/polyfill.ts\" in projects[APP_ID].commands.build.options.polyfill example: { \"projects\": { \"pfphome\": { \"name\": \"pfphome\", \"root\": \"src\", \"type\": \"application\", \"commands\": { \"build\": { \"options\": { \"server\": \"src/index.ts\", \"vendor\": \"src/vendor.ts\", \"polyfill\": \"src/polyfill.ts\" } } } } } } Copy "},{"title":"How polyfills loading works​","type":1,"pageTitle":"How to enable polyfills?","url":"docs/how-to/how-to-enable-polyfills#how-polyfills-loading-works","content":"On the @tramvai/cli side, we have configured to build the polyfills into a separate file, so it doesn't mix with the main code. On every build we will have a file with polyfills. module-render if it finds polyfills in the build, then for each client embeds inline code that checks the availability of features in the browser and if the browser does not support any of the features, then we consider the browser is legacy and load polyfills. An example of a check: !window.Promise.prototype.finally || !window.URL || !window.URLSearchParams || !window.AbortController || !window.IntersectionObserver || !Object.fromEntries' "},{"title":"Replacing the polyfills loading check​","type":1,"pageTitle":"How to enable polyfills?","url":"docs/how-to/how-to-enable-polyfills#replacing-the-polyfills-loading-check","content":""},{"title":"Why would it be necessary?​","type":1,"pageTitle":"How to enable polyfills?","url":"docs/how-to/how-to-enable-polyfills#why-would-it-be-necessary","content":"If you do not fit the standard check for supported features in the browser and polyfills do not load in browsers where they should. In this case, it is better to create issue and we will update the check, or you can replace the check with another. "},{"title":"Important tips​","type":1,"pageTitle":"How to enable polyfills?","url":"docs/how-to/how-to-enable-polyfills#important-tips","content":"POLYFILL_CONDITION should return true if the browser does not support some featuresYou should not load polyfiles into all browsersIt is better to extend DEFAULT_POLYFILL_CONDITION with additional checks, rather than replacing it "},{"title":"Replacing the check​","type":1,"pageTitle":"How to enable polyfills?","url":"docs/how-to/how-to-enable-polyfills#replacing-the-check","content":"To do this, we need to set provider POLYFILL_CONDITION, which is in import { POLYFILL_CONDITION } from '@tramvai/module-render' and pass a new line. Example: This is a synthetic example, but suppose we want to additionally check for the presence of window.Promise in the browser, to do this we extend DEFAULT_POLYFILL_CONDITION string. The resulting expression should return true if the browsers do not support the feature. import { POLYFILL_CONDITION, DEFAULT_POLYFILL_CONDITION } from '@tramvai/module-render'; import { provide } from '@tramvai/core'; const provider = provide({ provide: POLYFILL_CONDITION, useValue: `${DEFAULT_POLYFILL_CONDITION} || !window.Promise`, }); Copy "},{"title":"Adding endpoint handler for an application","type":0,"sectionRef":"#","url":"docs/how-to/server-add-path-handler","content":"Adding endpoint handler for an application Tramvai gives you the ability to process any application url yourself, via tokens WEB_APP_BEFORE_INIT_TOKEN и WEB_APP_INIT_TOKEN Example of adding handlers import { createApp, provide } from '@tramvai/core'; import { WEB_APP_BEFORE_INIT_TOKEN, WEB_APP_INIT_TOKEN } from '@tramvai/module-server'; import { LOGGER_TOKEN } from '@tramvai/module-common'; import { modules } from '../common'; createApp({ name: 'server', modules: [...modules], bundles: {}, providers: [ provide({ // Subscribe to WEB_APP_BEFORE_INIT_TOKEN event to subscribe to all default handlers provide: WEB_APP_BEFORE_INIT_TOKEN, multi: true, useFactory: ({ logger }) => { const log = logger('my-path'); // di should get the function from the web application return (app) => { app.use('/my-path', (req, res, next) => { // there will be no cookies in the req because you signed up before setting the cookieParser in @tramvai/module-server log.error('request start!', !!req.cookies); next(); }); }; }, deps: { logger: LOGGER_TOKEN, }, }), provide({ // Subscribe to WEB_APP_INIT_TOKEN event to subscribe to the default root handler provide: WEB_APP_INIT_TOKEN, multi: true, useFactory: ({ logger }) => { const log = logger('my-path'); return (app) => { app.use('/my-path', (req, res) => { // The cookies in the req here will already be there since they signed up after setting the cookieParser in @tramvai/module-server log.error('request start!', !!req.cookies); res.send({ hello: 'world', cookies: req.cookies }); }); }; }, deps: { logger: LOGGER_TOKEN, }, }), ], }); Copy","keywords":""},{"title":"SSR with async components","type":0,"sectionRef":"#","url":"docs/how-to/ssr-async-components","content":"SSR with async components When using dynamic import to load React components, we lose the ability to render them on the server. This problem is solved by the library @tramvai/react lazy Example of connecting a lazy component in a bundle import { createApp, createBundle } from '@tramvai/core'; import { lazy } from '@tramvai/react'; import { modules } from '../common'; const bundle = createBundle({ name: 'mainDefault', components: { // wrap the import in a lazy call so that the component is successfully rendered on the server // and the scripts/styles for the component are preloaded on the client pageDefault: lazy(() => import('./pages/page')), }, }); createApp({ name: 'ssr-async-components', modules: [...modules], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), }, }); Copy","keywords":""},{"title":"How to update tramvai version?","type":0,"sectionRef":"#","url":"docs/how-to/tramvai-update","content":"","keywords":""},{"title":"Upgrading to a latest version​","type":1,"pageTitle":"How to update tramvai version?","url":"docs/how-to/tramvai-update#upgrading-to-a-latest-version","content":"tramvai update by default use latest: tramvai update Copy "},{"title":"Upgrading to a specific version​","type":1,"pageTitle":"How to update tramvai version?","url":"docs/how-to/tramvai-update#upgrading-to-a-specific-version","content":"Third argument allows you to specify the version range or exact version: tramvai update ^1 Copy or tramvai update 1.0.0 Copy "},{"title":"Installing the new tramvai package in the app​","type":1,"pageTitle":"How to update tramvai version?","url":"docs/how-to/tramvai-update#installing-the-new-tramvai-package-in-the-app","content":"tramvai add <packageName> by default installs the package to dependencies: tramvai add @tramvai/module-router Copy The --dev flag will install the package to devDependencies: tramvai add @tramvai/test-unit --dev Copy "},{"title":"Checking tramvai versions in the app​","type":1,"pageTitle":"How to update tramvai version?","url":"docs/how-to/tramvai-update#checking-tramvai-versions-in-the-app","content":"The utility @tramvai/tools-check-versions has been created to automatically check the synchronization of tramvai versions. To check, you need to run the command: yarn tramvai-check-versions Copy "},{"title":"analyze command","type":0,"sectionRef":"#","url":"docs/references/cli/analyze","content":"","keywords":""},{"title":"See what is got bundled​","type":1,"pageTitle":"analyze command","url":"docs/references/cli/analyze#see-what-is-got-bundled","content":"The special webpack plugin webpack-bundle-analyzer able to show every modules get bundled For running analyze npx tramvai analyze APP_ID Copy After that app will be built in prod mode and a new tab in browser will be opened "},{"title":"Figure out why dependency got bundled​","type":1,"pageTitle":"analyze command","url":"docs/references/cli/analyze#figure-out-why-dependency-got-bundled","content":"With that can help utility whybundled that parses the webpack stats.json file and can show the reason why dependency has been added to bundle Run next command npx tramvai analyze APP_ID --plugin whybundled Copy After that a special version of stats.json can be found inside outputClient directory. The exact path will be showed in your terminal Next, you can run whybundled to resolve reasons: # why `debug` got bundled npx whybundled ./dist/client/stats.json debug # what dependencies were bundled because of the `debug` package npx whybundled ./dist/client/stats.json --by debug Copy See more options in the whybundled docs "},{"title":"Using @tramvai/react-query library","type":0,"sectionRef":"#","url":"docs/how-to/react-query-usage","content":"","keywords":""},{"title":"Basic example with createQuery and useQuery​","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#basic-example-with-createquery-and-usequery","content":" Expand import React from 'react'; import { createQuery, useQuery } from '@tramvai/react-query'; import { FAKE_API_CLIENT } from '../../fakeApiClient'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get<string>('api/base'); await new Promise((resolve) => setTimeout(resolve, 50)); return payload; }, deps: { apiClient: FAKE_API_CLIENT, }, }); // eslint-disable-next-line import/no-default-export export default function Component() { const { data, isLoading } = useQuery(query); return <div>{isLoading ? 'loading...' : data}</div>; } Copy  "},{"title":"Preloading data on the server for useQuery​","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#preloading-data-on-the-server-for-usequery","content":" Expand import React from 'react'; import { createQuery, useQuery } from '@tramvai/react-query'; import { FAKE_API_CLIENT } from '../../fakeApiClient'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get<string>('api/base'); await new Promise((resolve) => setTimeout(resolve, 50)); return payload; }, deps: { apiClient: FAKE_API_CLIENT, }, }); // eslint-disable-next-line import/no-default-export export default function Component() { const { data, isLoading } = useQuery(query); return <div>{isLoading ? 'loading...' : data}</div>; } Component.actions = [query.prefetchAction()]; Copy  "},{"title":"Sharing useQuery data between components​","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#sharing-usequery-data-between-components","content":" Expand import React, { useState, useEffect } from 'react'; import { createQuery, useQuery } from '@tramvai/react-query'; import { FAKE_API_CLIENT } from '../../fakeApiClient'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get<string>('api/base'); await new Promise((resolve) => setTimeout(resolve, 5000)); return payload; }, deps: { apiClient: FAKE_API_CLIENT, }, }); const Child1 = () => { const { isLoading, data } = useQuery(query); return <div>Child1: {isLoading ? 'loading...' : data}</div>; }; const Child2 = () => { const { isLoading, data } = useQuery(query); return <div>Child2: {isLoading ? 'loading...' : data}</div>; }; const Child3 = () => { const { isLoading, data } = useQuery(query); return <div>Child3: {isLoading ? 'loading...' : data}</div>; }; // eslint-disable-next-line import/no-default-export export default function Component() { const [child2, setChild2Visible] = useState(false); const [child3, setChild3Visible] = useState(false); useEffect(() => { setTimeout(() => { setChild2Visible(true); }, 3000); setTimeout(() => { setChild3Visible(true); }, 7000); }, []); return ( <> <Child1 /> {child2 && <Child2 />} {child3 && <Child3 />} </> ); } Copy  "},{"title":"Passing parameters for the request​","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#passing-parameters-for-the-request","content":" Expand import React, { useState, useEffect } from 'react'; import { createQuery, useQuery } from '@tramvai/react-query'; import { FAKE_API_CLIENT } from '../../fakeApiClient'; const query = createQuery({ key: (parameter: string) => ['api-group', parameter], fn: async (parameter, { apiClient }) => { console.log(`request to ${parameter}`); const { payload } = await apiClient.get<string>(`api/group/${parameter}`); await new Promise((resolve) => setTimeout(resolve, 5000)); return payload; }, deps: { apiClient: FAKE_API_CLIENT, }, }); const Child1 = () => { const { isLoading, data } = useQuery(query, 'test-1'); return <div>Child1: {isLoading ? 'loading...' : data}</div>; }; const Child2 = () => { const { isLoading, data } = useQuery(query, 'test-1'); return <div>Child2: {isLoading ? 'loading...' : data}</div>; }; const Child3 = () => { const { isLoading, data } = useQuery(query, 'test-2'); return <div>Child3: {isLoading ? 'loading...' : data}</div>; }; // eslint-disable-next-line import/no-default-export export default function Component() { const [child2, setChild2Visible] = useState(false); const [child3, setChild3Visible] = useState(false); useEffect(() => { setTimeout(() => { setChild2Visible(true); }, 3000); setTimeout(() => { setChild3Visible(true); }, 7000); }, []); return ( <> <Child1 /> {child2 && <Child2 />} {child3 && <Child3 />} </> ); } Copy  "},{"title":"Setting react-query parameters​","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#setting-react-query-parameters","content":" Expand import React from 'react'; import { createQuery, useQuery } from '@tramvai/react-query'; import { FAKE_API_CLIENT } from '../../fakeApiClient'; const query = createQuery({ key: 'time', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get<string>('api/time'); return payload; }, deps: { apiClient: FAKE_API_CLIENT, }, queryOptions: { refetchOnWindowFocus: true, refetchOnMount: true, }, }); // eslint-disable-next-line import/no-default-export export default function Component() { const { data } = useQuery( query.fork({ refetchInterval: 2000, refetchIntervalInBackground: false, }) ); return <div>{data}</div>; } Copy  "},{"title":"Failed requests​","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#failed-requests","content":" Expand import React from 'react'; import { createQuery, useQuery } from '@tramvai/react-query'; import { FAKE_API_CLIENT } from '../../fakeApiClient'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get('api/fail'); return payload; }, deps: { apiClient: FAKE_API_CLIENT, }, queryOptions: { retryDelay: 500, }, }); // eslint-disable-next-line import/no-default-export export default function Component() { const { data, isLoading, isError, error } = useQuery(query); if (isLoading) { return <div>loading...</div>; } if (isError) { return <div>error: {error!.message}</div>; } return <div>{data}</div>; } Copy  "},{"title":"Using conditions for query​","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#using-conditions-for-query","content":" Expand import React from 'react'; import { createQuery, useQuery } from '@tramvai/react-query'; import { FAKE_API_CLIENT } from '../../fakeApiClient'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get('api/auth'); return payload; }, deps: { apiClient: FAKE_API_CLIENT, }, conditions: { onlyServer: true, }, }); // eslint-disable-next-line import/no-default-export export default function Component() { const { data = 'no-data', isLoading } = useQuery(query); return <div>{isLoading ? 'loading...' : data}</div>; } Copy  "},{"title":"Basic example for createInfiniteQuery and useInfiniteQuery​","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#basic-example-for-createinfinitequery-and-useinfinitequery","content":" Expand import React from 'react'; import { createInfiniteQuery, useInfiniteQuery } from '@tramvai/react-query'; import { FAKE_API_CLIENT } from '../../fakeApiClient'; interface Response { nextPage?: number; list: string[]; } const query = createInfiniteQuery({ key: 'list', fn: async (_, start = 0, { apiClient }) => { const { payload } = await apiClient.get<Response>('api/list', { query: { count: 30, start, }, }); return payload; }, getNextPageParam: (page: Response) => { return page.nextPage; }, deps: { apiClient: FAKE_API_CLIENT, }, infiniteQueryOptions: {}, }); // eslint-disable-next-line import/no-default-export export default function Component() { const { data, isLoading, fetchNextPage, hasNextPage } = useInfiniteQuery(query); if (isLoading) { return <>loading...</>; } return ( <div> <div> {data!.pages.map((page) => { return page.list.map((entry) => { return <div key={entry}>{entry}</div>; }); })} </div> {hasNextPage && ( <button type=\"button\" onClick={() => fetchNextPage()}> Load more </button> )} </div> ); } Copy  "},{"title":"Basic example for createMutation and useMutation​","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#basic-example-for-createmutation-and-usemutation","content":" Подробнее import React from 'react'; import { createMutation, useMutation } from '@tramvai/react-query'; import { FAKE_API_CLIENT } from '../../fakeApiClient'; const mutation = createMutation({ key: 'post', fn: async (_, data: string, { apiClient }) => { const { payload } = await apiClient.post('api/post', { body: { data, }, }); return payload; }, deps: { apiClient: FAKE_API_CLIENT, }, }); // eslint-disable-next-line import/no-default-export export default function Component() { const { isLoading, mutate } = useMutation(mutation); if (isLoading) { return <>loading...</>; } return ( <button type=\"button\" onClick={() => mutate('test')}> Send data </button> ); } Copy  "},{"title":"Integration with browserslist","type":0,"sectionRef":"#","url":"docs/references/cli/browserslist","content":"","keywords":""},{"title":"Supported envs for browserslist​","type":1,"pageTitle":"Integration with browserslist","url":"docs/references/cli/browserslist#supported-envs-for-browserslist","content":"In cli only specific list of supported env targets is used for browserslist: modern - used for builds supposed to be provided for modern browsersnode - used for builds running on serverdefaults - used otherwise, usually for outdated browsers "},{"title":"cli setup​","type":1,"pageTitle":"Integration with browserslist","url":"docs/references/cli/browserslist#cli-setup","content":"By default, cli uses browserslist config from a library @tinkoff/browserslist-config. To extend or override default settings, you can use any of the methods for browserslist config following next rules: It is allowed to change config only for envs from the list used in cli. How to do it see browserslist docs. If some of env is not defined, the default config for the env will be used.If you want to extend default settings then use the ability to extend config \"browserslist\": { \"modern\": [ \"extends @tinkoff/browserslist-config\", \"chrome > 25\" ], \"node\": [ \"extends @tinkoff/browserslist-config\" ], \"defaults\": [ \"extends @tinkoff/browserslist-config\", \"chrome > 27\" ] } Copy If you want to narrow down the supported list of the browsers, then do not use extends @tinkoff/browserslist-config and specify list of the supported browsers yourself. Take the default list from the @tinkoff/browserslist-config as a basis. Do it for every env if you need it. Not overrided env will use default settings. "},{"title":"Debug​","type":1,"pageTitle":"Integration with browserslist","url":"docs/references/cli/browserslist#debug","content":"You can test how browserslist works using next commands: npx browserslist --env=modern # list of the modern browsers npx browserslist --env=node # list of the supported nodejs versions npx browserslist # list of the browsers including legacy one Copy "},{"title":"Caveats​","type":1,"pageTitle":"Integration with browserslist","url":"docs/references/cli/browserslist#caveats","content":""},{"title":"autoprefixer​","type":1,"pageTitle":"Integration with browserslist","url":"docs/references/cli/browserslist#autoprefixer","content":"Because of the some internal restrictions of the autoprefixer build will be executed only using defaults config. If you really interested in this feature, please, create an issue on the github. "},{"title":"Base","type":0,"sectionRef":"#","url":"docs/references/cli/base","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Base","url":"docs/references/cli/base#installation","content":"Global installation on the developer machine. After that the new command tramvai will be available in terminal. npm i -g @tramvai/cli Copy Local installation to the project npm i --save-dev @tramvai/cli Copy "},{"title":"API​","type":1,"pageTitle":"Base","url":"docs/references/cli/base#api","content":""},{"title":"Commands​","type":1,"pageTitle":"Base","url":"docs/references/cli/base#commands","content":"After any command you can pass --help string, e.g. tramvai --help or tramvai start --help. After that you will see description of the command and its options. tramvai new - generate new tramvai app with @tramvai/clitramvai start - run app in the development modetramvai start-prod - run app in development mode, but code will be build in the production modetramvai build - build an app for server and clienttramvai analyze - analyze bundle sizetramvai generate - code generation for different components. E.g. new projects, react components, actions and etc.tramvai update - update @tramvai/cli and all of the @tramvai and @tramvai-tinkoff dependencies in the project. This command additionally executes dependency deduplication and code migrationstramvai add - add @tramvai or @tramvai-tinkoff dependency to the app. This command additionally executes dependency deduplication and code migrations "},{"title":"Explanation​","type":1,"pageTitle":"Base","url":"docs/references/cli/base#explanation","content":""},{"title":"Notifications settings​","type":1,"pageTitle":"Base","url":"docs/references/cli/base#notifications-settings","content":"Inside tramvai.json the settings for the notification can be specified at path commands.serve.notifications. Parameters are passed to webpack-build-notifier. You can specify global configuration or a specific configuration either for client or server build. \"commands\": { \"serve\": { \"notifications\": { \"suppressSuccess\": \"always\", \"server\": { \"suppressWarning\": true }, \"client\": { \"activateTerminalOnError\": true } } } } Copy "},{"title":"CSS class names generation settings​","type":1,"pageTitle":"Base","url":"docs/references/cli/base#css-class-names-generation-settings","content":"Name generation is configured via the options cssLocalIdentNameDev and cssLocalIdentNameProd (common option cssLocalIdentName might be used to specify settings for both prod and dev). \"commands\": { \"build\": { \"configurations\": { \"postcss\": { \"cssLocalIdentName\": \"[hash:base64:5]\", // default value (deprecated) \"cssLocalIdentNameDev\": \"[name]__[local]_[minicss]\", // available values see in the docs to [css-loader](https://github.com/webpack-contrib/css-loader) \"cssLocalIdentNameProd\": \"[minicss]\", // additionally new tag `minicss` can be used for the generating minimal css names. Based on [article](https://dev.to/denisx/reduce-bundle-size-via-one-letter-css-classname-hash-strategy-10g6) }; }; }; }; Copy "},{"title":"Polyfills for the standard NodeJS modules​","type":1,"pageTitle":"Base","url":"docs/references/cli/base#polyfills-for-the-standard-nodejs-modules","content":"By default, webpack starting with 5th version, do not add polyfills to browser bundle when using nodejs standard modules in the browser code, e.g. when using crypto, path, process, buffer, etc. @tramvai/cli explicitly adds polyfills for path and process modules as these modules are often used and lightweighted. "},{"title":"Checking TypeScript types​","type":1,"pageTitle":"Base","url":"docs/references/cli/base#checking-typescript-types","content":"Checking types is enabled by flag checkAsyncTs. When running tramvai start ts compilation and type checks will be executed. Inside tramvai.json \"checkAsyncTs\": { \"failOnBuild\": true, // optional \"pluginOptions\": {} // optional }, Copy failOnBuild adds type checks when running tramvai build. This way build will fail in case of wrong types. pluginOptions – list of the additional options for the plugin fork-ts-checker-webpack-plugin If you want to override path to tsconfig through pluginOptions.tsconfig the option should be specified relative to the @tramvai/cli folder itself e.g. node_modules/@tramvai/cli. By default tsconfig is expected to be in the project root directory: \\<rootDir>/tsconfig.json "},{"title":"Deduplication of modules​","type":1,"pageTitle":"Base","url":"docs/references/cli/base#deduplication-of-modules","content":"Option commands.build.configurations.dedupe controls the settings of plugin for the deduplication process. Available options are: \"equality\" - uses strict version comparison. Dedupes modules in node_modules with equal package version that are imported from different sources. E.g. imports for node_modules/package/index.js and node_modules/nested-package/node_modules/package/index.js are deduped into a single node_modules/package/index.js import whilst without dedupe it will bundle two files as separate modules.\"semver\" - compares version of packages based on semver. It can dedupe all of the imports with the same major version and any of the minor and patch versions. E.g. next versions will be deduped: from 1.14.0 and 1.16.2 to 1.16.2, from 0.14.1 and 0.16.5 to 0.16.5, whilst versions 0.0.2 and 0.0.5 will be left without deduplication.false - disable deduplication, by default "},{"title":"Debug an app​","type":1,"pageTitle":"Base","url":"docs/references/cli/base#debug-an-app","content":"While developing sometimes it is needed to debug nodejs app directly so see CPU, memory consumptions etc. To do it the options --debug might be passed to commands start and start-prod which do next: enables source maps for build on client and serverstarts the server process with the flag --inspect. After that you can open debugger in the chrome devtools - chrome://inspect Source Maps​ webpack offers several kind of sourcemap qualities. Some of the examples are: Source code - the code before transpilation and bundling. Snapshot of the source code, splitted by modulesTransformed code - the code after transpilation by loaders (etc. babel-loader), splitted by modulesGenerated code - the code after transpilation and bundling, splitted by modules. Every import and exported are replaced by webpack wrapper code For development source maps for transformed or generated code is used as it is more performant and shows the exact code that is executed in the target environment. The main differences from the debugging without sourcemaps is that code has links to modules to original source files. tramvai generates big single bundle with server code and that's why it is preferred to not include sourcemaps in the code itself and put it to the separate .js.map file. Development​ By default, for browser is used the fastest sourcemaps, while for server no sourcemaps is used. Flag --debug enables sourcemap generation for the server bundle. Option commands.serve.configurations.sourceMap enables sourcemap generation both for browser and server code. Production​ By default, sourcemaps are disabled both for the client and server code. Flag --debug enables sourcemaps generation for the client and server bundles. Option commands.build.configurations.sourceMap enables sourcemap generation for the client bundle. Option commands.build.configurations.sourceMapServer enables sourcemap generation for the server bundle. "},{"title":"How to​","type":1,"pageTitle":"Base","url":"docs/references/cli/base#how-to","content":""},{"title":"Code generation​","type":1,"pageTitle":"Base","url":"docs/references/cli/base#code-generation","content":"For make life easier for developers @tramvai/cli has ability to automatically generate code with template. For running code generator use command tramvai generate and pick up one of the options available to generate that entity: actionbundlereducerpagecomponentmodule After that template files will be generated "},{"title":"Generate new project​","type":1,"pageTitle":"Base","url":"docs/references/cli/base#generate-new-project","content":"For the quick start of new project you can use command tramvai new that will generate new base project with the tramvai and tramvai-cli install tramvai-cli globallyenter command tramvai new NAME_YOUR_APP in the shellchoose options based on your preferences: monorepo or multirepo, CI integration and testing framework After command execution and dependency installation new project will be ready to use "},{"title":"How to run nodejs app in debug mode?​","type":1,"pageTitle":"Base","url":"docs/references/cli/base#how-to-run-nodejs-app-in-debug-mode","content":"Add flag --debug when running app tramvai start my-app --debug Copy Then open chrome devTools, click on NodeJs logo in the upper left corner. New window with the nodejs devtools will be opened that allows to debug memory and cpu usage, debug code and take the performance profiles. "},{"title":"Get details for deprecated and warning logs​","type":1,"pageTitle":"Base","url":"docs/references/cli/base#get-details-for-deprecated-and-warning-logs","content":"It might be useful to get the stacktraces of some of the warnings. E.g., while running app if you see logs like this (node:2898) DeprecationWarning: ... (Use `node --trace-deprecation ...` to show where the warning was created) Copy You may add flag --trace in order to run nodejs server with the additional options. tramvai start my-app --trace Copy After that these logs will be printed with their stacktraces "},{"title":"How to use browserstack for testing​","type":1,"pageTitle":"Base","url":"docs/references/cli/base#how-to-use-browserstack-for-testing","content":"To get access to browserstack just type command /bs in slack Run app as usual with tramvai start command and follow the browsertack instruction for the local development. If everything were done right you will be able to get access to localhost inside browserstack and test your app through it. "},{"title":"How to test app on mobile or other device in local network​","type":1,"pageTitle":"Base","url":"docs/references/cli/base#how-to-test-app-on-mobile-or-other-device-in-local-network","content":"Both devices one that running the app and one for testing must reside in the same network. For setting access through local network follow next steps: figure out the ip of the machine that runs apprun command tramvai start with flag --staticHost with value of the ip address that was resolved on previous step (e.g. tramvai start tincoin --staticHost 192.168.1.3)from the testing device open the new page in the browser and use the ip address from the previous step as domain name When calling @tramvai/cli using npm you need to pass -- before any additional arguments, e.g. command should look similar to this npm start -- --staticHost 192.168.1.3 "},{"title":"build command","type":0,"sectionRef":"#","url":"docs/references/cli/build","content":"build command Command tramvai build can build libraries to separate bundles for various environments: CommonJS modules + ES2019 code (for nodejs without ESM support) - it uses field main in package.jsonES modules + ES2019 code (for nodejs with ESM support) - it uses filed module in package.jsonES modules + ES2019 code (for browsers) - it uses field browser in package.json @tramvai/cli use @tramvai/build package under the hood for bundling packages. To specify new library in tramvai.json add new project with the type package: { \"projects\": { \"{{packageName}}\": { \"name\": \"{{packageName}}\", \"type\": \"package\", \"root\": \"libs/{{packageName}}\" } } } Copy Library settings should be specified in the package.json of the library itself: { \"name\": \"{{packageName}}\", \"version\": \"1.0.0\", \"main\": \"dist/index.js\", // main library entry point \"browser\": \"dist/browser.js\", // optional field, library entry point for browsers bundle \"typings\": \"src/index.ts\", // \"sideEffects\": false, \"scripts\": { \"start\": \"tramvai build {{packageName}} --watchMode\", // watch mode to develop package \"build\": \"tramvai build {{packageName}} --forPublish\" // single time build for the production } } Copy See the complete documentation about output targets, configuration and many reciepes in @tramvai/build documentation.","keywords":""},{"title":"Experimental settings","type":0,"sectionRef":"#","url":"docs/references/cli/experiments","content":"","keywords":""},{"title":"Webpack settings​","type":1,"pageTitle":"Experimental settings","url":"docs/references/cli/experiments#webpack-settings","content":"Webpack by itself has a list of experimental flags which might be passed directly to webpack through experiments.webpack. "},{"title":"Defaults​","type":1,"pageTitle":"Experimental settings","url":"docs/references/cli/experiments#defaults","content":"cacheUnaffected=true - should improve build performance in serve mode "},{"title":"minicss​","type":1,"pageTitle":"Experimental settings","url":"docs/references/cli/experiments#minicss","content":"Flags are specified through experiments.minicss and allows to enable experimental settings for mini-css-extract-plugin useImportModule - enables a special way to compile css modules that should improve build time and decrease memory usage. More details in the official docs "},{"title":"Defaults​","type":1,"pageTitle":"Experimental settings","url":"docs/references/cli/experiments#defaults-1","content":"useImportModule=true - enabled by default as this improves build time and provides better css related error descriptions "},{"title":"Configuration","type":0,"sectionRef":"#","url":"docs/references/cli/config","content":"","keywords":""},{"title":"config file format​","type":1,"pageTitle":"Configuration","url":"docs/references/cli/config#config-file-format","content":"{ \"projects\": { \"react-app\": { \"name\": \"new-app\", \"root\": \"src\", \"type\": \"application\", \"commands\": { \"build\": { \"options\": { ... }, \"configurations\": { ... } }, \"serve\": { \"configurations\": { ... } } } } } } Copy projects - map of the projects that resides in the current repository. @tramvai/cli supports many apps and packages inside single repository (so called monorepo concept). "},{"title":"Поддержка JSON схемы файла конфигурации в IDE​","type":1,"pageTitle":"Configuration","url":"docs/references/cli/config#поддержка-json-схемы-файла-конфигурации-в-ide","content":""},{"title":"JSON schema validation and autocomplete in IDEs​","type":1,"pageTitle":"Configuration","url":"docs/references/cli/config#json-schema-validation-and-autocomplete-in-ides","content":"Link to the actual json schema for the tramvai.json is ./node_modules/@tramvai/cli/schema.json The most simple way to add config validation and autocomplete is to add schema through field $schema inside tramvai.json: { \"$schema\": \"./node_modules/@tramvai/cli/schema.json\", \"projects\": {} } Copy Another way is to add schema to the IDE settings: How to add schema to the JetBrains IDE you can find in the official docs. You also need to set tramvai.json as file path pattern in settings. How to add schema to the VSCode you can find in the official docs New projects generated by tramvai new command already has field $schema in their tramvai.json config. "},{"title":"Настройки для build этапа​","type":1,"pageTitle":"Configuration","url":"docs/references/cli/config#настройки-для-build-этапа","content":"\"commands\": { \"build\": { \"options\": { \"vendor\": \"\", // path to the vendor file. If not provided vendor bundle will not be generated \"polyfill\": \"\", // path to the polyfill file with all of the required polyfills. If not provided vendor bundle will not be generated \"server\": \"src/server\", // path to the server entry point \"outputServer\": \"dist/server\", // folder to output server bundle \"outputClient\": \"dist/client\" // folder to output client bundle }, \"configurations\": { \"commonChunk\": true, // enables generation common chunk that includes shared code between chunks \"commonChunkSplitNumber\": 3, // number of different chunks that should link to code in order to put that code in commonChunk \"sourceMap\": false, // is client sourcemaps are enabled \"sourceMapServer\": false, // is server sourcemaps are enabled \"modern\": true, // enable separate client bundle for the modern browsers only \"checkAsyncTs\": false, // enables background type checks \"terserParallel\": true, // enables parallel terser compression \"granularChunks\": false, // enables splitting commonChunk to many independent pieces. It may significantly reduce js size on some pages \"granularChunksSplitNumber\": 2, // number of duplicates before move code to the granular chunk \"generateDataQaTag\": false, // @deprecated automatically generate unique id for react components \"definePlugin\": { // replaces passed strings with passed values in the build time \"prod\": {}, \"dev\": {} }, \"threadLoader\": { // config for the multithread build process (https://webpack.js.org/loaders/thread-loader/). }, \"postcss\": { // config for the postcss-loader \"cssLocalIdentName\": \"[hash:base64:5]\", // specifies identifier for the css class names \"config\": \"postcss.config\" // path to the postcss.config file }, \"alias\": {}, // alias config. More details in the [docs](https://www.npmjs.com/package/babel-plugin-module-resolver) \"removeTypeofWindow\": true, // enables babel plugin transform-define that will replace code `typeof window` to 'undefined' or 'object' depending on the environment \"dedupe\": \"equality\" | \"semver\" | false, // controls the deduplication plugin \"svgo\": { \"plugins\": [{ \"cleanupIDs\": false }, { \"collapseGroups\": false }], // svgo plugins (https://github.com/svg/svgo#what-it-can-do) }, \"imageOptimization\": { // config for the process of the image optimizations enabled: true, // enable image optimization options: {} // options for the detailed settings (https://github.com/tcoopman/image-webpack-loader#options) } } } } Copy "},{"title":"Add new config parameters​","type":1,"pageTitle":"Configuration","url":"docs/references/cli/config#add-new-config-parameters","content":"Config parameters for the @tramvai/cli are stored as TypeScript interface from which JSON Schema is generating. This schema is used for the config validation and applying config defaults, thanks to the library ajv. "},{"title":"Putting inline code for the client on server","type":0,"sectionRef":"#","url":"docs/references/cli/serverInline","content":"","keywords":""},{"title":"Solution​","type":1,"pageTitle":"Putting inline code for the client on server","url":"docs/references/cli/serverInline#solution","content":"For clients transpilation is already happens using wepback and babel that targets specific browsers. That way we can reuse that transpilation for client code in order to build specific code on the server which is intended to use on client-side. Rules for transpiling specific code for clients on the server: code for insertion must be placed in separate fileinside that file no imports should be used as it requires webpack runtime which won't know about server modules on the clientcode itself should be defined as exported function and these functions can use only passed arguments. Using external variables is not possiblethe name of the file should end on .inline(.es)?.[tj]s. It works as a marker to transpile this file with a client configinstead on inline code put to the insertion place the string with call of the exported function with passing arguments to it. Thanks to the fact that conversion function to string returns the body of the function itself it should work on the client "},{"title":"Example​","type":1,"pageTitle":"Putting inline code for the client on server","url":"docs/references/cli/serverInline#example","content":"Create new file test.inline.ts with the inline code export const test = (arg: string) => { class Test { log() { console.log({ arg, a: 1, }); } } const t = new Test(); t.log(); }; Copy Import the exported function and put it to the initial html import { Module } from '@tramvai/core'; import { RENDER_SLOTS, ResourceType, ResourceSlot } from '@tramvai/module-render'; import { test } from './test.inline'; @Module({ providers: [ { provide: RENDER_SLOTS, multi: true, useFactory: () => { const arg = 'Hello'; return { slot: ResourceSlot.HEAD_SCRIPTS, type: ResourceType.inlineScript, // Please, note that we are using function like we are adding new iife function, but instead of adding the body of function manually we are using import from the module // And when passing string as arguments we should additionally wrap it with quotes payload: `(${test})('${arg}')`, }; }, }, ], }) export class CustomModule {} Copy After building the project and requesting the page, the browser should get the code looking like that instead of source code <script> (function test(arg) { var Test = /*#__PURE__*/ (function () { function Test() {} var _proto = Test.prototype; _proto.log = function log() { console.log({ arg: arg, a: 1, }); }; return Test; })(); var t = new Test(); t.log(); })('Hello'); </script> Copy "},{"title":"start command","type":0,"sectionRef":"#","url":"docs/references/cli/start","content":"","keywords":""},{"title":"Enable sourcemaps in dev mode​","type":1,"pageTitle":"start command","url":"docs/references/cli/start#enable-sourcemaps-in-dev-mode","content":"In tramvai.json \"commands\": { \"serve\": { \"configurations\": { \"sourceMap\": true } } } Copy "},{"title":"modern build and dev-mode​","type":1,"pageTitle":"start command","url":"docs/references/cli/start#modern-build-and-dev-mode","content":"In dev-mode may work only single build mode: either modern or legacy. By default legacy is used. If you want to use modern build in dev mode, add next lines to the tramvai.json: \"commands\": { \"serve\": { \"configurations\": { \"modern\": true } } } Copy "},{"title":"How to​","type":1,"pageTitle":"start command","url":"docs/references/cli/start#how-to","content":""},{"title":"Speed up development build​","type":1,"pageTitle":"start command","url":"docs/references/cli/start#speed-up-development-build","content":"Build only specific bundles​ App may contain of many bundles and the more there bundle, the more code get bundled to the app, the more long in building and rebuilding the app during development. In order to speed up that process when running @tramvai/cli it is possible to specify bundles required for the development and cli will build only that bundles. Bundles should be placed in directory bundles and should be imported from the index app file. When trying to request bundle that was disabled, server will fail with status 500, as it is unexpected condition for the server that bundle is missing # if you need only single bundle during development tramvai start myapp --onlyBundles=account # if you need several bundles tramvai start myapp --onlyBundle=account,trading Copy "},{"title":"browserslist-config","type":0,"sectionRef":"#","url":"docs/references/libs/browserslist-config","content":"","keywords":""},{"title":"Api​","type":1,"pageTitle":"browserslist-config","url":"docs/references/libs/browserslist-config#api","content":""},{"title":"defaults​","type":1,"pageTitle":"browserslist-config","url":"docs/references/libs/browserslist-config#defaults","content":"Contains config for every supported browser "},{"title":"modern​","type":1,"pageTitle":"browserslist-config","url":"docs/references/libs/browserslist-config#modern","content":"Contains config for, so called \"modern\" browser. Browser's versions in this list are higher than for defaults and these browsers support more functionality "},{"title":"node​","type":1,"pageTitle":"browserslist-config","url":"docs/references/libs/browserslist-config#node","content":"Contains config for nodejs "},{"title":"legacy​","type":1,"pageTitle":"browserslist-config","url":"docs/references/libs/browserslist-config#legacy","content":"Config for legacy but still supported browsers. Currently this is equal to defaults "},{"title":"browser-timings","type":0,"sectionRef":"#","url":"docs/references/libs/browser-timings","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"browser-timings","url":"docs/references/libs/browser-timings#installation","content":"Install npm package npm i --save @tinkoff/browser-timings Copy "},{"title":"How to​","type":1,"pageTitle":"browser-timings","url":"docs/references/libs/browser-timings#how-to","content":"import { browserTimings } from '@tinkoff/browser-timings'; window.addEventListener('load', () => { setTimeout(() => { // setTimeout is necessary in order to get metrics about loadEventEnd const perfData = browserTimings(); }, 0); }); Copy After executing perfData will contain client performance metrics which may be send to any external system for further analysis. Call of the library should be executed only after page load in order to get actual data. Otherwise, it may return empty object without data. "},{"title":"Lib interface​","type":1,"pageTitle":"browser-timings","url":"docs/references/libs/browser-timings#lib-interface","content":"export interface Timings { /* Connection timing from client to server */ connection: number; /* How much time backend was preparing response */ backend: number; /* Page download to client */ pageDownload: number; /* Timing of first paint for a page */ 'first-paint': number; /* Timing when DOM becomes interactive */ domInteractive: number; /* DOM building is complete */ domComplete: number; /* Page and every resource were loaded */ pageLoadTime: number; /* Common information about resources and its loading time grouped by type */ download: { html: TimingResource; js: TimingResource; css: TimingResource; img: TimingResource; font: TimingResource; other: TimingResource; }; } interface TimingResource { /* Timing of resource loading */ duration: number; /* Byte-size measure of data used by resource */ encodedDecodeSize: number; /* Byte-size measure of data transferred by network. Calculating difference between encodedDecodeSize - transferSize may reveal how much data where stored in browser cache */ transferSize: number; } Copy "},{"title":"error-handlers","type":0,"sectionRef":"#","url":"docs/references/libs/error-handlers","content":"","keywords":""},{"title":"Api​","type":1,"pageTitle":"error-handlers","url":"docs/references/libs/error-handlers#api","content":"globalErrorHandler = (logger: Logger = console) - init logging of global errorsunhandledRejectionHandler = (logger: Logger = console) - init logging of unhandled rejection promise "},{"title":"Parameters​","type":1,"pageTitle":"error-handlers","url":"docs/references/libs/error-handlers#parameters","content":"Logger - used for logging errors export interface Logger { warn: Function; error: Function; } Copy "},{"title":"express-terminus","type":0,"sectionRef":"#","url":"docs/references/libs/express-terminus","content":"","keywords":""},{"title":"Features​","type":1,"pageTitle":"express-terminus","url":"docs/references/libs/express-terminus#features","content":"healthChecks handlers are creater for an express app, in contrast to original library which redefines request event handler of server object. Original behaviour is more complicated in case of a need to add common logic for every request in the app, including healthChecks itself. E.g. it was not possible to add http-header in single place to make it work for every request. "},{"title":"eslint-plugin-tramvai","type":0,"sectionRef":"#","url":"docs/references/libs/eslint-plugin-tramvai","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"eslint-plugin-tramvai","url":"docs/references/libs/eslint-plugin-tramvai#installation","content":"Install necessary packages first npm i --save-dev @tinkoff/eslint-config @tinkoff/eslint-config-react @tinkoff/eslint-plugin-tramvai Copy Add recommended settings to .eslintrc: { \"extends\": [ \"@tinkoff/eslint-config/app\", \"@tinkoff/eslint-config-react\", \"plugin:@tinkoff/tramvai/recommended\" ] } Copy Or add plugin manually: { \"extends\": [ \"@tinkoff/eslint-config/app\", \"@tinkoff/eslint-config-react\" ], \"plugins\": [ \"@tinkoff/tramvai\" ], \"rules\": { \"@tinkoff/tramvai/bundle-chunk-name\": \"warn\" } } Copy "},{"title":"Rules​","type":1,"pageTitle":"eslint-plugin-tramvai","url":"docs/references/libs/eslint-plugin-tramvai#rules","content":""},{"title":"bundle-chunk-name​","type":1,"pageTitle":"eslint-plugin-tramvai","url":"docs/references/libs/eslint-plugin-tramvai#bundle-chunk-name","content":"In a tramvai app, in order to work properly with the bundle system it is necessary to put a special comment for dynamic imports. This rule checks that dynamic imports of bundles are marked with a proper control comment webpackChunkName: [name]. The rule also provides autofix in order to add add/fix control comment automatically. Example of the wrong code: createApp({ bundles: { 'tramvai/bundle-1': () => import('./bundles/bundle1'), 'tramvai/bundle-2': () => import(/* webpackChunkName: \"randomValue\" */ './bundles/bundle2'), }, }); Copy Example of the right code after autofix for the code above: createApp({ bundles: { 'tramvai/bundle-1': () => import(/* webpackChunkName: \"bundle-1\" */ './bundles/bundle1'), 'tramvai/bundle-2': () => import(/* webpackChunkName: \"bundle-2\" */ './bundles/bundle2'), }, }); Copy Options: propertyNames: defines array of object properties which will be analyzed. By default it equals to [\"bundles\"]. "},{"title":"hooks","type":0,"sectionRef":"#","url":"docs/references/libs/hooks","content":"","keywords":""},{"title":"Explanation​","type":1,"pageTitle":"hooks","url":"docs/references/libs/hooks#explanation","content":"Working with lib consist of two phases: Adding in the target code hook runner call, e.g. runAsyncHooks, with unique event key and additional parameters. It creates a slot for this event that allow to subscribe on the event.Registering hook handler with registerHooks that will be executed when run... function will be called "},{"title":"Caveats​","type":1,"pageTitle":"hooks","url":"docs/references/libs/hooks#caveats","content":"There is different types hooks that are not interoperable. So carefully add new registrations with checking expected hook type. Also you should preserve data chain, e.g. return data with same interface from hook, as it otherwise may break other hooks. "},{"title":"API​","type":1,"pageTitle":"hooks","url":"docs/references/libs/hooks#api","content":"Hooks​ Create new instance of @tinkoff/hook-runner import { Hooks } from '@tinkoff/hook-runner'; const hookRunner = new Hooks(); Copy registerHooks(key, hooks)​ Register new hook for a specific key. runHooks(key, context, payload, options)​ Execute sync hooks. payload is passed through every hook and will be returned as a result (it may be changed by hooks). runAsyncHooks(key, context, payload, options)​ Executes async hooks using setTimeout. payload is passed to every hook with its initial value. runPromiseHooks(key, context, options) => (payload) => Promise​ Execute promise-based hooks. payload is passed through every hook and will be returned as a result (it may be changed by hooks) "},{"title":"Hooks​","type":1,"pageTitle":"hooks","url":"docs/references/libs/hooks#hooks-1","content":""},{"title":"Types​","type":1,"pageTitle":"hooks","url":"docs/references/libs/hooks#types","content":"sync​ Accepts (context, payload, options). Hooks are running in order passing previous hook result as input for next hook. async​ Accepts (context, payload, options). Hooks are running independently from each other. promise​ Accepts (context, payload, options). Hooks are running in order passing previous hook result as input for next hook with wrapping call in promise. "},{"title":"is-modern-lib","type":0,"sectionRef":"#","url":"docs/references/libs/is-modern-lib","content":"","keywords":""},{"title":"Usage​","type":1,"pageTitle":"is-modern-lib","url":"docs/references/libs/is-modern-lib#usage","content":"Based on example from the article Publish, ship, and install modern JavaScript // webpack.config.js const { modernLibsFilter } = require('@tinkoff/is-modern-lib'); module.exports = { module: { rules: [ // Transpile for your own first-party code: { test: /\\.[cm]?js$/i, loader: 'babel-loader', exclude: /node_modules/, }, // Transpile modern dependencies: { test: /\\.[cm]?js$/i, include: modernLibsFilter, use: { loader: 'babel-loader', options: { babelrc: false, configFile: false, presets: ['@babel/preset-env'], }, }, }, ], }, }; Copy "},{"title":"http-client","type":0,"sectionRef":"#","url":"docs/references/libs/http-client","content":"","keywords":""},{"title":"API​","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#api","content":""},{"title":"HttpClient​","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#httpclient","content":"type HttpClient = { // common method for sending HTTP requests request<P = any>(request: HttpClientRequest): Promise<HttpClientResponse<P>>; // method for sending GET requests get<R = any>( path: string, payload?: Pick<HttpClientRequest, 'query' | 'headers'>, config?: Omit<HttpClientRequest, 'url' | 'query' | 'body' | 'headers'> ): Promise<HttpClientResponse<R>>; // method for sending POST requests, uses `requestType: 'json'` by default post<R = any>( path: string, payload?: Pick<HttpClientRequest, 'query' | 'body' | 'headers'>, config?: Omit<HttpClientRequest, 'url' | 'query' | 'body' | 'headers'> ): Promise<HttpClientResponse<R>>; // method for sending PUT requests, uses `requestType: 'json'` by default put<R = any>( path: string, payload?: Pick<HttpClientRequest, 'query' | 'body' | 'headers'>, config?: Omit<HttpClientRequest, 'url' | 'query' | 'body' | 'headers'> ): Promise<HttpClientResponse<R>>; // method for sending DELETE requests delete<R = any>( path: string, payload?: Pick<HttpClientRequest, 'query' | 'headers'>, config?: Omit<HttpClientRequest, 'url' | 'query' | 'body' | 'headers'> ): Promise<HttpClientResponse<R>>; // method for creating a new instance of the HTTP client, based on the settings of the current fork(options?: HttpClientRequest, mergeOptionsConfig?: { replace?: boolean }): HttpClient; } Copy "},{"title":"HttpClientRequest​","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#httpclientrequest","content":"type HttpClientRequest = { // absolute url of the request, do not use simultaneously with `path` url?: string; // url of the request, not to be used simultaneously with `url` path?: string; // base url, which is added to all queries before the `path` value baseUrl?: string; // basic HTTP methods are supported - GET, POST, PUT, DELETE method?: HttpMethod; // request data type, `form` by default requestType?: HttpContentType; // response data type, is calculated from the `content-type` header by default responseType?: HttpContentType; // HTTP request headers headers?: Record<string, any>; // request query parameters query?: Record<string, any>; // request body body?: Record<string, any>; // request execution time limit, in ms timeout?: number; // disabling logging inside the HTTP client. It is recommended to use if a request error is logged manually silent?: boolean; // disabling the request cache cache?: boolean; // if `abortPromise` is resolved, the request will be canceled abortPromise?: Promise<void>; // method to modify request data modifyRequest?: (req: HttpClientRequest) => HttpClientRequest; // method to modify response data modifyResponse?: <P = any>(res: HttpClientResponse<P>) => HttpClientResponse<P>; // method to modify the error object modifyError?: (error: HttpClientError, req: HttpClientRequest) => HttpClientError; [key: string]: any; } Copy "},{"title":"HttpClientResponse​","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#httpclientresponse","content":"type HttpClientResponse<P = any> = { // response body payload: P; // HTTP response code status: number; // HTTP response headers headers: Record<string, any>; } Copy "},{"title":"HttpClientError​","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#httpclienterror","content":"type HttpClientError = Error & { [key: string]: any; } Copy "},{"title":"ApiService​","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#apiservice","content":"ApiService - abstract class for easy creation of services for working with API, allows you to override custom logic in the request method, on top of which the rest of the basic methods work. For example, a service that automatically displays a pop-up window when a request error occurs: class CustomApiService extends ApiService { constructor({ httpClient }: { httpClient: HttpClient }) { super(httpClient); } request<R = any>(request: HttpClientRequest): Promise<HttpClientResponse<R>> { return this.httpClient.request(request).catch((error) => { alert(error); }); } } const service = new CustomApiService({ httpClient }); service.request({ path: 'fake' }) // show alert service.get('fake') // also show alert Copy "},{"title":"Layout factory","type":0,"sectionRef":"#","url":"docs/references/libs/layout-factory","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Layout factory","url":"docs/references/libs/layout-factory#installation","content":"Install @tinkoff/layout-factory using your package manager, e.g. for npm: npm i @tinkoff/layout-factory Copy Create new layout object import React from 'react'; import { createLayout } from '@tinkoff/layout-factory'; import { Content, Page, Feedback } from './components'; import { layoutWrapper, feedbackWrapper } from './wrappers'; const MyLayout = createLayout({ components: { page: Page, content: Content, feedback: Feedback, }, wrappers: { layout: layoutWrapper, feedback: feedbackWrapper, }, }); Copy "},{"title":"Layout structure​","type":1,"pageTitle":"Layout factory","url":"docs/references/libs/layout-factory#layout-structure","content":"Layout has the following structure: <LayoutWrapper> {globalComponents} <ContentWrapper> <HeaderWrapper> <Header /> </HeaderWrapper> <PageWrapper>{page}</PageWrapper> <FooterWrapper> <Footer /> </FooterWrapper> </ContentWrapper> </LayoutWrapper> Copy Any of the wrappers could be customized. By default, every wrapper just renders passed children prop, but HeaderWrapper and FooterWrapper render only if components Header and Footer were passed as props to result layout. "},{"title":"Customization ways​","type":1,"pageTitle":"Layout factory","url":"docs/references/libs/layout-factory#customization-ways","content":"Customization is made through options components and wrappers "},{"title":"Components​","type":1,"pageTitle":"Layout factory","url":"docs/references/libs/layout-factory#components","content":"React components header, footer, layout, content, page are base components for wrappers. They should render passed prop children. By default, layout, content, page are \"render children\" while header and footer are \"render prop\"any of the other components are, so called, globalComponents. They are just rendered as components inside LayoutWrapper "},{"title":"Wrappers​","type":1,"pageTitle":"Layout factory","url":"docs/references/libs/layout-factory#wrappers","content":"HOC for components header, footer, layout, content, page - HOC for the base componentsall of the other components are HOCs for все остальные wrappers - HOC for corresponding globalComponents It is possible to pass a list of HOCs. This way order of render wrapping for passed component will be from end to start of the list. Such wrappers and used for: hide/show elements by conditionset additional css style for componentsinject additional code/handlerpass additional props Example of such wrapper: function layoutWrapper(WrappedComponent) { return (props) => ( <div className=\"ui-layout\"> <WrappedComponent {...props} /> </div> ); } Copy "},{"title":"meta-tags-generate","type":0,"sectionRef":"#","url":"docs/references/libs/meta-tags-generate","content":"","keywords":""},{"title":"Api​","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#api","content":"Meta({ list: [] }): Meta - object used for constructing an instance of meta-tags based on passed sourcesRender(meta: Meta): { render(): string } - render of specific Meta instance as a string. Used in SSRUpdate(meta: Meta): { update(): void } - updates meta-tags layout in browser. Used in browser while SPA-navigations "},{"title":"Format​","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#format","content":"Library accepts special parameters which are used to generate result html tags. These parameters have next format: { customTag: { tag: 'meta', attributes: { name: 'k', content: 'i' }, innerHtml: '1' } } Copy thar renders in the next tag: <meta name=\"k\" content=\"i\">1</meta> Copy "},{"title":"Converters​","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#converters","content":"Converters are used to convert meta-tags with specific keys in format view new Meta({ list, converters: { title: (value) => ({ tag: 'meta', innerHtml: value }) } }); Copy After that you now can pass meta as { title: 'Тинькофф' } in order to render it through converter above. "},{"title":"Sources​","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#sources","content":"Through options list can be passed sources for meta-tags generating. These sources have the form of function that are called in runtime for generating result render. E.g.: const list = [ (walker) => walker.updateMeta(10, { title: 'test', tag: { tag: 'meta', attributes: { link: 'link' } }, }), (walker) => walker.updateMeta(20, { title: 'tinkoff', ogTitle: 'tinkoff', }), ]; const meta = new Meta({ list, converters }); Copy When generating meta tags all functions passed in list will be called with argument of class Walker. Inside such function it is possible to modify data using method updateMeta, which accepts the priority of the change and value. Elements with higher priority overrides values with lower priorities. "},{"title":"How to​","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#how-to","content":""},{"title":"Set Meta​","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#set-meta","content":"import { Meta, Render, Update } from '@tinkoff/meta-tags-generate'; const list = [ (walker) => walker.updateMeta(10, { title: 'test', tag: { tag: 'meta', attributes: { link: 'link' } }, }), ]; const meta = new Meta({ list, converters }); const metaContent = new Render(meta).render(); console.log(metaContent); // > <title>test</title><meta link=link/> new Update(meta).update(); // Removes all previous meta and adds new one Copy "},{"title":"Remove meta parameters​","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#remove-meta-parameters","content":"In order to remove data just pass null as a value. E.g. if you want to remove keywords meta: (walker) => walker.updateMeta(30, { keywords: null, }); Copy After that specified meta tag will be remove "},{"title":"minicss","type":0,"sectionRef":"#","url":"docs/references/libs/minicss","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"minicss","url":"docs/references/libs/minicss#installation","content":"Install using yarn yarn add --dev @tinkoff/minicss-class-generator Copy or npm npm i --save-dev @tinkoff/minicss-class-generator Copy "},{"title":"Setup​","type":1,"pageTitle":"minicss","url":"docs/references/libs/minicss#setup","content":"Define options localIdentName и getLocalIdent for css-loader config inside your webpack config: ({ loader: 'css-loader', options: { modules: { getLocalIdent: createGenerator(), localIdentName: '[minicss]', }, }, }); Copy For localIdentName it is possible to pass any template which is accepted by css-loader. E.g. if you want to add the origin filename and the className pass [name]__[local]_[minicss] as localIdentName "},{"title":"How does it work​","type":1,"pageTitle":"minicss","url":"docs/references/libs/minicss#how-does-it-work","content":"Plugin generate unique key for a className using formula ${order}${contentHash} where contentHash is a hash of the source file content and order - ordered key of class definition inside source file. Using contentHash from source allows to generate less unique string and allows to reuse the same contentHash for every className that leads for better data compression with gzip/brotli. Using order helps sustain uniqueness for every className in single source file. Examples: [hash:base64:5] file: Button.css .2hlLi .32BZU Copy [minicss] file: Button.css .abhUzy .bbhUzy Copy "},{"title":"logger","type":0,"sectionRef":"#","url":"docs/references/libs/logger","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#installation","content":"Install using package manager, e.g. for npm: npm i --save @tinkoff/logger Copy for yarn: yarn add @tinkoff/logger Copy "},{"title":"Api​","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#api","content":""},{"title":"Child loggers​","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#child-loggers","content":"You can create child loggers using method .child of the current logger instance. Child logger will inherit parent logger settings and can override these settings. const log = logger({ name: 'test' }); const childLog = log.child('child'); // as this logger is child logger the result name will be 'test.child' const childLogWithDefaults = log.child({ name: 'withDefaults', defaults: { // defaults might be used to specify properties which will be merged to log objects logged with this logger child: true, }, }); const childLogWithOverrides = log.child({ name: 'override', reporters: [], // may override settings of the parent logger filters: [], extensions: [], }); Copy "},{"title":"Display logs​","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#display-logs","content":"Library allows to specify used logging level, show/hide logs for specific instances of the logger, reset display settings. By default, error level is used for every logger. Settings display level higher than error for single logger, e.g. logger.enable('info', 'my-logger'), overrides logging level only for my-logger. It is impossible to set logging level lower than common level, e.g. when using common logging level equal to error calls to logger.enable('fatal', 'my-logger') changes nothing. All subsequent setup for log displaying are preserved, e.g. subsequent calls logger.enable('info', 'my-logger') and logger.enable('trace', 'yet-another-logger') will enable logs to both logger according to their settings. Display logs on server​ For control of displaying logs on server environment variables LOG_LEVEL and LOG_ENABLE are used: LOG_LEVEL = trace | debug | info | warn | error | fatal - enables displaying logs for specified level and higher. E.g.: if LOG_LEVEL=info then all logs of levels info, warn, error, fatal will be showed. LOG_ENABLE = ${name} | ${level}:${name} - let to enable displaying logs for a specific name and level. It can accept several entries that are passed as comma-separated. E.g.: if LOG_ENABLE=server then all logs for name server will be displayedif LOG_ENABLE=trace:server* then for logs with name server only trace level will be showedif LOG_ENABLE=info:server,client,trace:shared then displaying logs will be enabled for specified loggers using rules above Display logs in browser​ In browser display settings are stored in localStorage, so it will work even after page reloads. In order to reset settings you may clear localStorage. For convenient usage a special object logger is added to window object in the browser. logger === window.logger; logger.setLevel('warn'); // enable displaying log for level `warn` and higher logger.enable('info', 'test'); // enable displaying logs for logger `test` with level `info` также отображать вывод логгера test уровня info logger.enable('my-logger'); // show all logs for logger `my-logger` logger.enable('perf*'); // enable all logs with name starting with `perf` logger.disable('my-logger'); // disable displaying logs for `my-logger` logger.clear(); // reset all settings Copy "},{"title":"Configuration​","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#configuration","content":"Local logger configuration​ import { logger } from '@tinkoff/logger'; const log = logger({ name: 'my-logger' }); // name is required field in order to identify logs const log = logger('my-logger'); // same as above const log = logger({ name: 'remote-logger', defaults: { remote: true, }, }); Copy Options: name[='log'] - name of the new logger "},{"title":"Extend logger functionality​","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#extend-logger-functionality","content":"@tinkoff/logger might be extended using next entities: Filter​ Filters can disable logging for specific logs base on inner conditions import { logger } from '@tinkoff/logger'; interface Filter { filter(logObj: LogObj): boolean; } logger.addFilter(filter as Filter); // add new filter to list of previously added filters logger.setFilters([filter1, filter2]); // replace current filters with passed list. that allows to override default settings Copy Extension​ Extensions can extend or override log object before making actual logging import { logger } from '@tinkoff/logger'; interface Extension { extend(logObj: LogObj): LogObj; } logger.addExtension(extension as Extension); // add new extension to list of previously added extensions logger.setExtensions([extension1, extension2]); // replace current extensions with passed list. that allows to override default settings Copy Reporter​ Reporters can change the way logs are showed (json, fancy logs in browser, send logs to remote api). Be default, enabled only reporters for displaying logs in console based on display logs settings Reporters are depends of logger level settings as reporters will not be called if level of the current log are lower than display logs setting import { logger } from '@tinkoff/logger'; interface Reporter { log(logObj: LogObj): void; } logger.addReporter(reporter as Reporter); // add new reporter to list of previously added reporters logger.setReporters([reporter1, reporter2]); // replace current reporters with passed list. that allows to override default settings Copy BeforeReporter​ Same as usual Reporter but BeforeReporter are called unconditionally for every log and get called before any other extension. import { logger } from '@tinkoff/logger'; interface Reporter { log(logObj: LogObj): void; } logger.addBeforeReporter(reporter as Reporter); // add new beforeReporter to list of previously added beforeReporter logger.setBeforeReporters([reporter1, reporter2]); // replace current beforeReporters with passed list. that allows to override default settings Copy "},{"title":"Bundled Reporters​","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#bundled-reporters","content":"BrowserReporter​ Standard reporter to show logs in browser NodeDevReporter​ Standard reporter to showing logs in the server console with handy formatting Used by default in dev-mode or if environment variable process.env.DEBUG_PLAIN is specified. NodeBasicReporter​ Minimal reporter to showing logs in the server console. JSONReporter​ Show logs in json format. RemoteReporter​ Sends logs on remote api. import { logger, RemoteReporter } from '@tinkoff/logger'; const remote = new RemoteReporter({ requestCount: 1, // number of parallel request emitLevels: { error: true, fatal: true }, // log levels which will be send to api async makeRequest(logObj) { // function that accepts log object and sends data to api return await request(); }, }); logger.addReporter(remote); const log = logger({ name: 'test-remote' }); // settings for remote will be inherited from RemoteReporter itself log.error('error'); // will be sent to api log.info('test'); // will not be sent to api const remoteLog = logger({ name: 'remote-for-all', remote: true }); // `remote` allows to override settings from RemoteReporter and send logs unconditionally remoteLog.info('test'); // will be sent to api remoteLog.debug('test'); // will be sent to api const traceLog = logger({ name: 'log-trace', emitLevels: { trace: true } }); // override RemoteReporter settings traceLog.trace('test'); // will be sent to api traceLog.error('test'); // will not be sent to api Copy "},{"title":"How to​","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#how-to","content":""},{"title":"Base usage​","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#base-usage","content":"import logger from '@tinkoff/logger'; // import logger const log = logger('my-component'); // create new logger with an id `my-component`. This id will be added for every log at field `name`. Using unique ids will help to find source of the logs // logs can be created with different levels log.trace('trace'); log.debug('debug'); log.info({ event: 'client-visited', message: 'client visited tinkoff.ru' }); log.warn('warn'); log.error({ event: 'form-send-error', error: new Error('form') }); log.fatal('fatal error'); Copy More about logging level and what do they mean in the article. "},{"title":"How to log properly​","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#how-to-log-properly","content":"To log properly it is suitable to use next format: interface Log { event?: string; // unique id of event which is might be easily found in log management tool message?: string; // log description error?: Error; // error if appropriate [key]: any; // any other data } Copy In case of logging simple text just use string template to pass result string to logger. For json format this string will be available in the message props. logger.info('hello logger'); // identical to logger.info({ message: 'hello logger' }); Copy In order to log some object or many arguments, compile they together to single object: logger.warn({ message: 'be warn', event: 'my-warning', ...obj1, ...obj2, a: 1, b: 2, }); Copy In order to log error object either pass the error with the props error or pass it to logger as only argument logger.error({ error: new Error('message'), }); logger.error(new Error('message')); logger.error(new Error('typeError'), 'custom error message'); // a special format to redefine error message Copy In case of several arguments were passed to logger then only the first argument will be proceeded with the rules from above while all of the other arguments will be passed as an args props logger.debug( { event: 'watch', data: 'some data', }, 'arg2', 'arg3' ); Copy These formatting rules are handful to connect logging to external tools like kibana, splunk. So it is desirable to follow these rules, otherwise it may lead to troubles with searching and analyzing your logs. "},{"title":"Troubleshooting​","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#troubleshooting","content":""},{"title":"I use logger in my Nest.js application, and it does not work​","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#i-use-logger-in-my-nestjs-application-and-it-does-not-work","content":"Be sure that you set all required environment variable (LOG_LEVEL and LOG_ENABLE) before app initialization. If you set all variable in .env and parse them via Nest.js's ConfigModule, they will not be available in the logger initialization phase. ConfigModule parses .env-file later. Also, check here that DEBUG_PLAIN or NODE_ENV variables are available. "},{"title":"module-loader-client","type":0,"sectionRef":"#","url":"docs/references/libs/module-loader-client","content":"","keywords":""},{"title":"Установка​","type":1,"pageTitle":"module-loader-client","url":"docs/references/libs/module-loader-client#установка","content":"Для yarn: yarn add @tinkoff/module-loader-client Copy Для npm: npm install @tinkoff/module-loader-client Copy "},{"title":"Подключение и использование​","type":1,"pageTitle":"module-loader-client","url":"docs/references/libs/module-loader-client#подключение-и-использование","content":""},{"title":"loadModule​","type":1,"pageTitle":"module-loader-client","url":"docs/references/libs/module-loader-client#loadmodule","content":"В loadModule встроена дедубликация загрузки через поиск уже вставленного скрипта с тем же урлом, что позволяет инициировать загрузку скриптов на этапе разбора html, в этом случае вы должны самостоятельно навесить атрибут loaded скрипту, чтобы метод loadModule понимал загружен скрипт или еще нет: <script src=\"https://cdn.example.com/bundle.js\" onload=\"this.setAttribute('loaded', true)\" onerror=\"this.setAttribute('loaded', 'error')\" /> Copy Пример использования: import { loadModule } from '@tinkoff/module-loader-client'; loadModule('https://cdn.example.com/js/module.js', { cssUrl: 'https://cdn.example.com/js/module.css', // опционально }).then(() => { // ... }); Copy "},{"title":"addScript​","type":1,"pageTitle":"module-loader-client","url":"docs/references/libs/module-loader-client#addscript","content":"Вставляет тег script без какой-либо допольнительной логике по дедубликации: import { addScript } from '@tinkoff/module-loader-client'; addScript(src, maybeAttrs, maybeScriptHandler).then(() => something()); Copy Коллбэк вызывается сихронно, в который передается непосредственно script элемент. "},{"title":"addLink​","type":1,"pageTitle":"module-loader-client","url":"docs/references/libs/module-loader-client#addlink","content":"Вставляет тег link без какой-либо допольнительной логике по дедубликации: import { addLink } from '@tinkoff/module-loader-client'; addLink(type, href, maybeAttrs).then(() => something()); Copy "},{"title":"Интерфейс и типы​","type":1,"pageTitle":"module-loader-client","url":"docs/references/libs/module-loader-client#интерфейс-и-типы","content":" type LogFunction = (...args: unknown[]) => void; export interface Logger { trace: LogFunction; debug: LogFunction; info: LogFunction; warn: LogFunction; error: LogFunction; } export interface LoadModuleOptions { cssUrl?: string; } Copy  "},{"title":"mocker","type":0,"sectionRef":"#","url":"docs/references/libs/mocker","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#installation","content":"Install @tinkoff/mocker: npmYarn npm install @tinkoff/mocker Copy Add your first mock to file mocks/first-api.js: module.exports = { api: 'first-api', mocks: { 'GET /endpoint': { status: 200, headers: {}, payload: 'mocked response', }, }, }; Copy Set up mocker in your project: import { Mocker, FileSystemMockRepository } from '@tinkoff/mocker'; // Repository will read mocks from directory `mocks` relative from current dir const repository = new FileSystemMockRepository({ cwd: process.cwd(), root: 'mocks' }); // Mocker to all of the request on `/first-api/...` will response with mock found in fs or with proxying request to the source API const options = { apis: { 'first-api': { target: 'https://real-first-api.com/', }, }, passUnhandledRequests: true, }; const mocker = new Mocker({ options, repository, logger: console }); (async () => { // with this call mocker reads mocks from repository and creates according routes await mocker.init(); mocker.start(4000, () => { console.log('Mocker is running at 4000 port'); }); })(); Copy Now we can make a GET request to mocker (async () => { const response = await fetch('http://localhost:4000/first-api/endpoint'); const data = await response.json(); console.log(data); // \"mocked response\" })(); Copy "},{"title":"Explanation​","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#explanation","content":"Library is based on express. mocker can be used as standalone server or as a middleware for existing server through call mocker.use(req, res). FileSystemMockRepository supports mock in js и json formats. js mocks are able to define custom express handler as a mock handler. For choosing right mock for request next parameters of the request are considered: method, url and query. Mocker supports proxying requests to API that allows to mock only part of the API and not a whole backend "},{"title":"Routing​","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#routing","content":"If mocker is running as a standalone server, for example on 4000 port, then it will be accessible at url http://localhost:4000/. For every api from settings options.apis will be created a nester router, e.g. for first-api it will be http://localhost:4000/first-api/. Routes for api are getting created based on mocks, in which key is a method + url of the request, e.g. mock GET /endpoint will be accessible at http://localhost:4000/first-api/endpoint for GET requests. "},{"title":"FileSystem mocks​","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#filesystem-mocks","content":"Mocker reads mocks using Repository, that allows to store mocks in FileSystem or on the another server. FileSystemMockRepository works with FileSystem and supports next kinds of mocks: mock.json { \"api\": \"first-api\", \"mocks\": { \"GET /foo\": { \"status\": 200, \"headers\": {}, \"payload\": { \"fake\": \"true\" } } } } Copy mock.js module.exports = { api: 'first-api', mocks: { 'GET /bar': { status: 200, headers: {}, payload: { fake: 'true', }, }, 'POST /bar': (req, res) => { res.status(200); res.set('X-Mock-Server', 'true'); res.json({ fake: 'true' }); }, }, }; Copy "},{"title":"API​","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#api","content":""},{"title":"Mocker​","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#mocker","content":"interface Mocker { new (params: { options: MockerOptions; repository: MockRepository; logger: Logger }): Mocker; init(): Promise<void>; update(): Promise<void>; use(req: IncomingMessage, res: ServerResponse): express.Express; start(port: number, callback?: (...args: any[]) => void): Server; } Copy Mocker.init - resolve mocks using MockRepository, routing initialization. Must be called before using server with mocks. Mocker.update - updating mocks using MockRepository, routing update. Might be called in runtime. Mocker.use - express middleware. Might be used for adding mocker on the existing server. Mocker.start - run mocker as a standalone http-server. "},{"title":"MockerOptions​","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#mockeroptions","content":"interface MockerOptions { apis: Record<string, { target: string }>; passUnhandledRequests?: boolean; apiRoutePrefix?: string; } Copy MockerOptions.apis - list of APIs for mocking, key target points to the source API. MockerOptions.passUnhandledRequests - when enabled, all of the request without according mock will be proxied to the target, otherwise fail the request. MockerOptions.apiRoutePrefix - if mocker is used in existing server on nested route, e.g. /mocker, this option might be used to pass this route as apiRoutePrefix for proper routing. "},{"title":"MockRepository​","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#mockrepository","content":"interface MockRepository { get(api: string, endpoint: string): Promise<Mock>; getAll(api: string): Promise<Record<string, Mock>>; add(api: string, endpoint: string, mock: Mock): Promise<void>; delete(api: string, endpoint: string): Promise<void>; } Copy MockRepository.getAll - get all mocks for specified API. MockRepository.get - get specific mock for specific API. MockRepository.add - add new mock for specific API. MockRepository.delete - remove specific mock for specific API. "},{"title":"How to​","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#how-to","content":""},{"title":"How to mock request with specific query parameters?​","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#how-to-mock-request-with-specific-query-parameters","content":"Mocker allows to specify query parameters for mocks. In the example below request to /endpoint?foo=bar will be mocked with first mock, and request to /endpoint?foo=baz will be mocked with second. All of the other requests with\\without query will be proxied to source API (if passUnhandledRequests is enabled). module.exports = { api: 'api', mocks: { 'GET /endpoint?foo=bar': { status: 200, headers: {}, payload: 'mocked bar response', }, 'GET /endpoint?foo=baz': { status: 200, headers: {}, payload: 'mocked baz response', }, }, }; Copy "},{"title":"How to proxy specific request to source API?​","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#how-to-proxy-specific-request-to-source-api","content":"It might be useful if option passUnhandledRequests is disabled. In that case you may pass option pass: true to mock: module.exports = { api: 'api', mocks: { 'ALL /endpoint': { pass: true, }, }, }; Copy "},{"title":"module-loader-server","type":0,"sectionRef":"#","url":"docs/references/libs/module-loader-server","content":"","keywords":""},{"title":"Установка​","type":1,"pageTitle":"module-loader-server","url":"docs/references/libs/module-loader-server#установка","content":"Для yarn: yarn add @tinkoff/module-loader-server Copy Для npm: npm install @tinkoff/module-loader-server Copy "},{"title":"Подключение и использование​","type":1,"pageTitle":"module-loader-server","url":"docs/references/libs/module-loader-server#подключение-и-использование","content":"import { ServerLoader } from '@tinkoff/module-loader-server'; const loader = new ServerLoader(); loader.resolveByUrl('https://cdn.example.com/js/module.js').then((moduleExports) => { // ... }); Copy В конструктор можно передать опции (см. интерфейс LoaderDeps), из важных это параметр request который по умлочанию определяется библиотекой request, и содержит только deduplicate плагин. Если вам нужны другие плагины или поведение при запросе на сервер, переопределите параметр request в конструкторе лоадера. "},{"title":"Взаимодействие с кешем​","type":1,"pageTitle":"module-loader-server","url":"docs/references/libs/module-loader-server#взаимодействие-с-кешем","content":"Допустим вам нужно сихронное апи для получения объекта, при условии что он есть в кэше. Тогда есть два способа. Первый, используем метод loadByUrl<R>(url: string, options: LoadOptions), который возвращает Promise<R> если объекта нет в кеше, и R если он там есть: const result = loader.loadByUrl(url); if (!isPromise(result)) { syncOperation(result); } else { asyncOperation(result); } Copy Второй, можно использовать метод getByUrl<R = any>(url: string, options: LoadOptions = {}): R | void, который возвращает объект, только если он присутствует в кеше: const result = loader.getByUrl(url); if (result !== void 0) { syncOperation(result); } else { asyncOperation(loader.resolveByUrl(url)); } Copy "},{"title":"Интерфейс и типы​","type":1,"pageTitle":"module-loader-server","url":"docs/references/libs/module-loader-server#интерфейс-и-типы","content":" type LogFunction = (...args: unknown[]) => void; export interface Logger { trace: LogFunction; debug: LogFunction; info: LogFunction; warn: LogFunction; error: LogFunction; } export type RequestFunc = (options: { url: string; responseType?: string }) => Promise<any>; export interface Cache { get: (key: string) => any; set: (key: string, module: any) => void; } export interface LoaderDeps { log?: Logger; request?: RequestFunc; cache?: Cache; externals?: Record<string, any>; debug?: string[]; } export interface LoadOptions { [key: string]: any; // тип ресурса, по умолчанию 'module', используется при логировании kind?: string; // если задан, будет использоваться после kind при логировании displayName?: string; // если задан, ресурс будет проверен на соответствие заданному хешу integrity?: string; codePrefix?: string; } Copy  "},{"title":"papi","type":0,"sectionRef":"#","url":"docs/references/libs/papi","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"papi","url":"docs/references/libs/papi#installation","content":"You need to install @tramvai/papi yarn add @tramvai/module-papi Copy "},{"title":"Usage​","type":1,"pageTitle":"papi","url":"docs/references/libs/papi#usage","content":"import { createPapiMethod } from '@tramvai/papi'; export const papi = createPapiMethod({ path: '/my/papi', method: 'post', async handler(deps) { return 'test'; }, deps: { tinkoffApiService: TINKOFF_API_SERVICE, }, }); Copy "},{"title":"pubsub","type":0,"sectionRef":"#","url":"docs/references/libs/pubsub","content":"","keywords":""},{"title":"subscribe - event subscription​","type":1,"pageTitle":"pubsub","url":"docs/references/libs/pubsub#subscribe---event-subscription","content":"pubsub.subscribe('type', callback) - subscribe to event with name type. callback accepts as arguments payload from pubsub.publish. callback can return promise which will can be awaited from call pubsub.publish. "},{"title":"publish - event publish​","type":1,"pageTitle":"pubsub","url":"docs/references/libs/pubsub#publish---event-publish","content":"pubsub.publish('type', ...args) - publish event with name type. args will be passed as arguments to the subscribers. Return promise which will be resolved after resolve of all subscriptions. "},{"title":"Typed PubSub​","type":1,"pageTitle":"pubsub","url":"docs/references/libs/pubsub#typed-pubsub","content":"PubSub can use typed events. For example: a common PubSub with many events and subscriptions. In order to enable type checking for event subscriptions: Create a new type with all event definitions: type MyAwesomeFeatureEvents = { event1: (payload: number) => any; event2: (payload: { prop: boolean }) => any; }; Copy Do a typecast in code when using PubSub instance. It will enable type checks for every usage for a new typed instance const featurePubSub = (pubSub as any) as PubSub<MyAwesomeFeatureEvents>; // OK! 👍 featurePubSub.subscribe('event1', (payload) => console.log(1 + payload)); featurePubSub.publish('event1', 2); // Error 👎 featurePubSub.subscribe('event3', (payload) => console.log(1 + payload)); // No such event featurePubSub.publish('event3', 2); // НNo such event featurePubSub.subscribe('event1', (payload) => payload.toLowerCase()); // Wrong payload type featurePubSub.publish('event1', 'string'); // number expected Copy "},{"title":"prettier","type":0,"sectionRef":"#","url":"docs/references/libs/prettier","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"prettier","url":"docs/references/libs/prettier#installation","content":"Install with package manager, e.g. for npm: npm i --save-dev prettier-config-tinkoff Copy Create new file .prettierrc.js in project root: module.exports = require('prettier-config-tinkoff'); Copy It will set default settings from config, in order to change some settings follow official guide for prettier "},{"title":"React Hooks","type":0,"sectionRef":"#","url":"docs/references/libs/react-hooks","content":"","keywords":""},{"title":"Api​","type":1,"pageTitle":"React Hooks","url":"docs/references/libs/react-hooks#api","content":""},{"title":"useShallowEqual​","type":1,"pageTitle":"React Hooks","url":"docs/references/libs/react-hooks#useshallowequal","content":"Makes shallow equal check for passed argument. If current argument is equal to previous then result of the hook will not be changed. Otherwise it will be equal to a current argument. import { useEffect } from 'react'; import { useShallowEqual } from '@tinkoff/react-hooks'; export function Cmp({ obj }) { // obj - some object // objRef - reference to object. For example, if reference obj were changed after sequential render, // but it still shallow equals to initial obj then objRef will reference to the initial obj ссылка на объект obj const objRef = useShallowEqual(obj); useEffect(() => { // React checks deps with reference equality that may lead to unnecessary hook call when reference were changed // but we care only about actual changes to object itself not reference // in that case objRef will not lead to effect call in case new reference is shallowly equal to previous }, [objRef]); } Copy "},{"title":"safe-strings","type":0,"sectionRef":"#","url":"docs/references/libs/safe-strings","content":"","keywords":""},{"title":"safeParseJSON​","type":1,"pageTitle":"safe-strings","url":"docs/references/libs/safe-strings#safeparsejson","content":"Tries to parse json and if it successful returns it, otherwise returns second argument as default value. "},{"title":"safeStringify​","type":1,"pageTitle":"safe-strings","url":"docs/references/libs/safe-strings#safestringify","content":"Converts object to json with a replacement of insecure symbols that allows to insert result string in the response html "},{"title":"safeStringiyfJSON​","type":1,"pageTitle":"safe-strings","url":"docs/references/libs/safe-strings#safestringiyfjson","content":"Converts object to json with a circular reference handling "},{"title":"removeXss​","type":1,"pageTitle":"safe-strings","url":"docs/references/libs/safe-strings#removexss","content":"Removes possible xss strings "},{"title":"tinkoff-request-http-client-adapter","type":0,"sectionRef":"#","url":"docs/references/libs/tinkoff-request-http-client-adapter","content":"","keywords":""},{"title":"API​","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#api","content":""},{"title":"createAdapter​","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#createadapter","content":"createAdapter - factory to create an HTTP client. It configures an instance of @tinkoff/request via createTinkoffRequest, and based on it creates an instance of HttpClientAdapter type createAdapter = (options: TinkoffRequestOptions) => HttpClient; Copy "},{"title":"TinkoffRequestOptions​","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#tinkoffrequestoptions","content":"interface TinkoffRequestOptions extends HttpClientRequest { // tramvai logger logger?: typeof LOGGER_TOKEN; // namespace for the logger, the prefix `request.` will be added to it name?: string; // will disable the default caching via `@tinkoff/request-plugin-cache-memory` disableCache?: boolean; // cache factory for `@tinkoff/request-plugin-cache-memory` createCache?: (options: any) => any; // cache ttl for `@tinkoff/request-plugin-cache-memory` cacheTime?: number; // the default request execution time limit, in ms defaultTimeout?: number; // response validator for `@tinkoff/request-plugin-validate` validator?: RequestValidator; // error validator for `@tinkoff/request-plugin-validate` errorValidator?: RequestValidator; // method allows you to modify the error object before sending logs from `@tinkoff/request-plugin-log` errorModificator?: RequestValidator; } Copy "},{"title":"createTinkoffRequest​","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#createtinkoffrequest","content":"createTinkoffRequest - creates an instance of @tinkoff/request with all the necessary plugins type createTinkoffRequest = (options: TinkoffRequestOptions) => MakeRequest; Copy "},{"title":"HttpClientAdapter​","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#httpclientadapter","content":"HttpClientAdapter - adapts @tinkoff/request to the interface HttpClient. The request method wraps the request parameters in the modifyRequest option, and passes them to @tinkoff/request. Then, the received response is modified in the HttpClientRequest, and wrapped in the modifyResponse option. If there is an error, it will wrapped into the modifyError option. The fork method creates a new instance of HttpClientAdapter, but with the same @tinkoff/request instance. type HttpClientAdapter = HttpClient; Copy "},{"title":"mergeOptions​","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#mergeoptions","content":"By default, mergeOptions compose modifyRequest, modifyResponse and modifyError options, with the corresponding options from options being executed first, then from nextOptions. If you pass a third parameter { replace: true }, all parameters of the same name from options will simply be overwritten by parameters from nextOptions type mergeOptions = ( options: HttpClientRequest, nextOptions: HttpClientRequest, config?: { replace?: boolean } ) => HttpClientRequest; Copy "},{"title":"url","type":0,"sectionRef":"#","url":"docs/references/libs/url","content":"","keywords":""},{"title":"Api​","type":1,"pageTitle":"url","url":"docs/references/libs/url#api","content":""},{"title":"parse​","type":1,"pageTitle":"url","url":"docs/references/libs/url#parse","content":"Parses url and returns object of class URL with additional property query which represents searchParams as a simple object. import { parse } from '@tinkoff/url'; const url = parse('https://tinkoff.ru/test/?a=1&b=2#abc'); url.protocol; // => :https url.href; // => https://tinkoff.ru/test/?a=1&b=2#abc url.origin; // => https://tinkoff.ru url.pathname; // => /test/ url.hash; // => #abc url.query; // => { a: '1', b: '2' } Copy "},{"title":"rawParse​","type":1,"pageTitle":"url","url":"docs/references/libs/url#rawparse","content":"Same as parse but instead of returning wrapper for URL returns raw URL object "},{"title":"resolve​","type":1,"pageTitle":"url","url":"docs/references/libs/url#resolve","content":"Computes absolute url for relative url of base value import { resolve } from '@tinkoff/url'; resolve('//tinkoff.ru', './test123'); // => http://tinkoff.ru/test123 resolve('//tinkoff.ru/a/b/c/', '../../test'); // => http://tinkoff.ru/a/test resolve('https://tinkoff.ru/a/b/c/?test=123#abc', '.././test/?me=123#123'); // => https://tinkoff.ru/a/b/test/?me=123#123 Copy "},{"title":"resolveUrl​","type":1,"pageTitle":"url","url":"docs/references/libs/url#resolveurl","content":"Computes absolute url for relative url of base value. Unlike resolve can accept string or URL and return URL wrapper "},{"title":"rawResolveUrl​","type":1,"pageTitle":"url","url":"docs/references/libs/url#rawresolveurl","content":"Same as resolveUrl but instead of returning wrapper for URL returns raw URL object "},{"title":"isAbsoluteUrl​","type":1,"pageTitle":"url","url":"docs/references/libs/url#isabsoluteurl","content":"Checks that passed string is absolute url "},{"title":"isInvalidUrl​","type":1,"pageTitle":"url","url":"docs/references/libs/url#isinvalidurl","content":"Checks that passed string represents invalid url import { isAbsoluteUrl } from '@tinkoff/url'; isAbsoluteUrl('https://www.exmaple.com'); // true - secure http absolute URL isAbsoluteUrl('//cdn.example.com/lib.js'); // true - protocol-relative absolute URL isAbsoluteUrl('/myfolder/test.txt'); // false - relative URL Copy "},{"title":"convertRawUrl​","type":1,"pageTitle":"url","url":"docs/references/libs/url#convertrawurl","content":"Returns handy wrapper for URL in form of plain object with some additional fields "},{"title":"rawAssignUrl​","type":1,"pageTitle":"url","url":"docs/references/libs/url#rawassignurl","content":"Allows to set parameters to passed raw URL object (passed URL-object will be changed) "},{"title":"router","type":0,"sectionRef":"#","url":"docs/references/libs/router","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"router","url":"docs/references/libs/router#installation","content":"You need to install @tinkoff/router: yarn add @tinkoff/router Copy And connect it to the project: import { Router } from '@tinkoff/router'; const router = new Router(); Copy "},{"title":"Explanation​","type":1,"pageTitle":"router","url":"docs/references/libs/router#explanation","content":"Features: The library supports options for working both on the server and on the client.It is possible to use different client transition options: with or without SPA transitions.There are Guards to check the availability of a route under specific conditions.You can subscribe to different stages of the transition through hooksComponents and hooks for easy routing from react "},{"title":"Server and client version​","type":1,"pageTitle":"router","url":"docs/references/libs/router#server-and-client-version","content":"It is enough just to import routing from the library itself and, based on the settings in package.json, the required version for the server or client will be returned import { Router } from '@tinkoff/router'; Copy "},{"title":"Client routing with/without SPA transitions​","type":1,"pageTitle":"router","url":"docs/references/libs/router#client-routing-withwithout-spa-transitions","content":"By default, routing with SPA transitions is enabled on the client. If you need to disable SPA transitions, you need to import a special version of the routing import { Router, SpaHistory } from '@tinkoff/router'; import { NoSpaRouter } from '@tinkoff/router'; const spaRouter = new Router({ history: new SpaHistory() }); const noSpaRouter = new NoSpaRouter(); Copy "},{"title":"Router Guards​","type":1,"pageTitle":"router","url":"docs/references/libs/router#router-guards","content":"Guards allow you to control the availability of a particular route for a specific transition. From the guard, you can block the transition or initiate a redirect. import { NavigationGuard } from '@tinkoff/router'; export const myGuard: NavigationGuard = async ({ to }) => { if (to.config.blocked) { return false; // block this transition } if (to.config.redirect) { return '/login/'; // call a redirect to the specified page } // if nothing is returned, the transition will be performed as usual }; router.registerGuard(myGuard); Copy Rules​ guards are asynchronous and it execution will be awaited inside routingall guards are running in parallel and they are all awaitedif several guars return something then the result from a guard that was registered early will be used Possible result​ The behaviour of routing depends on the result of executing guards functions and there result might be next: if all of the guards returns undefined than navigation will continue executingif any of the guards returns false than navigation is getting blocked and next action differs on server and clientif any of the guards returns string it is considered as url to which redirect should be happenif any of the guards returns NavigateOptions interface, url property from it is considered as url to which redirect should be happen "},{"title":"Transitions hooks​","type":1,"pageTitle":"router","url":"docs/references/libs/router#transitions-hooks","content":"Transition hooks allow you to perform your asynchronous actions at different stages of the transition. import { NavigationHook } from '@tinkoff/router'; export const myHook: NavigationHook = async ({ from, to, url, fromUrl }) => { console.log(`navigating from ${from} to route ${to}`); }; router.registerHook('beforeNavigate', myHook); Copy Rules​ all hooks from the same event are running in parallelmost of the hooks are asynchronous and are awaited inside routerif some error happens when running hook it will be logged to console but wont affect navigation (except for the beforeResolve hook - error for it will be rethrown) List of available hooks​ Async hooks: navigate hooks - asynchronous hooks only for navigate callsupdateCurrentRoute hooks - asynchronous hooks only for updateCurrentRoute calls Sync hooks: change - runs when any of changes to current route\\url happens "},{"title":"API​","type":1,"pageTitle":"router","url":"docs/references/libs/router#api","content":""},{"title":"Getting data about the current route or url​","type":1,"pageTitle":"router","url":"docs/references/libs/router#getting-data-about-the-current-route-or-url","content":"router.getCurrentRoute(); // will return the current route router.getCurrentUrl(); // will return the parsed version of the url of the current page Copy "},{"title":"Transition initiation​","type":1,"pageTitle":"router","url":"docs/references/libs/router#transition-initiation","content":"There are two methods for initializing the navigation and updating the address bar in the browser. The main difference between these two methods is that one of them will launch a full-fledged transition with data updating and starting heavy data loading actions. The second method is mainly used to update the state for the current route: to update the query parameters on the page or change the dynamic parameters of the route itself. navigate​ Initiates a full transition, defining the next route and updating the state in the browser. router.navigate('/test'); router.navigate({ url: './test', query: { a: '1' } }); Copy navigate hooks​ beforeResolvebeforeNavigateafterNavigate navigate workflow​ beforeResolve hookguardsbeforeNavigatechangeafterNavigate updateCurrentRoute​ The transition is based on the current route (therefore this method cannot be called on the server) and allows you to simply update some data for the current page router.updateCurrentRoute({ params: { id: 'abc' } }); router.updateCurrentRoute({ query: { a: '1' } }); Copy updateCurrentRoute hooks​ beforeUpdateCurrentafterUpdateCurrent updateCurrentRoute workflow​ beforeUpdateCurrentchangeafterUpdateCurrent "},{"title":"Working with query​","type":1,"pageTitle":"router","url":"docs/references/libs/router#working-with-query","content":"query option​ Allows you to set a search string for an url as an object via the query option when navigating. The previous query value will be cleared router.getCurrentUrl().query; // { с: 'c' } router.navigate({ query: { a: 'a', b: 'b' } }); router.updateCurrentRoute({ query: { a: 'a', b: 'b' } }); router.getCurrentUrl().query; // { a: 'a', b: 'b' } Copy preserveQuery​ Allows you to keep the query value from the current navigation and use them in a new transition router.getCurrentUrl().query; // { с: 'c' } router.navigate({ query: { a: 'a' }, preserveQuery: true }); router.updateCurrentRoute({ query: { a: 'a' }, preserveQuery: true }); router.getCurrentUrl().query; // { a: 'a', c: 'c' } Copy If you pass undefined as the value for a specific query key, then this value will be cleared in a new query: router.getCurrentUrl().query; // { a: 'a', b: 'b' } router.navigate({ query: { a: undefined, c: 'c' }, preserveQuery: true }); router.updateCurrentRoute({ query: { a: undefined, c: 'c' }, preserveQuery: true }); router.getCurrentUrl().query; // { b: 'b', c: 'c' } Copy "},{"title":"Constructor options​","type":1,"pageTitle":"router","url":"docs/references/libs/router#constructor-options","content":"trailingSlash - do router should force all urls to end with slash. If true - force trailing slash for every path, false - force no trailing slash, undefined - trailing slash is specified by request and both trailing and not trailing slashes are used. By default value if undefinedmergeSlashes - replace several consecutive slashes by single slashes (slashes after protocol are still be with // after protocol name). By default is false - no merge for slashes. "},{"title":"Integration with React​","type":1,"pageTitle":"router","url":"docs/references/libs/router#integration-with-react","content":"Library has some useful React hooks and components for working with routing useRoute​ Returns current active route of the application import React from 'react'; import { useRoute } from '@tinkoff/router'; export const Component = () => { const route = useRoute(); return <div>Route path: {route.actualPath}</div>; }; Copy useUrl​ Returns current active URL of the application import React from 'react'; import { useUrl } from '@tinkoff/router'; export const Component = () => { const url = useUrl(); return <div>Url query: {JSON.stringify(url.query)}</div>; }; Copy useNavigate​ Creates a callback with a navigation call that can be passed to child components or used as an event handler export const Cmp = () => { const navigate = useNavigate('/test/'); return <div onClick={navigate}>Test</div>; }; Copy Link​ A wrapper for a react component that makes it clickable If the react component is passed to the Link as children, then this passed component will be rendered and the href, onClick props will be passed as props to that component and they should be used to make the navigation. Otherwise, the <a> tag will be rendered with children as a child. import { Link } from '@tinkoff/router'; import CustomLink from '@custom-scope/link'; export const Component = () => { return ( <Link url=\"/test/\"> <CustomLink /> </Link> ); }; export const WrapLink = () => { return <Link url=\"/test/\">Click me</Link>; }; Copy "},{"title":"How to​","type":1,"pageTitle":"router","url":"docs/references/libs/router#how-to","content":""},{"title":"Load route config from external api​","type":1,"pageTitle":"router","url":"docs/references/libs/router#load-route-config-from-external-api","content":"Use transition hookbeforeResolve and load routes config based on url. router.registerHook('beforeResolve', async (navigation) => { const route = await routeResolve(navigation); if (route) { router.addRoute(routeTransform(route)); } }); Copy "},{"title":"App behind proxy​","type":1,"pageTitle":"router","url":"docs/references/libs/router#app-behind-proxy","content":"Router doesn't support proxy setup directly. But proxy still can be used with some limitations: setup proxy server to pass requests to app with rewriting request and response paths. (E.g. for nginx)it wont work as expected on spa navigation on client, so only option in this case is use the NoSpaRouter "},{"title":"user-agent","type":0,"sectionRef":"#","url":"docs/references/libs/user-agent","content":"user-agent Library for parsing and executing check to userAgent string. Based on ua-parser-js","keywords":""},{"title":"cache-warmup","type":0,"sectionRef":"#","url":"docs/references/modules/cache-warmup","content":"","keywords":""},{"title":"Как подключить?​","type":1,"pageTitle":"cache-warmup","url":"docs/references/modules/cache-warmup#как-подключить","content":"По умолчанию модуль уже подключается в @tramvai/module-server и при его использовании дополнительных действий не требуется. import { createApp } from '@tramvai/core'; import { CacheWarmupModule } from '@tramvai/module-cache-warmup'; createApp({ modules: [CacheWarmupModule], }); Copy "},{"title":"Что делает?​","type":1,"pageTitle":"cache-warmup","url":"docs/references/modules/cache-warmup#что-делает","content":"При старте приложения с запрашивает у bundleInfo список урлов приложения. Затем шлет по 2 запроса на каждый из урлов, но не более 2 запросов одновременно. 2 запроса нужны для того, чтобы симулировать запрос с десктопа и мобильного устройства. User-Agentы, которые использует модуль: [ /** Chrome on Mac OS */ 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.87 Safari/537.36', /** Chrome on Mobile */ 'Mozilla/5.0 (Linux; Android 7.0; SM-G930V Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.125 Mobile Safari/537.36', ]; Copy Модуль выполняется только при NODE_ENV === production. "},{"title":"Отладка​","type":1,"pageTitle":"cache-warmup","url":"docs/references/modules/cache-warmup#отладка","content":"Модуль использует логгер с идентификатором cache-warmup "},{"title":"autoscroll","type":0,"sectionRef":"#","url":"docs/references/modules/autoscroll","content":"","keywords":""},{"title":"Подключение​","type":1,"pageTitle":"autoscroll","url":"docs/references/modules/autoscroll#подключение","content":"Необходимо установить @tramvai/module-autoscroll yarn add @tramvai/module-autoscroll Copy Подключить в проекте AutoscrollModule import { createApp } from '@tramvai/core'; import { AutoscrollModule } from '@tramvai/module-autoscroll'; createApp({ name: 'tincoin', modules: [AutoscrollModule], }); Copy Если нужно отключить подскрол для отдельных страниц - при переходе navigate нужно указать navigateState.disableAutoscroll = true import { useNavigate } from '@tramvai/module-router'; function Component() { const navigateToWithoutScroll = useNavigate({ url: '/url/', navigateState: { disableAutoscroll: true }, }); return <Button onClick={navigateToWithoutScroll} />; } Copy behavior: smooth поддерживается не во всех браузерах (например, плавный подскролл не работает в Safari). При необходимости подключите полифил smoothscroll-polyfill в свое приложение. "},{"title":"client-hints","type":0,"sectionRef":"#","url":"docs/references/modules/client-hints","content":"","keywords":""},{"title":"Подключение в проект​","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#подключение-в-проект","content":""},{"title":"1. Зависимости​","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#1-зависимости","content":"Необходимо установить @tramvai/module-client-hints с помощью npm npm i --save @tramvai/module-client-hints Copy или yarn add @tramvai/module-client-hints Copy "},{"title":"2. Подключение модуля​","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#2-подключение-модуля","content":"Нужно передать в список модулей приложения ClientHintsModule import { createApp } from '@tramvai/core'; import { ClientHintsModule } from '@tramvai/module-client-hints'; createApp({ modules: [ClientHintsModule], }); Copy "},{"title":"Экспортируемые токены​","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#экспортируемые-токены","content":""},{"title":"USER_AGENT_TOKEN​","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#user_agent_token","content":"Объект - результат парсинга строки юзер-агента с помощью @tinkoff/user-agent. Парсинг происходит только на сервере, на клиенте - используется инфомация с сервера. "},{"title":"Сторы​","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#сторы","content":""},{"title":"userAgent​","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#useragent","content":"Стор который хранит результат парсинга юзер-агента. "},{"title":"media​","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#media","content":"Стор который хранит медиа-информацию о типе и размере экрана клиента. API для проверки media​ Данные в сторе media: type Media = { width: number; height: number; isTouch: boolean; retina: boolean; supposed?: boolean; synchronized?: boolean; }; Copy fromClientHints(media: Media): boolean - возвращает true, когда media синхронизированны на сервере и на клиенте isSupposed(media: Media): boolean - возвращает true, когда media определены на сервере по User-Agent, и могут измениться на клиенте isRetina(media: Media): boolean - вовзращает true, когда плотность пикселей на экране 2 или выше useMedia(): Media - возвращает текущее состояние стора media useFromClientHints(): boolean - вычисляет fromClientHints из стора media useIsSupposed(): boolean - вычисляет isSupposed из стора media useIsRetina(): boolean - вычисляет isRetina из стора media "},{"title":"Особенности работы с media на сервере и клиенте​","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#особенности-работы-с-media-на-сервере-и-клиенте","content":"Одна из проблем SSR - рендеринг компонентов, которые зависят от текущего размера экрана, например карусель изображений, которая должна рендерить определенное количество картинок, в зависимости от ширины экрана. По умолчанию, узнать точные размеры мы можем только на стороне клиента, и не имеем возможности отрисовать на сервере контент, идентичный клиенту. Если этот контент не требуется для SEO, можно использовать скелетоны или спиннеры, но это подходит не для всех случаев. Модуль Client Hints позволяет частично решить эту проблему, сохраняя данные об устройстве пользователя в cookies при первом заходе, и используя эти данные на сервере при следующих заходах на страницы приложения. "},{"title":"Механизм работы Client Hints​","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#механизм-работы-client-hints","content":"Первый заход на страницу​ При первом заходе на страницу, на стороне сервере, модуль определяет тип устройство по User-Agent, и сохраняет предположительные данные об устройстве в стор media. Например, при первом заходе с компьютера, значение стора media будет таким: const state = { width: 1024, height: 768, isTouch: false, retina: false, supposed: true, synchronized: false, }; Copy На клиенте, ориентируясь на значение supposed: true, модуль получает реальные данные об устройстве, и обновляет стор media, вызывая перерендер зависимых компонентов. После этого, для широкоэкранного монитора, значение стора media может быть таким: const state = { width: 1920, height: 1080, isTouch: false, retina: true, supposed: false, synchronized: false, }; Copy Пока мы имеем значение synchronized: false, нельзя полагаться на данные из media для серверного рендеринга компонентов, т.к. это вызовет \"скачок\" при сохранении реальных данных об устройстве. Повторный заход на страницу​ При повторном заходе на страницу, данные об устройстве считываются из cookies, значение synchronized выставляется в true. Таким образом, и на сервере, и на клиенте, мы получим одно значение стора media, и отсутствие перерендера на клиенте: const state = { width: 1920, height: 1080, isTouch: false, retina: true, supposed: false, synchronized: true, }; Copy Итоги​ Общая информация для компонентов, которые зависят от текущего размера экрана: При первом заходе на страницу, нельзя гарантировать одинаковый результат рендеринга на сервере и на клиенте При первом заходе на страницу, можно показать юзеру скелетон компонента, отображая скелетон при свойстве supposed: true Гарантировать одинаковый результат рендеринга на сервере и на клиенте можно при свойстве synchronized: true Рецепт, который позволит показать скелетон только один раз, при первой загрузке приложения: const App = () => { const isSupposed = useIsSupposed(); if (isSupposed) { return <AdaptiveSliderSkeleton />; } return <AdaptiveSlider />; }; Copy Рецепт, который позволит рендерить общий адаптивный компонент при первой загрузке приложения, и выбирать отдельные под desktop и mobile при повторных загрузках: const App = () => { const media = useMedia(); const fromClientHints = useFromClientHints(); let Block = AdaptiveBlock; if (fromClientHints) { Block = media.width >= 1024 ? DesktopBlock : MobileBlock; } return <Block />; }; Copy "},{"title":"child-app","type":0,"sectionRef":"#","url":"docs/references/modules/child-app","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"child-app","url":"docs/references/modules/child-app#installation","content":"First, install @tramvai/module-child-app yarn add @tramvai/module-child-app Copy And then add module to your app import { createApp } from '@tramvai/core'; import { ChildAppModule } from '@tramvai/module-child-app'; createApp({ name: 'tincoin', modules: [ChildAppModule], }); Copy "},{"title":"Explanation​","type":1,"pageTitle":"child-app","url":"docs/references/modules/child-app#explanation","content":""},{"title":"Terms​","type":1,"pageTitle":"child-app","url":"docs/references/modules/child-app#terms","content":"root-app - basic tramvai-app constructed with createApp from @tramvai/core. It can connect with many child-appchild-app - external microfrontend constructed with createChildApp from @tramvai/child-app-core. It is loaded by root-app and provides some external functionalitySingletonDI - DI-container which is exist in single instance for app and exists as long as app itselfRequestDI - DI-Container which is created for every request and represents specific data for single client. RequestDI inherits providers from SingletonDI and it is independent from other RequestDIsCommandLineRunner - instance of CommandModule "},{"title":"DI​","type":1,"pageTitle":"child-app","url":"docs/references/modules/child-app#di","content":"Every child-app has its own DI-hierarchy which is isolated from other child app and partially from root-app. The only way communicate fpr DIs it's getting providers from root-app di inside child-app. Next picture shows connection between DI-containers in root-app and child-apps  How does it work when we trying to get provider from DI in child-app: First check that provider is exist in the current DI-container. If it is then return it.If current DI is RequestDI then go to SingletonDI of child-app and look for provider. If it exists in SingletonDI then return itGo to RequestDI of root-app and if provider exists in it return itGo to SingletonDI of root-app and if provider exists in it return itThrow error otherwise If current DI is SingletonDI then go to SingletonDI of root-app and check for provider there If it exists then return itThrow error otherwise "},{"title":"CommandLineRunner​","type":1,"pageTitle":"child-app","url":"docs/references/modules/child-app#commandlinerunner","content":"Each child-app has its own CommandLineRunner instance which allows to child-app make some preparations before the actual page render. This CommandLineRunner has almost identical lines as root-app to simplicity, but it is actually completely other line which are independent from lines in root-app  All of the accepted line tokens: const command = { customer: [ commandLineListTokens.customerStart, commandLineListTokens.resolveUserDeps, commandLineListTokens.resolvePageDeps, ], clear: [commandLineListTokens.clear], spa: [ commandLineListTokens.resolveUserDeps, commandLineListTokens.resolvePageDeps, commandLineListTokens.spaTransition, ], }; Copy Child-app must be preloaded first to allow to execute commandline runner. In case of late preloading CommandLineRunner will be executed anyway but it will be out of sync with root-app CommandLineRunner (it will be called as soon as child-app code was loaded). Server​ If child-app was preloaded before root-app resolvePageDeps then customer line list is executed on root-app resolvePageDeps lineIf child-app was preloaded on root-app resolvePageDeps then customer line list is executed as soon as child-app was loaded. preload call must be awaited in order to prevent root-app CommandLineRunner to passing to next line. That still counts as executing on resolvePageDeps line.Child-app clear line list is executed on root-app clear line for every child-app that was preloaded on previous lines Client​ First Page load​ If child-app was preloaded on server customer line list is executed on root-app resolvePageDeps lineIf child-app was not preloaded on server but was preloaded on client then customer line list is executed on root-app clear lineChild-app clear line list is executed on root-app clear line for every child-app that was preloaded on previous lines Spa-transitions​ If child-app was not preloaded on any previous pages before but was preloaded on next page then customer line list is executed as soon as child-app is loadedIf child-app was preloaded on next page then child-app spa line list is executed on root-app spaTransition line "},{"title":"Loading Child App​","type":1,"pageTitle":"child-app","url":"docs/references/modules/child-app#loading-child-app","content":"Loading of child-app is happens only after preloading child-app with CHILD_APP_PRELOAD_MANAGER. This preloading loads code for a child-app and marks it to execution using CommandLineRunner.  Server​ Calling PreloadManager.preload(...) loads a child-app code, executes and marks it as executable to CommandLineRunnerResult of PreloadManager.preload(...) must be awaited as it is important to synchronize child-app commands lines execution with a root-app CommandLinerRunnerPreloads after root-app resolvePageDeps are useless as they wont change page render and wont be used by root-app.If child-app was not preloaded at all but still is used on render then the child-app is still preloaded automatically, but it will lead to additional React render and may significantly increase response latency. Client​ Calling PreloadManager.preload(...) loads a child-app code, executes and marks it as executable to CommandLineRunnerResult of PreloadManager.preload(...) must be awaited as it is important to synchronize child-app commands lines execution with a root-app CommandLinerRunnerIf child-app was preloaded on server then child-app customer line list is executed on resolvePageDeps on first page renderIf child-app was not preloaded on server then actual loading and command-line execution are happens on root-app clear line as executing child-app before page render may break React hydration and should be executed only after it.On spa transition when previously child-app is preloaded it will be reusedOn spa transition if preloaded child-app was not loaded before it will be loaded and executed as soon as possible. "},{"title":"State​","type":1,"pageTitle":"child-app","url":"docs/references/modules/child-app#state","content":"State Management is almost completely isolated from root-app and other of child-apps. Every child-app can register own stores, actions. State for child-apps will be dehydrated on server as separate variable in the result html and then will be automatically rehydrated on client for every child-app. Usually child-app cannot read data from root-app stores, but the dangerous workaround that allows to subscribe on any root-app store exists. It may be done using CHILD_APP_ROOT_STATE_SUBSCRIPTION_TOKEN token. This token is considered dangerous as it leads to high coupling with stores from root-app and this way stores in root-app might not change their public interface. But, in most cases, changes in stores ignore breaking change tracking and often breaks backward-compatibility. So do not use this token if you can, and if you should - use as little as possible from root-app and provide some fallback in case of wrong data. ::: API​ How to​ Connect a child app​ Place a child-app React component somewhere in your page render import React from 'react'; import { ChildApp } from '@tramvai/module-child-app'; export const Page = () => { return ( <div> ... <ChildApp name=\"[name]\" /> ... </div> ); }; Copy Add configuration for child-app loading providers: [ provide({ provide: CHILD_APP_RESOLVE_BASE_URL_TOKEN, // or use `CHILD_APP_EXTERNAL_URL` env useValue: 'http://localhost:4040/', }), provide({ provide: CHILD_APP_RESOLUTION_CONFIGS_TOKEN, useValue: [ { name: '[name]', // name of the child-app byTag: { latest: { version: '[version]', // current version for the child app for tag `latest` }, }, }, ], }), ]; Copy Preload child-app execution in order to improve performance and allow child-app execute its data preparations import { commandLineListTokens, Provider, provide } from '@tramvai/core'; import { CHILD_APP_PRELOAD_MANAGER_TOKEN } from '@tramvai/module-child-app'; const providers: Provider[] = [ provide({ provide: commandLineListTokens.customerStart, multi: true, useFactory: ({ preloadManager }) => { return function preloadHeaderChildApp() { return preloadManager.preload({ name: '[name]' }); // this call is important }; }, deps: { preloadManager: CHILD_APP_PRELOAD_MANAGER_TOKEN, }, }), ]; Copy Preload child-app​ Preloading is vital for using child-app without extensive overhead on its loading. You may preload using next ways: Preload with CHILD_APP_PRELOAD_MANAGER_TOKEN provide({ provide: commandLineListTokens.customerStart, multi: true, useFactory: ({ preloadManager }) => { return function preloadHeaderChildApp() { return preloadManager.preload({ name: '[name]' }); }; }, deps: { preloadManager: CHILD_APP_PRELOAD_MANAGER_TOKEN, }, }); Copy Add needed child-apps to the pageComponent or layoutComponent through field childApps const PageComponent = () => { return 'Page'; }; PageComponent.childApps = [{ name: '[name]' }]; Copy Debug child-app​ Single child-app​ Run child-app using cli yarn tramvai start child-app Copy Run root-app with CHILD_APP_DEBUG environment variable CHILD_APP_DEBUG=child-app yarn tramvai start root-app Copy Multiple child-app​ Run somehow multiple child-apps. They should be started on different ports. And either pass Base Url showed from cli as url to debug every child-app CHILD_APP_DEBUG=child-app1=baseUrl1;child-app2=baseUrl2 yarn tramvai start root-app Copy Or implement proxy on default http:://localhost:4040/ yourself which redirects to concrete server by url CHILD_APP_DEBUG=child-app1;child-app2 yarn tramvai start root-app Copy More detailed debug setup​ You may specify a full config to debug to a specific child-app: To token CHILD_APP_RESOLUTION_CONFIGS_TOKEN for needed child-apps add special tag debug: ({ name: 'child-app', byTag: { latest: { version: 'latest', }, debug: { baseUrl: '...url', version: '...version', client: {}, server: {}, css: {}, }, }, }); Copy Run root-app with CHILD_APP_DEBUG environment variable with value of child-app names needed to debug "},{"title":"common","type":0,"sectionRef":"#","url":"docs/references/modules/common","content":"","keywords":""},{"title":"Подключение в проект​","type":1,"pageTitle":"common","url":"docs/references/modules/common#подключение-в-проект","content":""},{"title":"1. Зависимости​","type":1,"pageTitle":"common","url":"docs/references/modules/common#1-зависимости","content":"Необходимо установить @tramvai/module-common с помощью npm npm i @tramvai/module-common Copy "},{"title":"2. Подключение модуля​","type":1,"pageTitle":"common","url":"docs/references/modules/common#2-подключение-модуля","content":"Нужно передать в список модулей приложения CommonModule import { createApp } from '@tramvai/core'; import { CommonModule } from '@tramvai/module-common'; createApp({ modules: [CommonModule], }); Copy "},{"title":"Включенные модули​","type":1,"pageTitle":"common","url":"docs/references/modules/common#включенные-модули","content":""},{"title":"CommandModule​","type":1,"pageTitle":"common","url":"docs/references/modules/common#commandmodule","content":"Модуль которые добавляет в проект реализацию commandLineRunner и дефолтных команд Модуль использует логгер с идентификатором command:command-line-runner "},{"title":"StateModule​","type":1,"pageTitle":"common","url":"docs/references/modules/common#statemodule","content":"Подключает и инициализирует state-manager в проекте "},{"title":"ActionModule​","type":1,"pageTitle":"common","url":"docs/references/modules/common#actionmodule","content":"Реализация системы экшенов Модуль использует логгер с идентификатором action:action-page-runner "},{"title":"CookieModule​","type":1,"pageTitle":"common","url":"docs/references/modules/common#cookiemodule","content":"Подключен модуль который позволяет работать с куками, документация "},{"title":"EnvironmentModule​","type":1,"pageTitle":"common","url":"docs/references/modules/common#environmentmodule","content":"Модуль для работы с env переменные в приложении на стороне сервера и клиента, документация "},{"title":"PubSub​","type":1,"pageTitle":"common","url":"docs/references/modules/common#pubsub","content":"Для отправки событий между модулями используется PubSub который позволяет отправлять сообщения и подписываться на изменения, документация Модуль использует логгер с идентификатором pubsub "},{"title":"LogModule​","type":1,"pageTitle":"common","url":"docs/references/modules/common#logmodule","content":"Минимальная реализация логгера для токена LOGGER_TOKEN без фильтров и дополнительных фич "},{"title":"CacheModule​","type":1,"pageTitle":"common","url":"docs/references/modules/common#cachemodule","content":"Модуль для работы с кешами. Функции: Создать новый инстанс кеша (на данный момент это lru-cache)Очистить все ранее созданные кешиПодписка на событие очистки кеша для реализации собственного тригера очистки своих кешейДобавляет papi-метод '/clear-cache' который генерирует событе очистки кешей Модуль использует логгер с идентификатором cache:papi-clear-cache Пример​ import { provide } from '@tramvai/core'; export const providers = [ provide({ provide: MY_MODULE_PROVIDER_FACTORY, scope: Scope.SINGLETON, useFactory: ({ createCache }) => { const cache = createCache('memory', ...args); // тип кеша и дополнительные аргументы которые будут переданы в конструктор кеша return someFactory({ cache }); }, deps: { createCache: CREATE_CACHE_TOKEN, }, }), provide({ provide: REGISTER_CLEAR_CACHE_TOKEN, scope: Scope.SINGLETON, useFactory: ({ cache }) => { return async () => { await cache.reset(); console.log('my module cache cleared'); }; }, deps: { cache: MY_MODULE_CACHE, }, }), provide({ provide: commandLineListTokens.clear, useFactory: ({ clearCache }) => { return function clear() { clearCache(); // очистить кеши явно в своем провайдере }; }, deps: { clearCache: CLEAR_CACHE_TOKEN, }, }), ]; Copy "},{"title":"RequestManagerModule​","type":1,"pageTitle":"common","url":"docs/references/modules/common#requestmanagermodule","content":"Модуль для работы с параметрами запроса "},{"title":"ResponseManagerModule​","type":1,"pageTitle":"common","url":"docs/references/modules/common#responsemanagermodule","content":"Модуль для работы с параметрами ответа "},{"title":"Экспортируемые токены​","type":1,"pageTitle":"common","url":"docs/references/modules/common#экспортируемые-токены","content":"tokens-commoncookieenv "},{"title":"deps-graph","type":0,"sectionRef":"#","url":"docs/references/modules/deps-graph","content":"","keywords":""},{"title":"Установка​","type":1,"pageTitle":"deps-graph","url":"docs/references/modules/deps-graph#установка","content":""},{"title":"1. Зависимости​","type":1,"pageTitle":"deps-graph","url":"docs/references/modules/deps-graph#1-зависимости","content":"Необходимо установить @tramvai/module-deps-graph с помощью npm/yarn npm i @tramvai/module-deps-graph Copy "},{"title":"2. Подключение модуля​","type":1,"pageTitle":"deps-graph","url":"docs/references/modules/deps-graph#2-подключение-модуля","content":"Нужно передать в список модулей приложения CommonModule import { createApp } from '@tramvai/core'; import { DepsGraphModule } from '@tramvai/module-deps-graph'; createApp({ modules: [DepsGraphModule], }); Copy "},{"title":"Использование​","type":1,"pageTitle":"deps-graph","url":"docs/references/modules/deps-graph#использование","content":"Добавляет папи роут /deps-graph (можно найти по адресу /:appName/papi/deps-graph, где appName - поле name из tramvai.json), по которому выводится граф всех зависимостей с возможностью поиска по токену и имени модуля Описание графа​ Синий - обычный провайдерЖелтый - mutli-провайдерКрасный - подпавший под поиск  "},{"title":"cookie","type":0,"sectionRef":"#","url":"docs/references/modules/cookie","content":"","keywords":""},{"title":"Features​","type":1,"pageTitle":"cookie","url":"docs/references/modules/cookie#features","content":"Изоморфный код, работает на сервере и в браузереНа сервере происходит дедубликация одинаковых кук и при добавлении куки, кука будет доступна в методе getПо дефолту мы проставляем secure параметр "},{"title":"Установка​","type":1,"pageTitle":"cookie","url":"docs/references/modules/cookie#установка","content":"Уже поставляется внутри @tramvai/module-common и не нужно устанавливать, если подключен module-common. Иначе, нужно подключить @tramvai/module-cookie "},{"title":"Использование​","type":1,"pageTitle":"cookie","url":"docs/references/modules/cookie#использование","content":"import { COOKIE_MANAGER, Module, provide } from '@tramvai/core'; @Module({ providers: [ provide({ // Управление куками в приложении provide: 'my_module', useFactory: ({ cookie }) => { cookie.get('sid'); // > ads.api3 }, deps: { cookie: COOKIE_MANAGER, // добавляем в зависимость }, }), ], }) class MyModule {} Copy "},{"title":"Интерфейс​","type":1,"pageTitle":"cookie","url":"docs/references/modules/cookie#интерфейс","content":"Реализует интерфейс CookieManager и добавляет в di провайдер COOKIE_MANAGER. @tinkoff/core "},{"title":"Экспортируемые токены​","type":1,"pageTitle":"cookie","url":"docs/references/modules/cookie#экспортируемые-токены","content":"COOKIE_MANAGER_TOKEN​ Сущность для работы с куками interface CookieSetOptions { name: string; value: string; expires?: number | Date | string; domain?: string; path?: string; secure?: boolean; httpOnly?: boolean; sameSite?: boolean | 'lax' | 'strict' | 'none'; } interface CookieManager { get(name: any): string; all(): Record<string, string>; set({ name, value, ...options }: CookieSetOptions): void; remove(name: string): void; } Copy "},{"title":"error-interceptor","type":0,"sectionRef":"#","url":"docs/references/modules/error-interceptor","content":"","keywords":""},{"title":"Интеграция с tramvai​","type":1,"pageTitle":"error-interceptor","url":"docs/references/modules/error-interceptor#интеграция-с-tramvai","content":"Модуль не предоставляет публтичного интерфейса, а только подписывается на события инициализации и подключает @tinkoff/error-handlers который перехватывает ошибки в браузере и клиенте "},{"title":"Принцип работы​","type":1,"pageTitle":"error-interceptor","url":"docs/references/modules/error-interceptor#принцип-работы","content":"На сервере подписываемся на события unhandledRejection и внезапные остановки выполнения с помощью библиотеки death, затем ошибку кидает в консоль. "},{"title":"env","type":0,"sectionRef":"#","url":"docs/references/modules/env","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"env","url":"docs/references/modules/env#installation","content":"Already supplied inside @tramvai/module-common and does not need to be installed if module-common is connected. Otherwise, you need to install @tramvai/module-environment "},{"title":"Explanation​","type":1,"pageTitle":"env","url":"docs/references/modules/env#explanation","content":""},{"title":"Dynamically generated list of used env variables​","type":1,"pageTitle":"env","url":"docs/references/modules/env#dynamically-generated-list-of-used-env-variables","content":"All the parameters used in the application are registered by implementing the ENV_USED_TOKEN token in the DI and it is assumed that each module individually registers only the env parameters it needs. In this case, when a module is connected, there will be automatic validation of all passed parameters that are necessary for the application to work import { provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: ENV_USED_TOKEN, useValue: [ { key: 'DEBUG_MODULE', optional: true }, { key: 'DEBUG_MODULE_URL', optional: true }, ], multi: true, }), ], }) export class MyModule {} Copy In the above example, the module registers several env tokens, which will be initialized and will be available in environmentManager.get('DEBUG_MODULE'). In doing so, the optional parameter has been passed, which indicates that the variables are not required for the application to work. "},{"title":"Validation of environment variables values​","type":1,"pageTitle":"env","url":"docs/references/modules/env#validation-of-environment-variables-values","content":"When the application starts, it checks the tokens that were registered in the DI and passed to env at startup. If all required env variables have not been passed to the application, the application will crash. It is also possible to write validators for env values, which will run when the application is initialized. import { provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: ENV_USED_TOKEN, useValue: [ { key: 'MY_ENV', validator: (env) => { if (!env.includes('https')) { return 'Incorrect link format. The link should contain https'; } }, }, ], multi: true, }), ], }) export class MyModule {} Copy "},{"title":"Functionality works on the server and in the browser​","type":1,"pageTitle":"env","url":"docs/references/modules/env#functionality-works-on-the-server-and-in-the-browser","content":"All env variables will be available both on the server and in the browser without any additional actions or settings. Env variables that have dehydrate: true are automatically passed to the browser "},{"title":"Priority of obtaining values for env variables​","type":1,"pageTitle":"env","url":"docs/references/modules/env#priority-of-obtaining-values-for-env-variables","content":"Since it is possible to overwrite the values of the variables, the variables are replaced according to certain rules The replacement rules are arranged in order of priority, from lower to higher: Parameters set in tokens { key: 'ENV_PARAM', value: 'env value' }Parameters written in env.development.js filePassing application launch parameters MY_ENV=j node server.js "},{"title":"API​","type":1,"pageTitle":"env","url":"docs/references/modules/env#api","content":" Exported tokens and TS interface import { createToken } from '@tinkoff/dippy'; export interface EnvironmentManager { get(name: string): string; getInt(name: string, def: number): number; getAll(): Record<string, string>; update(result: Record<string, string>): void; clientUsed(): Record<string, string>; updateClientUsed(result: Record<string, string>): void; } /** * @description * Instance that used for managing env data on the server and on the client */ export const ENV_MANAGER_TOKEN = createToken<EnvironmentManager>('environmentManager'); /** * @description * List of envs that are used by the module or the app. * All of the envs specified by that token will be accessible in the code through `environmentManager` * ENV_USED_TOKEN format: - `key` - id of the env. At that id the value of the env will be accessible through `environmentManager` and will be loaded from the external sources. - `value` - default low-priority value for env `key` - `optional` - is current env is optional. If `true` the app can work as usual event if the env value were not provided, if `false` - the app will fail to run without env value - `validator` - validation function for passed env value. In case this function returns string it will be used as error message and validation will fail - `dehydrate` - if `false` then env value will not be passed to client and this env can be used only on server * * @example ```tsx interface EnvParameter { key: string; value?: string; optional?: boolean; validator?: (value: string) => boolean | string; dehydrate?: boolean; } ``` */ export interface EnvParameter { key: string; value?: string; optional?: boolean; validator?: (value: string) => boolean | string; dehydrate?: boolean; } export const ENV_USED_TOKEN = createToken<EnvParameter[]>('envUsed', { multi: true }); Copy  "},{"title":"How to​","type":1,"pageTitle":"env","url":"docs/references/modules/env#how-to","content":""},{"title":"How to read data in an application​","type":1,"pageTitle":"env","url":"docs/references/modules/env#how-to-read-data-in-an-application","content":"Suppose we registered the parameter CONFIG_API used by env with the ENV_USED_TOKEN token, now we need to connect environmentManager in the application and read the data: import { provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: 'MY_SERVICE', useClass: class MyService { constructor({ environmentManager }) { console.log(environmentManager.get('CONFIG_API')); } }, deps: { environmentManager: ENV_MANAGER_TOKEN, }, }), ], }) export class MyModule {} Copy This code will work both on the server and in the browser "},{"title":"How you can simply pass parameters in local development​","type":1,"pageTitle":"env","url":"docs/references/modules/env#how-you-can-simply-pass-parameters-in-local-development","content":"To do this, create a file env.development.js in the root of the project and write all env variables for the application. When the application is initialized, this file will be read. Peculiarities of using env.developmen.js in production builds​ The twelve factors application stores the configuration in environment variables, so by default when process.env.NODE_ENV === 'production' EnvironmentManger will not read the env.development.js file. If you want to test the application locally with NODE_ENV=production, you can pass the flag DANGEROUS_UNSAFE_ENV_FILES='true' so that EnvironmentManger will read the env.development.js file and not have to enter all variables by hand. "},{"title":"How to pass env parameters to the application during the deploys​","type":1,"pageTitle":"env","url":"docs/references/modules/env#how-to-pass-env-parameters-to-the-application-during-the-deploys","content":"To do this, pass env parameters when starting the application. For example in Docker you can do this with the parameter -e docker run -e MY_ENV_VAR=/ my-image. "},{"title":"How to view all env variables of an application​","type":1,"pageTitle":"env","url":"docs/references/modules/env#how-to-view-all-env-variables-of-an-application","content":"This method allows you to see only client variables To get a list of variables, there is a /papi/apiList method Request example: http://localhost:3000/${appName}/papi/apiList "},{"title":"http-proxy-agent","type":0,"sectionRef":"#","url":"docs/references/modules/http-proxy-agent","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"http-proxy-agent","url":"docs/references/modules/http-proxy-agent#installation","content":"You need to install @tramvai/module-http-proxy-agent yarn add @tramvai/module-http-proxy-agent Copy And connect in the project import { createApp } from '@tramvai/core'; import { HttpProxyAgentModule } from '@tramvai/module-http-proxy-agent'; createApp({ name: 'tincoin', modules: [ HttpProxyAgentModule ], }); Copy "},{"title":"Environment variables​","type":1,"pageTitle":"http-proxy-agent","url":"docs/references/modules/http-proxy-agent#environment-variables","content":"HTTP_PROXY - proxy url for HTTP requests http_proxy - see HTTP_PROXY HTTPS_PROXY - proxy url for HTTPS requests https_proxy - see HTTPS_PROXY NO_PROXY - list of urls patterns for which proxying is disabled no_proxy - see NO_PROXY "},{"title":"Explanation​","type":1,"pageTitle":"http-proxy-agent","url":"docs/references/modules/http-proxy-agent#explanation","content":"HttpProxyAgentModule mokeypatch standard NodeJS https.Agent for supporting connections via forwarding proxy, if some of mentioned above env variables are presented. Some NO_PROXY env specification and examples available here Source code forked from node-keepalive-proxy-agent "},{"title":"Limitations​","type":1,"pageTitle":"http-proxy-agent","url":"docs/references/modules/http-proxy-agent#limitations","content":"HttpProxyAgentModulesupport only HTTPS requests "},{"title":"http-client","type":0,"sectionRef":"#","url":"docs/references/modules/http-client","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#installation","content":"You need to install @tramvai/module-http-client yarn add @tramvai/module-http-client Copy And connect in the project import { createApp } from '@tramvai/core'; import { HttpClientModule } from '@tramvai/module-http-client'; createApp({ name: 'tincoin', modules: [HttpClientModule], }); Copy "},{"title":"Features​","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#features","content":"The http-client module adds functionality to the application related to API requests. Available providers allow you to create new services to work with any API and create more specific services with preset settings for specific APIs. The module implements interfaces from the library @tramvai/http-client using a special library - adapter @tramvai/tinkoff-request-http-client-adapter, running on top of @tinkoff/request. "},{"title":"Concepts​","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#concepts","content":""},{"title":"HTTP client​","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#http-client","content":"HTTP client - implementation of the HttpClient interface, created via the HTTP_CLIENT_FACTORY token. HTTP client accepts general settings, some of which will be used as defult values ​​for all requests. The HTTP client does not provide an opportunity to add additional methods for requests, and to perform side actions when the request is completed or failed. "},{"title":"Services for working with API​","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#services-for-working-with-api","content":"The API service inherits from the ApiService class, which is exported from @tramvai/http-client. The API service takes an HTTP client in its constructor and uses it for requests. The API service implements all methods for requests from the HttpClient interface, but allows you to modify them. For example, you can replace the implementation of the request method by adding an error message to the catch request via an HTTP client - this logic will automatically work for all other methods - get, put, post, delete. In the API service, you can add custom methods for requests to certain API endpoints, and specify only the necessary parameters in them, and type responses. Additional reasons to create API services - if you need to use several different HTTP clients to work with a specific API, or you need the ability to add a convenient abstraction on top of the basic methods for sending requests. "},{"title":"Usage​","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#usage","content":""},{"title":"Create a new HTTP client​","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#create-a-new-http-client","content":"Each new HTTP client must directly or indirectly inherit HTTP_CLIENT_FACTORY. New HTTP clients / API services should not be created with scope: Scope.SINGLETON, because each request is supplemented with default parameters specific to each user, for example - passing the X-Real-Ip header from the request to the application in all requests to the API. Basic HTTP client​ The HTTP_CLIENT_FACTORY token - provides a factory for creating new HTTP clients. The options are preinstalled with a logger and a cache factory. Peculiarities​ For all requests to the API, headers are added from the list returned by the API_CLIENT_PASS_HEADERS token, and X-Real-Ip from the current request to the application Token interface: type HTTP_CLIENT_FACTORY = (options: HttpClientFactoryOptions) => HttpClient; Copy Token use: import { Scope, provide } from '@tramvai/core'; import { ENV_MANAGER_TOKEN } from '@tramvai/tokens-common'; import { HTTP_CLIENT_FACTORY } from '@tramvai/tokens-http-client'; const provider = provide({ provide: 'WHATEVER_API_HTTP_CLIENT', useFactory: ({ factory, envManager, }: { factory: typeof HTTP_CLIENT_FACTORY; envManager: typeof ENV_MANAGER_TOKEN; }) => { return factory({ name: 'whatever-api', baseUrl: envManager.get('WHATEVER_API'), }); }, deps: { factory: HTTP_CLIENT_FACTORY, envManager: ENV_MANAGER_TOKEN, }, }); Copy "},{"title":"Using existing HTTP clients​","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#using-existing-http-clients","content":"Most HTTP clients implement additional logic for requests, and inherit from ApiService. Thus, each service has methods get, post, put, delete and request, but there may be specific methods. Common HTTP client​ The HTTP_CLIENT token provides a basic client for sending requests to any URLs, request caching is disabled. Token use: import { createAction } from '@tramvai/core'; import { HTTP_CLIENT } from '@tramvai/tokens-http-client'; export const fetchAction = createAction({ name: 'fetch', fn: async (_, __, { httpClient }) => { const { payload, headers, status } = await httpClient.get( 'https://www.domain.com/api/endpoint' ); return payload; }, deps: { httpClient: HTTP_CLIENT, }, }); Copy "},{"title":"Adding custom data to requests​","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#adding-custom-data-to-requests","content":"Let's consider a case using the abstract service WHATEVER_API_SERVICE as an example. Let's say we want to add an X-Real-Ip header to every request: import { provide } from '@tramvai/core'; import { HttpClientRequest, HttpClient } from '@tramvai/http-client'; import { REQUEST_MANAGER_TOKEN } from '@tramvai/tokens-common'; const provider = provide({ provide: 'WHATEVER_API_SERVICE', useFactory: ({ factory, requestManager, envManager, }: { factory: typeof HTTP_CLIENT_FACTORY; requestManager: typeof REQUEST_MANAGER_TOKEN; envManager: typeof ENV_MANAGER_TOKEN; }) => { return factory({ name: 'whatever-api', baseUrl: envManager.get('WHATEVER_API'), modifyRequest: (request: HttpClientRequest) => { return { ...request, headers: { ...request.headers, 'X-real-ip': requestManager.getClientIp(), }, }; }, }); }, deps: { factory: HTTP_CLIENT_FACTORY, requestManager: REQUEST_MANAGER_TOKEN, envManager: ENV_MANAGER_TOKEN, }, }); Copy "},{"title":"How to​","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#how-to","content":""},{"title":"How to disable HTTP request caching?​","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#how-to-disable-http-request-caching","content":"To disable caching for all HTTP clients, pass the env variable HTTP_CLIENT_CACHE_DISABLED: true to the application "},{"title":"Testing​","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#testing","content":"Testing your api clients​ If you have a module or providers that define api-clients, then it will be convenient to use special utilities in order to test them separately import { testApi } from '@tramvai/module-http-client/tests'; import { CustomModule } from './module'; describe('testApi', () => { it('test', async () => { const { di, fetchMock, mockJsonResponse } = testApi({ modules: [CustomModule], env: { TEST_API: 'testApi', }, }); const httpClient: typeof HTTP_CLIENT = di.get('CUSTOM_HTTP_CLIENT') as any; mockJsonResponse({ a: 'aaa' }); const { payload } = await httpClient.get('test'); expect(payload).toEqual({ a: 'aaa' }); expect(fetchMock).toHaveBeenCalledWith('http://testApi/test', expect.anything()); }); }); Copy "},{"title":"Logging​","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#logging","content":"By default, @tinkoff/request will log every failed requests with level error. You can disable logging by pass { silent: true } parameter to request parameters. Useful meta information about request will be available in error.__meta property. Example: const log = logger('request:test'); httpClient.request({ path: 'test', silent: true }).catch((error) => { log.info(error); }); Copy "},{"title":"Debug​","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#debug","content":"You can show all the default logs of http clients by providing these env variables: LOG_ENABLE=request* LOG_LEVEL=trace Copy If the built-in http clients logs are not enough, you can enable NodeJS debugging of the request module this way: NODE_DEBUG=request tramvai start<appName> Copy "},{"title":"Exported tokens​","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#exported-tokens","content":"link "},{"title":"Environment Variables​","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#environment-variables","content":"HTTP_CLIENT_CACHE_DISABLED - disable caching for all HTTP clientsHTTP_CLIENT_CIRCUIT_BREAKER_DISABLED - disable plugin https://tinkoff.github.io/tinkoff-request/docs/plugins/circuit-breaker.html "},{"title":"log","type":0,"sectionRef":"#","url":"docs/references/modules/log","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"log","url":"docs/references/modules/log#installation","content":"Module is automatically installs and adds with module @tramvai/module-common "},{"title":"Explanation​","type":1,"pageTitle":"log","url":"docs/references/modules/log#explanation","content":""},{"title":"Display logs​","type":1,"pageTitle":"log","url":"docs/references/modules/log#display-logs","content":"see @tinkoff/logger. By default, on server all of the logs of level warn and above are enabled. On the client in dev-mode all the logs of level error and above are enabled while in prod-mode all of the logs on client are disabled. "},{"title":"Send logs to the API​","type":1,"pageTitle":"log","url":"docs/references/modules/log#send-logs-to-the-api","content":"It is implied that logs from the server are collected by the external tool that has access to the server console output and because of this logging to the external API from the server is not needed. In browser logs to the API are send with RemoteReporter. By default, all of the logs with levels error and fatal are send. The url for the API is specified by environment variable FRONT_LOG_API. For the customization see docs for the RemoteReporter. "},{"title":"See logs from the server in browser​","type":1,"pageTitle":"log","url":"docs/references/modules/log#see-logs-from-the-server-in-browser","content":"This functionality is available only in dev-mode and can make development a little easier. In browser console when loading page of the app the special log group with name Tramvai SSR Logs will be showed. If you open this group you will see logs from the server that was logged to this particular request. Herewith will be displayed only logs that are enabled for the displaying on the server. If you want to see all of the logs in browser with settings for displaying in browser you can specify env DEBUG_FULL_SSR when running app. "},{"title":"See logs for the requests​","type":1,"pageTitle":"log","url":"docs/references/modules/log#see-logs-for-the-requests","content":"Works only with @tinkoff/request http-client is already passes logger and its settings to the log plugin. Plugin automatically generates names for loggers using template request.${name} that might be used to setting up displaying of logs: const logger = di.get(LOGGER_TOKEN); const makeRequest = request([...otherPlugins, logger({ name: 'my-api-name', logger })]); Copy As name of the logger equals to my-api-name to show logs: on server extend env LOG_ENABLE: 'request.my-api-name'on client call logger.enable('request.my-api-name') "},{"title":"Change logger settings on server​","type":1,"pageTitle":"log","url":"docs/references/modules/log#change-logger-settings-on-server","content":"By default, settings for the logger on server are specified by envs LOG_ENABLE and LOG_LEVEL. You can change this settings in runtime using papi-route {app}/private/papi/logger Displaying of the logs is changed by query with the name enable, e.g.: https://localhost:3000/{app}/private/papi/logger?enable=request.tinkoff Copy Level of the logs is change by query with the name level, e.g.: https://localhost:3000/{app}/private/papi/logger?level=warn Copy To reset settings to default, based on env, use mode=default: https://localhost:3000/{app}/private/papi/logger?mode=default Copy "},{"title":"Env​","type":1,"pageTitle":"log","url":"docs/references/modules/log#env","content":"LOG_LEVEL = trace | debug | info | warn | error | fatal - show logs with specified level and higher. E.g.: if LOG_LEVEL=info then logs with levels info, warn, error, fatal will be showed LOG_ENABLE = ${name} | ${level}:${name} - show logs with specified name of the logger or name + level. Several entries are passed with comma as delimiter. E.g.: if LOG_ENABLE=server then show logs with the name serverif LOG_ENABLE=trace:server* then show logs with the name server and level traceif LOG_ENABLE=info:server,client,trace:shared then show all of the specified logs using rules from above "},{"title":"Debug​","type":1,"pageTitle":"log","url":"docs/references/modules/log#debug","content":"Module uses logger with the id ssr-logger "},{"title":"How to​","type":1,"pageTitle":"log","url":"docs/references/modules/log#how-to","content":""},{"title":"Example of base usage​","type":1,"pageTitle":"log","url":"docs/references/modules/log#example-of-base-usage","content":"import { Module, commandLineListToken, provide } from '@tramvai/core'; import { LOGGER_TOKEN } from '@tramvai/module-common'; @Module({ providers: [ provide({ provide: commandLineListToken.customerStart, useFactory: ({ logger }) => { logger.debug('customer start'); // logging in the global namespace const myLogger = logger({ name: 'test', }); myLogger.warn('warning'); // logging in the namespace test myLogger.error('error!'); }, deps: { logger: LOGGER_TOKEN, }, }), ], }) export class MyModule {} Copy "},{"title":"How to properly format logs​","type":1,"pageTitle":"log","url":"docs/references/modules/log#how-to-properly-format-logs","content":"See @tinkoff/logger "},{"title":"Exported tokens​","type":1,"pageTitle":"log","url":"docs/references/modules/log#exported-tokens","content":""},{"title":"LOGGER_TOKEN​","type":1,"pageTitle":"log","url":"docs/references/modules/log#logger_token","content":"Instance of the logger. Replaces base implementation for the LOGGER_TOKEN from the @tramvai/module-common "},{"title":"mocker","type":0,"sectionRef":"#","url":"docs/references/modules/mocker","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#installation","content":"First, install @tramvai/module-mocker: npmYarn npm install @tramvai/module-mocker Copy Then, add your first mock to a new file mocks/my-api.js. In this file add export of object literal with the field api that should be specified as a name of environment variable for the API url that should be mocked: module.exports = { api: 'MY_API', mocks: { 'GET /endpoint?foo=bar': { status: 200, headers: {}, payload: { result: { type: 'json', value: { a: 'b', }, }, }, }, }, }; Copy Add module to the project: import { createApp } from '@tramvai/core'; import { MockerModule } from '@tramvai/module-module'; createApp({ name: 'tincoin', modules: [MockerModule], }); Copy Run app with env MOCKER_ENABLED, e.g.: MOCKER_ENABLED=\"true\" tramvai start tincoin Copy After that, all of the requests to MY_API in browser and on server will be automatically sent to mocker. In case mocker doesn't have a suitable mock the request, the request will be proxied to the original API. "},{"title":"Explanation​","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#explanation","content":"Most of the mocker features are described in the lib documentation. Module adds mocker middleware to papi route /mocker and replaces all of the env variables that were defined in mocks by links to the papi. After that all of the request to the original API are routed first to mocker that accepts requests from the client and the server side. By default, all of the API that were defined mocks are mocked, but it might be overridden. Mocker us enabled only when env variable MOCKER_ENABLED is defined. "},{"title":"Env variables replacement​","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#env-variables-replacement","content":"Let's say app has env variable MY_API: https://www.my-api.com/ and for that api some mock is defined. The module can work locally, on dynamic stand, in test/stage environments. But this flexibility leads to the following problems when resolving path to the papi endpoint: On server we should execute requests with absolute path. In this case we know that app is always available at localhost that mean we can replace API env variables by urls like http://localhost:3000/tincoin/papi/mocker/MY_API/On client test stands we do not known the domain of the app. In this case we should make requests by relative urls that mean we can replace API env variables by urls like /tincoin/papi/mocker/MY_API/ Thanks to this env replacement we can redirect all of the request to the APIs to our mocker first automatically. "},{"title":"How to​","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#how-to","content":""},{"title":"Mock only specific API​","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#mock-only-specific-api","content":"By default, all of the API that has corresponding mock will be mocked. It might be overridden by passing list of the APIs to mock when initializing module: MockerModule.forRoot({ config: () => ({ apis: ['MY_API'], }), }); Copy "},{"title":"Exported tokens​","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#exported-tokens","content":" import { createToken } from '@tinkoff/dippy'; import type { Mocker, MockRepository } from '@tinkoff/mocker'; export interface MockerOptions { apis: string[]; } export const MOCKER = createToken<Mocker>('MOCKER'); export const MOCKER_REPOSITORY = createToken<MockRepository[]>('MOCKER_REPOSITORY', { multi: true, }); export const MOCKER_CONFIGURATION = createToken<() => Promise<MockerOptions>>( 'MOCKER_CONFIGURATION' ); Copy  "},{"title":"metrics","type":0,"sectionRef":"#","url":"docs/references/modules/metrics","content":"","keywords":""},{"title":"Explanation​","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#explanation","content":""},{"title":"Monitoring outgoing requests​","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#monitoring-outgoing-requests","content":"To monitor the state of the outgoing requests (like number of requests, number of error, time execution) the module monkey-patches request and get methods of the standard modules http and https. To make it work just add metrics module to the app. Next labels are added to metrics: http methodhttp response codeservice name Name of the service calculates by comparing request urls with values in MetricsServicesRegistry. Initially the register is bootstrapped with the inverted content of env variables, e.g. if some url from env is a substring of the request url, then the name of the env become the service name. If several envs matches this logic then the env with the longest url is used. "},{"title":"Client metrics​","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#client-metrics","content":"Module implements feature to collect metrics from the clients and share it with Prometheus by sending metrics from the client to server papi-route. Metrics module can help in implementing this functionality in common cases. To create metric register provider for the token REGISTER_INSTANT_METRIC_TOKEN. Your provider should return list of two entities - first is a slug of papi-route and second is an instance of Counter. E.g.: import { provide } from '@tramvai/core'; provide({ provide: REGISTER_INSTANT_METRIC_TOKEN, multi: true, deps: { metrics: METRICS_MODULE_TOKEN, }, useFactory({ metrics }) { return ['page-load', new Counter({ name: 'client_page_load_total', help: 'Client page load' })]; }, }); Copy After that to increment metric client_page_load_total you can call papi-route /metrics/page-load. instantMetricsReporter​ In practice it become clear that besides metric collection it often needed to collect logs with details. This can be implemented with instantMetricsReporter. When calling logger module will check that any metric with the slug equal to the event of the log is exist. If so module will send request to the corresponding papi-route. Next way you can log event and increment server metric: import { provide } from '@tramvai/core'; provide({ provide: commandLineListTokens.init, multi: true, deps: { logger: LOGGER_TOKEN, }, useFactory({ logger }) { return () => { window.on('load', () => { logger.info({ event: 'page-load' }); }) }; }, }), Copy "},{"title":"How to​","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#how-to","content":""},{"title":"Usage Example​","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#usage-example","content":"import { createToken } from '@tinkoff/dippy'; import { Module, provide } from '@tramvai/core'; import { Counter, Metrics, METRICS_MODULE_TOKEN } from '@tramvai/tokens-metrics'; interface SomeModuleOptions { metrics: Metrics; } class SomeModule { private metricActionCounter: Counter; constructor(options: SomeModuleOptions) { this.metricActionCounter = options.metrics.counter({ name: 'some_actions_total', help: 'Total count of some actions', }); } public action(): void { this.metricActionCounter.inc(); // Do some meaningful action } } export const SOME_MODULE = createToken<SomeModule>('someModule'); @Module({ providers: [ provide({ provide: SOME_MODULE, useFactory: (deps) => new SomeModule(deps), deps: { metrics: METRICS_MODULE_TOKEN, }, }), ], }) export class SomeModuleContainer {} Copy "},{"title":"Make service names showed in metrics instead of hostnames​","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#make-service-names-showed-in-metrics-instead-of-hostnames","content":"It is possible to give a hint to module about the service name in case url is dynamic. To do that: use token METRICS_SERVICES_REGISTRY_TOKEN;call metricsServicesRegistry.register(\"Part of the url or the whole url\", \"Name of service\") "},{"title":"Use metrics to profile performance in browser​","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#use-metrics-to-profile-performance-in-browser","content":"To measure length of the events you must use method startTimer of classes Gauge, Histogram, Summary. In dev-mode these classes are patched and methods to work with timers will use PerformanceApi. Example without additional fields: const metric = metrics.gauge({ name: 'request_measure', help: 'Request duration measure', }); const endTimer = metric.startTimer(); fetch(url).then(() => { endTimer(); // output the result - performance.getEntriesByName('request_measure'); }); Copy Example with adding dynamic fields: const metric = metrics.gauge({ name: 'request_measure', help: 'Request duration measure', }); const endTimer = metric.startTimer({ method: 'GET' }); fetch(url).then(() => { endTimer({ status: 200 }); // output the result - performance.getEntriesByName('request_measure{method=\"GET\",status=\"200\"}'); }); Copy "},{"title":"Debug​","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#debug","content":"The module uses loggers with the next ids: metrics:perf, metrics:papi "},{"title":"Exported tokens​","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#exported-tokens","content":"link "},{"title":"react-query","type":0,"sectionRef":"#","url":"docs/references/modules/react-query","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#installation","content":"You need to install @tramvai/module-react-query yarn add @tramvai/module-react-query Copy And connect in the project import { createApp } from '@tramvai/core'; import { ReactQueryModule } from '@tramvai/module-react-query'; createApp({ name: 'tincoin', modules: [...ReactQueryModule], }); Copy "},{"title":"Explanation​","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#explanation","content":"The module adds an instance react-query QueryClient to the DI и and allows specifying options for creating it. The module also adds React wrappers for react-query to the application renderer, which allow using functions for working with query inside components. "},{"title":"Server​","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#server","content":"On the server, the module also additionally performs dehydration of the data preloaded on the server in order to transfer them to the client "},{"title":"Client​","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#client","content":"The browser additionally performs rehydration of the data preloaded on the server "},{"title":"API​","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#api","content":"The module basically provides the necessary things in DI for the library @tramvai/react-query and itself may be needed only if there is a need to change the settings for QueryClient or use QueryClient directly (but better not to use directly) "},{"title":"How to​","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#how-to","content":""},{"title":"Enable devtools​","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#enable-devtools","content":"React-query devtools are provided through @tramvai/module-dev-tools and to enable it both modules should be passed to modules list: import { ReactQueryModule, ReactQueryDevtoolsModule } from '@tramvai/module-react-query'; import { DevToolsModule } from '@tramvai/module-dev-tools'; createApp({ name: 'app', modules: [ ...modules, ReactQueryModule, ...(process.env.NODE_ENV === 'development' ? [DevToolsModule, ReactQueryDevtoolsModule] : []), ], bundles: {}, providers: [], }); Copy "},{"title":"Exported tokens​","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#exported-tokens","content":" import { createToken } from '@tinkoff/dippy'; import type { QueryClient, DefaultOptions } from 'react-query'; import type { DehydratedState } from 'react-query/hydration'; /** * @description * [Клиент react-query](https://react-query.tanstack.com/reference/QueryClient) */ export const QUERY_CLIENT_TOKEN = createToken<QueryClient>('reactQuery queryClient'); /** * @description * [Дефолтные опции для клиента react-query](https://react-query.tanstack.com/guides/important-defaults) */ export const QUERY_CLIENT_DEFAULT_OPTIONS_TOKEN = createToken<DefaultOptions>( 'reactQuery queryClientDefaultOptions' ); /** * @description * [Стейт для клиента react-query](https://react-query.tanstack.com/reference/hydration/dehydrate), иницилизированный на сервере */ export const QUERY_CLIENT_DEHYDRATED_STATE_TOKEN = createToken<DehydratedState>( 'reactQuery queryClientDehydratedState' ); export const QUERY_DEHYDRATE_STATE_NAME_TOKEN = createToken<string>( 'reactQuery dehydrate state name' ); Copy  "},{"title":"render","type":0,"sectionRef":"#","url":"docs/references/modules/render","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"render","url":"docs/references/modules/render#overview","content":" Module contains the logic for generating HTML pages, starting from getting current page component, and finishing with the rendering result HTML using the @tinkoff/htmlpagebuilder library. This module includes code for creating top-level React component with all necessary providers composition, and page and layout components from the current route. "},{"title":"Installation​","type":1,"pageTitle":"render","url":"docs/references/modules/render#installation","content":"You need to install @tramvai/module-render npmYarn npm install @tramvai/module-render Copy And connect to the project import { createApp } from '@tramvai/core'; import { RenderModule } from '@tramvai/module-render'; createApp({ name: 'tincoin', modules: [RenderModule], }); Copy "},{"title":"Explanation​","type":1,"pageTitle":"render","url":"docs/references/modules/render#explanation","content":""},{"title":"Different React rendering modes​","type":1,"pageTitle":"render","url":"docs/references/modules/render#different-react-rendering-modes","content":"More information about rendering modes can be found in the official documentation, RenderModule has support for all rendering types and you can choose the right one for your application. To set the mode, you must pass the mode parameter when initializing the RenderModule. RenderModule.forRoot({ mode: 'concurrent' }); Copy Available modes: 'legacy' | 'strict' | 'blocking' | 'concurrent' Gradual concurrent mode adoption "},{"title":"Application static assets​","type":1,"pageTitle":"render","url":"docs/references/modules/render#application-static-assets","content":"For static assets (JS, CSS, fonts, etc.) we create special resources registry module, which allow to provide in DI list of resources, and then render them to specifics slots in final HTML. Example: createApp({ providers: [ { multi: true, useValue: [ { type: ResourceType.inlineScript, // inlineScript wrap payload in tag <script> slot: ResourceSlot.HEAD_CORE_SCRIPTS, // define position where in HTML will be included resource payload: 'alert(\"render\")', }, { type: ResourceType.asIs, // asIs just add payload as a string, without special processing slot: ResourceSlot.BODY_TAIL, payload: '<div>hello from render slots</div>', }, ], }, ], }); Copy type - presets for different resources typesslot - slot in HTML where resource will be includedpayload - information that will be rendered  Available slots export const REACT_RENDER = 'react:render'; export const HEAD_PERFORMANCE = 'head:performance'; export const HEAD_META = 'head:meta'; export const HEAD_POLYFILLS = 'head:polyfills'; export const HEAD_CORE_STYLES = 'head:core-styles'; export const HEAD_CORE_SCRIPTS = 'head:core-scripts'; export const HEAD_DYNAMIC_SCRIPTS = 'head:dynamic-scripts'; export const HEAD_ANALYTICS = 'head:analytics'; export const HEAD_ICONS = 'head:icons'; export const BODY_START = 'body:start'; export const BODY_END = 'body:end'; export const BODY_TAIL_ANALYTICS = 'body:tail:analytics'; export const BODY_TAIL = 'body:tail'; Copy   Layout of slots in the HTML page import type { StaticDescriptor, DynamicDescriptor } from '@tinkoff/htmlpagebuilder'; import { dynamicRender, staticRender } from '@tinkoff/htmlpagebuilder'; import { ResourceSlot } from '@tramvai/tokens-render'; import { formatAttributes } from './utils'; const { REACT_RENDER, HEAD_CORE_SCRIPTS, HEAD_DYNAMIC_SCRIPTS, HEAD_META, HEAD_POLYFILLS, HEAD_CORE_STYLES, HEAD_PERFORMANCE, HEAD_ANALYTICS, BODY_START, BODY_END, HEAD_ICONS, BODY_TAIL_ANALYTICS, BODY_TAIL, } = ResourceSlot; export const htmlPageSchemaFactory = ({ htmlAttrs, }): Array<StaticDescriptor | DynamicDescriptor> => { return [ staticRender('<!DOCTYPE html>'), staticRender(`<html ${formatAttributes(htmlAttrs, 'html')}>`), staticRender('<head>'), staticRender('<meta charset=\"UTF-8\">'), dynamicRender(HEAD_META), dynamicRender(HEAD_PERFORMANCE), dynamicRender(HEAD_CORE_STYLES), dynamicRender(HEAD_POLYFILLS), dynamicRender(HEAD_DYNAMIC_SCRIPTS), dynamicRender(HEAD_CORE_SCRIPTS), dynamicRender(HEAD_ANALYTICS), dynamicRender(HEAD_ICONS), staticRender('</head>'), staticRender(`<body ${formatAttributes(htmlAttrs, 'body')}>`), dynamicRender(BODY_START), // react app dynamicRender(REACT_RENDER), dynamicRender(BODY_END), dynamicRender(BODY_TAIL_ANALYTICS), dynamicRender(BODY_TAIL), staticRender('</body>'), staticRender('</html>'), ]; }; Copy  How to add assets loading to a page "},{"title":"Automatic resource inlining​","type":1,"pageTitle":"render","url":"docs/references/modules/render#automatic-resource-inlining","content":"Concept​ A large number of resource files creates problems when loading the page, because the browser has to create a lot of connections to small files Solution​ To optimize page loading, we've added the ability to include some resources directly in the incoming HTML from the server. To avoid inlining everything at all, we've added the ability to set an upper limit for file size. Connection and configuration​ Since version 0.60.7 inlining for styles is enabled by default, CSS files smaller than 40kb before gzip (+-10kb after gzip) are inlined. To override these settings, add a provider specifying types of resources to be inlined (styles and/or scripts) and an upper limit for file size (in bytes, before gzip): import { RESOURCE_INLINE_OPTIONS } from '@tramvai/tokens-render'; import { ResourceType } from '@tramvai/tokens-render'; import { provide } from '@tramvai/core'; provide({ provide: RESOURCE_INLINE_OPTIONS, useValue: { types: [ResourceType.script, ResourceType.style], // Turn on for a CSS and JS files threshold: 1024, // 1kb unzipped }, }), Copy Peculiarities​ All scripts and styles (depending on the settings) registered through the ResourcesRegistry are inlined. File uploading to the server occurs in lazy mode, asynchronously. This means that there will be no inlining when the page first loads. It also means that there is no extra waiting for resources to load on the server side. Once the file is in the cache it will be inline. The cache has a TTL of 30 minutes and there is no resetting of the cache. "},{"title":"Automatic resource preloading​","type":1,"pageTitle":"render","url":"docs/references/modules/render#automatic-resource-preloading","content":"To speed up data loading, we've added a preloading system for resources and asynchronous chunks, which works according to the following scenario: After rendering the application, we get information about all the CSS, JS bundles and asynchronous chunks used in the applicationNext we add all the CSS to the preload tag and add onload event on them. We need to load the blocking resources as quickly as possible.When loading any CSS file, onload event will be fired (only once time) and add all preload tags to the necessary JS files "},{"title":"Basic layout​","type":1,"pageTitle":"render","url":"docs/references/modules/render#basic-layout","content":"The RenderModule has a default basic layout that supports different ways of extending and adding functionality Read more about layout on the library page Adding a basic header and footer​ The module allows you to add header and footer components, which will be rendered by default for all pages Via provider​ Register header and footer components through providers: import { DEFAULT_HEADER_COMPONENT, DEFAULT_FOOTER_COMPONENT } from '@tramvai/tokens-render'; import { provide } from '@tramvai/core'; createApp({ providers: [ provide({ provide: DEFAULT_HEADER_COMPONENT, useValue: DefaultHeader, }), provide({ provide: DEFAULT_FOOTER_COMPONENT, useValue: DefaultFooter, }), ], }); Copy Via bundle​ You can register a headerDefault and footerDefault component in the bundle, which will be rendered for all routes that do not have headerComponent and footerComponent redefined in configuration: createBundle({ name: 'common-bundle', components: { headerDefault: CustomHeader, footerDefault: CustomFooter, }, }); Copy Adding components and wrappers​ You can add custom components and wrappers for layout via the token LAYOUT_OPTIONS import { provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: 'LAYOUT_OPTIONS', multi: true, useValue: { // React components components: { // content component, this component wraps the header, page and footer content: Content, // page component page: Page, // any global components alerts: Alerts, feedback: Feedback, }, // HOC's for components wrappers: { layout: layoutWrapper, alerts: [alertWrapper1, alertWrapper2], }, }, }), ], }) export class MyLayoutModule {} Copy More details about the components and wrappers options can be found in @tinkoff/layout-factory Replacing the basic layout​ If the basic layout doesn't work for you, you can replace it with any other React component. In doing so, you need to implement all the wrappers yourself and plug in global components if you need them. You can replace it in two ways: Add layoutComponent to route​ You can add a layoutComponent property to route config and register component in bundle. This layout will be rendered when you go to the corresponding route. createBundle({ name: 'common-bundle', components: { myCustomLayout: CustomLayout, }, }); Copy Replace layoutDefault​ You can register a layoutDefault component in bundle, which will be automatically rendered for all routes that do not have an layoutComponent in config property. createBundle({ name: 'common-bundle', components: { layoutDefault: CustomLayout, }, }); Copy "},{"title":"How to​","type":1,"pageTitle":"render","url":"docs/references/modules/render#how-to","content":""},{"title":"How to add assets loading to a page​","type":1,"pageTitle":"render","url":"docs/references/modules/render#how-to-add-assets-loading-to-a-page","content":"There are 2 main ways how you can add resources to your application The RENDER_SLOTS token, where you can pass a list of resources, such as HTML markup, inline scripts, script tagToken RESOURCES_REGISTRY to get the resource manager, and register the desired resources manually Example:  Application example import React from 'react'; import { createApp, createBundle, commandLineListTokens } from '@tramvai/core'; import { RENDER_SLOTS, RESOURCES_REGISTRY, ResourceType, ResourceSlot, } from '@tramvai/module-render'; import { modules } from '../common'; function Page() { return <div>Render</div>; } const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, }, }); createApp({ name: 'render-add-resources', modules: [...modules], providers: [ { // If you want to add your own resources (scripts, styles, images) for loading, // you can use the provider RENDER_SLOTS to add the necessary assets, // all this will then be used in the RenderModule and inserted into HTML provide: RENDER_SLOTS, multi: true, useValue: [ { type: ResourceType.inlineScript, // inlineScript wrap payload in tag <script> slot: ResourceSlot.HEAD_CORE_SCRIPTS, // define position where in HTML will be included resource payload: 'alert(\"render\")', }, { type: ResourceType.asIs, // asIs just add payload as a string, without special processing slot: ResourceSlot.BODY_TAIL, payload: '<div>hello from render slots</div>', }, ], }, { provide: commandLineListTokens.resolveUserDeps, multi: true, // You can also add resources separately via DI and the RESOURCES_REGISTRY token useFactory: ({ resourcesRegistry }) => { return function addMyScripts() { resourcesRegistry.register({ type: ResourceType.script, // script will create new script tag with src equal to payload slot: ResourceSlot.HEAD_ANALYTICS, // define position where in HTML will be included resource payload: './some-script.js', }); }; }, deps: { resourcesRegistry: RESOURCES_REGISTRY, }, }, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), }, }); Copy  "},{"title":"Gradual concurrent mode adoption​","type":1,"pageTitle":"render","url":"docs/references/modules/render#gradual-concurrent-mode-adoption","content":"React allows a gradual migration of an application Stages of migration: Strict Mode - strict mode, in which React warns about using the legacy API To connect, you must configure the RenderModule modules: [ RenderModule.forRoot({ mode: 'strict' }) ] Copy Then you need to fix any new warnings, such as using legacy lifecycle methods and string refs. Blocking Mode - adds some Concurrent Mode features, such as Suspense on the server. Suitable for gradual migration to Concurrent Mode. To connect, install an experimental version of React and configure the RenderModule npmYarn npm install react@experimental react-dom@experimental Copy modules: [ RenderModule.forRoot({ mode: 'blocking' }) ] Copy At this stage, you need to check the performance of the application, and you can try new APIs, for example SuspenseList Concurrent Mode To connect, install an experimental version of React and configure the RenderModule npmYarn npm install react@experimental react-dom@experimental Copy modules: [ RenderModule.forRoot({ mode: 'concurrent' }) ] Copy At this stage, you need to check the performance of the application, and you can try new APIs, for example useTransition "},{"title":"Testing​","type":1,"pageTitle":"render","url":"docs/references/modules/render#testing","content":"Testing render extensions via RENDER_SLOTS or RESOURCES_REGISTRY tokens​ If you have a module or providers that define RENDER_SLOTS or use RESOURCES_REGISTRY, it is convenient to use special utilities to test them separately import { RENDER_SLOTS, ResourceSlot, RESOURCES_REGISTRY, ResourceType, } from '@tramvai/tokens-render'; import { testPageResources } from '@tramvai/module-render/tests'; import { CustomModule } from './module'; import { providers } from './providers'; describe('testPageResources', () => { it('modules', async () => { const { render } = testPageResources({ modules: [CustomModule], }); const { head } = render(); expect(head).toMatchInlineSnapshot(` \" <meta charset=\\\\\"UTF-8\\\\\"> <script>console.log(\\\\\"from module!\\\\\")</script> \" `); }); it('providers', async () => { const { render, runLine } = testPageResources({ providers, }); expect(render().body).toMatchInlineSnapshot(` \" \" `); await runLine(commandLineListTokens.resolvePageDeps); expect(render().body).toMatchInlineSnapshot(` \" <script defer=\\\\\"defer\\\\\" charset=\\\\\"utf-8\\\\\" crossorigin=\\\\\"anonymous\\\\\" src=\\\\\"https://scripts.org/script.js\\\\\"></script> <span>I\\`m body!!!</span> \" `); }); }); Copy "},{"title":"Exported tokens​","type":1,"pageTitle":"render","url":"docs/references/modules/render#exported-tokens","content":"link "},{"title":"sentry","type":0,"sectionRef":"#","url":"docs/references/modules/sentry","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#installation","content":"You need to install @tramvai/module-sentry: yarn add @tramvai/module-sentry Copy And connect to the project: SentryModule: warning Put SentryModule as one of the first modules in the list. import { SentryModule } from '@tramvai/module-sentry'; createApp({ modules: [SentryModule], }); Copy And make sure to add SENTRY_DSN environment on deployed stands. Otherwise module will not work. "},{"title":"Explanation​","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#explanation","content":""},{"title":"Environment variables​","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#environment-variables","content":"Required: SENTRY_DSN - DSN of the app Optional: SENTRY_RELEASE - information about current app releaseSENTRY_ENVIRONMENT - information about environmentSENTRY_SDK_URL - URL for downloading Sentry SDK in browserSENTRY_DSN_CLIENT - DSN of the app for use in browser "},{"title":"Sensitive Data​","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#sensitive-data","content":"Before start to use the module take a closer look to the sentry documentation. Sentry tries to enrich error context as much as possible by using breadcrumbs, getting information from additional integrations. It is all configurable but it still should be carefully monitored what data is saved in Sentry storage. "},{"title":"Behaviour​","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#behaviour","content":"Module uses universal approach that let use error logging on the client and server. Integration with Sentry SDK happens on commandLineListTokens.init. By default Sentry is enabled only on production and if DSN was provided. Browser​ Module uses lazy loaded approach. This way Sentry SDK is added dynamically and only if needed, e.g. @sentry/browser is not bundled to the app Node​ Uses @sentry/node and Sentry express middleware "},{"title":"How to​","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#how-to","content":""},{"title":"Send custom error​","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#send-custom-error","content":"import { createAction } from '@tramvai/core'; import { SENTRY_TOKEN } from '@tramvai/module-sentry'; import { loadUsers } from './users'; export default createAction({ name: 'loadUsers', fn: async (context, _, { sentry }) => { try { await loadUsers(); } catch (e) { sentry.captureException(e); throw e; } }, deps: { sentry: SENTRY_TOKEN, }, }); Copy "},{"title":"Debug locally​","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#debug-locally","content":"Sentry is disabled on local run and if you want to debug it you have to enable Sentry explicitly. SentryModule.forRoot({ enabled: true, debug: true }); Copy Add parameter SENTRY_DSN to env.development.js. After steps below Sentry will be enabled while local development. "},{"title":"Get DSN​","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#get-dsn","content":"Go to the Sentry UIClick on tab SettingsIn the tab Projects pick up your project выберите свой проектChoose Client Keys (DSN)From DSN field copy text with Default . "},{"title":"Upload sourcemaps​","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#upload-sourcemaps","content":"To upload sourcemaps to Sentry storage you can use @sentry/cli. warning It is important to specify --url-prefixin right way. Flag --rewrite is used to reduce size of the files to upload and perform checks for the sourcemaps correctness. Example script: set -eu -o pipefail -x PACKAGE_VERSION=$(node -p -e \"require('./package.json').version\") VERSION=${SENTRY_RELEASE:-\"${PACKAGE_VERSION}-${CI_COMMIT_SHA}\"} export SENTRY_PROJECT=\"${APP}\" export SENTRY_URL=\"${SENTRY_URL_TEST}\" export SENTRY_AUTH_TOKEN=\"${SENTRY_AUTH_TOKEN_TEST}\" sentry-cli releases files $VERSION upload-sourcemaps --rewrite --url-prefix \"~/\" ./server/ & \\ sentry-cli releases files $VERSION upload-sourcemaps --rewrite --url-prefix \"~/platform/\" ./assets/ Copy In order to generate sourcemaps for server specify \"sourceMapServer\": true to configurations to app's tramvai.json. "},{"title":"Exported tokens​","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#exported-tokens","content":"SENTRY_TOKEN​ Ready to use instance of Sentry that was created with Node SDK or Browser SDK "},{"title":"SENTRY_OPTIONS_TOKEN​","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#sentry_options_token","content":"Configuration options for Sentry either for Node or for Browser environment "},{"title":"SENTRY_REQUEST_OPTIONS_TOKEN​","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#sentry_request_options_token","content":"Configuration options for the request data parser for the express middleware "},{"title":"SENTRY_FILTER_ERRORS​","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#sentry_filter_errors","content":"Can be used to pass function to perform filtering on error objects before sending it to Sentry. Process is described in Sentry docs. Function accepts arguments event and hint for method beforeSend. "},{"title":"seo","type":0,"sectionRef":"#","url":"docs/references/modules/seo","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#installation","content":"You need to install @tramvai/module-seo npm i @tramvai/module-seo Copy And connect to the project import { createApp } from '@tramvai/core'; import { SeoModule } from '@tramvai/module-seo'; createApp({ name: 'tincoin', modules: [...SeoModule], }); Copy "},{"title":"Tramvai integration​","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#tramvai-integration","content":"The module does not add a public api to the DI. The seo renderer uses the @tramvai/module-render capabilities to insert code into the html page. "},{"title":"Basic data sources​","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#basic-data-sources","content":"default - list of basic default parametersconfig/meta - a list of meta parameters from the route configuration "},{"title":"Connecting additional data sources​","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#connecting-additional-data-sources","content":"The @tinkoff/meta-tags-generate library allows you to connect additional data sources for meta tags with the ability to overwrite basic ones. To do this, you need to define a multi-provider META_UPDATER_TOKEN. import { createApp, provide } from '@tramvai/core'; import { SeoModule, META_UPDATER_TOKEN, META_PRIORITY_ROUTE } from '@tramvai/module-seo'; const metaSpecial = (meta) => { meta.updateMeta(META_PRIORITY_ROUTE, { // priority - 10 title: 'title', // key/value in meta, metaCustom: { // more information about the format [in the documentation](references/libs/meta-tags-generate.md) tag: 'meta', attributes: { name: 'metaCustomNameAttribute', content: 'metaCustomContent', }, }, }); }; createApp({ providers: [ provide({ // or add via provider provide: META_UPDATER_TOKEN, multi: true, useValue: metaSpecial, }), ], modules: [ SeoModule.forRoot({ list: [metaSpecial], }), ], }); Copy Each source is a function that takes a meta and allows you to extend the meta through a updateMeta call. The priority is a positive number, for each specific meta key the value with the highest priority will be used, the value with priority 0 denotes the default value. More about the format in the documentation "},{"title":"Setting seo data dynamically​","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#setting-seo-data-dynamically","content":"If you want to install seo in a page action or in one of the commandLineRunner steps, you can explicitly use the MetaWalk entity from the @tinkoff/meta-tags-generate lib. import { createAction } from '@tramvai/core'; import { META_WALK_TOKEN, META_PRIORITY_APP } from '@tramvai/module-seo'; createAction({ name: 'action', fn: async (context, payload, { meta }) => { meta.updateMeta(META_PRIORITY_APP, { title: 'WoW, such dynamic!', }); }, deps: { meta: META_WALK_TOKEN, }, conditions: { always: true, }, }); Copy "},{"title":"Replacing default seo data​","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#replacing-default-seo-data","content":"The SEO module comes with a default package of seo tags. If they do not suit you, you can replace the provider's implementation and put your own data: import { createApp } from '@tramvai/core'; import { SeoModule, META_DEFAULT_TOKEN } from '@tramvai/module-seo'; createApp({ providers: [ // Change metaDefaultPack token implementation { provide: META_DEFAULT_TOKEN, useValue: { title: 'E Corp' }, }, ], modules: [SeoModule], }); Copy After that we will substitute the new default parameters "},{"title":"Meta parameters​","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#meta-parameters","content":"The library already predefines some basic parameters for convenient use when configuring routers. And we can use meta parameters like title: 'Tinkoff'. See the list of such converters in the src/converters/converters.ts file "},{"title":"How to​","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#how-to","content":""},{"title":"Testing​","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#testing","content":"Testing work with META_UPDATER_TOKEN and META_DEFAULT_TOKEN​ If you have a module or providers that define META_UPDATER_TOKEN or META_DEFAULT_TOKEN then it is convenient to use special utilities to test them separately import { Module, provide } from '@tramvai/core'; import { testMetaUpdater } from '@tramvai/module-seo/tests'; import { META_PRIORITY_APP, META_DEFAULT_TOKEN, META_UPDATER_TOKEN } from '@tramvai/module-seo'; describe('testMetaUpdater', () => { it('modules', async () => { const metaUpdater = jest.fn< ReturnType<typeof META_UPDATER_TOKEN>, Parameters<typeof META_UPDATER_TOKEN> >((walker) => { walker.updateMeta(META_PRIORITY_APP, { title: 'test title', }); }); @Module({ providers: [ provide({ provide: META_UPDATER_TOKEN, multi: true, useValue: metaUpdater, }), ], }) class CustomModule {} const { renderMeta } = testMetaUpdater({ modules: [CustomModule], }); const { render, metaWalk } = renderMeta(); expect(metaWalk.get('title').value).toBe('test title'); expect(render).toMatch('<title data-meta-dynamic=\"true\">test title</title>'); }); it('providers', async () => { const { renderMeta } = testMetaUpdater({ providers: [ provide({ provide: META_DEFAULT_TOKEN, useValue: { title: 'default title', }, }), ], }); const { render } = renderMeta(); expect(render).toMatch('<title data-meta-dynamic=\"true\">default title</title>'); }); }); Copy "},{"title":"server","type":0,"sectionRef":"#","url":"docs/references/modules/server","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"server","url":"docs/references/modules/server#installation","content":"You need to install @tramvai/module-server npm i --save @tramvai/module-server Copy And connect to the project import { createApp } from '@tramvai/core'; import { ServerModule } from '@tramvai/module-server'; createApp({ name: 'tincoin', modules: [ServerModule], }); Copy "},{"title":"Explanation​","type":1,"pageTitle":"server","url":"docs/references/modules/server#explanation","content":""},{"title":"Processing the users requests​","type":1,"pageTitle":"server","url":"docs/references/modules/server#processing-the-users-requests","content":"ServerModule creates express.js application, handles user requests, runs commandLineRunner, and sends responses to users with data, headers and status from RESPONSE_MANAGER_TOKEN token. "},{"title":"Request proxying​","type":1,"pageTitle":"server","url":"docs/references/modules/server#request-proxying","content":"ServerModule allows you to configure the proxying of urls to the application using the library http-proxy-middleware To enable proxying, create a file proxy.conf.js or proxy.conf.json in the root of the project to export the request mapping object, or you can use the PROXY_CONFIG_TOKEN token. Proxy config format​ Key-value object​ const testStand = 'https://example.org'; module.exports = { // The key is the path pattern for the `express` to be passed to `app.use` // value can be a string, in order to proxy all urls starting with `/login/` '/login/': testStand, // or can be a config object for [http-proxy](https://github.com/chimurai/http-proxy-middleware#http-proxy-options) '/test/': { target: testStand, auth: true, xfwd: true, ... } }; Copy Object with context and target properties​ module.exports = { // context - is similar to the option for [http-proxy-middleware](https://github.com/chimurai/http-proxy-middleware#context-matching) context: ['/login/', '/registration/', '/auth/papi/'], target: 'https://example.org', // other `http-proxy-middleware` options changeOrigin: true, }; Copy Array with context and target properties​ [ { \"context\": [\"/a/\", \"/b/*/c/\"], \"target\": \"https://example.org\" } ] Copy Implementation of the PROXY_CONFIG_TOKEN token​ import { Scope, provide } from '@tramvai/core'; import { PROXY_CONFIG_TOKEN } from '@tramvai/tokens-server'; [ provide({ provide: PROXY_CONFIG_TOKEN, scope: Scope.SINGLETON, useValue: { context: ['/a/', '/b/*/c/'], target: 'https://example.org', }, multi: true, }), ]; Copy "},{"title":"Serving static files​","type":1,"pageTitle":"server","url":"docs/references/modules/server#serving-static-files","content":"The ServerModule has a built-in static server that allows you to distribute static files to users. To serve files, you need to create a directory public in the root of the project in which to place the necessary files. After that, all files will be available for request by browsers. For example, we want to distribute sw.js file from the project's root: for this we create a folder public in which we put the file sw.js. Now on the client side, we will be able to request data from the url http://localhost:3000/sw.js. Also, we will most likely need some modifications on the CI/CD side to copy the public folder to the stands. This function is also available in production. For this purpose, copy the folder public into the docker container "},{"title":"PAPI​","type":1,"pageTitle":"server","url":"docs/references/modules/server#papi","content":"Papi - API routes for the tramvai application. More information is available in Papi "},{"title":"Emulation of network/backends problems in the application​","type":1,"pageTitle":"server","url":"docs/references/modules/server#emulation-of-networkbackends-problems-in-the-application","content":"(functionality is only available in dev mode) The server has the ability to increase the response time of all requests. To do this you must: start the applicationsend a POST request to /private/papi/debug-http-request with a delay for the request: curl --location --request POST 'http://localhost:3000/tincoin/private/papi/debug-http-request' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --data-urlencode 'delay=2000' Copy check if the application works. Note: after each restart of the server the settings are reset, so after each rebuild it is necessary to access papi again.you can disable the timeout by accessing the same papi using the DELETE method curl --location --request DELETE 'http://localhost:3000/tincoin/private/papi/debug-http-request' Copy "},{"title":"Logging requests sent to the server​","type":1,"pageTitle":"server","url":"docs/references/modules/server#logging-requests-sent-to-the-server","content":"In dev mode, all requests sent through the standard http and https libraries for nodejs are logged under a special server:node-debug:request key. This allows you to see all requests that have been sent to the server, even if no logging has been defined for the requests explicitly. To enable such logging, simply add the server:node-debug:request key to the LOG_ENABLE environment variable "},{"title":"Health checks​","type":1,"pageTitle":"server","url":"docs/references/modules/server#health-checks","content":"/healthz - always replies OK after starting the application/readyz - always replies OK after starting the application Metrics The metrics module is automatically connected into the server module. For more information on metrics, you can read in the metrics documentation "},{"title":"Warming application caches​","type":1,"pageTitle":"server","url":"docs/references/modules/server#warming-application-caches","content":"The cache-warmup module is automatically plugged into the server module. Detailed information on cache warmup can be found in cache-warmup documentation "},{"title":"Custom headers​","type":1,"pageTitle":"server","url":"docs/references/modules/server#custom-headers","content":"Building and Deployment Information​ There are special headers in the module, which help to determine the exact information about the version of the built application, commit, branch, etc: x-app-id - The name of the application specified in createApp. Specified in the application code.x-host - Hostname of the server where the current application is running. Computed in runtime.x-app-version - version of the running application. Transmitted through the environment variable APP_VERSION.x-deploy-branch - branch from which the current application image was built. Passed through environment variable DEPLOY_BRANCH.x-deploy-commit - sha commit from which current application image was built. Passed through environment variable DEPLOY_COMMIT.x-deploy-version - deploy revision number in k8s. Passed through environment variable DEPLOY_VERSION.x-deploy-repository - application repository link. Passed through environment variable DEPLOY_REPOSITORY. For all of the headers above which are passed via environment variables to be available, you need the external infrastructure to pass them when building and deprovisioning the application image (inside tinkoff this is done automatically). "},{"title":"Debugging​","type":1,"pageTitle":"server","url":"docs/references/modules/server#debugging","content":"Module uses loggers with identifiers: server, server:static, server:webapp, server:node-debug:request "},{"title":"How to​","type":1,"pageTitle":"server","url":"docs/references/modules/server#how-to","content":""},{"title":"Specify server port​","type":1,"pageTitle":"server","url":"docs/references/modules/server#specify-server-port","content":"By default server starts at 3000 port. You can change this value by specifying environment variable PORT: in dev environment it can be done by adding env PORT to file env.development.json e.g. PORT: \"8080\"it can be specified explicitly as an environment variable PORT e.g. PORT=8080 "},{"title":"Exportable tokens​","type":1,"pageTitle":"server","url":"docs/references/modules/server#exportable-tokens","content":"Link "},{"title":"Child app","type":0,"sectionRef":"#","url":"docs/references/test/test-child-app","content":"","keywords":""},{"title":"How to​","type":1,"pageTitle":"Child app","url":"docs/references/test/test-child-app#how-to","content":""},{"title":"Test child-app main component render​","type":1,"pageTitle":"Child app","url":"docs/references/test/test-child-app#test-child-app-main-component-render","content":"You can get React Component returned by child-app from return value of testChildApp function and use for example testComponent helper from the @tramvai/test-react warning To properly render child-app component pass as props to it its di and optionally props object, that will be passed to the underlying child-app component. import { testComponent } from '@tramvai/test-react'; import childApp from './child-app.tsx'; (async () => { const { childApp: { Component, di }, close, } = await testChildApp(childApp); const { render } = testComponent(<Component di={di} props={{ test: 'abc' }} />); expect(render.getByTestId('from-root').textContent).toBe('Value from Root: abc'); })(); Copy "},{"title":"Test child-app di​","type":1,"pageTitle":"Child app","url":"docs/references/test/test-child-app#test-child-app-di","content":"import childApp from './child-app.tsx'; (async () => { const { childApp: { di }, close, } = await testChildApp(childApp); expect(di.get(CHILD_APP_BASE_TOKEN)).toBe(\"I'm little child app\"); })(); Copy  More examples /** * @jest-environment jsdom */ import React from 'react'; import { testComponent } from '@tramvai/test-react'; import { testChildApp } from './testChildApp'; import BaseChildApp, { CHILD_APP_BASE_TOKEN } from './__fixtures__/base'; describe('test/childApp/testChildApp', () => { it('base test', async () => { const { childApp: { di, Component }, close, } = await testChildApp(BaseChildApp); const { render, rerender } = testComponent( <Component di={di} props={{ fromRoot: 'test123' }} /> ); expect(render.getByTestId('token').textContent).toBe(\"Children App: I'm little child app\"); expect(render.getByTestId('from-root').textContent).toBe('Value from Root: test123'); expect(di.get(CHILD_APP_BASE_TOKEN)).toBe(\"I'm little child app\"); rerender(<Component di={di} props={{ fromRoot: 'root' }} />); expect(render.getByTestId('from-root').textContent).toBe('Value from Root: root'); return close(); }); }); Copy  "},{"title":"Integration tests","type":0,"sectionRef":"#","url":"docs/references/test/test-integration","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Integration tests","url":"docs/references/test/test-integration#installation","content":"npm i --save-dev @tramvai/test-integration Copy "},{"title":"How To​","type":1,"pageTitle":"Integration tests","url":"docs/references/test/test-integration#how-to","content":""},{"title":"Test request to the tramvai app without using browser (aka curl)​","type":1,"pageTitle":"Integration tests","url":"docs/references/test/test-integration#test-request-to-the-tramvai-app-without-using-browser-aka-curl","content":"For testing requests to the tramvai app libraries superagent and node-html-parser are used under hood. Call of app.request sends requests to the app. All of the features of superagent are available. Call of app.render resolves to the HTML render that is returned from server while serving the request. import { startCli } from '@tramvai/test-integration'; import { initPuppeteer, wrapPuppeteerPage } from '@tramvai/test-puppeteer'; beforeAll(async () => { app = await startCli('bootstrap', { env: { SOME_ENV: 'test', }, }); }, 80000); afterAll(() => { return app.close(); }); it('request to main page should return status 200', async () => { return app.request('/').expect(200); }); it('main page HTML snapshot', async () => { const parsed = await app.render('/'); const applicationInnerHtml = parsed.application; expect(parsed.application).toMatchInlineSnapshot(); }); Copy "},{"title":"Testing app in browser with the puppeteer​","type":1,"pageTitle":"Integration tests","url":"docs/references/test/test-integration#testing-app-in-browser-with-the-puppeteer","content":"You may use another library @tramvai/test-puppeteer to implement testing in the browser. "},{"title":"Usage of @tinkoff/mocker in tests​","type":1,"pageTitle":"Integration tests","url":"docs/references/test/test-integration#usage-of-tinkoffmocker-in-tests","content":"In order to use mocker there should be added @tramvai/module-mocker to the tramvai app modules list. After thar mocker will read file based mocks as it described in the docs to the mocker itself and it can be used dynamically in the tests: it('should work with mocker', async () => { await app.mocker.addMocks('CONFIG_API', { 'GET /test/': { status: 200, payload: { status: 'OK', response: 'smth', }, }, }); await app.request('/api/').expect(200); await app.papi.clearCache(); await app.mocker.removeMocks('CONFIG_API', ['GET /test/']); await app.request('/api/').expect(500); }); Copy "},{"title":"Jest integration","type":0,"sectionRef":"#","url":"docs/references/test/test-integration-jest","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Jest integration","url":"docs/references/test/test-integration-jest#installation","content":"npm i --save-dev @tramvai/test-integration-jest Copy "},{"title":"How To​","type":1,"pageTitle":"Jest integration","url":"docs/references/test/test-integration-jest#how-to","content":""},{"title":"Debug and development of integration tests in Jest​","type":1,"pageTitle":"Jest integration","url":"docs/references/test/test-integration-jest#debug-and-development-of-integration-tests-in-jest","content":"Using this jest preset you can run integration tests in watch mode. In this case, application itself will be launched only once and will work in background. Add preset @tramvai/test-integration-jest to jest.integration.config.js: module.exports = { preset: '@tramvai/test-integration-jest', }; Copy Add new script for running tests in watch mode to package.json: { \"scripts\": { \"test:integration\": \"jest -w=3 --config ./jest.integration.config.js\", \"test:integration:watch\": \"jest --runInBand --watch --config ./jest.integration.config.js\" } } Copy Run some test with yarn test:integration:watch <path_to_test>. In this case you are able to go to local url http://localhost:3000 and see application at work. "},{"title":"Environment for Jest​","type":1,"pageTitle":"Jest integration","url":"docs/references/test/test-integration-jest#environment-for-jest","content":"Minimal set of dependencies for running jest: npm i --save-dev jest @types/jest jest-circus Copy "},{"title":"JSDom tests","type":0,"sectionRef":"#","url":"docs/references/test/test-jsdom","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"JSDom tests","url":"docs/references/test/test-jsdom#installation","content":"npm i --save-dev @tramvai/test-jsdom Copy "},{"title":"Api​","type":1,"pageTitle":"JSDom tests","url":"docs/references/test/test-jsdom#api","content":""},{"title":"waitRaf​","type":1,"pageTitle":"JSDom tests","url":"docs/references/test/test-jsdom#waitraf","content":"Wait for execution of requestAnimationFrame callback import { waitRaf } from '@tramvai/test-jsdom'; describe('test', () => { it('test', async () => { // some code with raf usage await waitRaf(); }); }); Copy "},{"title":"router","type":0,"sectionRef":"#","url":"docs/references/modules/router","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"router","url":"docs/references/modules/router#installation","content":"You need to install @tramvai/module-router: yarn add @tramvai/module-router Copy And connect in the project: import { createApp } from '@tramvai/core'; import { NoSpaRouterModule, SpaRouterModule } from '@tramvai/module-router'; createApp({ name: 'tincoin', modules: [SpaRouterModule], // modules: [ NoSpaRouterModule ], if you want to disable client SPA transitions }); Copy "},{"title":"Explanation​","type":1,"pageTitle":"router","url":"docs/references/modules/router#explanation","content":"The module is based on the library @tinkoff/router "},{"title":"Default Settings​","type":1,"pageTitle":"router","url":"docs/references/modules/router#default-settings","content":"Next settings are used trailingSlashes = truemergeSlashes = true "},{"title":"Navigation flow on the server​","type":1,"pageTitle":"router","url":"docs/references/modules/router#navigation-flow-on-the-server","content":" "},{"title":"Flow of the first navigation on the client​","type":1,"pageTitle":"router","url":"docs/references/modules/router#flow-of-the-first-navigation-on-the-client","content":" "},{"title":"Flow of navigation on the client without SPA transitions​","type":1,"pageTitle":"router","url":"docs/references/modules/router#flow-of-navigation-on-the-client-without-spa-transitions","content":" "},{"title":"Flow of navigation on the client with SPA transitions​","type":1,"pageTitle":"router","url":"docs/references/modules/router#flow-of-navigation-on-the-client-with-spa-transitions","content":" "},{"title":"API​","type":1,"pageTitle":"router","url":"docs/references/modules/router#api","content":""},{"title":"Static routes in the application​","type":1,"pageTitle":"router","url":"docs/references/modules/router#static-routes-in-the-application","content":"Route description format: const routes = [ { // the name of the route is required name: 'route1', // the path of the route is required path: '/route/a/', // additional configs for the route config: { // layout component name layoutComponent: 'layout', // page component name pageComponent: 'page', }, }, ]; Copy You can explicitly transfer a list of routes to routing when adding a router module: import { createApp } from '@tramvai/core'; import { SpaRouterModule } from '@tramvai/module-router'; const routes = [ // ... ]; createApp({ modules: [ // ..., SpaRouterModule.forRoot(routes), ], }); Copy Or separately with the ROUTES_TOKEN token (you can set it several times): import { ROUTES_TOKEN } from '@tramvai/module-router'; import { provide } from '@tramvai/core'; const routesCommon = [ // ... ]; const routesSpecific = [ // ... ]; const providers = [ // ..., provide({ provide: ROUTES_TOKEN, multi: true, useValue: routesCommon, }), provide({ provide: ROUTES_TOKEN, multi: true, useValue: routesSpecific, }), ]; Copy "},{"title":"PAGE_SERVICE_TOKEN​","type":1,"pageTitle":"router","url":"docs/references/modules/router#page_service_token","content":"Service wrapper for working with routing. Serves to hide routing work and is the preferred way of routing work. Methods: getCurrentRoute() - get the current routegetCurrentUrl() - object-result of parsing the current urlgetConfig() - get the config of the current pagegetContent() - get content for the current pagegetMeta() - get the meta for the current pagenavigate(options) - navigation to a new page moreupdateCurrentRoute(options) - update the current route with new parameters moreback() - go back through historyforward() - go forward through historygo(to) - go to the specified delta by historyaddComponent(name, component) - add new component to current page into ComponentRegistrygetComponent(name) - get component from current page components from ComponentRegistry "},{"title":"RouterStore​","type":1,"pageTitle":"router","url":"docs/references/modules/router#routerstore","content":"Store that stores information about the current and previous routes. Properties: currentRoute - current routecurrentUrl - current urlpreviousRoute - previous routepreviousUrl - previous url "},{"title":"ROUTER_GUARD_TOKEN​","type":1,"pageTitle":"router","url":"docs/references/modules/router#router_guard_token","content":"Allows you to block or redirect the transition to the page under certain conditions. See @tinkoff/router "},{"title":"Redirects​","type":1,"pageTitle":"router","url":"docs/references/modules/router#redirects","content":"Redirects can be done via guards or explicitly via the redirect property in the route. const routes = [ // ..., { name: 'redirect', path: '/from/', redirect: '/to/', }, ]; Copy "},{"title":"Not Found route​","type":1,"pageTitle":"router","url":"docs/references/modules/router#not-found-route","content":"The route used if no matches were found for the current page, can be specified in a special way in the list of routes. const route = [ // ...other routes, { name: 'not-found', path: '*', config: { pageComponent: 'notfoundComponentName', }, }, ]; Copy "},{"title":"ROUTE_RESOLVE_TOKEN​","type":1,"pageTitle":"router","url":"docs/references/modules/router#route_resolve_token","content":"Allows you to define an asynchronous function that returns a route object that will be called if no suitable static route was found in the application. "},{"title":"ROUTE_TRANSFORM_TOKEN​","type":1,"pageTitle":"router","url":"docs/references/modules/router#route_transform_token","content":"Transformer function for application routes (set statically and those that will be loaded via ROUTE_RESOLVE_TOKEN) "},{"title":"Method of setting when actions should be performed during SPA transitions​","type":1,"pageTitle":"router","url":"docs/references/modules/router#method-of-setting-when-actions-should-be-performed-during-spa-transitions","content":"By default, SPA transitions execute actions after defining the next route, but before the actual transition, which allows the page to be displayed immediately with new data, but can cause a noticeable visual lag if the actions are taken long enough. It is possible to change the behavior and make the execution of actions after the transition itself. Then, when developing components, you will need to take into account that data will be loaded as it becomes available. Configurable explicitly when using the routing module: import { createApp } from '@tramvai/core'; import { SpaRouterModule } from '@tramvai/module-router'; createApp({ modules: [ // ..., SpaRouterModule.forRoot([], { spaActionsMode: 'after', // default is 'before' }), ], }); Copy or through token ROUTER_SPA_ACTIONS_RUN_MODE_TOKEN: import { ROUTER_SPA_ACTIONS_RUN_MODE_TOKEN } from '@tramvai/module-router'; import { provide } from '@tramvai/core'; const providers = [ // ..., provide({ provide: ROUTER_SPA_ACTIONS_RUN_MODE_TOKEN, useValue: 'after', }), ]; Copy "},{"title":"How to​","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to","content":""},{"title":"Working with navigation in providers and actions​","type":1,"pageTitle":"router","url":"docs/references/modules/router#working-with-navigation-in-providers-and-actions","content":"In this case, it is best to use the PAGE_SERVICE_TOKEN import { provide, createAction } from '@tramvai/core'; import { PAGE_SERVICE_TOKEN } from '@tramvai/module-router'; const provider = provide({ provide: 'token', useFactory: ({ pageService }) => { if (pageService().getCurrentUrl().pathname === '/test/') { return pageService.navigate({ url: '/redirect/', replace: true }); } }, deps: { pageService: PAGE_SERVICE_TOKEN, }, }); const action = createAction({ name: 'action', fn: (_, __, { pageService }) => { if (pageService.getConfig().pageComponent === 'pageComponent') { return page.updateCurrentRoute({ query: { test: 'true' } }); } }, deps: { pageService: PAGE_SERVICE_TOKEN, }, }); Copy "},{"title":"Working with navigation in React components​","type":1,"pageTitle":"router","url":"docs/references/modules/router#working-with-navigation-in-react-components","content":"You can work with routing inside React components using hooks and components - useNavigate, useRoute, Link from the @tinkoff/router  An example of working with navigation in the application import React from 'react'; import { createApp, createBundle } from '@tramvai/core'; import { SpaRouterModule, useNavigate, useUrl, Link } from '@tramvai/module-router'; import { modules } from '../common'; const Navigation = ['/1/', '/2/', '/3/']; function Page() { // useUrl allows you to get the current url const { pathname, path } = useUrl(); // useNavigate allows you to get a function with which you can call the navigation const navigate = useNavigate(); // useNavigate also allows you to set properties immediately so that the result can be passed immediately as a callback const navigateToRoot = useNavigate({ url: '/', query: { a: '1', b: '2' } }); return ( <div> <div>Current Path: {path}</div> <div> <button type=\"button\" onClick={navigateToRoot}> Navigate to Root </button> {/* the Link component allows you to create a link with a transition */} <Link url=\"/link/\" replace> <button type=\"button\">Navigate By Link</button> </Link> </div> {Navigation.map((p) => { if (p !== pathname) { return ( <button type=\"button\" onClick={() => navigate({ url: p })}> Navigate to {p} </button> ); } return null; })} </div> ); } const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, }, }); createApp({ name: 'router-navigate', modules: [ SpaRouterModule.forRoot([ { name: 'root', path: '/', }, { name: 'link', path: '/link/', }, { name: '1', path: '/1/', }, { name: '2', path: '/2/', }, { name: '3', path: '/3/', }, ]), ...modules, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), }, }); Copy  "},{"title":"How to set static routes​","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to-set-static-routes","content":"RouterModule allows you to add new routes when configuring your application. The second way is to pass static routes to DI via the ROUTES_TOKEN token.  An example of adding static routes to an application import React from 'react'; import { createApp, createBundle } from '@tramvai/core'; import { useSelector } from '@tramvai/state'; import { useDi } from '@tramvai/react'; import { SpaRouterModule, ROUTES_TOKEN, PAGE_SERVICE_TOKEN } from '@tramvai/module-router'; import { modules } from '../common'; const Navigation = ['/1/', '/2/', '/3/']; function Page() { // useSelector to get the current route // store 'router' is provided by RouterModule const state = useSelector('router', (x) => x.router); // pageService - a wrapper for working with a router, you can get various properties and initiate a transition // but through useDi you cannot subscribe to data changes inside services, so to subscribe to route changes // used by useSelector above const pageService = useDi(PAGE_SERVICE_TOKEN); const { pathname, path } = state.currentUrl; return ( <div> <div>Current Path: {path}</div> {Navigation.map((p) => { if (p !== pathname) { return ( <button type=\"button\" onClick={() => pageService.navigate({ url: p })}> Navigate to {p} </button> ); } return null; })} </div> ); } const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, }, }); createApp({ name: 'route-static-routes', modules: [ // the static forRoot method allows you to define static routes in the application - // these routes are always available and the config for them is not loaded from the admin panel, but are set right there SpaRouterModule.forRoot([ { name: '1', path: '/1/', }, { name: '2', path: '/2/', }, ]), ...modules, ], providers: [ { // you can also set static routes by a separate provider provide: ROUTES_TOKEN, multi: true, useValue: [ { name: '3', path: '/3/', }, ], }, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), }, }); Copy  "},{"title":"How to set Route Guard​","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to-set-route-guard","content":"ROUTER_GUARD_TOKEN is set as an asynchronous function, which allows you to perform various actions and influence the routing behavior.  Example router guards job in application import React from 'react'; import { createReducer, createEvent } from '@tramvai/state'; import { createApp, createBundle, createAction } from '@tramvai/core'; import { SpaRouterModule, ROUTER_GUARD_TOKEN, useNavigate, useUrl } from '@tramvai/module-router'; import { STORE_TOKEN, CONTEXT_TOKEN, COMBINE_REDUCERS } from '@tramvai/module-common'; import { modules } from '../common'; const Navigation = ['/1/', '/2/', '/3/', '/redirect/', '/block/']; function Page() { const navigate = useNavigate(); const { pathname, path } = useUrl(); return ( <div> <div>Current Path: {path}</div> {Navigation.map((p) => { if (p !== pathname) { return ( <button type=\"button\" onClick={() => navigate({ url: p })}> Navigate to {p} </button> ); } return null; })} </div> ); } const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, }, }); const event = createEvent<boolean>('event'); const store = createReducer<boolean | void>('store', undefined).on(event, (_, val) => val); const action = createAction({ name: 'action', fn: async (context) => { await new Promise<void>((res) => setTimeout(res, 1200)); return context.dispatch(event(true)); }, }); createApp({ name: 'router-guards', modules: [ SpaRouterModule.forRoot([ { name: 'root', path: '/', }, { name: '1', path: '/1/', }, { name: '2', path: '/2/', }, { name: '3', path: '/3/', }, { name: 'redirect', path: '/redirect/', }, { name: 'block', path: '/block/', }, ]), ...modules, ], providers: [ { provide: COMBINE_REDUCERS, multi: true, useValue: store, }, { provide: ROUTER_GUARD_TOKEN, multi: true, useValue: async ({ to }) => { if (to.path === '/redirect/') { // we can make a redirect from the guard return '/3/'; } }, }, { provide: ROUTER_GUARD_TOKEN, multi: true, useFactory: ({ store: state, context }) => { return async ({ to }) => { if (to.path === '/block/') { if (state.getState().store === undefined) { await context.executeAction(action); } if (state.getState().store) { // we can block navigation return false; } } }; }, deps: { store: STORE_TOKEN, context: CONTEXT_TOKEN, }, }, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), }, }); Copy  "},{"title":"How to add transition hooks​","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to-add-transition-hooks","content":"Transition hooks allows to subscribe on different steps of the transition Get router instance with ROUTER_TOKEN tokenUse methods registerHook, registerSyncHook to add new hooks to the routerRegistration should happen as soon as possible so appropriate line is customerStart as it executes before navigation happens. "},{"title":"How to set the Not found route​","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to-set-the-not-found-route","content":"The Not found route is used if the corresponding route is not found for the url. Such a route is specified in the list of routes with the special * character in the path property.  An example of setting a Not Found route in an application import React from 'react'; import { createApp, createBundle } from '@tramvai/core'; import { SpaRouterModule, useNavigate, useUrl } from '@tramvai/module-router'; import { modules } from '../common'; const Navigation = [ '/1/', '/2/', '/3/', '/not-found', '/child/1/', '/child/2/', '/child/3/', '/child/not-found', ]; function Page() { const navigate = useNavigate(); const { pathname, path } = useUrl(); return ( <div> <div>Current Path: {path}</div> {Navigation.map((p) => { if (p !== pathname) { return ( <button type=\"button\" onClick={() => navigate({ url: p })}> Navigate to {p} </button> ); } return null; })} </div> ); } // Defining a separate page const NotFoundRoot = () => { return 'not found root'; }; const NotFoundChild = () => { return 'not found child'; }; const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, notFoundRoot: NotFoundRoot, notFoundChild: NotFoundChild, }, }); createApp({ name: 'router-not-found', modules: [ SpaRouterModule.forRoot([ { name: 'root', path: '/', }, { name: '1', path: '/1/', }, { name: '2', path: '/2/', }, { name: '3', path: '/3/', }, { name: 'child-1', path: '/child/1/', }, { name: 'child-2', path: '/child/2/', }, { name: 'child-1', path: '/child/3/', }, { name: 'not-found-root', path: '*', config: { pageComponent: 'notFoundRoot', }, }, { name: 'not-found-child', path: '/child/*', config: { pageComponent: 'notFoundChild', }, }, ]), ...modules, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), }, }); Copy  "},{"title":"How to change Not found route response status​","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to-change-not-found-route-response-status","content":"By default, responses for the Not found route return a status of 200. You can change status in custom Route Guard, by using RESPONSE_MANAGER_TOKEN.  An example of changing a Not Found route response status import React from 'react'; import { createApp, createBundle } from '@tramvai/core'; import { SpaRouterModule, useNavigate, useUrl, ROUTER_GUARD_TOKEN } from '@tramvai/module-router'; import { RESPONSE_MANAGER_TOKEN } from '@tramvai/tokens-common'; import { modules } from '../common'; const Navigation = ['/', '/not-found']; function Page() { const navigate = useNavigate(); const { pathname, path } = useUrl(); return ( <div> <div>Current Path: {path}</div> {Navigation.map((p) => { if (p !== pathname) { return ( <button type=\"button\" onClick={() => navigate({ url: p })}> Navigate to {p} </button> ); } return null; })} </div> ); } const NotFoundRoot = () => { return 'not found root'; }; const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, notFoundRoot: NotFoundRoot, }, }); createApp({ name: 'router-not-found-custom-status', modules: [ SpaRouterModule.forRoot([ { name: 'root', path: '/', }, { name: 'not-found', path: '*', config: { pageComponent: 'notFoundRoot', }, }, ]), ...modules, ], providers: [ { provide: ROUTER_GUARD_TOKEN, multi: true, useFactory: ({ responseManager }): typeof ROUTER_GUARD_TOKEN => { return async ({ to }) => { // watch all navigations, and wait for route with name `not-found` if (to && to.name === 'not-found') { // set the response status, it will be applied until the end of the response responseManager.setStatus(404); } }; }, deps: { responseManager: RESPONSE_MANAGER_TOKEN, }, }, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), }, }); Copy  "},{"title":"How to change response status in actions​","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to-change-response-status-in-actions","content":"For example, you make a important request in action, and if this request will fail, application need to return 500 or 404 status. Page actions running after router navigation flow, when route is completely resolved. You can change status by using RESPONSE_MANAGER_TOKEN. If you want to prevent page component rendering, you can throw NotFoundError from @tinkoff/errors library.  An example of changing response status in actions import React from 'react'; import { createApp, createBundle, createAction } from '@tramvai/core'; import { SpaRouterModule, useNavigate, useUrl } from '@tramvai/module-router'; import { RESPONSE_MANAGER_TOKEN } from '@tramvai/tokens-common'; import { NotFoundError } from '@tinkoff/errors'; import { modules } from '../common'; const Navigation = ['/']; const fetchSomeData = () => new Promise((resolve, reject) => { setTimeout(() => { reject(); }, 100); }); const pageAction = createAction({ name: 'pageAction', fn: async (_, __, { responseManager }) => { try { await fetchSomeData(); } catch (e) { const isCriticalDataError = false; if (isCriticalDataError) { // if you throw NotFoundError, Page component will not be rendered, response body will be empty throw new NotFoundError(); } else { // otherwise, if you only change response status, Page component will be rendered without neccesary data responseManager.setStatus(500); } } }, deps: { responseManager: RESPONSE_MANAGER_TOKEN, }, }); function Page() { const navigate = useNavigate(); const { pathname, path } = useUrl(); return ( <div> <div>Current Path: {path}</div> {Navigation.map((p) => { if (p !== pathname) { return ( <button type=\"button\" onClick={() => navigate({ url: p })}> Navigate to {p} </button> ); } return null; })} </div> ); } Page.actions = [pageAction]; const NotFoundRoot = () => { return 'not found root'; }; const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, notFoundRoot: NotFoundRoot, }, }); createApp({ name: 'router-action-error', modules: [ SpaRouterModule.forRoot([ { name: 'root', path: '/', }, { name: 'not-found-root', path: '*', config: { pageComponent: 'notFoundRoot', }, }, ]), ...modules, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), }, }); Copy  "},{"title":"Testing​","type":1,"pageTitle":"router","url":"docs/references/modules/router#testing","content":"Testing ROUTER_GUARD_TOKEN extensions​ If you have a module or providers that define ROUTER_GUARD_TOKEN, then it will be convenient to use special utilities to test them separately import { ROUTER_GUARD_TOKEN } from '@tramvai/tokens-router'; import { testGuard } from '@tramvai/module-router/tests'; import { CustomModule } from './module'; import { providers } from './providers'; describe('router guards', () => { it('should redirect from guard', async () => { const { router } = testGuard({ providers, }); await router.navigate('/test/'); expect(router.getCurrentUrl()).toMatchObject({ path: '/redirect/', }); }); it('should block navigation', async () => { const { router } = testGuard({ modules: [CustomModule], }); expect(router.getCurrentUrl()).toMatchObject({ path: '/' }); await router.navigate('/test/').catch(() => null); expect(router.getCurrentUrl()).toMatchObject({ path: '/', }); }); }); Copy "},{"title":"Exported tokens​","type":1,"pageTitle":"router","url":"docs/references/modules/router#exported-tokens","content":"link "},{"title":"Mocks","type":0,"sectionRef":"#","url":"docs/references/test/test-mocks","content":"","keywords":""},{"title":"Подключение​","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#подключение","content":"npm i --save-dev @tramvai/test-mocks Copy "},{"title":"Api​","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#api","content":""},{"title":"STORE_TOKEN​","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#store_token","content":"Creates mock instance for token STORE_TOKEN which used in app as a common storage for store Empty State​ import { createMockStore } from '@tramvai/test-mocks'; const store = createMockStore(); const state = store.getState(); store.dispatch('event'); Copy Initial State​ import { createMockStore } from '@tramvai/test-mocks'; const initialState = { a: 1, b: 2 }; const reducerC = createReducer('c', 3); const store = createMockStore({ stores: [reducerC], initialState }); const state = store.getState(); Copy  More examples import { createReducer, createEvent } from '@tramvai/state'; import { createMockStore } from './store'; describe('test/unit/mocks/store', () => { it('should create empty store', () => { const store = createMockStore(); const spyGetState = jest.spyOn(store, 'getState'); expect(store.getState()).toEqual({}); expect(spyGetState).toHaveBeenCalled(); }); it('should update stores with dispatch', () => { const event = createEvent<string>('testEvent'); const reducer = createReducer('test', { a: 'test' }).on(event, (_, data) => { return { a: data, }; }); const store = createMockStore({ stores: [reducer] }); expect(store.getState()).toEqual({ test: { a: 'test' } }); store.dispatch(event('dispatched')); expect(store.getState()).toEqual({ test: { a: 'dispatched' } }); }); it('should create store by initialState', () => { const initialState = { a: 1, b: 2 }; const reducerA = createReducer('a', {}); const reducerB = createReducer('b', {}); const store = createMockStore({ stores: [reducerA, reducerB], initialState }); expect(store.getState()).toEqual(initialState); }); it('should create fake reducer stores for every key in initialState', () => { const initialState = { a: 1, b: 2 }; const reducerC = createReducer('c', 3); const store = createMockStore({ stores: [reducerC], initialState }); expect(store.getState()).toEqual({ a: 1, b: 2, c: 3, }); }); }); Copy  "},{"title":"DI​","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#di","content":"Creates mock instance of DI-container import { createMockDi } from '@tramvai/test-mocks'; const di = createMockDi(); const dep = di.get(SOME_TOKEN); Copy "},{"title":"Context​","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#context","content":"Creates mock instance for CONTEXT_TOKEN import { createMockContext } from '@tramvai/test-mocks'; it('test', async () => { const context = createMockContext(); await context.dispatch('event'); await context.executeAction(action); const spyExecuteAction = jest.spyOn(context, 'executeAction'); expect(spyExecuteAction).toHaveBeenCalled(); }); Copy  More examples import { createEvent, createReducer } from '@tramvai/state'; import { createMockContext } from './context'; describe('test/unit/mocks/context', () => { it('should create consumer context', () => { const context = createMockContext(); expect(context.executeAction).toBeInstanceOf(Function); expect(context.getState).toBeInstanceOf(Function); expect(context.dispatch).toBeInstanceOf(Function); expect(context.getState()).toEqual({}); }); it('should dispatch data', async () => { const event = createEvent<string>('mockEvent'); const reducer = createReducer('a', 'data').on(event, (_, data) => data); const context = createMockContext({ stores: [reducer], }); const spyDispatch = jest.spyOn(context, 'dispatch'); await context.dispatch(event('mock1')); expect(spyDispatch).toHaveBeenCalledWith(event('mock1')); expect(context.getState()).toEqual({ a: 'mock1' }); }); }); Copy  "},{"title":"Router​","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#router","content":"Creates mock instance for @tinkoff/router import { createMockRouter } from '@tramvai/test-mocks'; describe('test', () => { it('should create router mock', () => { const router = createMockRouter(); expect(router.getCurrentRoute()).toMatchObject({ path: '/' }); expect(router.getCurrentUrl()).toMatchObject({ path: '/' }); }); it('should allow to specify currentRoute', () => { const router = createMockRouter({ currentRoute: { name: 'page', path: '/page/test/' } }); expect(router.getCurrentRoute()).toMatchObject({ path: '/page/test/' }); expect(router.getCurrentUrl()).toMatchObject({ path: '/page/test/' }); }); }); Copy "},{"title":"Puppeteer tests","type":0,"sectionRef":"#","url":"docs/references/test/test-puppeteer","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Puppeteer tests","url":"docs/references/test/test-puppeteer#installation","content":"npm i --save-dev @tramvai/test-puppeteer Copy "},{"title":"How To​","type":1,"pageTitle":"Puppeteer tests","url":"docs/references/test/test-puppeteer#how-to","content":""},{"title":"Tests in browser​","type":1,"pageTitle":"Puppeteer tests","url":"docs/references/test/test-puppeteer#tests-in-browser","content":"Puppeteer runs tests in headless Chrome browser, documentation can be found on official site import { startCli } from '@tramvai/test-integration'; import { initPuppeteer, wrapPuppeteerPage } from '@tramvai/test-puppeteer'; beforeAll(async () => { app = await startCli('bootstrap', { env: { SOME_ENV: 'test', }, }); }, 80000); afterAll(() => { return app.close(); }); it('puppeteer', async () => { const { browser } = await initPuppeteer(app.serverUrl); const page = await browser.newPage(); const wrapper = wrapPuppeteerPage(page); await page.goto(app.serverUrl); expect( await page.$eval('.application', (node) => (node as HTMLElement).innerText) ).toMatchInlineSnapshot(`\"Main Page click link\"`); await wrapper.router.navigateWithReload('./second'); expect( await page.$eval('.application', (node) => (node as HTMLElement).innerText) ).toMatchInlineSnapshot(`\"Second Page click link\"`); await browser.close(); }); Copy "},{"title":"React tests","type":0,"sectionRef":"#","url":"docs/references/test/test-react","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"React tests","url":"docs/references/test/test-react#installation","content":"npm i --save-dev @tramvai/test-react Copy "},{"title":"Explanation​","type":1,"pageTitle":"React tests","url":"docs/references/test/test-react#explanation","content":""},{"title":"act​","type":1,"pageTitle":"React tests","url":"docs/references/test/test-react#act","content":"Based on the React act test helper that is used to perform rerender component after start changes. Put you actions that will update React state inside act function in order to check result render in the next code. warning Current wrapper should be awaited in tests to execute some additional internal steps "},{"title":"How to​","type":1,"pageTitle":"React tests","url":"docs/references/test/test-react#how-to","content":""},{"title":"Test component​","type":1,"pageTitle":"React tests","url":"docs/references/test/test-react#test-component","content":"Under the hood the @testing-library/react is used. /** * @jest-environment jsdom */ import { testComponent } from '@tramvai/test-react'; describe('test', () => { it('render', async () => { const { render, rerender, context, act, fireEvent, Wrapper } = testComponent(<Cmp id={1} />); // test component render expect(render.getByTestId('test').textContent).toBe('Content 1'); // test render after store update act(() => { context.dispatch(event('data')); }); // interact with the component fireEvent.click(render.getByText('Button')); // component rerender rerender(<Cmp id={2} />); expect(render.getByTestId('test').textContent).toBe('Content 2'); }); }); Copy  More examples /** * @jest-environment jsdom */ import React, { useEffect, useRef } from 'react'; import { createReducer, createEvent, useStore, useStoreSelector } from '@tramvai/state'; import { useDi } from '@tramvai/react'; import { useRoute } from '@tinkoff/router'; import { testComponent } from './testComponent'; describe('test/unit/react/testComponent', () => { it('should render simple component', async () => { const Cmp = () => { return ( <div> <div>Root</div> <div data-testid=\"test\">Content</div> </div> ); }; const { render } = testComponent(<Cmp />); expect(render.getByTestId('test').textContent).toBe('Content'); }); it('should rerender component on store updates', async () => { const event = createEvent<void>('evnt'); const store = createReducer('store', { a: 1 }).on(event, (state) => ({ a: state.a + 1 })); const Cmp = () => { const { a } = useStore(store); return ( <div> <span data-testid=\"content\">Counter: {a}</span> </div> ); }; const { context, render, act } = testComponent(<Cmp />, { stores: [store] }); expect(render.getByTestId('content').textContent).toBe('Counter: 1'); await act(() => { context.dispatch(event()); }); expect(render.getByTestId('content').textContent).toBe('Counter: 2'); }); it('should rerender component on store updates using storeSelector', async () => { const event = createEvent<void>('evnt'); const store = createReducer('store', { a: 1 }).on(event, (state) => ({ a: state.a + 1 })); const Cmp = () => { const a = useStoreSelector(store, (s) => s.a); return ( <div> <span data-testid=\"content\">Counter: {a}</span> </div> ); }; const { context, render, act } = testComponent(<Cmp />, { stores: [store] }); expect(render.getByTestId('content').textContent).toBe('Counter: 1'); await act(() => { context.dispatch(event()); }); expect(render.getByTestId('content').textContent).toBe('Counter: 2'); }); it('should work with di', async () => { const Cmp = () => { const { provider } = useDi({ provider: 'provider' }); return <span role=\"status\">{provider}</span>; }; const { render } = testComponent(<Cmp />, { providers: [ { provide: 'provider', useValue: 'test', }, ], }); expect(render.getByRole('status')).toMatchInlineSnapshot(` <span role=\"status\" > test </span> `); }); it('should work with routing', async () => { const Cmp = () => { const route = useRoute(); return ( <div> <div data-testid=\"route\"> <div data-testid=\"route-path\">{route.actualPath}</div> <div data-testid=\"route-name\">{route.name}</div> </div> </div> ); }; const { render } = testComponent(<Cmp />, { currentRoute: { name: 'test', path: '/test/' } }); expect(render.getByTestId('route-path').textContent).toBe('/test/'); expect(render.getByTestId('route-name').textContent).toBe('test'); }); it('should rerender simple component', async () => { expect.hasAssertions(); const Cmp = ({ label }: { label: string }) => { const count = useRef(1); useEffect(() => { count.current += 1; }, [label]); return ( <div> <div>Root</div> <div data-testid=\"test\">{`${count.current}. ${label}`}</div> </div> ); }; const { render, rerender } = testComponent(<Cmp label=\"first render\" />); expect(render.getByTestId('test').textContent).toBe('1. first render'); rerender(<Cmp label=\"second render\" />); expect(render.getByTestId('test').textContent).toBe('2. second render'); }); it('should rerender component on props updates', async () => { const event = createEvent<void>('evnt'); const store = createReducer('store', { a: 1 }).on(event, (state) => ({ a: state.a + 1 })); const Cmp = ({ label }: { label: string }) => { const count = useRef(1); const { a } = useStore(store); useEffect(() => { count.current += 1; }, [label]); return ( <div> <span data-testid=\"content\">{`${count.current}. ${label}: ${a}`}</span> </div> ); }; const { context, render, rerender, act } = testComponent(<Cmp label=\"first render\" />, { stores: [store], }); expect(render.getByTestId('content').textContent).toBe('1. first render: 1'); await act(() => { context.dispatch(event()); }); expect(render.getByTestId('content').textContent).toBe('2. first render: 2'); rerender(<Cmp label=\"second render\" />); expect(render.getByTestId('content').textContent).toBe('2. second render: 2'); }); }); Copy  "},{"title":"Test React-hooks​","type":1,"pageTitle":"React tests","url":"docs/references/test/test-react#test-react-hooks","content":"Under the hood the @testing-library/react-hooks is used. /** * @jest-environment jsdom */ import { testHooks } from '@tramvai/test-react'; describe('test', () => { it('hook', async () => { const { result, context, act } = testHook(() => useHook()); // test the result of hook call expect(result.current).toBe('result'); // test the result after store update act(() => { context.dispatch(event('data')); }); }); }); Copy  More examples /** * @jest-environment jsdom */ import { createReducer, createEvent, useStore } from '@tramvai/state'; import { useDi } from '@tramvai/react'; import { useRoute } from '@tinkoff/router'; import { waitRaf } from '@tramvai/test-jsdom'; import { testHook } from './testHook'; describe('test/unit/react/testHook', () => { it('should render simple hook', async () => { const useHook = jest.fn((p: string) => 'result'); const { result } = testHook(() => useHook('test')); expect(result.current).toBe('result'); expect(useHook).toHaveBeenCalledWith('test'); }); it('should rerender hook', async () => { const event = createEvent<void>('evnt'); const store = createReducer('store', { a: 1 }).on(event, (state) => ({ a: state.a + 1 })); const useHook = () => { return useStore(store).a; }; const { context, result, act } = testHook(() => useHook(), { stores: [store] }); expect(result.current).toBe(1); await act(async () => { await context.dispatch(event()); await waitRaf(); }); expect(result.current).toBe(2); }); it('should work with di', async () => { const useHook = () => { return useDi({ provider: 'provider' }).provider; }; const { result } = testHook(() => useHook(), { providers: [ { provide: 'provider', useValue: 'test', }, ], }); expect(result.current).toEqual('test'); }); it('should work with routing', async () => { const useHook = () => { const route = useRoute(); return [route.actualPath, route.name]; }; const { result } = testHook(() => useHook(), { currentRoute: { name: 'test', path: '/test/' }, }); expect(result.current).toEqual(['/test/', 'test']); }); }); Copy  "},{"title":"Jest unit","type":0,"sectionRef":"#","url":"docs/references/test/test-unit-jest","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Jest unit","url":"docs/references/test/test-unit-jest#installation","content":"Install package: npm i --save-dev @tramvai/test-unit-jest Copy Add new preset to your jest.config: module.exports = { preset: '@tramvai/test-unit-jest', }; Copy "},{"title":"Explanation​","type":1,"pageTitle":"Jest unit","url":"docs/references/test/test-unit-jest#explanation","content":"This presets implements next settings: use jest-circus as testRunnerdefault testEnvironment is nodeuses @swc-node/jest for transformationcss files are mapped with identity-obj-proxyimage files are mapped to empty string "},{"title":"How To​","type":1,"pageTitle":"Jest unit","url":"docs/references/test/test-unit-jest#how-to","content":""},{"title":"Override testEnvironment for file​","type":1,"pageTitle":"Jest unit","url":"docs/references/test/test-unit-jest#override-testenvironment-for-file","content":"Based on jest doc Just add at the start of test file following comment: /** * @jest-environment your-environment */ Copy "},{"title":"child-app-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/child-app-tokens","content":"child-app-tokens import { createToken } from '@tinkoff/dippy'; import type { Action, Command } from '@tramvai/core'; import type { INITIAL_APP_STATE_TOKEN } from '@tramvai/tokens-common'; import type { ComponentType } from 'react'; import type { ChildAppLoader, ChildAppDiManager, ChildAppPreloadManager, ChildAppCommandLineRunner, ChildAppRequestConfig, WrapperProps, RootStateSubscription, ChildAppStateManager, ChildAppFinalConfig, ChildAppRenderManager, ChildAppResolutionConfig, ResolutionConfig, } from './types'; export * from './types'; const multiOptions = { multi: true }; /** * @public * @description CommandLineRunner steps specific for child app */ export const commandLineListTokens = { // section: client processing customerStart: createToken<Command>('child-app customer_start', multiOptions), // Инициализация клиента resolveUserDeps: createToken<Command>('child-app resolve_user_deps', multiOptions), // Получение данных о клиенте resolvePageDeps: createToken<Command>('child-app resolve_page_deps', multiOptions), // Получение данных необходимых для роута // section: clear data clear: createToken<Command>('child-app clear', multiOptions), // Очистка данных // section: spa transitions spaTransition: createToken<Command>('child-app spa_transition', multiOptions), }; /** * @public * @description Contains child app configs that was used to figure out how to load child apps */ export const CHILD_APP_RESOLUTION_CONFIGS_TOKEN = createToken<ChildAppResolutionConfig[]>( 'child-app resolve configs' ); /** * @public * @description async function to execute any preload action before any child-app starts execute */ export const CHILD_APP_PRELOAD_EXTERNAL_CONFIG_TOKEN = createToken<() => Promise<void>>( 'child-app preload external config' ); /** * @public * @description Used to resolve resolution config for a specific child-app */ export const CHILD_APP_GET_RESOLUTION_CONFIG_TOKEN = createToken< (config: ChildAppRequestConfig) => ResolutionConfig >('child-app get resolution config'); /** * @public * @description Used to resolve external config with urls to external code entries */ export const CHILD_APP_RESOLVE_CONFIG_TOKEN = createToken< (config: ChildAppRequestConfig) => ChildAppFinalConfig >('child-app resolve external config'); /** * @public * @description Base url for external urls for child apps on client */ export const CHILD_APP_RESOLVE_BASE_URL_TOKEN = createToken<string>( 'child-app resolve external base url' ); /** * @public * @description Allows to preload child app for the specific page */ export const CHILD_APP_PRELOAD_MANAGER_TOKEN = createToken<ChildAppPreloadManager>( 'child-app preload manager' ); /** * @public * @description Contains child app config that was used to load current child app */ export const CHILD_APP_INTERNAL_CONFIG_TOKEN = createToken<ChildAppFinalConfig>( 'child-app current config' ); /** * @public * @description Actions of child app */ export const CHILD_APP_INTERNAL_ACTION_TOKEN = createToken<Action>( 'child-app action', multiOptions ); /** * @public * @description Subscription on a root state updates */ export const CHILD_APP_INTERNAL_ROOT_STATE_SUBSCRIPTION_TOKEN = createToken<RootStateSubscription>( 'child-app root state subscription', multiOptions ); /** * @public * @description Allows to recreate token implementation the same way as in root di, but specific to child-app di */ export const CHILD_APP_INTERNAL_ROOT_DI_BORROW_TOKEN = createToken<any>( 'child-app root di borrow', multiOptions ); /** * @private * @description boolean flag indicating that current di if for a child-app */ export const IS_CHILD_APP_DI_TOKEN = createToken<boolean>('child-app isChildApp Di'); /** * @private * @description Manages Singleton-Scope DIs for every child app */ export const CHILD_APP_SINGLETON_DI_MANAGER_TOKEN = createToken<ChildAppDiManager>( 'child-app singleton di manager' ); /** * @private * @description Manages Request-Scope DIs for every child app */ export const CHILD_APP_DI_MANAGER_TOKEN = createToken<ChildAppDiManager>('child-app di manager'); /** * @private * @description Bridge from React render to di providers for child apps */ export const CHILD_APP_RENDER_MANAGER_TOKEN = createToken<ChildAppRenderManager>( 'child-app render manager' ); /** * @private * @description Manages state dehydration for child-app */ export const CHILD_APP_STATE_MANAGER_TOKEN = createToken<ChildAppStateManager>( 'child-app state manager' ); /** * @private * @description Manages loading child-app resources from the external place */ export const CHILD_APP_LOADER_TOKEN = createToken<ChildAppLoader>('child-app loader'); /** * @private * @description Implements CommandLineRunner for child apps */ export const CHILD_APP_COMMAND_LINE_RUNNER_TOKEN = createToken<ChildAppCommandLineRunner>( 'child-app command runner' ); /** * @private * @description Stores the common server-dehydrated state for all of child apps */ export const CHILD_APP_COMMON_INITIAL_STATE_TOKEN = createToken< Record<string, typeof INITIAL_APP_STATE_TOKEN> >('child-app initialAppState'); /** * @private * @description Used as render function for a child app. Usually implemented as a wrapper over child app render itself with an additional logic for di and connections to root app */ export const CHILD_APP_INTERNAL_RENDER_TOKEN = createToken<ComponentType<WrapperProps<any>>>( 'child-app render' ); Copy","keywords":""},{"title":"Unit tests","type":0,"sectionRef":"#","url":"docs/references/test/test-unit","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#installation","content":"npm i --save-dev @tramvai/test-unit Copy "},{"title":"How to​","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#how-to","content":""},{"title":"Testing reducers​","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#testing-reducers","content":"import { testReducer } from '@tramvai/test-unit'; it('test', async () => { const { dispatch, getState } = testReducer(reducer); expect(getState()).toEqual([]); dispatch(event(1)); expect(getState()).toEqual([1]); }); Copy  More examples import { createEvent, createReducer } from '@tramvai/state'; import { testReducer } from './testReducer'; describe('test/unit/testReducer', () => { it('should handle state change', () => { const handle = jest.fn((state: number[], payload: number) => { return [...state, payload]; }); const event = createEvent<number>('push'); const reducer = createReducer('test', [] as number[]).on(event, handle); const { dispatch, getState } = testReducer(reducer); expect(getState()).toEqual([]); expect(handle).not.toHaveBeenCalled(); dispatch(event(1)); expect(getState()).toEqual([1]); expect(handle).toHaveBeenCalledWith([], 1); dispatch(event(3)); expect(getState()).toEqual([1, 3]); expect(handle).toHaveBeenCalledWith([1], 3); }); it('should handle several tests reducers at separate', () => { const event = createEvent<number>('push'); const reducer = createReducer('test', [] as number[]).on(event, (state, payload) => { return [...state, payload]; }); const test1 = testReducer(reducer); const test2 = testReducer(reducer); expect(test1.getState()).toEqual([]); expect(test2.getState()).toEqual([]); test1.dispatch(event(1)); expect(test1.getState()).toEqual([1]); expect(test2.getState()).toEqual([]); test2.dispatch(event(2)); expect(test1.getState()).toEqual([1]); expect(test2.getState()).toEqual([2]); }); }); Copy  "},{"title":"Testing actions​","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#testing-actions","content":"import { testAction } from '@tramvai/test-unit'; it('test', async () => { const { run } = testAction(action); expect(await run(true)).toBe('hello'); expect(await run(false)).toBe('world'); }); Copy  More examples import { createAction } from '@tramvai/core'; import { createEvent } from '@tramvai/state'; import { createMockContext } from '@tramvai/test-mocks'; import { testAction } from './testAction'; describe('test/unit/state/testAction', () => { it('should call action', async () => { const action = createAction({ name: 'test', fn: (context, payload: boolean) => { if (payload) { return 'hello'; } return 'world'; }, }); const { run } = testAction(action); expect(await run(true)).toBe('hello'); expect(await run(false)).toBe('world'); }); it('should call action with custom context', async () => { const context = createMockContext(); const event = createEvent<string>('test'); const action = createAction({ name: 'dispatch', fn: (ctx, payload: string) => { return ctx.dispatch(event(`action${payload}`)); }, }); const spyDispatch = jest.spyOn(context, 'dispatch'); const { run } = testAction(action, { context }); await run('ping'); expect(spyDispatch).toHaveBeenCalledWith({ payload: 'actionping', type: 'test' }); await run('pong'); expect(spyDispatch).toHaveBeenCalledWith({ payload: 'actionpong', type: 'test' }); }); it('should not require payload', async () => { const action = createAction({ name: 'no-payload', fn: () => { return 'empty'; }, }); const { run } = testAction(action); await expect(run()).resolves.toBe('empty'); }); }); Copy  "},{"title":"Testing tramvai module​","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#testing-tramvai-module","content":"Testing module in isolation​ import { testModule } from '@tramvai/test-unit'; it('test', async () => { const { di, module, runLine } = testModule(TestModule); expect(module).toBeInstanceOf(TestModule); expect(di.get('testToken')).toEqual({ a: 1 }); // Run only specific command line in order to execute handlers for this line inside module await runLine(commandLineListTokens.generatePage); }); Copy Testing module in conjunction with other modules​ import { createTestApp } from '@tramvai/test-unit'; it('test', async () => { const { app } = await createTestApp({ modules: [TestModule, DependentModule] }); // get tokens from di implemented by module expect(app.di.get('testToken')).toEqual({ a: 1 }); }); Copy  More examples import { commandLineListTokens, DI_TOKEN, Module } from '@tramvai/core'; import { Container } from '@tinkoff/dippy'; import { testModule } from './testModule'; describe('test/unit/module/testModule`', () => { it('should test module', () => { const mockConstructor = jest.fn(); @Module({ providers: [ { provide: 'testToken', useFactory: () => { return { a: 1 }; }, }, ], deps: { di: DI_TOKEN, optToken: { token: 'optional_token', optional: true }, }, }) class TestModule { constructor(deps: any) { mockConstructor(deps); } } const { di, module } = testModule(TestModule); expect(module).toBeInstanceOf(TestModule); expect(mockConstructor).toHaveBeenCalledWith({ di: expect.any(Container), optToken: null }); expect(di.get('testToken')).toEqual({ a: 1 }); }); it('should test command line', async () => { const mock = jest.fn(); @Module({ providers: [ { provide: commandLineListTokens.generatePage, multi: true, useFactory: () => { return mock; }, }, ], }) class TestModule {} const { runLine } = testModule(TestModule); expect(() => runLine(commandLineListTokens.customerStart)).toThrow(); expect(mock).not.toHaveBeenCalled(); await runLine(commandLineListTokens.generatePage); expect(mock).toHaveBeenCalledWith(); }); }); Copy  "},{"title":"Testing app​","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#testing-app","content":"Testing app works only in node-environment. See jest docs import { testApp } from '@tramvai/test-unit'; it('test', async () => { const { request, render } = await testApp(app); const response = await request('/').expect(200).expect('X-App-Id', 'unit-app'); expect(response.text).toMatch('<html class=\"no-js\" lang=\"ru\">'); expect(response.text).toMatch('<div class=\"application\">rootPage</div>'); expect(response.text).toMatch('<script>var initialState ='); const rootPage = await render('/'); expect(rootPage.application).toEqual('rootPage'); const secondPage = await render('/second/'); expect(secondPage.application).toEqual('secondPage'); expect(secondPage.initialState).toEqual({ stores: expect.objectContaining({ environment: { FRONT_LOG_API: 'test', }, router: expect.objectContaining({ currentUrl: expect.objectContaining({ path: '\\\\u002Fsecond\\\\u002F', }), }), }), }); }); Copy  More examples import { NoSpaRouterModule } from '@tramvai/module-router'; import { commandLineListTokens, createApp, createBundle } from '@tramvai/core'; import { CommonModule, ENV_USED_TOKEN } from '@tramvai/module-common'; import { LogModule } from '@tramvai/module-log'; import { RenderModule } from '@tramvai/module-render'; import { ServerModule } from '@tramvai/module-server'; import { testApp } from './testApp'; type ThenArg<T> = T extends PromiseLike<infer U> ? U : T; const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: () => 'rootPage', pageSecond: () => 'secondPage', }, }); describe('test/unit/app/testApp', () => { let testEnv: ThenArg<ReturnType<typeof testApp>>; describe('normal', () => { beforeAll(async () => { const app = createApp({ name: 'unit-app', bundles: { mainDefault: () => Promise.resolve({ default: bundle }), }, modules: [ CommonModule, LogModule, RenderModule, ServerModule, NoSpaRouterModule.forRoot([ { name: 'root', path: '/', }, { name: 'other', path: '/second/', config: { pageComponent: 'pageSecond', }, }, ]), ], providers: [ { provide: ENV_USED_TOKEN, multi: true, useValue: { key: 'FRONT_LOG_API', value: 'test' }, }, ], }); testEnv = await testApp(app); }); afterAll(() => { return testEnv.close(); }); it('should request to server', async () => { const { request } = testEnv; const response = await request('/').expect(200).expect('X-App-Id', 'unit-app'); expect(response.text).toMatch('<html class=\"no-js\" lang=\"ru\">'); expect(response.text).toMatch('<div class=\"application\">rootPage</div>'); expect(response.text).toMatch('<script>var initialState ='); }); it('should return render of page', async () => { const { render } = testEnv; const rootPage = await render('/'); expect(rootPage.application).toEqual('rootPage'); const secondPage = await render('/second/'); expect(secondPage.application).toEqual('secondPage'); expect(secondPage.initialState).toEqual({ stores: expect.objectContaining({ environment: { FRONT_LOG_API: 'test', }, router: expect.objectContaining({ currentUrl: expect.objectContaining({ path: '/second/', }), }), }), }); }); it('should return mocker instance', async () => { const { mocker } = testEnv; expect(mocker).toBeDefined(); }); }); describe('fail', () => { beforeAll(async () => { const app = createApp({ name: 'unit-app', bundles: { mainDefault: () => Promise.resolve({ default: bundle }), }, modules: [CommonModule, LogModule, RenderModule, ServerModule], providers: [ { provide: commandLineListTokens.resolveUserDeps, multi: true, useFactory: ({ wrong }) => { return wrong.test(); }, deps: { wrong: '_unknown_provider', }, }, ], }); testEnv = await testApp(app); }); afterAll(() => { return testEnv.close(); }); it('render with 500 status should fail', async () => { const { render } = testEnv; await expect(render('/')).rejects.toThrowError( 'Error: Token not found &quot;_unknown_provider&quot; at &quot;resolve_user_deps&quot;' ); }); }); }); Copy  "},{"title":"Adding providers to DI​","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#adding-providers-to-di","content":"Most of the helpers accepts option providers which allows to redefine already existing providers or add new. For example, passing providers to helper testAction allows to access this provider inside action itself: import { createAction } from '@tramvai/core'; import { testAction } from '@tramvai/test-unit'; const action = createAction({ name: 'action', fn: (_, __, { test }) => { console.log(test); // token value }, deps: { test: 'token name', }, }); it('test', async () => { const { run } = testAction(action, { providers: [ { provide: 'token name', useValue: 'token value', }, ], }); }); Copy "},{"title":"Create app only for testing​","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#create-app-only-for-testing","content":"import { createTestApp } from '@tramvai/test-unit'; it('test', async () => { const { app } = await createTestApp({ modules: [TestModule, DependentModule] }); // get tokens from di implemented by module expect(app.di.get('testToken')).toEqual({ a: 1 }); }); Copy  More examples import http from 'http'; import { ENV_MANAGER_TOKEN } from '@tramvai/tokens-common'; import { SERVER_TOKEN } from '@tramvai/tokens-server'; import { CommonModule } from '@tramvai/module-common'; import { createTestApp } from './createTestApp'; describe('test/unit/app/createTestApp', () => { it('should return app', async () => { const { app, close } = await createTestApp(); const envManager = app.di.get(ENV_MANAGER_TOKEN); expect(envManager.get('FRONT_LOG_API')).toBe('test'); expect(envManager.get('TEST_ENV')).toBeUndefined(); expect(app.di.get(SERVER_TOKEN)).toBeInstanceOf(http.Server); return close(); }); it('should specify env', async () => { const { app, close } = await createTestApp({ env: { TEST_ENV: '1234', }, }); const envManager = app.di.get(ENV_MANAGER_TOKEN); expect(envManager.get('FRONT_LOG_API')).toBe('test'); expect(envManager.get('TEST_ENV')).toBe('1234'); return close(); }); it('should ignore default modules', async () => { const { app } = await createTestApp({ excludeDefaultModules: true, modules: [CommonModule], }); expect(() => app.di.get(SERVER_TOKEN)).toThrow('Token not found'); }); it('should return mocker instance', async () => { const { mocker, close } = await createTestApp(); expect(mocker).toBeDefined(); return close(); }); }); Copy  "},{"title":"http-client-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/http-client-tokens","content":"","keywords":""},{"title":"Tokens​","type":1,"pageTitle":"http-client-tokens","url":"docs/references/tokens/http-client-tokens#tokens","content":" import { createToken } from '@tinkoff/dippy'; import type { ApiService, HttpClient } from '@tramvai/http-client'; import type { TinkoffRequestOptions, Agent } from '@tramvai/tinkoff-request-http-client-adapter'; export type HttpClientFactoryOptions = TinkoffRequestOptions & { name: string }; /** * @description * Factory of HTTP clients with minimal base settings */ export const HTTP_CLIENT_FACTORY = createToken<(options: HttpClientFactoryOptions) => HttpClient>( 'HTTP_CLIENT_FACTORY' ); /** * @description * Universal HTTP client for arbitrary requests */ export const HTTP_CLIENT = createToken<HttpClient>('HTTP_CLIENT'); /** * @description * Global HTTP and HTTPS agents for all clients * https://nodejs.org/dist/latest-v16.x/docs/api/http.html#class-httpagent */ export const HTTP_CLIENT_AGENT = createToken<{ http: Agent; https: Agent; }>('HTTP_CLIENT_AGENT'); /** * @description * List of HTTP headers that are proxied from app request to all of the backend API */ export const API_CLIENT_PASS_HEADERS = createToken<string[]>('apiClientPassHeaders', { multi: true, }); /** * @description * Internal api for app server. * Uses the value of `APP_INFO_TOKEN` from di for constructing the request address */ export const PAPI_SERVICE = createToken<ApiService>('papi service'); Copy  "},{"title":"metrics-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/metrics-tokens","content":"","keywords":""},{"title":"Tokens list​","type":1,"pageTitle":"metrics-tokens","url":"docs/references/tokens/metrics-tokens#tokens-list","content":" import { createToken } from '@tinkoff/dippy'; import type { Counter, CounterConfiguration, Gauge, GaugeConfiguration, Histogram, HistogramConfiguration, Summary, SummaryConfiguration, } from 'prom-client'; interface Metrics { counter<T extends string = string>(opt: CounterConfiguration<T>): Counter<T>; gauge<T extends string = string>(opt: GaugeConfiguration<T>): Gauge<T>; histogram<T extends string = string>(opt: HistogramConfiguration<T>): Histogram<T>; summary<T extends string = string>(opt: SummaryConfiguration<T>): Summary<T>; } export { Counter, Gauge, Histogram, Summary, Metrics }; /** * @description * Metric module implementation */ export const METRICS_MODULE_TOKEN = createToken<Metrics>('metricsModule'); export interface MetricsServicesRegistryInterface { register(url: string, serviceName: string): void; registerEnv(env: Record<string, unknown>): void; getServiceName(url: string): string | void; } /** * @description * Utility for pointing out to metric module which service name to set for different requests */ export const METRICS_SERVICES_REGISTRY_TOKEN = createToken<MetricsServicesRegistryInterface>( 'metricsServicesRegistry' ); /** * @description * Token for registering counter metric which can be incremented with POST papi request */ export const REGISTER_INSTANT_METRIC_TOKEN = createToken<[string, Counter<string>]>( 'registerInstantMetric' ); Copy  "},{"title":"render-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/render-tokens","content":"","keywords":""},{"title":"Список токенов​","type":1,"pageTitle":"render-tokens","url":"docs/references/tokens/render-tokens#список-токенов","content":" import type { ReactElement, ComponentType } from 'react'; import { createToken } from '@tinkoff/dippy'; import { StorageRecord } from '@tinkoff/htmlpagebuilder'; import * as ResourceSlot from './slots'; /** * @description * Token adding resources to specific render slots. * Used only on server and it is equivalent to usage of RESOURCES_REGISTRY. * * [Usage example](https://tramvai.dev/docs/how-to/render-add-resources) */ export const RENDER_SLOTS = createToken<PageResource | PageResource[]>('RENDER_SLOTS', { multi: true, }); /** * @description * Token for defining additional attributes for html, body and app container. Keep in mind that: * - only raw html attributes are allowed (not react or anything else, e.g. do not use className use class) * - new attributes overrides old one * - only text values are supported * * @example ```tsx { provide: HTML_ATTRS, useValue: { target: 'body', attrs: { class: 'custom-class', }, }, multi: true, }, ``` */ export const HTML_ATTRS = createToken<HtmlAttrs>('HTML_ATTRS', { multi: true }); /** * @description * Add node-style callback on render event in browser. * Passes error instance as first argument if there was an error */ export const RENDERER_CALLBACK = createToken<((e?: Error) => void)[]>('RENDERER_CALLBACK', { multi: true, }); /** * @description * Used as async function which overrides app render. This function may define render parameters or override render result. */ export const CUSTOM_RENDER = createToken<(content: JSX.Element) => Promise<string>>( 'CUSTOM_RENDER' ); /** * @description * Resources registry is used only on server for registering any additional assets for browser (scripts, styles, html) which should be added to response html page */ export const RESOURCES_REGISTRY = createToken<ResourcesRegistry>('resourcesRegistry'); /** * @description * A string used for check of need to loading polyfills in the client browser. * Polyfills are always loading for browsers without module support and if browser do support modules * this check will called in order to find out the need of loading polyfills * (by default checks for Promise.prototype.finally and implementations for URL and URLSearchParams) * * [Polyfill documentation](https://tramvai.dev/docs/how-to/how-to-enable-polyfills) */ export const POLYFILL_CONDITION = createToken<string>('POLYFILL_CONDITION'); /** * @description * Allows to specify different modes for React Render - `strict`, `blocking`, `concurrent`, by default value `legacy` is used * * [More details in doc for module-render](https://tramvai.dev/docs/references/modules/render) */ export const RENDER_MODE = createToken<RenderMode>('RENDER_MODE'); /** * @description * A wrapper for app render. * Through that token is possible to specify for example React.Context.Provider for the app */ export const EXTEND_RENDER = createToken<Array<(current: ReactElement) => ReactElement>>( 'EXTEND_RENDER', { multi: true, } ); /** * @description * Token for default layout for page */ export const DEFAULT_LAYOUT_COMPONENT = createToken('defaultLayoutComponent'); /** * @description * Token for default header for page */ export const DEFAULT_HEADER_COMPONENT = createToken('defaultHeaderComponent'); /** * @description * Token for default footer for page */ export const DEFAULT_FOOTER_COMPONENT = createToken('defaultFooterComponent'); /** * @description * Token for passing parameters for page layout */ export const LAYOUT_OPTIONS = createToken<LayoutOptions[]>('layoutOptions', { multi: true }); type ReactComponent = ComponentType<any>; type Wrapper = (WrappedComponent: ReactComponent) => ReactComponent; export interface LayoutOptions { components?: Record<string, ReactComponent>; wrappers?: Record<string, Wrapper | Wrapper[]>; } export interface PageResource { type: keyof typeof StorageRecord; slot: typeof ResourceSlot[keyof typeof ResourceSlot]; payload: string | null; attrs?: Record<string, string | null>; } export interface ResourcesRegistry { register(resource: PageResource | PageResource[]): void; getPageResources(): PageResource[]; } export type HtmlAttrs = { target: 'html' | 'body' | 'app'; attrs: { [name: string]: string | boolean | Record<string, any> | number }; }; export type RenderMode = 'legacy' | 'strict' | 'blocking' | 'concurrent'; type ResourceInlineOptions = { threshold: number; types: (keyof typeof StorageRecord)[]; }; /** * @description * Settings for HTML resources inlining * * threshold Maximum value (in bytes) of the file which are getting inlined in HTML page * * types Types of resources which should be inlined */ export const RESOURCE_INLINE_OPTIONS = createToken<ResourceInlineOptions>( 'resourceInlineThreshold' ); export { ResourceSlot }; export { StorageRecord as ResourceType }; Copy  "},{"title":"Render slots​","type":1,"pageTitle":"render-tokens","url":"docs/references/tokens/render-tokens#render-slots","content":" export const HEAD_META = 'head:meta'; export const HEAD_PERFORMANCE = 'head:performance'; export const HEAD_CORE_STYLES = 'head:core-styles'; export const HEAD_POLYFILLS = 'head:polyfills'; export const HEAD_CORE_SCRIPTS = 'head:core-scripts'; export const HEAD_DYNAMIC_SCRIPTS = 'head:dynamic-scripts'; export const HEAD_ANALYTICS = 'head:analytics'; export const HEAD_ICONS = 'head:icons'; export const BODY_START = 'body:start'; export const REACT_RENDER = 'react:render'; export const BODY_END = 'body:end'; export const BODY_TAIL_ANALYTICS = 'body:tail:analytics'; export const BODY_TAIL = 'body:tail'; Copy  "},{"title":"common-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/common-tokens","content":"","keywords":""},{"title":"Action tokens​","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#action-tokens","content":" import { createToken } from '@tinkoff/dippy'; import type { Action } from '@tramvai/core'; /** * @description * Registry for storing actions based on their type */ export const ACTION_REGISTRY_TOKEN = createToken<ActionsRegistry>('actionRegistry'); /** * @description * Instance that executes actions */ export const ACTION_EXECUTION_TOKEN = createToken<ActionExecution>('actionExecution'); /** * @description * Instance that executes actions on navigations */ export const ACTION_PAGE_RUNNER_TOKEN = createToken<ActionPageRunner>('actionPageRunner'); /** * @description * Conditions that specify should action be executing or not */ export const ACTION_CONDITIONALS = createToken<ActionCondition[]>('actionConditionals', { multi: true, }); export interface ActionsRegistry { add(type: string, actions: Action | Action[]): void; get(type: string, addingActions?: Action[]): Action[]; getGlobal(): Action[]; remove(type: string, actions?: Action | Action[]): void; } export interface ActionExecution { execution: Map<string, any[]>; run(action: Action, payload: any): Promise<any>; } export interface ActionPageRunner { runActions(actions: Action[], stopRunAtError?: (error: Error) => boolean): Promise<any>; } export interface ActionConditionChecker<State = any> { payload: any; parameters: any; conditions: Record<string, any>; type: 'global' | 'local'; allow(): void; setState(value: State): void; getState(): State; forbid(): void; } export type ActionCondition = { key: string; fn: (checker: ActionConditionChecker) => void; }; Copy  "},{"title":"Bundle tokens​","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#bundle-tokens","content":" import { createToken } from '@tinkoff/dippy'; import type { Bundle } from '@tramvai/core'; /** * @description * Bundle Storage. When getting bundle additionally adds actions and components from bundle to according storages */ export const BUNDLE_MANAGER_TOKEN = createToken<BundleManager>('bundleManager'); /** * @description * Provides additional bundles to the app. * Important! This token doesn't overrides already existing bundles. */ export const ADDITIONAL_BUNDLE_TOKEN = createToken<{ [key: string]: Bundle }>('additional bundle', { multi: true, }); export interface BundleManager { bundles: Record<string, any>; get(name: string, pageComponent: string): Promise<any>; has(name: string, pageComponent: string): boolean; } Copy  "},{"title":"ComponentRegistry tokens​","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#componentregistry-tokens","content":" import type { ComponentType } from 'react'; import { createToken } from '@tinkoff/dippy'; import type { Action } from '@tramvai/core'; export interface RegistryComponentExtend { redirects?: any; actions?: Action[]; } export type Component = ComponentType & RegistryComponentExtend; /** * @description * React components storage. * Components in the repository are divided into groups, e.g. you can specify a bundle or a page component as a group key. * The entity also allows you to get static component parameters through the `getComponentParam` method (will not work with `lazy` components) */ export const COMPONENT_REGISTRY_TOKEN = createToken<ComponentRegistry>('componentRegistry'); export interface ComponentRegistry { components: Record<string, Component>; add(name: string, component: Component, group?: string): void; get(name: string, group?: string): Component; getComponentParam<T>(param: string, defaultValue: T, component: string, group?: string): T; } Copy  "},{"title":"Env tokens​","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#env-tokens","content":" import { createToken } from '@tinkoff/dippy'; export interface EnvironmentManager { get(name: string): string; getInt(name: string, def: number): number; getAll(): Record<string, string>; update(result: Record<string, string>): void; clientUsed(): Record<string, string>; updateClientUsed(result: Record<string, string>): void; } /** * @description * Instance that used for managing env data on the server and on the client */ export const ENV_MANAGER_TOKEN = createToken<EnvironmentManager>('environmentManager'); /** * @description * List of envs that are used by the module or the app. * All of the envs specified by that token will be accessible in the code through `environmentManager` * ENV_USED_TOKEN format: - `key` - id of the env. At that id the value of the env will be accessible through `environmentManager` and will be loaded from the external sources. - `value` - default low-priority value for env `key` - `optional` - is current env is optional. If `true` the app can work as usual event if the env value were not provided, if `false` - the app will fail to run without env value - `validator` - validation function for passed env value. In case this function returns string it will be used as error message and validation will fail - `dehydrate` - if `false` then env value will not be passed to client and this env can be used only on server * * @example ```tsx interface EnvParameter { key: string; value?: string; optional?: boolean; validator?: (value: string) => boolean | string; dehydrate?: boolean; } ``` */ export interface EnvParameter { key: string; value?: string; optional?: boolean; validator?: (value: string) => boolean | string; dehydrate?: boolean; } export const ENV_USED_TOKEN = createToken<EnvParameter[]>('envUsed', { multi: true }); Copy  "},{"title":"Context tokens​","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#context-tokens","content":" import type { Container } from '@tinkoff/dippy'; import { createToken } from '@tinkoff/dippy'; import type { ConsumerContext as BaseConsumerContext } from '@tramvai/types-actions-state-context'; import type { PUBSUB_TOKEN } from './pubsub'; export { PlatformAction } from '@tramvai/types-actions-state-context'; /** * @description * Context implementation */ export const CONTEXT_TOKEN = createToken<ConsumerContext>('context'); export interface ConsumerContext extends BaseConsumerContext { readonly di: Container; readonly pubsub: typeof PUBSUB_TOKEN; dehydrate: () => { dispatcher: { stores: Record<string, any>; }; }; } Copy  "},{"title":"Hook tokens​","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#hook-tokens","content":" import { createToken } from '@tinkoff/dippy'; /** * @description * [Hooks documentation](https://tramvai.dev/docs/references/libs/hooks) */ export const HOOK_TOKEN = createToken<Hooks>('hooks'); type Hook<TPayload> = (context: any, payload?: TPayload, options?: any) => TPayload; export interface Hooks { /** * Register hooks */ registerHooks<TPayload>(name: string, list: Hook<TPayload>[] | Hook<TPayload>): void; /** * Run sync hook */ runHooks<TPayload>(name: string, context: any, payload?: TPayload, options?: any): TPayload; /** * Run async hooksЗапуск ассихронных хуков */ runAsyncHooks<TPayload>(name: string, context: any, payload: TPayload, options?: any): TPayload; /** * Run promise hooks */ runPromiseHooks( name: string, context: any, options?: any ): <TPayload>(payload: TPayload) => Promise<TPayload> | Promise<never>; } Copy  "},{"title":"Logger tokens​","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#logger-tokens","content":" import type { Logger } from '@tinkoff/logger'; import { createToken } from '@tinkoff/dippy'; /** * @description * Logger implementation */ export const LOGGER_TOKEN = createToken<LoggerFactory>('logger'); /** * @description * Hook to be able to modify logger on initialization */ export const LOGGER_INIT_HOOK = createToken<LoggerInitHook>('loggerHook'); type Config = { name: string; [key: string]: any; }; export type LoggerFactory = Logger & ((configOrName: string | Config) => Logger); type LoggerInitHook = (logger: LoggerFactory) => void; export type { Logger, LogFn, LogArg } from '@tinkoff/logger'; Copy  "},{"title":"Pubsub tokens​","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#pubsub-tokens","content":" import { createToken } from '@tinkoff/dippy'; /** * @description * Factory for creating pubsub instances */ export const PUBSUB_FACTORY_TOKEN = createToken<() => PubSub>('pubsubFactory'); /** * @description * Singleton pubsub instance */ export const PUBSUB_TOKEN = createToken<PubSub>('pubsub'); /** * @description * Request pubsub instance that is created for every client */ export const ROOT_PUBSUB_TOKEN = createToken<PubSub>('rootPubsub'); export interface PubSub { subscribe(event: string, fn: (payload?: any) => void): () => boolean; publish(event: string, ...args: unknown[]): any; } Copy  "},{"title":"RequestManager tokens​","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#requestmanager-tokens","content":" import { createToken } from '@tinkoff/dippy'; import type { Request } from 'express'; // HACK: to prevent inlining of Request and providing internal express dependencies to outside type RequestExt = Request; /** * @description * Direct reference to request object */ export const REQUEST = createToken<RequestExt>('request'); /** * @description * Instance for managing client requests (request headers, query-parameters, cookies etc). * Mostly used on server, but has partial functional for browser for simplification build isomorphic app */ export const REQUEST_MANAGER_TOKEN = createToken<RequestManager>('requestManager'); export interface RequestManager { getBody(): unknown; getUrl(): string; getMethod(): string; getCookie(key: string): string; getCookies(): Record<string, string>; getHeader(key: string): string | string[]; getHeaders(): Record<string, string | string[]>; getClientIp(): string; getHost(): string; } Copy  "},{"title":"ResponseManager tokens​","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#responsemanager-tokens","content":" import { createToken } from '@tinkoff/dippy'; import type { Response } from 'express'; /** * @description * Direct reference to Response instance */ export const RESPONSE = createToken<Response>('response'); /** * @description * Instance for managing client response (response headers, cookies, response body). * Mostly used on server, but has partial functional for browser for simplification build isomorphic app */ export const RESPONSE_MANAGER_TOKEN = createToken<ResponseManager>('responseManager'); export interface ResponseManager { getBody(): string; setBody(value: string): void; getHeader(key: string): string | string[]; getHeaders(): Record<string, string | string[]>; setHeader(key: string, value: string): void; getCookie(key: string): string; getCookies(): Record<string, string>; setCookie(key: string, value: string): void; getStatus(): number; setStatus(status: number): void; } Copy  "},{"title":"State tokens​","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#state-tokens","content":" import { createToken } from '@tinkoff/dippy'; import type { DispatcherContext, Event, Middleware, Reducer } from '@tramvai/state'; /** * @description * dispatcher implementation * Реализация dispatcher */ export const DISPATCHER_TOKEN = createToken('dispatcher'); /** * @description * dispatcher context implementation */ export const DISPATCHER_CONTEXT_TOKEN = createToken<DispatcherContext<any>>('dispatcherContext'); /** * @description * Token for adding stores that were created with createReducer */ export const COMBINE_REDUCERS = createToken('combineReducers', { multi: true }); /** * @description * Common app store */ export const STORE_TOKEN = createToken<Store>('store'); /** * @description * Custom middlewares for working with store state */ export const STORE_MIDDLEWARE = createToken<Middleware>('storeMiddleware', { multi: true }); /** * @description * Начальное состояние для клиента */ export const INITIAL_APP_STATE_TOKEN = createToken<{ stores: Record<string, any> }>( 'initialAppState' ); export interface Store<State = Record<string, any>> { dispatch: <Payload>(actionOrNameEvent: string | Event<Payload>, payload?: Payload) => Payload; subscribe(callback: (state: Record<string, any>) => void): () => void; subscribe<S>(reducer: Reducer<S>, callback: (state: S) => void): () => void; getState(): State; getState<S>(reducer: Reducer<S>): S; } Copy  "},{"title":"router-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/router-tokens","content":"","keywords":""},{"title":"Tokens​","type":1,"pageTitle":"router-tokens","url":"docs/references/tokens/router-tokens#tokens","content":" import { createToken } from '@tinkoff/dippy'; import type { AbstractRouter, NavigationGuard, Route, Navigation, NavigationRoute, NavigateOptions, UpdateCurrentRouteOptions, HistoryOptions, } from '@tinkoff/router'; import type { Component } from '@tramvai/tokens-common'; /** * @description * Token to access the router instance */ export const ROUTER_TOKEN = createToken<AbstractRouter>('router router'); /** * @description * Token for defining static routes */ export const ROUTES_TOKEN = createToken<Route>('router routes', { multi: true }); /** * @description * Token for providing guard handlers for page transitions */ export const ROUTER_GUARD_TOKEN = createToken<NavigationGuard>('router guard', { multi: true }); /** * @description * Encapsulates the logic of working with the router - contains methods for getting the configuration of the route and performing navigation */ export const PAGE_SERVICE_TOKEN = createToken<PageService>('router pageService'); /** * @description * Hook to resolve route dynamically */ export const ROUTE_RESOLVE_TOKEN = createToken<RouteResolve>('router routeResolve'); /** * @description * Hook to transform route config */ export const ROUTE_TRANSFORM_TOKEN = createToken<RouteTransform>('router routeTransform', { multi: true, }); /** * @description * Flag for SPA-transitions, indicating that actions must be executed before or after a route update in the stor */ export const ROUTER_SPA_ACTIONS_RUN_MODE_TOKEN = createToken<'before' | 'after'>( 'router spaRunMode' ); export interface PageService { getCurrentRoute(): NavigationRoute; getCurrentUrl(): ReturnType<AbstractRouter['getCurrentUrl']>; getConfig(): Route['config']; getContent(): Record<string, any>; getMeta(): { seo: Record<string, string>; analytics: Record<string, string> }; navigate(options: string | NavigateOptions): Promise<void>; updateCurrentRoute(options: UpdateCurrentRouteOptions): Promise<void>; back(options?: HistoryOptions): Promise<void>; forward(): Promise<void>; go(to: number, options?: HistoryOptions): Promise<void>; addComponent(name: string, component: Component): void; getComponent(name: string): Component; resolveComponentFromConfig(property: 'page' | 'layout' | 'header' | 'footer'): Component; } export type RouteResolve = (navigation: Navigation) => Promise<Route | void>; export type RouteTransform = (route: Route) => Route; Copy  "},{"title":"server-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/server-tokens","content":"","keywords":""},{"title":"Tokens​","type":1,"pageTitle":"server-tokens","url":"docs/references/tokens/server-tokens#tokens","content":" import type { Server } from 'http'; import type { Application } from 'express'; import { createToken } from '@tinkoff/dippy'; import type { Papi } from '@tramvai/papi'; /** * @description * Specifies base url for public papi handlers. By default equals to `/[appName]/papi` */ export const SERVER_MODULE_PAPI_PUBLIC_URL = createToken<string>('serverModulePapiPublicUrl'); /** * @description * Specifies base url for private papi handlers. By default equals `/[appName]/private/papi` */ export const SERVER_MODULE_PAPI_PRIVATE_URL = createToken<string>('serverModulePapiPrivateUrl'); /** * @description * Add private papi route */ export const SERVER_MODULE_PAPI_PRIVATE_ROUTE = createToken<Papi>('serverModulePapiPrivateRoute', { multi: true, }); /** * @description * Add public papi route */ export const SERVER_MODULE_PAPI_PUBLIC_ROUTE = createToken<Papi>('serverModulePapiPublicRoute', { multi: true, }); /** * @description * Settings for the static server */ export const SERVER_MODULE_STATICS_OPTIONS = createToken<ServerModuleStaticsOptions>( 'serverModuleStaticsOptions' ); /** * @description * Instance of nodejs `http.Server`. * Can be used for adding custom logic on server, like error handling, connection settings * * @example ```tsx { provide: commandLineListTokens.init, multi: true, useFactory: ({ server }) => { return function serverListen() { createTerminus(server, {}); }; }, deps: { SERVER_TOKEN, }, }, ``` */ export const SERVER_TOKEN = createToken<Server>('server'); /** * @description * Instance of the current server app. By default it is an `express` app. * Can be used to setup custom request handler and add custom routes * * @example ```tsx { provide: SERVER_TOKEN, useFactory: ({ webApp }) => { const server = https.createServer(); server.on('request', webApp); return server; }, deps: { WEB_APP_TOKEN, } } ``` */ export const WEB_APP_TOKEN = createToken<Application>('webApp'); /** * @description * Subscription to before web-app initialization. It is called before any standard handlers. * * @example ```tsx { provide: WEB_APP_BEFORE_INIT_TOKEN, multi: true, useValue: (app) => { app.use(cookieParser()) } } ``` */ export const WEB_APP_BEFORE_INIT_TOKEN = createToken<APP_INIT_HANDLER>('webAppBeforeInit', { multi: true, }); /** * @description * Subscription to web-app initialization. * It is called after global request handlers but before handlers for page rendering * * @example ```tsx { provide: WEB_APP_INIT_TOKEN, multi: true, useValue: (app) => { app.use('mm.css', proxyCss()); app.use('mm.js', proxyClientJs()); } } ``` */ export const WEB_APP_INIT_TOKEN = createToken<APP_INIT_HANDLER>('webAppInit', { multi: true }); /** * @description * Subscription to after web-app initialization. * It is called after any other handlers * * @example ```tsx { provide: WEB_APP_AFTER_INIT_TOKEN, multi: true, useValue: (app) => { app.use(logMiddleware()) } } ``` */ export const WEB_APP_AFTER_INIT_TOKEN = createToken<APP_INIT_HANDLER>('webAppAfterInit', { multi: true, }); /** * @description * Add resources for request proxying to the app through `http-proxy-middleware` */ export const PROXY_CONFIG_TOKEN = createToken<ProxyConfig[]>('proxyConfigToken', { multi: true, }); /** * @description * Override filter function when accessing papi route `/dependenciesVersion` */ export const DEPENDENCIES_VERSION_FILTER_TOKEN = createToken<DepsFilter>( 'dependenciesVersionFilter' ); /** * @description * List of the special URLs on server (e.g. healthz and readyz) * Url matching is happens with a library `path-to-regexp`. */ export const SPECIAL_SERVER_PATHS = createToken<string>('specialServerPaths', { multi: true }); export interface ServerModuleStaticsOptions { path: string; } export type APP_INIT_HANDLER = Array<(app?: Application) => Promise<never> | never>; export type ProxyConfig = | { [key: string]: | string | { target: string; [key: string]: any; }; } | { context: string | string[]; target: string; [key: string]: any; }; export type DepsFilter = ( deps: Record<string, string> ) => Record<string, string> | Promise<Record<string, string>>; Copy  "},{"title":"@tramvai/build","type":0,"sectionRef":"#","url":"docs/references/tools/build","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#installation","content":"Install @tramvai/build first: yarn add @tramvai/build Copy Add necessary fields to package.json: { \"main\": \"lib/index.js\", \"typings\": \"src/index.ts\" } Copy \"main\": \"lib/index.js\" based on that field lib calculates entry point for the build and it will be \"src/index.ts\" in this case \"typings\": \"src/index.ts\" desirable to specify that field to entry point as it is useful for the monorepo projects and allows to use current package in other packages without build. After build package for publication this filed will be replaced to point to the built typedef file, in this case - \"typings\": \"lib/index.d.ts\" And to tsconfig.json: { \"compilerOptions\": { \"moduleResolution\": \"node\", \"target\": \"ES5\", \"module\": \"CommonJS\", \"declaration\": true, \"importHelpers\": true, \"skipLibCheck\": true, \"rootDir\": \"./src\", \"outDir\": \"./lib\", \"declarationDir\": \"./lib\" }, \"include\": [\"./src\"] } Copy Add to dependencies library tslib: yarn add tslib Copy Build package with command tramvai-build: tramvai-build --forPublish Copy with flag --forPublish tramvai-build replaces some fields in package.json in order to make built package usable in the end apps, for example \"typings\": \"src/index.ts\" replaces by \"typings\": \"lib/index.d.ts\" "},{"title":"Explanation​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#explanation","content":"The main purpose for the lib is the effective production build for TypeScript package using rollup, with watch mode support. Such builds, especially for monorepositories with big number of packages, can take a long time and are not very comfortable to work. Thats why, for the development environment it is preferred to use tsc with project references and incremental build. Recommended and automatically generated package.json for @tramvai/build allows apps to use packages that were built either with tsc, or with @tramvai/build without any additional steps. All of the built bundles will contain ES2019 standard code, it is expected that they will be bundled to ES5 using bundler (Webpack, etc.) with configured transpilation through babel for packages inside node_modules, written in modern JS. "},{"title":"NodeJS bundle in CommonJs format​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#nodejs-bundle-in-commonjs-format","content":"NodeJS before 12 version hasn't supported ES modules or supported it only behind special flag. @tramvai/build generates bundle in ES2019 standard in CommonJS format automatically. Name of the result bundle is taken from field main in package.json, e.g. lib/index.js. When bundling package in the app using webpack with option target: 'node' this CommonJS bundle probably will not be used as webpack will prefer to use module field while resolving source code. It is expected that bundle from field \"main\" will be resolved only by NodeJS itself while bundlers will use bundle from field \"module\" "},{"title":"Bundle for bundlers (Webpack, etc.) in ES modules format​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#bundle-for-bundlers-webpack-etc-in-es-modules-format","content":"Modern bundlers support ES modules and non-standard field \"module\" in package.json. @tramvai/build generates bundle in ES2019 standard in ES modules format automatically. Name of the result bundle is calculates from field main in package.json by adding postfix .es e.g. lib/index.es.js. If build was called with flag --forPublish to package.json will be added new field \"module\": \"lib/index.es.js\". When bundling package in the app through webpack with option target: 'node' bundle from field module will have higher priority over bundle from main. ES2019 code standard is generated as it is expected that bundle from field \"module\" will be resolved by bundler with configured transpilation through babel for packages inside node_modules, written in modern JS. Why we still prefer to use ES5 code over ES2019? Apparently, code in ES5 is still notably faster on NodeJS server. In the same time output bundle size is not important on server. "},{"title":"Bundle for browsers​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#bundle-for-browsers","content":"Modern bundlers support ES modules and non-standard field \"browser\" in package.json. When field browser in specified in package.json, @tramvai/build will generate bundle in ES2019 standard in ES modules format. If field browser in package.json is defined as a string then this string determines entry point to browser bundle and its name. E.g. when \"browser\": \"lib/browser.js\" entry point will be src/browser.ts and bundle will have a name lib/browser.js. Otherwise, if field browser is defined as an object and build was called with flag --forPublish then name is defined by the field main in package.json with adding postfix .browser e.g. lib/index.browser.js. After that to field browser new property will be added as pointer for bundlers to bundle for the browser, instead of the field module: { \"browser\": { ..., \"./index.es.js\": \"./index.browser.js\" } } Copy Specification for the field browser ES2019 code standard is generated as it is expected that bundle from \"browser\" field will be resolved by bundler with configured transpilation through babel for packages inside node_modules written in modern JS to the code according to the browserslist config. When building our package in the app with webpack with option target: 'web' bundle from field browser will be prioritized over field module. "},{"title":"Copy static assets​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#copy-static-assets","content":"For every build, all of the non JS/TS/JSON files (e.g. CSS, fonts, images) are copied to the output bundle preserving their relative paths (e.g. src/css/style.css -> lib/css/style.css). You can disable such copying by using flag copyStaticAssets: tramvai-build --copyStaticAssets false Copy "},{"title":"Build and copy migrations​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#build-and-copy-migrations","content":"When directory migrations has any code files they are considered as migration files. These files will be compiled to .js and copied to directory __migrations__. "},{"title":"CLI​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#cli","content":""},{"title":"Single build​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#single-build","content":"tramvai-build Copy "},{"title":"Build in watch mode​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#build-in-watch-mode","content":"tramvai-build --watch Copy "},{"title":"Copy static assets​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#copy-static-assets-1","content":"tramvai-copy Copy "},{"title":"Available flags​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#available-flags","content":"tramvai-build --help Copy "},{"title":"JavaScript API​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#javascript-api","content":""},{"title":"TramvaiBuild​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#tramvaibuild","content":"TramvaiBuild is used to configure build process for following usage. import { TramvaiBuild } from '@tramvai/build'; new TramvaiBuild(options); Copy Available options:  export type Options = { sourceDir?: string; watchMode?: boolean; copyStaticAssets?: boolean; forPublish?: boolean; }; Copy  "},{"title":"Build​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#build","content":"Method TramvaiBuild.start builds package either single time or in watch mode depending on configuration of TramvaiBuild: import { TramvaiBuild } from '@tramvai/build'; new TramvaiBuild(options).start(); Copy "},{"title":"Copy static files​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#copy-static-files","content":"Method TramvaiBuild.copy copies static assets to the output directory: import { TramvaiBuild } from '@tramvai/build'; new TramvaiBuild(options).copy(); Copy "},{"title":"How to​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#how-to","content":""},{"title":"Build separate bundle for browsers​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#build-separate-bundle-for-browsers","content":"Let's say we have to entry points. One is for the server - src/server.ts and for the client - src/browser.ts. In this case we should set field browser in package.json the next way: { \"main\": \"lib/server.js\", \"browser\": \"lib/browser.js\" } Copy After build for publication we will get next package.json: { \"main\": \"lib/server.js\", \"browser\": \"lib/browser.js\", \"typings\": \"lib/server.d.ts\", \"module\": \"lib/server.es.js\" } Copy "},{"title":"Replace specific module for browser bundle​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#replace-specific-module-for-browser-bundle","content":"Let's say we have one entry point - src/index.ts and a module src/external.ts we want to replace by src/external.browser.ts. In this case we should set field browser in package.json the next way: { \"main\": \"lib/index.js\", \"browser\": { \"./lib/external.js\": \"./lib/external.browser.js\" } } Copy After build for publication we will get next package.json: { \"main\": \"lib/index.js\", \"browser\": { \"./lib/external.js\": \"./lib/external.browser.js\", \"./lib/index.es.js\": \"./lib/index.browser.js\" }, \"typings\": \"lib/index.d.ts\", \"module\": \"lib/index.es.js\" } Copy "},{"title":"Build all of the packages in monorepo in watch mode​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#build-all-of-the-packages-in-monorepo-in-watch-mode","content":"@TODO + link to @tinkoff/fix-ts-references "},{"title":"Import module only under some circumstances or put module to separate chunk​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#import-module-only-under-some-circumstances-or-put-module-to-separate-chunk","content":"Instead of static imports you can use dynamic import or require. In this case imported module will be build in the separate chunk. Later this chunk can be added by bundler to the generated bundle and if dynamic import was used it will be separate chunk as well after bundlers build, but when using require separate chunk will not be generated. let func = noop; if (process.env.NODE_ENV !== 'production') { func = require('./realFunc').func; } export { func }; Copy "},{"title":"Use JSON in package​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#use-json-in-package","content":"By default in root tsconfig.json option resolveJsonModule is enabled. It is allows to import json-files the same way as usual source code using import, moreover typecheck and tree-shaking will work to json as well when publishing package. To disable ts errors for json imports add to tsconfig.json of the package new entry to field includes: { \"includes\": [\"./src\", \"./src/**/*.json\"] } Copy "},{"title":"Use assets file in the package (e.g. css, svg)​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#use-assets-file-in-the-package-eg-css-svg","content":"These files are not used in bundle or source code and ts will ignore them. For proper package usage additional setup should be done. Add script tramvai-copy to package.json: { \"scripts\": { \"copy-static-assets\": \"tramvai-copy\" } } Copy This script will copy not related files to source code to the output directory. Copying itself happens either on dependencies install in the repository root or on package publishing. As for some reasons output directory might be deleted it may be needed to rerun tramvai-copy command for package. "},{"title":"Use css-modules​","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#use-css-modules","content":"In order to disable typescript errors for css-modules imports add new file typings.d.ts to the src folder with the next content: declare module '*.css' { const value: any; export default value; } Copy To copy css while deb-build change next command: \"watch\": \"tramvai-copy && tsc -w\" Copy Such imports are not compiled. To use it properly you can use @tramvai/cli for building app or any other solution for the css-modules. When building correctness of imports for the css is not checking so check your package manually before publication. "},{"title":"@tramvai/tools-check-versions","type":0,"sectionRef":"#","url":"docs/references/tools/check-versions","content":"","keywords":""},{"title":"Prerelease versions​","type":1,"pageTitle":"@tramvai/tools-check-versions","url":"docs/references/tools/check-versions#prerelease-versions","content":"Prerelease versions often used for the testing. The tool will recognize prerelease versions for the tramvai dependencies and won't count this as mismatched in case all of the prerelease versions are higher than other stable versions. \"dependencies\": { \"@tramvai/core\": \"0.5.0-rc.2\", // release candidate version. The version is higher than other dependencies, so no error will be generated \"@tramvai/module-common\": \"0.4.2\", \"@tramvai/module-router\": \"0.4.2\", \"@tramvai/state\": \"0.4.2\", } Copy "},{"title":"Patterns for the related dependencies​","type":1,"pageTitle":"@tramvai/tools-check-versions","url":"docs/references/tools/check-versions#patterns-for-the-related-dependencies","content":"Packages with the name that matches the following patterns are considered related and for these packages the @tramvai/tools-check-versions will execute checks /^@tramvai\\/core$//^@tramvai\\/module-//^@tramvai-tinkoff\\/module-//^@tramvai\\/tokens-/ "},{"title":"@tramvai/tools-migrate","type":0,"sectionRef":"#","url":"docs/references/tools/migrate","content":"","keywords":""},{"title":"How to​","type":1,"pageTitle":"@tramvai/tools-migrate","url":"docs/references/tools/migrate#how-to","content":""},{"title":"Disable migrations​","type":1,"pageTitle":"@tramvai/tools-migrate","url":"docs/references/tools/migrate#disable-migrations","content":"To disable migration add environment variable SKIP_TRAMVAI_MIGRATIONS. "},{"title":"Add new migration​","type":1,"pageTitle":"@tramvai/tools-migrate","url":"docs/references/tools/migrate#add-new-migration","content":"You can add new migration with command yarn generate:migration. You will need to specify package name for the migration and the migration name itself. Also add to this package's package.json folder with the built migrations to the field files if it wasn't specified before: \"files\": [ \"lib\", \"__migrations__\" ], Copy Migration is a function that accepts special api using which it implements changes to the source code or configs. export interface Api { packageJSON: PackageJSON; // object represented root package.json tramvaiJSON: TramvaiJSON; // object represented tramvai.json transform: (transformer: Transform, pathTransformer?: PathTransformer) => Promise<void>; // function that accepts transform function for `jscodeshift` and transform function for the file renames } Copy Code transformations is done with jscodeshift "},{"title":"How to​","type":1,"pageTitle":"@tramvai/tools-migrate","url":"docs/references/tools/migrate#how-to-1","content":""},{"title":"Write migration​","type":1,"pageTitle":"@tramvai/tools-migrate","url":"docs/references/tools/migrate#write-migration","content":"Transformation​ Rules: Prefer to return null | undefined or original source from the transform function in cases when migration doesn't change source code. Otherwise it will lead to unnecessary fs writing.Prefer to use embedded methods of collections returned by call j(source) to make searches and transforms "},{"title":"@tinkoff-monorepo/depscheck","type":0,"sectionRef":"#","url":"docs/references/tools/monorepo-tools/depscheck","content":"","keywords":""},{"title":"Config parameters for .depscheckrc.yml and cli​","type":1,"pageTitle":"@tinkoff-monorepo/depscheck","url":"docs/references/tools/monorepo-tools/depscheck#config-parameters-for-depscheckrcyml-and-cli","content":"All of the available parameters for the depscheck can be seen in docs. collector --collector Module for collecting packages for depshcheck. Should implement interface @tinkoff-monorepo/pkgs-collector -> CollectorInterface (currently @tinkoff-monorepo/pkgs-collector-pvm is used) [required] [default: {\"name\":\"@tinkoff-monorepo/pkgs-collector-workspaces\"}] --collector-config-strategy [string] [choices: \"about-to-update\", \"update\", \"changed\", \"changed-since-release\", \"affected\", \"released\", \"updated\", \"all\"] [default: [\"affected\"]] depcheck --depcheck-ignore-matches List of module patterns that should not generate error in case they are missing in package.json [array] [default: []] --depcheck-ignore-dirs List of directory names that depscheck should not check [array] [default: []] --depcheck-skip-missing Disable check for missing dependencies [boolean] [default: false] --depcheck-ignore-bin-package Disable checks in bin files for project [boolean] [default: false] Options: --version Show version number [boolean] --config Path to the config (by default cosmiconfig is used) [string] --fix Enables fix error mode. Currently only fixes unused dependency errors[boolean] [default: false] --ignore-patterns List of file patterns that should be ignored for checks on missing deps [array] [default: []] --ignore-peer-dependencies List of module patterns from peerDependencies that should not generate error when dependency is missing [array] [default: []] --ignore-unused List of module patterns that should not generate error when dependency is not used [array] [default: []] -h Show help [boolean] Copy "},{"title":"Config example​","type":1,"pageTitle":"@tinkoff-monorepo/depscheck","url":"docs/references/tools/monorepo-tools/depscheck#config-example","content":"ignore-patterns: ['**/*.spec.{ts,tsx}', '**/*.test.{ts,tsx}', '**/dynamic-components/*/shared/externals.{js,ts}'] depcheck-ignore-dirs: ['__integration__', 'examples', '__tests__'] depcheck-ignore-matches: ['@platform/cli', '@tramvai/tools-migrate'] Copy "},{"title":"@tinkoff-monorepo/fix-ts-references","type":0,"sectionRef":"#","url":"docs/references/tools/monorepo-tools/fix-ts-references","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"@tinkoff-monorepo/fix-ts-references","url":"docs/references/tools/monorepo-tools/fix-ts-references#install","content":"yarn add fix-ts-references Copy "},{"title":"Usage​","type":1,"pageTitle":"@tinkoff-monorepo/fix-ts-references","url":"docs/references/tools/monorepo-tools/fix-ts-references#usage","content":"npx fix-ts-references --fix Copy Script will do next: With flag --fix: Remove references from references list for package if dependency has been removed from package.jsonAdd new references to references list for package if dependency has been added to package.jsonSetting tsconfig.compilerOptions.rootDir=./src if it is not setRemove reference from project reference solution if package has been removed from repositoryAdd reference to project reference solution if package has been added to the repository Without flag --fix will just show list of errors "},{"title":"@tinkoff-monorepo/pkgs-collector-dir","type":0,"sectionRef":"#","url":"docs/references/tools/monorepo-tools/pkgs-collector-dir","content":"","keywords":""},{"title":"Configuration​","type":1,"pageTitle":"@tinkoff-monorepo/pkgs-collector-dir","url":"docs/references/tools/monorepo-tools/pkgs-collector-dir#configuration","content":""},{"title":"pkgDirs​","type":1,"pageTitle":"@tinkoff-monorepo/pkgs-collector-dir","url":"docs/references/tools/monorepo-tools/pkgs-collector-dir#pkgdirs","content":"List of the path patterns to packages in glob format "},{"title":"@tinkoff-monorepo/pkgs-collector-workspaces","type":0,"sectionRef":"#","url":"docs/references/tools/monorepo-tools/pkgs-collector-workspaces","content":"@tinkoff-monorepo/pkgs-collector-workspaces Get all of the packages defined in package.json -> workspaces","keywords":""},{"title":"createApp","type":0,"sectionRef":"#","url":"docs/references/tramvai/create-app","content":"","keywords":""},{"title":"createApp({ modules, bundles, providers })​","type":1,"pageTitle":"createApp","url":"docs/references/tramvai/create-app#createapp-modules-bundles-providers-","content":"modules - array with used modules in the applicationbundles - object with used bundles with data in the application. The key is the bundle identifier, the value is Promise which returns the bundleproviders - an array with application providers, which will be added last in the DI (after module providers) and thus it will be possible to overwrite the implementation of the tokensactions - array with global actions, which will be registered for all bundles and pages "},{"title":"Usage​","type":1,"pageTitle":"createApp","url":"docs/references/tramvai/create-app#usage","content":"import { createApp, provide } from '@tramvai/core'; import { RouterModule } from '@tramvai/module-router'; import { RenderModule } from '@tramvai/module-render'; import { ServerModule } from '@tramvai/module-server'; createApp({ name: 'my-awesome-app', modules: [RouterModule, RenderModule, ServerModule], providers: [ provide({ provide: 'options', useValue: {}, }), ], bundles: { mainDefault: () => import(/* webpackChunkName: \"mainDefault\" */ './bundles/mainDefault'), }, actions: [loadDepositConfig], }); Copy After calling createApp, СommandLineRunner is started which performs the chain of actions necessary to initialize the application. "},{"title":"createAction","type":0,"sectionRef":"#","url":"docs/references/tramvai/create-action","content":"","keywords":""},{"title":"createAction({ name, fn, deps, conditions })​","type":1,"pageTitle":"createAction","url":"docs/references/tramvai/create-action#createaction-name-fn-deps-conditions-","content":"name - The name of the action, a unique identifier is expectedfn(context, payload, deps) - Implementation of the action, this function will be called when the action is used, maybe async context - ConsumerContextpayload - data passed to actiondeps - provider instances from deps deps - List of providers that are needed for the action to workconditions - List of restrictions for the execution of the action "},{"title":"Usage example​","type":1,"pageTitle":"createAction","url":"docs/references/tramvai/create-action#usage-example","content":"import { createAction } from '@tramvai/core'; createAction({ name: 'action log error', fn: (context, payload, deps) => { deps.logger.error('ERROR'); }, deps: { logger: 'logger', }, conditions: { requiredCoreRoles: ['god'], }, }); Copy "},{"title":"createBundle","type":0,"sectionRef":"#","url":"docs/references/tramvai/create-bundle","content":"","keywords":""},{"title":"Properties BundleOptions​","type":1,"pageTitle":"createBundle","url":"docs/references/tramvai/create-bundle#properties-bundleoptions","content":"name - Name of the bundle. The value will be used as a bundle identifier.components: {} - An object with registered components for the bundle, which you can use in application routespresets?: [] - A list of additional properties for the current bundle. This list is merged with the current properties. Needed to extract common parts, e.g. a set with actions and components for authorization. Reference - babel and eslint presetsactions?: [] - List of actions that will be registered globally for the bundlereducers?: [] - List of reducers, which must be registered with the loading of the bundle "},{"title":"Usage​","type":1,"pageTitle":"createBundle","url":"docs/references/tramvai/create-bundle#usage","content":"import { createBundle } from '@tramvai/core'; import { lazy } from '@tramvai/react'; createBundle({ name: 'app/bundle', presets: [commonPreset], components: { 'app/pages/MainPage': lazy(() => import('../pages/MainPage')), 'app/pages/SecondPage': lazy(() => import('../pages/SecondPage')), }, actions: [fooAction, barAction], reducers: [bazReducer], }); Copy "},{"title":"module","type":0,"sectionRef":"#","url":"docs/references/tramvai/module","content":"","keywords":""},{"title":"@Module({ providers, deps, imports })(class)​","type":1,"pageTitle":"module","url":"docs/references/tramvai/module#module-providers-deps-imports-class","content":"providers - Providers, which will be added to the root DI container and become available in other modulesdeps - List of dependencies from the DI container, necessary to initialize the moduleimports - A list of modules from which providers will be obtained and added to the DI. Allows you to create modules that combine many other modules "},{"title":"Usage​","type":1,"pageTitle":"module","url":"docs/references/tramvai/module#usage","content":"import { Module, provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: 'token', useValue: 'value-in-token', }), ], deps: { logger: 'logger', }, imports: [ModuleLogger], }) class ModulePubSub { constructor({ logger }) { logger.info('Module create'); } } Copy "},{"title":"Add new page","type":0,"sectionRef":"#","url":"docs/tutorials/pokedex-app/add-page","content":"Add new page tramvai supports file-system based routing. Detailed documentation is available in File-System Pages section. In this tutorial we will use the automatic way of generating new routes in the application, for which you only need to create a react page component, following the naming conventions. info In addition to automatic routes generation, there are several more flexible options for adding pages to the application, but requiring more manual work. In this tutorial we use the simplest and most convenient option. Let's take a more detailed look at routing, taking the main page of our Pokedex - the page with the list of pokemon - as an example. The page available on the url http://localhost:3000/ is located in the component routes/index.tsx. By default, all react components in the routes folder are interpreted as application routes, and a / route will be generated based on the component named routes/index.tsx. ⌛ Replace the contents of the home page component: routes/index.tsx import React from 'react'; export const PokemonList = () => { return <>Hi! This is PokemonList component :)</>; }; export default PokemonList; Copy info You need to use default export to be able to extract the page component into a separate chunk, and load it by demand Module @tramvai/module-router is responsible for routing and automatically adding file-system based routes to the application. Our PokemonList page is now registered in the app, and it will be automatically rendered on the / route, and available on http://localhost:3000/! Next lesson","keywords":""},{"title":"Create HTTP client","type":0,"sectionRef":"#","url":"docs/tutorials/pokedex-app/create-http-client","content":"Create HTTP client So far we are developing a very boring application. To display information about pokemon in our Pokedex, we need to get data from the pokeapi API. In this lesson we will learn how to create API clients and work with the Dependency Injection container. info Inversion of Control, and Dependency Injection (DI) are hard enough concepts to understand if you're dealing with them for the first time. But using DI makes our applications incredibly flexible, extensible and modular. The DI in tramvai is inspired by the dependency injection system in Angular. Module @tramvai/module-http-client provides a factory for creating HTTP clients. Important point! tramvai is built on the principle of dependenciy injection, so the library does not export the factory directly, but adds it to the DI container of the application by a special token as a key. The DI allows you to construct the application from modules as if they were separate LEGO blocks. ⌛ Install the library @tramvai/module-http-client: tramvai add @tramvai/module-http-client Copy ⌛ Connect @tramvai/module-http-client into the application: index.ts import { HttpClientModule } from '@tramvai/module-http-client'; createApp({ name: 'pokedex', modules: [ ...modules, HttpClientModule, ], providers: [...providers], actions: [...actions], bundles: {...bundles}, }); Copy Now we can create an API client specifically for pokeapi, let's make it a separate tramvai module right away to demonstrate module and DI capabilities. ⌛ Create a file shared/api/index.ts with an empty module: shared/api/index.ts import { Module } from '@tramvai/core'; @Module({ providers: [], }) export class PokeApiModule {} Copy It is recommended to add base urls for different APIs to application env variables via DI - this is useful for testing and mocking, and is consistent with 12-factor application. ⌛ Add support for the new env variable in PokeApiModule with the ENV_USED_TOKEN token: shared/api/index.ts import { Module, provide } from '@tramvai/core'; import { ENV_USED_TOKEN } from '@tramvai/module-common'; @Module({ providers: [ provide({ provide: ENV_USED_TOKEN, multi: true, useValue: [ { key: 'POKEAPI_BASE_URL', optional: true, // default value value: 'https://pokeapi.co/api/v2/', }, ], }), ] }) export class PokeApiModule {} Copy In value property we immediately added a default value. This value can be overridden in the env.development.js file when developing locally, or via environment variables when running the tramvai application on the server. To add a new provider to the DI, in this case a new HTTP client, you need two things: Create a token with the interface of the new HTTP client, with HttpClient as the interfaceCreate provider with the implementation of this token, using the factory HTTP_CLIENT_FACTORY ⌛ Create a token for the new HTTP client: shared/api/index.ts import { Module, provide, createToken } from '@tramvai/core'; import { ENV_USED_TOKEN } from '@tramvai/module-common'; import { HttpClient } from '@tramvai/module-http-client'; export const POKEAPI_HTTP_CLIENT = createToken<HttpClient>( 'pokeapi HTTP client' ); @Module({ providers: [ provide({ provide: ENV_USED_TOKEN, multi: true, useValue: [ { key: 'POKEAPI_BASE_URL', optional: true, value: 'https://pokeapi.co/api/v2/', }, ], }), ] }) export class PokeApiModule {} Copy The POKEAPI_HTTP_CLIENT token can be used simultaneously as a key in the DI, and as an interface, with typeof - typeof POKEAPI_HTTP_CLIENT ⌛ Create a provider with an implementation of the POKEAPI_HTTP_CLIENT token: shared/api/index.ts import { Module, provide, createToken } from '@tramvai/core'; import { ENV_USED_TOKEN, ENV_MANAGER_TOKEN } from '@tramvai/module-common'; import { HttpClient, HTTP_CLIENT_FACTORY } from '@tramvai/module-http-client'; export const POKEAPI_HTTP_CLIENT = createToken<HttpClient>('pokeapi HTTP client'); @Module({ providers: [ provide({ provide: POKEAPI_HTTP_CLIENT, // what the useFactory call will return will be written to the DI, // and the dependency types will be derived automatically from the deps useFactory: ({ factory, envManager }) => { return factory({ name: 'pokeapi', // используем базовый урл pokeapi из env переменной baseUrl: envManager.get('POKEAPI_BASE_URL'), }); }, // all dependencies from deps will be taken from DI and passed to useFactory deps: { factory: HTTP_CLIENT_FACTORY, envManager: ENV_MANAGER_TOKEN, }, }), provide({ provide: ENV_USED_TOKEN, multi: true, useValue: [ { key: 'POKEAPI_BASE_URL', optional: true, value: 'https://pokeapi.co/api/v2/', }, ], }), ] }) export class PokeApiModule {} Copy tip A unique instance of POKEAPI_HTTP_CLIENT will be created for each user request to the application, allowing you to centralized add user data to the request parameters, for example you can take the User-Agent of the user and add it to the headers of all API requests. In doing so, all these POKEAPI_HTTP_CLIENT instances will have a shared in-memory cache. This cache can be disabled, for example for integration tests, with the env variable HTTP_CLIENT_CACHE_DISABLED=true. ⌛ Connect PokeApiModule into the application: index.ts import { HttpClientModule } from '@tramvai/module-http-client'; import { PokeApiModule } from '~shared/api'; createApp({ name: 'pokedex', modules: [ ...modules, HttpClientModule, PokeApiModule, ], providers: [...providers], actions: [...actions], bundles: {...bundles}, }); Copy Now we have a ready HTTP client that can be used in components, actions and other providers! Next lesson","keywords":""},{"title":"Page with dynamic parameters","type":0,"sectionRef":"#","url":"docs/tutorials/pokedex-app/dynamic-page","content":"Page with dynamic parameters In this tutorial, we will create a page with detailed information about the pokemon, available at the url /pokemon/:name. The pokeapi gives us information about the pokemon's elements, and its basic parameters, and we will try to display this information. To create a url with dynamic parameters, the dynamic part of the path to the page component must be in square brackets, e.g. for the url /pokemon/:name you have to create a component at the path routes/pokemon/[name]/index.tsx. ⌛ Create empty page component: routes/pokemon/[name]/index.tsx import React from 'react'; export const PokemonView = () => { return <>Hi! This is PokemonView component :)</>; }; export default PokemonView; Copy After that, you can click on any of the pokemon on the homepage http://localhost:3000/ and after going to http://localhost:3000/pokemon/bulbasaur/ you will see the PokemonView component. It's time to download more pokemon information! The service PAGE_SERVICE_TOKEN will be used to get the dynamic parameters of the current route. ⌛ Add a new action to the pokemon entity to load data using dynamic parameters from the route: entities/pokemon/model.ts import { PAGE_SERVICE_TOKEN } from '@tramvai/tokens-router'; export const fetchPokemonAction = createAction({ name: 'fetchPokemon', fn: async (context, payload, deps) => { // access to the `:name` parameter of the current route via PAGE_SERVICE_TOKEN const { name } = deps.pageService.getCurrentRoute().params; // loading information about the pokemon const pokemonResponse = await deps.pokeapiHttpClient.get<Pokemon>(`/pokemon/${name}`); // save information about the pokemon in the store context.dispatch(pokemonLoadedEvent(pokemonResponse.payload)); }, deps: { pokeapiHttpClient: POKEAPI_HTTP_CLIENT, pageService: PAGE_SERVICE_TOKEN, }, conditions: { // disable caching of the action, since it must be executed again for different name values always: true, }, }); Copy tip You can read more about the need to add an always condition to an action that depends on page parameters in Action documentation ⌛ Connect action to a page: pages/pokemon/index.tsx import React from 'react'; import { fetchPokemonAction } from '~entities/pokemon'; export const PokemonView = () => { return <>Hi! This is PokemonView component :)</>; }; PokemonView.actions = [fetchPokemonAction]; export default PokemonView; Copy Before render Pokemon data, it is worth extending our Pokemon interface. ⌛ Complete the Pokemon interface: entities/pokemon/model.ts export type Pokemon = { id: number; name: string; stats: PokemonStat[]; types: PokemonType[]; }; export type PokemonStat = { // characteristic value base_stat: number; // characteristic name stat: { name: string }; }; export type PokemonType = { // element type type: { name: string }; }; Copy To get PAGE_SERVICE_TOKEN from the DI in the component, we'll use the useDi hook. ⌛ Add code to get information about the pokemon in PokemonView: pages/pokemon/index.tsx import React from 'react'; import { useStoreSelector } from '@tramvai/state'; import { useDi } from '@tramvai/react'; import { PAGE_SERVICE_TOKEN } from '@tramvai/tokens-router'; import { fetchPokemonAction } from '~entities/pokemon'; export const PokemonView = () => { // get PAGE_SERVICE_TOKEN from DI const pageService = useDi(PAGE_SERVICE_TOKEN); // access to the `:name` parameter of the current route via PAGE_SERVICE_TOKEN const { name } = pageService.getCurrentRoute().params; // get information about a specific pokemon const pokemon = useStoreSelector(PokemonsStore, (pokemons) => pokemons[name]); return <>Hi! This is PokemonView component :)</>; } PokemonView.actions = [fetchPokemonAction]; export default PokemonView; Copy ⌛ And render all the data on the page: pages/pokemon/index.tsx import React from 'react'; import { useStoreSelector } from '@tramvai/state'; import { useDi } from '@tramvai/react'; import { Link } from '@tramvai/module-router'; import { PAGE_SERVICE_TOKEN } from '@tramvai/tokens-router'; import type { Pokemon, PokemonStat } from '~entities/pokemon'; import { fetchPokemonAction, PokemonsStore } from '~entities/pokemon'; // utility to search for characteristics, will allow us to draw only some const findStatByName = ( pokemon: Pokemon, statKey: string ): PokemonStat | undefined => { return pokemon.stats.find((stat) => statKey === stat.stat.name); }; export const PokemonView = () => { const pageService = useDi(PAGE_SERVICE_TOKEN); const { name } = pageService.getCurrentRoute().params; const pokemon = useStoreSelector(PokemonsStore, (pokemons) => pokemons[name]); // If there is no information about the pokemon, consider it to be loading if (!pokemon) { return <div>Loading...</div>; } const hpStat = findStatByName(pokemon, 'hp'); const attackStat = findStatByName(pokemon, 'attack'); const defenseStat = findStatByName(pokemon, 'defense'); const speedStat = findStatByName(pokemon, 'speed'); return ( <div> <div> <Link url=\"/\">Return to list</Link> </div> <img alt={pokemon.name} width={200} height={200} src={`https://img.pokemondb.net/artwork/large/${pokemon.name}.jpg`} /> <h2>{pokemon.name}</h2> <div> <p>Stats</p> <ul> {hpStat && <li>HP: {hpStat.base_stat}</li>} {attackStat && <li>Attack: {attackStat.base_stat}</li>} {defenseStat && <li>Defense: {defenseStat.base_stat}</li>} {speedStat && <li>Speed: {speedStat.base_stat}</li>} </ul> </div> <div> <p>Types</p> <ul> {pokemon.types.map((type) => { const typeKey = type.type.name; return ( <li key={typeKey} data-type={typeKey}> {typeKey} </li> ); })} </ul> </div> </div> ); } PokemonView.actions = [fetchPokemonAction]; export default PokemonView; Copy Done! Now you can go to the http://localhost:3000/pokemon/bulbasaur/ page, where you will find detailed information about this wonderful creature :) Next lesson","keywords":""},{"title":"Create application","type":0,"sectionRef":"#","url":"docs/tutorials/pokedex-app/new-app","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Create application","url":"docs/tutorials/pokedex-app/new-app#introduction","content":"In this tutorial we will create a tramvai application using the main features of the framework. For interactivity we will use the wonderful public API - pokeapi as a backend. And we will create a real Pokedex! "},{"title":"Creating a new application​","type":1,"pageTitle":"Create application","url":"docs/tutorials/pokedex-app/new-app#creating-a-new-application","content":"For development, build and code generation there is a special CLI @tramvai/cli ⌛ Install @tramvai/cli globally: npmYarn npm install @tramvai/cli -g Copy After installation, the tramvai command will be available in the terminal, you can check the functionality and display a list of basic commands with the command tramvai --help. ⌛ Generate a template for the new application, name it pokedex: tramvai new pokedex Copy During the execution of the command you will need to select a base template, a package manager and a test framework. The command will create a new pokedex directory, and generate an application skeleton in it, then install the dependencies. ⌛ Go to the application folder, and run application in development mode: cd pokedex && npm start Copy The npm start under the hood will execute the tramvai start pokedex command, which will build the server and client code of the application, and start the server at http://localhost:3000/ note Most tramvai commands run automatic migrations and tramvai libraries version checking in the application, so do not be scared of unexpected logs after running npm start. Of course, migrations and version checks are not necessary for a freshly created application, but these actions may be useful for future upgrades. ⌛ Go to http://localhost:3000/ After loading, you will see a welcome page with the header Tramvai 🥳 "},{"title":"Application structure​","type":1,"pageTitle":"Create application","url":"docs/tutorials/pokedex-app/new-app#application-structure","content":"A detailed overview of the application structure can be found in Project structure and in the README.md file of our new application. We recommend using feature-sliced methodology to structure the code, which may be overkill for small demonstration applications, but will have a good effect on the structure of the application when it is further developed. Next lesson "},{"title":"Fetch data","type":0,"sectionRef":"#","url":"docs/tutorials/pokedex-app/fetch-data","content":"Fetch data In this lesson we will learn how to fetch data to the pages of our application by using the new HTTP client. Actions - the core mechanism for loading data in tramvai applications. You can add any number of actions at the level of the whole application, bundle and specific page. When loading a page, all these actions will be executed in parallel. Actions that won't be executed in 500ms on the server will be automatically executed on the client. Thanks to this, the minimal possible response time from the server is achieved. info The limit of 500ms is set in the ActionModule, and we do not recommend increasing this number. But if long responses from your API are the expected behavior, you can overwrite this value via the limitActionGlobalTimeRun string token. The data from the actions are not passed to the page component props. The standard pattern for loading data is to create a special reducer to store the data, and dispatch events to fill that reducer in the action. tip The following code is very similar to boilerplate code with redux and redux-thunk. If you don't need to save data in global store, you can use integration with react-query instead of actions and reducers. This will drastically reduce the amount of code, but also make our application less flexible. The main page of our Pokedex is the pokemon list, so we will work with the Pokemon entity, following the feature-sliced methodology. Let's add a new entityentities/couter to our application. ⌛ First, create a folder called entities/pokemon. ⌛ Next, create a model of our new entity with basic interfaces: entities/pokemon/model.ts // here we will gradually describe the interface that the API returns to us export type Pokemon = { id: number; name: string; }; // our reducer state interface export type PokemonsState = Record<string, Pokemon>; const initialState: PokemonsState = {}; Copy ⌛ Add events to update the reducer: entities/pokemon/model.ts import { createEvent } from '@tramvai/state'; export type Pokemon = { id: number; name: string; }; export type PokemonsState = Record<string, Pokemon>; const initialState: PokemonsState = {}; // event of successful download of the pokemon list export const pokemonListLoadedEvent = createEvent<Pokemon[]>('pokemonListLoaded'); // event of a successful download of information about a particular pokemon export const pokemonLoadedEvent = createEvent<Pokemon>('pokemonLoaded'); Copy ⌛ Then add an action to fetch the data, using our new HTTP client: entities/pokemon/model.ts import { createEvent } from '@tramvai/state'; import { createAction } from '@tramvai/core'; import { POKEAPI_HTTP_CLIENT } from '~shared/api'; export type Pokemon = { name: string; }; export type PokemonsState = Record<string, Pokemon>; const initialState: PokemonsState = {}; export const pokemonListLoadedEvent = createEvent<Pokemon[]>('pokemonListLoaded'); export const pokemonLoadedEvent = createEvent<Pokemon>('pokemonLoaded'); export const fetchPokemonListAction = createAction({ name: 'fetchPokemonList', fn: async (context, payload, deps) => { const limit = 10; const offset = 0; // upload a list of the names of the first 10 pokemon https://pokeapi.co/api/v2/pokemon/?limit=10&offset=0 const pokemonsNamesResponse = await deps.pokeapiHttpClient.get<{ results: { name: string }[] }>( '/pokemon', { query: { limit, offset } } ); const pokemonsNames = pokemonsNamesResponse.payload.results; // download detailed information about each pokemon in parallel https://pokeapi.co/api/v2/pokemon/bulbasaur/ const pokemonList = await Promise.all( pokemonsNames.map(async (name) => { const pokemonResponse = await deps.pokeapiHttpClient.get<Pokemon>(`/pokemon/${name}`); return pokemonResponse.payload; }) ); // save the final list to the reducer context.dispatch(pokemonListLoadedEvent(pokemonList)); }, deps: { pokeapiHttpClient: POKEAPI_HTTP_CLIENT, }, }); Copy ⌛ And describe the reducer itself: entities/pokemon/model.ts import { createEvent, createReducer } from '@tramvai/state'; import { createAction } from '@tramvai/core'; export type Pokemon = { id: number; name: string; }; export type PokemonsState = Record<string, Pokemon>; const initialState: PokemonsState = {}; export const pokemonListLoadedEvent = createEvent<Pokemon[]>('pokemonListLoaded'); export const pokemonLoadedEvent = createEvent<Pokemon>('pokemonLoaded'); export const fetchPokemonListAction = createAction({ name: 'fetchPokemonList', fn: async (context, payload, deps) => { const limit = 10; const offset = 0; const pokemonsNamesResponse = await deps.pokeapiHttpClient.get<{ results: { name: string }[] }>( '/pokemon', { query: { limit, offset } } ); const pokemonsNames = pokemonsNamesResponse.payload.results; const pokemonList = await Promise.all( pokemonsNames.map(async (name) => { const pokemonResponse = await deps.pokeapiHttpClient.get<Pokemon>(`/pokemon/${name}`); return pokemonResponse.payload; }) ); context.dispatch(pokemonListLoadedEvent(pokemonList)); }, deps: { pokeapiHttpClient: POKEAPI_HTTP_CLIENT, }, }); export const PokemonsStore = createReducer('pokemons', initialState) .on(pokemonListLoadedEvent, (state, pokemonList) => { return pokemonList.reduce((nextState, pokemon) => { return { ...nextState, [pokemon.name]: { ...nextState[pokemon.name], ...pokemon, }, }; }, state); }) .on(pokemonLoadedEvent, (state, pokemon) => { return { ...state, [pokemon.name]: { ...state[pokemon.name], ...pokemon, }, }; }); Copy Now we have a place to store data, an action to load it, and good typing at each level. ⌛ Create a ui entity, have this component give the preview and name of the pokemon: entities/pokemon/ui.tsx import React from 'react'; import { useStoreSelector } from '@tramvai/state'; import { Link } from '@tramvai/module-router'; import { PokemonsStore } from './model'; export const PokemonPreview = ({ name }: { name: string }) => { // get information about a specific pokemon const pokemon = useStoreSelector(PokemonsStore, (pokemons) => pokemons[name]); // in the next lesson we will add a page with detailed information about the pokemon to Pokedex const pokemonUrl = `/pokemon/${pokemon.name}`; return ( <div> <Link url={pokemonUrl}> <img alt={pokemon.name} src={`https://img.pokemondb.net/artwork/large/${pokemon.name}.jpg`} /> <p>{pokemon.name}</p> </Link> </div> ); }; Copy Our new PokemonPreview component will only update when this particular pokemon changes in the reducer. ⌛ Create an entry point into the Pokemon entity: entities/pokemon/index.ts import { Module } from '@tramvai/core'; import { COMBINE_REDUCERS } from '@tramvai/tokens-common'; import { PokemonsStore } from './model'; export * from './model'; export * from './ui'; @Module({ providers: [ // register reducer in the application { provide: COMBINE_REDUCERS, multi: true, useValue: PokemonsStore, }, ], }) export class PokemonModule {} Copy ⌛ Connect PokemonModule in the application: index.ts import { PokemonModule } from '~entities/pokemon'; createApp({ name: 'pokedex', modules: [ ...modules, PokemonModule, ], providers: [...providers], actions: [...actions], bundles: {...bundles}, }); Copy Now we have the logic and interface for fetching the data and rendering it on the Pokedex homepage ready! The final touch is left, the integration of the entity into the page component. ⌛ Add an action to load the list of pokemon on the page: pages/pokemons-list/index.tsx import React from 'react'; import { fetchPokemonListAction } from '~entities/pokemon'; export const PokemonList = () => { return ( <> Hi! This is PokemonList component :) </> ) } PokemonList.actions = [fetchPokemonListAction]; export default PokemonList; Copy ⌛ And render pokemon list: pages/pokemons-list/index.tsx import React from 'react'; import { useStore } from '@tramvai/state'; import { fetchPokemonListAction, PokemonPreview, PokemonsStore, } from '~entities/pokemon'; export const PokemonList = () => { const pokemons = useStore(PokemonsStore); const pokemonList = Object.values(pokemons); // If the list is empty, consider that it is still loading if (pokemonList.length === 0) { return <div>Loading...</div>; } return ( <div> <ul> {pokemonList.map((pokemon) => ( <li key={pokemon.name}> <PokemonPreview name={pokemon.name} /> </li> ))} </ul> </div> ); }; PokemonList.actions = [fetchPokemonListAction]; export default PokemonList; Copy Don't forget to visit our Pokedex http://localhost:3000/! Now you'll be greeted by ten of the cutest creatures on the page ❤️ caution If the UNABLE_TO_GET_ISSUER_CERT_LOCALLY error occurs on the server when querying pokeapi, try running the application with the environment variable NODE_TLS_REJECT_UNAUTHORIZED: NODE_TLS_REJECT_UNAUTHORIZED=0 tramvai start pokedex Copy Next lesson","keywords":""},{"title":"Styling","type":0,"sectionRef":"#","url":"docs/tutorials/pokedex-app/styling","content":"","keywords":""},{"title":"Conclusion​","type":1,"pageTitle":"Styling","url":"docs/tutorials/pokedex-app/styling#conclusion","content":"That's all for now! We learned how to create a new tramvai application, work with depencency injection, routing and global state, load data and style the application. You can familiarize yourself with framework features like API routing, try integration with react-query, integrate our awesome test utilities for unit and e2e testing into the application. "}]