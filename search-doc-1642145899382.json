[{"title":"Бандл","type":0,"sectionRef":"#","url":"docs/concepts/bundle","content":"","keywords":""},{"title":"Динамический импорт бандла","type":1,"pageTitle":"Бандл","url":"docs/concepts/bundle#динамический-импорт-бандла","content":"Для выделения ненужного на каждой странице кода, каждый бандл, передаваемый в createApp, должен иметь сигнатуру () => Promise<{ default: Bundle }>. Весь код, общий с подключаемыми в приложение модулями, останется в основном чанке приложения, и многие бандлы будут весить всего несколько КБ, но как только один из компонентов бандла подключит тяжелую зависимость, например библиотеку с формами, она полностью попадет в соответствующий бандл. Рекомендуется использовать dynamic import с магическим комментарием webpackChunkName для указания имени нового чанка, например: () => import(/* webpackChunkName: \"mainDefault\" */ './bundles/mainDefault') Скопировать "},{"title":"Бандл по умолчанию","type":1,"pageTitle":"Бандл","url":"docs/concepts/bundle#бандл-по-умолчанию","content":"Каждый роут должен иметь свойства bundle с названием бандла, pageComponent и layoutComponent с названиями соответствующих компонентов. По умолчанию задаются следующие значения: bundle: 'mainDefault'pageComponent: 'pageDefault'layoutComponent: 'layoutDefault' При использовании стандартного RenderModule, подключается LayoutModule, который провайдит layoutDefault и отдельный механизм для расширения и переопределения layout в приложении, поэтому нет необходимости добавлять свойство layoutDefault в список components бандла. Для создания бандла, который будет запускаться на всех страницах приложения, у которых отсутствуют специфичные настройки роутов, достаточно двух шагов: Создаем бандл# import { createBundle } from '@tramvai/core';import { MainPage } from './pages/MainPage'; export default createBundle({ name: 'mainDefault', components: { pageDefault: MainPage, },}); Скопировать Подключаем бандл# import { createApp } from '@tramvai/core'; createApp({ name: 'myApp', modules: [ // ... ], providers: [ // ... ], bundles: { mainDefault: () => import(/* webpackChunkName: \"mainDefault\" */ './bundles/mainDefault'), },}); Скопировать "},{"title":"Actions chain","type":0,"sectionRef":"#","url":"docs/concepts/command-line-runner","content":"","keywords":""},{"title":"Usage example","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#usage-example","content":"We have registered a new provider that will be called when commandLineRunner reaches the commandLineListTokens.generatePage token and the render function is executed: import { provide } from '@tramvai/core';@Module({ providers: [ provide({ provide: commandLineListTokens.generatePage, useFactory: ({ responseManager }) => { return function render() { responseManager.setBody(ReactDOM.renderToString(<App />)); }; }, deps: { responseManager: RESPONSE_MANAGER_TOKEN, }, multi: true, }), ],})export class RenderModule {} Скопировать "},{"title":"Action blocks","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#action-blocks","content":"A number of basic actions are predefined in the tramvai, which are performed at certain stages of the application. Based on these stages, the work of the basic tram modules is built and actions can be added to custom modules. "},{"title":"Initialization (init)","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#initialization-init","content":"When tramvai starts, a chain of actions is launched in which you can initialize asynchronous services (if necessary) and add basic functionality. These actions are performed only once and are not available to providers who need a custom context.  "},{"title":"Handling customer requests","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#handling-customer-requests","content":"For each client, we run a list of actions in which the user context and data are available. For each client, we create our own di context in which the implementations will live only while we process the client's request.  "},{"title":"SPA transitions (spa)","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#spa-transitions-spa","content":"For SPA transitions in the browser, routing triggers a list of actions  "},{"title":"Shutdown (close)","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#shutdown-close","content":"Before exiting the application, this list of actions is launched  "},{"title":"Tokens","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#tokens","content":""},{"title":"init","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#init","content":"Initializing Asynchronous Services For what: If you need to initialize global singletons asynchronously "},{"title":"listen","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#listen","content":"Subscribing to global events by the application For what: If you need to subscribe to global events or a port "},{"title":"customer_start","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#customer_start","content":"The starting token in the client request processing chain. Required to initialize custom asynchronous constructors. It is not advised to do any lengthy asynchronous tasks at this stage, as only synchronous actions are expected. For what: To initialize asynchronous services for each client "},{"title":"resolve_user_deps","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#resolve_user_deps","content":"The main goal of this stage is to find out all the necessary information about the client we are currently processing. Since all actions within one stage are performed in parallel with us, it is at this stage that you can efficiently and quickly request all the necessary information, for example, simultaneously with the request for customer data, you can find out about the status of the customer's authorization, get analytical information about the customer and similar actions. For what: To request any global customer information "},{"title":"resolve_page","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#resolve_page","content":"The main goal of this stage is to find out all the necessary information about the page the client visited. For what: To request information about the page "},{"title":"resolve_page_deps","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#resolve_page_deps","content":"At this stage, we already know about the client, about what this page is. But, we have not requested the necessary data for the page. For example: request resources from the admin panel, get a list of regions, load the necessary page blocks. And all the information that will be needed when generating the page. At this stage, it is not worth doing long asynchronous actions and it is supposed to be cached or moved to resolveUserDeps to achieve the maximum speed of response to clients. At this stage, action is executed and perhaps they will suit you better, as there are many additional functionality For what: To get the information needed to render the page "},{"title":"generate_page","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#generate_page","content":"At this stage, we already know the current route, which client and all actions for the page have already been loaded. And at this stage, according to the information from the previous stages, we generate an html page and give it to the client For what: this is more of an internal stage and should not be used in ordinary cases. Since race condition with application rendering "},{"title":"clear","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#clear","content":"This stage will be called after we have responded to the client, but some modules or libraries need to delete client data For what: The method is needed if you need to perform actions after a successful response to the user "},{"title":"spa_transition","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#spa_transition","content":"Tasks registered at this stage are executed on SPA transitions in the application For what: To update meta information on the current page "},{"title":"close","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#close","content":"Before closing the application, some modules may need to perform special actions, for example, close connections, send data and similar activities. In order not to duplicate the application closure tracking code in each module, this stage was made. For what: If you need to perform actions before closing the application. for example close connections, send logs and so on "},{"title":"Errors in stages","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#errors-in-stages","content":"On the server side, you can intercept errors from commandLineRunner stages by adding express error middleware with a multi token WEB_APP_AFTER_INIT_TOKEN. In this middleware you can change the response status, headers and body, and end the response. For example, exceptions when rendering React components from current page, get into this handler (Error Boundary not working at server-side). Middleware example: { provide: WEB_APP_AFTER_INIT_TOKEN, multi: true, useFactory: (deps) => { return (app) => { app.use((err, req: Request, res: Response, next) => { next(err); }); }; }, deps: {},}, Скопировать "},{"title":"Customization","type":1,"pageTitle":"Actions chain","url":"docs/concepts/command-line-runner#customization","content":"The application can override the standard list of actions, for example, delete unnecessary ones or add new ones. To do this, you need to define a provider in the application or module that will rewrite the base list import { provide } from '@tramvai/core';[ provide({ provide: COMMAND_LINES_TOKEN, scope: 'singleton', useValue: customLines, }),]; Скопировать Caution: do not delete stages, as this may cause some modules to stop working correctly. In this case, the best solution would be to delete the module that is being linked to an unnecessary stage. "},{"title":"Action","type":0,"sectionRef":"#","url":"docs/concepts/action","content":"","keywords":""},{"title":"Example action","type":1,"pageTitle":"Action","url":"docs/concepts/action#example-action","content":"import { createAction } from '@tramvai/core'; // create an actionconst actionFetchData = createAction({ name: 'fetch-data', fn: (context, payload) => fetch(payload.url),}); // execute the actioncontext .executeAction(actionFetchData, { url: 'https://tinkoff.ru' }) .then((data) => context.dispatch(loadData(data))); Скопировать "},{"title":"Global Actions","type":1,"pageTitle":"Action","url":"docs/concepts/action#global-actions","content":"Applications can add global actions in the application that need to be executed before rendering the page, in these actions they usually load the information necessary to display the page, for example, information about deposits. Before rendering the page, the different types of actions are collected into a single list and executed in parallel. In short, an action is global if added via createApp, createBundle, or a static property of a page component, such as PageComponent.actions. By default, global actions are executed once, on the server, and pass the status and result of the action to the client. "},{"title":"Execution Deadline","type":1,"pageTitle":"Action","url":"docs/concepts/action#execution-deadline","content":"Servers must respond quickly, so we must reduce the number of cases when global actions cause a delay in page loading, for example, if an API fails. To do this, there is a time limit on the server for executing global actions, and if this time passes, then waiting for actions ends and these actions must be executed on the client side. "},{"title":"Synchronizing actions between server and client","type":1,"pageTitle":"Action","url":"docs/concepts/action#synchronizing-actions-between-server-and-client","content":"Information about all successfully executed actions will be transferred to the client, which will start the execution of global actions based on this information. At the same time, if an action, for example, fell out of the deadline or fell by mistake, then it will be re-executed on the client side. "},{"title":"Errors in actions","type":1,"pageTitle":"Action","url":"docs/concepts/action#errors-in-actions","content":"By default, errors in actions only logged with event action-execution-error, but they do not stop the page rendering pipeline. The only exceptions are actions that throw NotFoundError or RedirectFoundError errors from @tinkoff/errors library. When new RedirectFoundError({ nextUrl }) is thrown, the page request will be redirected to nextUrl with 301 status (default). When new NotFoundError() is thrown, the page request will have a status of 404 (default), and if your application has not-found route, that route will not be render. "},{"title":"Types of global actions","type":1,"pageTitle":"Action","url":"docs/concepts/action#types-of-global-actions","content":"Application-wide global actions# To register within the application, we must pass an array of actions to createApp, after that all these actions will be executed for each page and any bundles: Connection# createApp({ name: 'myApp', actions: [loadDepositConfig],}); Скопировать You can also register actions with providers: import { ACTIONS_LIST_TOKEN } from '@tramvai/core';import { provide } from '@tramvai/core'; const provider = provide({ provide: ACTIONS_LIST_TOKEN, multi: true, useValue: [loadDepositConfig],}); Скопировать Global actions for the bundle# To register inside a bundle, we must pass to createBundle a list of actions that will then be executed for all pages that are present and used in the bundle. Connection# createBundle({ name: 'bundle', actions: [loadDepositConfig],}); Скопировать Global actions linked to the page# This is the lowest level of adding global actions, for a separate Page component, we can bind a list of actions that need to be performed before rendering the page. Connection# To do this, you need to add a static property to the page of the actions component and pass the list of required actions class PageComponent extends Copmponent { static actions = [loadDepositConfig];} Скопировать "},{"title":"Restrictions","type":1,"pageTitle":"Action","url":"docs/concepts/action#restrictions","content":"Not all actions can be executed under all circumstances, we can have actions that should be executed only on the server, others only in the browser, and having any other restrictions. There is a conditions property to solve this problem: createAction({ name: 'fetch-data', fn: (context, payload) => fetch(payload.url), conditions: { requiredCoreRoles: ['client'], onlyBrowser: true, },}); Скопировать In the example above, we create an action that will be executed only in the browser and only when we have the user role of the main core API equal to client. "},{"title":"Adding new restrictions to the application","type":1,"pageTitle":"Action","url":"docs/concepts/action#adding-new-restrictions-to-the-application","content":"You can implement your own constraints in an application or module. To do this, we must create an object with an interface: interface Condition { key: string; fn(checker: ActionConditionChecker): void;} Скопировать key - restriction identifierfn - a validation function that will be called for each action The function will receive in the argument checker, which has an interface interface ActionConditionChecker { payload: any; parameters: any; type: 'global' | 'local'; conditions: Record<string, any>; forbid(): void; setState(value: any): void; getState(): any; allow(): void;} Скопировать payload - data that was transferred with the actionparameters - parameters that were passed when creating the actionconditions - restrictions for the current actiontype - type of the executed action, can be global or simple execution via executeActionforbid - prohibits the execution of the action. If at least one checker calls this function, the action execution will be stoppedsetState - allows you to write the check data. It is necessary for cases when we need to know with what data it was executed before and whether it needs to be repeated, for example, restrictions on the authorization rolegetState - getting the previously recorded stateallow - tell the action to be executed again. The action will execute unless execution is forbidden via forbid "},{"title":"Example of a constraint","type":1,"pageTitle":"Action","url":"docs/concepts/action#example-of-a-constraint","content":"const isServer = typeof window === 'undefined'; export const onlyServer: ActionCondition = { key: 'onlyServer', fn: (checker) => { if (checker.conditions.onlyServer && !isServer) { checker.forbid(); } },}; Скопировать After connecting, the constraint will look if the action has a onlyServer field in conditions, and if so, it will change the action's behavior "},{"title":"Connecting restrictions to the application","type":1,"pageTitle":"Action","url":"docs/concepts/action#connecting-restrictions-to-the-application","content":"To do this, you need to add the multi provider ACTION_CONDITIONALS and pass a function that will have an interface import { provide } from '@tramvai/core'; const provider = provide({ provide: ACTION_CONDITIONALS, multi: true, useValue: [onlyServer],}); Скопировать "},{"title":"Preset limits available for each action","type":1,"pageTitle":"Action","url":"docs/concepts/action#preset-limits-available-for-each-action","content":"always - the action is executed on the server, then in the browser and on each SPA transition within the applicationonlyBrowser - the action is executed only in the browseronlyServer - the action is executed only on the serverpageBrowser - the global action is executed only in the browserpageServer - the global action is executed only on the serveralways + onlyBrowser - the action is executed in the browser and for each SPA transition within the application "},{"title":"Peculiarities","type":1,"pageTitle":"Action","url":"docs/concepts/action#peculiarities","content":"Keep in mind that actions are cached by default and are only executed once during the life cycle of the application. The following feature follows from this. Let's assume the following situation: we have a page of the concert venue at the url /concertvenue-[objectId] - where objectId is a parameter that corresponds to the concert venue identifier;on this page we have one component ConcertVenuePage and one page action preparePageAction;objectId in the url of the page is used to get data in preparePageAction, as well as to fetch data for rendering the page;we have a concert page /concert on which there are links to concert venues -/concertvenue-1, /concertvenue-2, /concertvenue-1. We can navigate to all these links with a SPA transition;Transitions between pages are client-side (SPA), not server-side; Sequencing: On the concert page we click on /concertvenue-1, the page of the concert venue opens, the page action is performed for the first time.We go back to the SPA concert page by transition.Click on /concertvenue-2.We get to an empty page, since the page action has already been executed, new data has not been requested, and the data selection for drawing the page was made according to ID from url - 2. If you want a page action to be executed every time you visit the page, you need to pass it the appropriate condition: const preparePageAction = creareAction({ name: 'preparePageAction', fn: () => { // ... }, conditions: { // with always: true, the action will always be called and not cached always: true, },}); ConcertVenuePage.actions = [preparePageAction]; Скопировать "},{"title":"Dependency Injection","type":0,"sectionRef":"#","url":"docs/concepts/di","content":"","keywords":""},{"title":"Концепции","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#концепции","content":"Провайдер - Имплементация токена в DIТокены - индетификатор провайдера в DI системе и одновременно его интерфейсКонтейнер - хранилище со всеми провайдерами и их реализациями "},{"title":"Особенности","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#особенности","content":""},{"title":"Динамическая инициализация","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#динамическая-инициализация","content":"Провадйры инициализируются только если в коде прозошло получение инстанса с помощью метода get у di контейнера или если провайдер был указан как deps зависимость у module. В остальных случаях провайдер не будет создан и проинициализирован. Эта особенность позволяем нам регистрировать провайдеры в любой последовательности и заменять реализации. "},{"title":"Замена реализаций","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#замена-реализаций","content":"В некоторых случаях, нам может не подойти базовая реализация функционала и для решения этой проблемы, мы можем переопределить реализацию провайдеров. К примеру нам не подходит текущий логгер из common-module и мы хотим его заменить, для этого нам необходимо закинуть в providers новую реализацию для токена. import { provide } from '@tramvai/core';createApp({ modules: [CommonModule], providers: [ provide({ provide: LOGGER_TOKEN, useValue: console, }), ],}); Скопировать После этого, мы заменим реализацию LOGGER_TOKEN, которая была объявлена в CommonModule, на нативный объект console "},{"title":"Проверка доступности реализации всех зависимостей","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#проверка-доступности-реализации-всех-зависимостей","content":"При инициализации провайдера автоматически проверяется доступность всех зависимостей, если не была найдена зависимость и провайдер не является optional, в development режиме выбрасывается исключение. "},{"title":"Использование DI","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#использование-di","content":""},{"title":"В модулях","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#в-модулях","content":"Передача массива в параметр providers который будут добавлены при инициализации приложения в DI. Подробнее о модулях @Module({ providers: [ // ... ],})export class MyModule {} Скопировать "},{"title":"В createApp","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#в-createapp","content":"Можно передать в createApp массив providers, который будет иметь максимальный приоритет и перепишет реализации интерфейсов модулей и core: createApp({ providers: [ // ... ],}); Скопировать "},{"title":"В экшенах","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#в-экшенах","content":"Для получшения реализаций провайдеров, можно передать объект deps при создании экшена: createAction({ name: 'action', fn: (context, payload, deps) => { deps.logger.error('ERROR'); }, deps: { logger: 'logger', },}); Скопировать "},{"title":"Контейнер","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#контейнер","content":"Контейнер в котором хранится список зарегистрированных провайдеров в приложении, так и инстансы реализаций провайдеров, которые уже были созданы. "},{"title":"Корневой контейнер","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#корневой-контейнер","content":"Глобальный контейнер верхнего уровня, который содержит в себе всех зарегистрированых провайдеров и глобальные синглтоны которые живут все время, пока живет приложение. "},{"title":"Контейнер - потомок","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#контейнер---потомок","content":"Создаваемый для каждого клиента (пользователя, отправившего запрос на сервер) инстанс DI который наследуется от root контейнера. Но позволяет создавать и хранить собственные инстансы классов. Которые могут содержать приватную информацию о клиенте и при этом, эта информация не утечет другим клиентам, например ссылка на актуальный объект Request. Consumer di создается и живет пока мы отвечаем клиенту. Как только мы ответили, consumer di удаляется и очищается вся приватная информация. При этом не нужно делать ручную очистку и удалять di контейнер или его зависимости. Это работа основывается на том, что при ответе клиенту, теряется ссылка на контекст и DI контейнер. После чего GC удалит все из памяти. "},{"title":"Дополнительный материал","type":1,"pageTitle":"Dependency Injection","url":"docs/concepts/di#дополнительный-материал","content":"Видео с рассказом о том, зачем нужен DI и почему его стоит использовать Part 1Part 2Выпуск девшахты который посвещен DI и зачем он нужен https://www.youtube.com/watch?v=3NgWwzwDeTQ "},{"title":"Введение в tramvai","type":0,"sectionRef":"#","url":"docs/concepts/overview","content":"","keywords":""},{"title":"Основные особенности","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#основные-особенности","content":"Модульный подход - можно расширять функционал приложений с помощью модулейUniversal - Работает одинаково хорошо для браузеров и сервераБыстрый - имеет малый вес, не оказывает влияния на общую производительность приложения, максимально распараллеливает действия на сервере "},{"title":"Используемые подходы","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#используемые-подходы","content":" "},{"title":"Модульность","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#модульность","content":"Архитектура tramvai строится на идее, что у нас весь функционал разделен на различные модули и все общение между модулями строится на общих интерфейсах, взаимодействуя через DI. Такая архитектура дает возможность легко добавлять новую функциональность в приложение, и заменять уже существующий функционал. "},{"title":"Стандартизация","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#стандартизация","content":"tramvai дает основу которая позволяет поддерживать и создавать приложения с одинаковой архитектурой для множества команд с возможностью шарить код между проектами, так как tramvai это легковесный слой, который помогает взаимодействовать различными модулям в приложении "},{"title":"Скорость","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#скорость","content":"Ядро tramvai вместе с DI весит 4 кб, всё остальное реализуется через сторонние модули, который расширяют функционал приложения. Это дает возможность делать приложения минимального размера, исключая ненужные фичи. Архитектура и модули разработаны с концепцией performance first для максимальной параллелизации, согласно best practice. "},{"title":"Универсальность","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#универсальность","content":"tramvai это SSR-first фреймворк и учитывает все особенности и проблемы, связанные с сервером, клиентом и взаимодействием между ними: Все модули разрабатываются и для браузера и для сервераИспользуются общие интерфейсыИспользуется цепочка команд на сервере и браузере которая позволяет выполнять действия в определение время жизни приложенияCистема экшенов позволяет одинаково запрашивать данные на сервере и в браузере, используя различные фичи (e.g. повторение в браузере экшена, упавшего на сервере) "},{"title":"Разбиение на внешние библиотеки","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#разбиение-на-внешние-библиотеки","content":"При разработке tramvai стараемся использовать уже готовые решения, либо создавать базовые библиотеки, которые никак не связаны с tramvai и могут использовать в других проектах и фреймворках. "},{"title":"DI с интерфейсом взятым с Nest или Angular DI","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#di-с-интерфейсом-взятым-с-nest-или-angular-di","content":"DI это основа tramvai позволяющая уменьшить связанность кода и разделение функциональности на модули. Внутри tramvai используется библиотека dippy которая реализует DI составляющую. Внутренний интерфейс DI повторяет интерфейс Nest, который позволяет удобно описать зависимости и реализации классов. "},{"title":"Возможность мягкого перехода","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#возможность-мягкого-перехода","content":"На www.tinkoff.ru уже было написано миллион+ строк кода и новое решение не должно было ломать имеющийся код, а также требовать от приложений тяжелого и долгого перехода "},{"title":"Почему был разработан:","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#почему-был-разработан","content":""},{"title":"tramvai","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#tramvai","content":"Зачастую React приложения — это конструктор из разных библиотек, которые были подключены в проект. Это хорошо работает на маленьких масштабах, но плохо работает для больших приложений, где работают 70+ разработчиков, так как в таком подходе легко подключить свое и разойтись кардинально в архитектуре приложений. Эту проблему берет на себя tramvai и стандартизирует и реализует общую архитектуру приложений которую используют все продуктовые команды. На github можно найти не так много open source решений, которые реализуют архитектуру больших приложений. Альтернативы# next.js# Один из самых лучших простых фреймворков для React, которые берет на себя проблему с рендерингом приложений на сервере и роутингом. При этом это легковесный фреймворк который никак не стандартизирует и не решает проблемы с модульностью компонентов. Поэтому большинство кода, который был написан на tramvai пришлось бы написать для next.js и пытаться как-то внедрить, так как в next.js очень ограничена возможность расширения функциональности fusionjs# Похожий фремворк, который развивался и появился в одно и тоже время с tramvai. У fusionjs нет полноценного DI, ограниченная возможность вынесения функциональности в модули и вся архитектура построена на основе middlewares, и присутствуют сложности вокруг зашитых приоритетов плагинов и отсутствия параллелизации действий nest.js# Отличный backend фреймворк который использует схожий DI, но полностью не заточен под SSR. И при использовании его, у нас должно было быть 2 архитектуры, одна для бекенда, другая написанная самим под клиент "},{"title":"dippy","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#dippy","content":"Легковесная DI библиотека с Angular подобным интерфейсом. В открытом доступе нет так много различных вариантов DI которые позволяют разделить реализации классов как базовые общие, так и специфичные для каждого клиента. Альтернативы# inversify# Это самая популярная библиотека для создания DI, при этом: весит 11кб, в сравнении dippy 1.2кбнизкоуровневый API который требует различных врапперов для реализации модульной системы.ts-nest это пример враппера над inversify который имеет слабую поддержку и только враппер содержит примерно столько-же кода как и dippy "},{"title":"state","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#state","content":"Встроенная в tramvai библиотека для управления состоянием почти полностью схожа интерфейсом с Redux, при этом: Позволяет подписывать компоненты только на обновление определенных редьюсеров, решая проблему с перфомансомИмеется много кода, написанного с использованием deprecated версии стейта и нельзя просто перейти на другое решение Альтернативы# redux# Переход на чистый redux не решит проблемы, а только добавит связанные с performance reatom# Очень похожая на state-management новая библиотека, в которой решена проблема с обновлениями и performance. Хороший кандидат, с которого можно взять некоторые фичи. Полный переход сильно дорог из-за кодовой базы effector# Интересная библиотека, которая имеет фокус на client side и не очень подходит для SSR "},{"title":"Concepts","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#concepts","content":""},{"title":"Module","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#module","content":"Основные базовые элементы tramvai архитектуры которые содержат в себе реализацию функциональности. При этом предполагается, что такие модули не будут огромными и будет появляться большое количество разных видов. Документация "},{"title":"DI система","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#di-система","content":"tramvai строится на DI системе которая хранит в себе реализации функциональности и получения реализаций по токенам и ключам. Это позволяет реализовать связи между модулями основываясь только на интерфейсах, при этом имея возможность изменять реализации по необходимости. Документация "},{"title":"CommandLineRunner","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#commandlinerunner","content":"Раннер для списка действий, на которые могут навесить действия модули. Списки действий бывают 2 видов: Инициализация приложенияОбработка запроса для клиента В рамках эти списка действий происходит получение роутов, статуса пользователя, рендеринга страницы и отдачи клиенту html. Документация "},{"title":"Диаграммы","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#диаграммы","content":""},{"title":"Принцип работы на серверной стороне","type":1,"pageTitle":"Введение в tramvai","url":"docs/concepts/overview#принцип-работы-на-серверной-стороне","content":" "},{"title":"Модуль","type":0,"sectionRef":"#","url":"docs/concepts/module","content":"","keywords":""},{"title":"Жизненный цикл модулей","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#жизненный-цикл-модулей","content":""},{"title":"Инициализация приложения","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#инициализация-приложения","content":"При создании приложения происходит обработка всех задекларированных провайдеров, которые попадут в общий DI контейнер. "},{"title":"Обработка запросов клиента","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#обработка-запросов-клиента","content":"Экземпляр модуля создается один раз на сервере (и используется для всех клиентов), после инициализации приложения, и один раз в браузере, после загрузки страницы и инициализации клиентской части. Эти инстансы содержат экземпляры классов, которые были переданы в deps, и будут переданы в конструктор модуля: import { Module } from '@tramvai/core'; @Module({ providers: [], deps: { log: 'log', },})class TestModule { constructor({ log }) { log.info('TestModule created'); }} Скопировать "},{"title":"Пример модуля","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#пример-модуля","content":"Основной функционал модуля находится в списке providers. Каждый провайдер либо добавляет новый функционал, например делает доступным во всех остальных модулях констатное значение New под ключем Token: import { Module, provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: 'Token', useValue: 'New', }), ],})class TestModule {} Скопировать Либо использует токены из других модулей, например добавление нового параметра окружения через токен ENV_USED_TOKEN, который обработает EnvModule: import { Module, provide } from '@tramvai/core';import { ENV_USED_TOKEN } from '@tramvai/module-common'; @Module({ providers: [ provide({ provide: ENV_USED_TOKEN, multi: true, useValue: [ { key: 'ENV_VARIABLE', value: 'New', optional: true, }, ], }), ],})class TestModule {} Скопировать "},{"title":"Импорт в модуле сторонних модулей","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#импорт-в-модуле-сторонних-модулей","content":"Модули могут внутри себя импортировать провайдеры сторонних модулей. Тем самым позволяя строить цепочку взаимосвязанных модулей. Пример кода import { Module } from '@tramvai/core';import { LogModule } from '@tramvai/module-log'; @Module({ providers: [], imports: [LogModule],})class TestModule {} Скопировать В этом случае, при инициализации TestModule, предварительно произойдет инициализация провайдеров из модуля ModuleLogger и вложенных imports, если они присутствуют. "},{"title":"Динамические модули","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#динамические-модули","content":"Конфигурировать модули можно двумя способами, причем оба способа можно использовать одновременно: передача параметров в moduleвозврат параметров в статическом методе forRoot Пример динамического модуля, в котором мы добавим в DI зависимости metaGenerate первым способом и meta-list вторым, причем одна из них зависит от другой: import { Module, provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: 'metaGenerate', useClass: class MetaGenerate {}, deps: { list: 'meta-list', }, }), ],})export class SeoModule { static forRoot({ metaList }: { metaList?: string[] }) { if (metaList) { return { mainModule: SeoModule, providers: [ provide({ provide: 'meta-list', useValue: metaList, }), ], }; } }} Скопировать Статичный метод должен вернуть объект с интерфейсом: type staticModule = { mainModule: Module; // Ссылка на основной модуль, из которого мы вощьмем всю основную информацию providers: Provider[]; // Провайдеры которые будут добавлены в DI}; Скопировать Теперь этот модуль содержит статичный метод forRoot который к стандартному модулю SeoModule добавляет дополнительные providers. Без этой конструкции нам нужно было бы явно прописывать в приложении провайдеры. Все данные, которые были добавлены в SeoModule будут наследованы и расширены. Теперь мы можем в приложении или в других модулях вызвать наш статичный метод. И результат выполнения forRoot будет добавлен в DI import { Module } from '@tramvai/core';import { SeoModule } from './SeoModule';import { metaFromConfig } from './metaFromConfig'; @Module({ imports: [SeoModule.forRoot([metaFromConfig])],})export class ApplicationModule {} Скопировать При этом стоит учитывать, что forRoot конструкция должна только упрощать использование модуля и мы должны так же поддерживать работоспособность модуля через обычное конфигурирование providers "},{"title":"Рекомендации для модулей","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#рекомендации-для-модулей","content":""},{"title":"Низкая связанность","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#низкая-связанность","content":"Желательно модули строить так, что бы они не зависели прямо от других модулей. Связанность только должна происходить на основе интерфейсов и с возможностью замены. Иначе нельзя будет просто заменить модули и произвести рефакторинг "},{"title":"Не большой размер","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#не-большой-размер","content":"Чем больше модуль, тем больше кода он содержит внутри и тем больше потенциально он имеет связей и причин для изменений. По этому причине модуль будет сложнее менять и будет больше шанс для поломки функционала при изменениях. Желательно, что бы модули реализовывали какую-то не большую часть функциональности. "},{"title":"Опциональные зависимости/конфигурирование","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#опциональные-зависимостиконфигурирование","content":"Модулем удобно пользоваться, если он не требует какое либо конфигурирование и по дефолту работает нормально. Но, если понятно, что для некоторых приложений и кейсов нужна будет дополнительная настройка поведения, то желательно использовать опциональные зависимости, которые смогут определить в приложении. Стоит помечать опциональными зависимостями не критичный функционал, который не обязательно нужен модулю. Для того, чтобы можно было не реализовывать интерфейсы и выкинуть часть логики. К примеру, логирование // @todo пример опциональной зависимости Скопировать "},{"title":"Отладка модулей","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#отладка-модулей","content":"Рекомендуется указывать в документации модуля уникальный идентификатор/namespace логгера, который используется в этом модуле. Пример идентификатора модуля для @tramvai/module-server: const log = logger('server'); // получаем экземпляр logger по токену LOGGER_TOKEN Скопировать "},{"title":"Дополнительные ссылки","type":1,"pageTitle":"Модуль","url":"docs/concepts/module#дополнительные-ссылки","content":"Про DI контейнерПро провайдеры "},{"title":"Versioning","type":0,"sectionRef":"#","url":"docs/concepts/versioning","content":"","keywords":""},{"title":"Unified versioning","type":1,"pageTitle":"Versioning","url":"docs/concepts/versioning#unified-versioning","content":"Most of the libraries in the tramvai repository are combined into end-to-end versioning - these are core packages, tram modules and tokens, everything that is included in the @tramvai and @tramvai-tinkoff scopes. The release and publication of these libraries occurs at the same time, even if the changes affect only one package from the list. You can see this approach in Angular, and with some restrictions, in monorepositories using Lerna The main advantage of unified versioning is that compatibility between packages of the same version is guaranteed. Previously, the user had only one way to raise the framework version without losing compatibility between packages - to install all packages to their latest version. Now, you can specify a common target version for each tramvai library, or use the tramvai update command. One of the drawbacks of this approach is that any update of a package from the unified list requires raising versions and publishing all these packages from the list, which significantly slows down CI. "},{"title":"Storing versions in release tags","type":1,"pageTitle":"Versioning","url":"docs/concepts/versioning#storing-versions-in-release-tags","content":"One of the reasons for storing a version in release tags is the protected master branch, which we cannot automatically make changes to after the release and update of package versions. Storing versions in release tags does not in itself provide any advantage, and we use it together with stub versions of packages in the source package.json files. Let's say we had a package with dependencies: { \"name\": \"@tramvai/foo\", \"version\": \"0.1.0\", \"dependencies\": { \"@tramvai/bar\": \"^1.1.0\", \"@tramvai/baz\": \"^2.0.0\" } } Скопировать Previously, every big Merge Request was accompanied by conflicts if package versions were updated in the master branch, and the affected libraries in MR contained changes in dependencies. Now, our package looks like this: { \"name\": \"@tramvai/foo\", \"version\": \"0.0.0-stub\", \"dependencies\": { \"@tramvai/bar\": \"0.0.0-stub\", \"@tramvai/baz\": \"0.0.0-stub\" } } Скопировать The version 0.0.0-stub will never cause merge conflicts, and the calculation of real versions occurs only in CI - when creating a new release tag and publishing, inside the pvm library. "},{"title":"Contribute","type":0,"sectionRef":"#","url":"docs/contribute/contribute","content":"Contribute Framework tramvai is in the process of incremental migration from our internal repo to open source. Migration consists of several stages: Push synchronization Сurrent stage, automatic mirroring internal releases to Github repository Pull synchronization Next stage, automatic mirroring pull requests from Github repository to our internal repo Full migration Perspective stage, moving source code, and all CI processes (testing, linting, building, publishing, versioning) to Github repository So for now contributors can open any issues and pull requests, but maintainers will need to manually transfer accepted changes to our internal repo.","keywords":""},{"title":"Child App","type":0,"sectionRef":"#","url":"docs/features/child-app/child-app","content":"","keywords":""},{"title":"Features","type":1,"pageTitle":"Child App","url":"docs/features/child-app/child-app#features","content":"Child app can be developed independently from main apps in another repoHigh integration with DI, including isolated di-container and child-root communicationChild app is isolated from root app and can only communicate with root app through special channels (mainly through di) "},{"title":"How to create Child App?","type":0,"sectionRef":"#","url":"docs/features/child-app/how-create-child-app","content":"","keywords":""},{"title":"Initialization","type":1,"pageTitle":"How to create Child App?","url":"docs/features/child-app/how-create-child-app#initialization","content":""},{"title":"Step By Step","type":1,"pageTitle":"How to create Child App?","url":"docs/features/child-app/how-create-child-app#step-by-step","content":"Create new repo Init package-manager Add necessarily package for child app yarn add --dev @tramvai/cli yarn add @tramvai/child-app-core Скопировать Create new file tramvai.json in the root with following content { \"$schema\": \"./node_modules/@tramvai/cli/schema.json\", \"projects\": { \"[name]\": { \"name\": \"[name]\", \"root\": \"src\", \"type\": \"child-app\" } }} Скопировать Add scripts to package.json for run child in dev and prod mode: { \"scripts\": { \"start\": \"tramvai start [name]\", \"build\": \"tramvai build [name]\" }} Скопировать Implement your React-component wrapper (for example in ./src/component.tsx) Add new file ./src/entry.ts for you app with following content: import { createChildApp } from '@tramvai/child-app-core';import { ChildAppComponent } from './component'; // eslint-disable-next-line import/no-default-exportexport default createChildApp({ name: '[name]', modules: [], render: ChildAppComponent,}); Скопировать "},{"title":"Development","type":1,"pageTitle":"How to create Child App?","url":"docs/features/child-app/how-create-child-app#development","content":""},{"title":"Add new functionality","type":1,"pageTitle":"How to create Child App?","url":"docs/features/child-app/how-create-child-app#add-new-functionality","content":"Child App should mostly reuse functionality from root app through di inheritance (it happens automatically) in cases when it is appropriate. But in order to properly work, some of the modules need a special wrapper module for child app (usually such a wrapper is needed when module functionality in used in React). In this case check interested module documentation on presence of such a wrapper module for a child app. If your child app has some specific functionality you may implement it the way you want: through module, provider, actions or inside React-component. Just make sure you are reusing as much functionality from root app as possible and you are adding as little code as needed to produce smallest possible child-app script. "},{"title":"Deploy","type":1,"pageTitle":"How to create Child App?","url":"docs/features/child-app/how-create-child-app#deploy","content":"@TODO "},{"title":"Провайдер","type":0,"sectionRef":"#","url":"docs/concepts/provider","content":"","keywords":""},{"title":"Формат","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#формат","content":"type Provider = { provide: Token | string; // идентификатор провайдера useValue?: any; // реализация идентификатора useFactory?: any; // реализация идентификатора useClass?: any; // реализация идентификатора deps?: Record<string, Token | string>; // список зависимостей которые необходимы провайдеру для работы multi?: boolean; // возможность зарегистрировать множество реализаций провайдеров, если true, при получении значения этого идентификатора, все зарегестрированные значения будут приходить в массиве scope?: 'request' | 'singleton'; // Если singleton, то контейнер зарегестрирует один экземпляр провайдера на все запросы клиента. Если request то будет создавать свой инстанс для каждого клиента и Request}; Скопировать "},{"title":"Разновидности провайдеров","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#разновидности-провайдеров","content":""},{"title":"Class","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#class","content":"При инициализации инстанса произойдет создание класса переданного в useClass, если были заданы deps то класс вызовется с объектом реализаций первым аргументом import { provide } from '@tramvai/core';const provider = provide({ provide: 'token', useClass: class ImplementClass { constructor({ logger }) {} }, deps: { logger: 'logger', },}); Скопировать "},{"title":"Factory","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#factory","content":"При инициализации инстанса произойдет вызов функции переданной в useFactory, если были заданы deps то функция вызовется с объектом реализаций первым аргументом import { provide } from '@tramvai/core';const provider = provide({ provide: 'token', useFactory: ({ logger }) => new Implement(logger), deps: { logger: 'logger', },}); Скопировать "},{"title":"Value","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#value","content":"Устанавливает значение провайдера теми данными, которые были переданы в параметре useValue, не будет производится дополнительная инициализация и нельзя использовать deps import { provide } from '@tramvai/core';const provider = provide({ provide: 'token', useValue: { appName: 'APP' },}); Скопировать "},{"title":"Multi провайдеры","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#multi-провайдеры","content":"Нам может понадобиться возможность регистрации для одного токена множества реализаций. Например, несколько действий для одного шага. Что бы это реализовать, нужно передать параметр multi в провайдер. В таком случае в di контейнере сохраняется массив провайдеров: import { provide } from '@tramvai/core';const providers = [ provide({ provide: 'token', multi: true, useValue: { route: '/' }, }), provide({ provide: 'token', multi: true, useValue: { route: '/cards' }, }),]; Скопировать "},{"title":"Зависимости (deps)","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#зависимости-deps","content":"Нужны для указания зависимостей, которые нужны для работы провайдера. При создании провайдера будут созданы инстансы зависимостей, которые указаны в deps и переданы в провайдер первым аргументом. Ключами объекта deps будут являться реализации, которые попадут в провайдер. При этом, если не будет найден провайдер в глобальном DI, будет выброшена ошибка с уведомлением что текущий токен не найден. "},{"title":"Формат","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#формат-1","content":"type Provider = { deps: { [key: string]: | Token | { token: Token; optional?: boolean; multi?: boolean; }; };}; Скопировать "},{"title":"Опциональные зависимости","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#опциональные-зависимости","content":"Нам не всегда нужны обязательные зависимости для работы. И мы хотим пометить, что зависимость не обязательно для работы и не нужно кидать ошибку. Для этого можно передать параметр optional который отключит выброс ошибки при отсутствии зависимости. Вместо реализации зависимости провайдеру придет значение null. import { provide } from '@tramvai/core';const provider = provide({ provide: 'token', useClass: class A { constructor({ log }) {} }, deps: { log: { token: 'log', optional: true, }, } as const,}); Скопировать "},{"title":"Multi зависимости","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#multi-зависимости","content":"Некоторые провайдеры являются мульти провайдерами и вместо одной реализации, нам придет массив реализаций. Для правильного вывода типов, мы должны передать параметр multi: true, применить as const для deps блока для корректного вывода типов через TS: import { provide } from '@tramvai/core';const provider = provide({ provide: 'token', useClass: class A { constructor({ commands }) { commands.forEach(); } }, deps: { commands: { token: 'commands', multi: true, }, } as const,}); Скопировать "},{"title":"Circular dependency","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#circular-dependency","content":"DI не позволяет объявлять зависимости, которые находятся в зависимости у друг друга, например: import { provide } from '@tramvai/core';const providers = [ provide({ provide: 'A', deps: { B: 'B', }, }), provide({ provide: 'B', deps: { A: 'A', }, }),]; Скопировать В этом примере мы с не сможем коректно создать инстансы провайдеров и код выкинет ошибку. Подобные провайдеры стоит пересмотреть и вынести общую часть в отдельный класс и провайдер и использовать совместно A и B "},{"title":"Scope","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#scope","content":"Опция влияет только на работу контейнера на сервере, на клиенте работает только один общий контейнер, в котором провайдеры с разным скопом хранятся вместе Позволяет создавать синглтон инстансы которые будут общие между множеством клиентов. В стандартном поведение, каждый объявленный провайдер будет автоматически удаляться и пересоздаваться для каждого нового клиента. Этот функционал был сделан для того, чтобы у нас была возможность хранить, как и синглтоны, к примеру кэш, так и различные персонализированные данные. К примеру статус пользователя и персонализацию. По дефолту все провайдеры имеют значение Scope.REQUEST, что означает, что значения провайдера будет создавать для каждого клиента. Исключение составляют провайдеры useValue, которые ведут себя как синглтон. "},{"title":"Интерфейс","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#интерфейс","content":"import { provide } from '@tramvai/core';const provider = provide({ provide: 'Cache', useFactory: Cache, scope: Scope.SINGLETON,}); Скопировать В этом случае, провайдер Cache зарегистрируются как глобальный синглтон, так как был передан параметр scope и будет использоваться единый инстанс для всех пользователей. "},{"title":"Токены (token)","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#токены-token","content":"Токены используются как идентификатор для провайдера в DI. По значению токена происходит регистрация провайдера и поиск реализации. "},{"title":"Интерфейс","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#интерфейс-1","content":"type token = Token | string; Скопировать Токен может быть как строкой, так и специально созданным с помощью функции createToken в который можно передать интерфейс. При этом можно использовать одновременно и строку и createToken, главное то, что бы идентификатор был одинаковым "},{"title":"createToken","type":1,"pageTitle":"Провайдер","url":"docs/concepts/provider#createtoken","content":"import { createToken } from '@tinkoff/dippy';import { provide } from '@tramvai/core'; const loggerToken = createToken<Logger>('logger'); const provider = provide({ provide: loggerToken, useClass: Logger,}); Скопировать Основное отличие заключается в том, что в createToken можно передать интерфейс реализации, который потом будет использоваться для проверки типов при получение зависимостей и создание провайдеров. "},{"title":"Автоматические миграции","type":0,"sectionRef":"#","url":"docs/features/migration","content":"","keywords":""},{"title":"Зачем нужны миграции","type":1,"pageTitle":"Автоматические миграции","url":"docs/features/migration#зачем-нужны-миграции","content":"Иногда в трамвае бывает необходимость внести какие-то ломающие изменения и чтобы упростить такой переход для конечных пользователей используются автоматические миграции, т.к. миграции позволяют перевести кодовую базу приложения на новую версию интерфейсов в автоматическом режиме и практически без участия разработчиков. "},{"title":"Как использовать миграции","type":1,"pageTitle":"Автоматические миграции","url":"docs/features/migration#как-использовать-миграции","content":"Миграции выполняются автоматически при установке новых версий пакетов трамвая. Для сохранения информации об уже выполненных миграциях используется файл .tramvai-migrate-applied.json в корне проекта. Всё что остается сделать разработчикам приложений: изучить доку по последним миграциям для пакетовзакомитить изменения в файле .tramvai-migrate-applied.json, т.к. в нем сохраняется игформация о выполненных миграциях и лучше его сохранить чтобы не выполнять миграции повторноесли после миграций изменился package.json, то необходимо выполнить установку пакетов чтобы обновился lock файл в проекте.проревьювить и закомитить все остальные изменения которые произошли в проекте (ревью необходимо т.к. в миграции сложно учесть все кейсы использований, а также результат после преобразования кода может не соответсвовать настройкам линтера в текущем проекте).проверить работу приложения на наличие проблем и внести изменения в соответсвии с докой по миграции "},{"title":"Как отключить миграции","type":1,"pageTitle":"Автоматические миграции","url":"docs/features/migration#как-отключить-миграции","content":"Добавить переменную окружения SKIP_TRAMVAI_MIGRATIONS перед запуском установки пакетов. "},{"title":"Как работают миграции","type":1,"pageTitle":"Автоматические миграции","url":"docs/features/migration#как-работают-миграции","content":"@tramvai/core содержит зависимость @tramvai/tools-migrateв @tramvai/tools-migrate содержится скрипт который выполняется на 'postinstall'скрипт выполняет анализ tramvai модулей в 'node_modules' и находим все миграциидальше проверяется файл .tramvai-migrate-applied.json и из него берется список уже выбранных миграций если такой файл естьвыполняется код миграций, которых нет в списке выполненных. Миграции выполняются последовательнов файл .tramvai-migrate-applied.json добавляется информация о только что выполненных миграциях, если файл был до этого, либо этот файл создаётся "},{"title":"Вопросы/ответы","type":1,"pageTitle":"Автоматические миграции","url":"docs/features/migration#вопросыответы","content":""},{"title":"Нужно ли хранить .tramvai-migrate-applied.json в гите","type":1,"pageTitle":"Автоматические миграции","url":"docs/features/migration#нужно-ли-хранить-tramvai-migrate-appliedjson-в-гите","content":"Да, иначе при следующих миграциях мы не будем знать какие миграции уже были выполнены и будут произведены повторные миграции "},{"title":"Papi introduction","type":0,"sectionRef":"#","url":"docs/features/papi/introduction","content":"","keywords":""},{"title":"Explanation","type":1,"pageTitle":"Papi introduction","url":"docs/features/papi/introduction#explanation","content":"Зачастую приложению нужны микросервисы, которые могут обрабатывать запрос пользователей и отдавать JSON ответы. Именно для решения этих кейсов были разработаны PAPI. PAPi позволяет реализовать обработчики запросов которые могут запросить клиенты и получить ответ в произвольном формате, к примеру JSON. PAPI позволяет быстро и дешево реализовать обработчики, не поднимая дополнительные микросервисы. Связанные с papi разделы Как получить данные с papiКак можно получать данные с DI в papi роутахКак добавить новый papi роут в приложении "},{"title":"How to","type":1,"pageTitle":"Papi introduction","url":"docs/features/papi/introduction#how-to","content":""},{"title":"Как получить данные с papi","type":1,"pageTitle":"Papi introduction","url":"docs/features/papi/introduction#как-получить-данные-с-papi","content":"papi доступно за урлом /${appInfo.appName}/papi. Такой урл выбран потому, что бы разделить множество различных papi сервисов на 1 домене приложении. Для примера выше с добавление роута, итоговый урл будет выглядеть так: /${appInfo.appName}/papi/test где appName это название переданное в createApp Что бы сделать запрос, необходимо использовать PAPI_SERVICE из модуля @tramvai/module-http-client который автоматически на клиенте сделает http запрос к papi а на сервере просто вызовет функцию handler "},{"title":"Как можно получать данные с DI в papi роутах","type":1,"pageTitle":"Papi introduction","url":"docs/features/papi/introduction#как-можно-получать-данные-с-di-в-papi-роутах","content":"Для papi-обработчика есть возможность задать зависимости которые требуются ему для работы. При этом для каждого вызова будет создан отдельный дочерний di-container что позволит использовать как SIGNLETON так и REQUEST зависимости. import { Module, provide } from '@tramvai/core';import { CREATE_CACHE_TOKEN } from '@tramvai/module-common';import { HTTP_CLIENT } from '@tramvai/module-http-client';import { SERVER_MODULE_PAPI_PUBLIC_ROUTE } from '@tramvai/module-server';import { createPapiMethod } from '@tramvai/papi'; @Module({ providers: [ provide({ provide: SERVER_MODULE_PAPI_PUBLIC_ROUTE, multi: true, useFactory: ({ createCache }) => { const cache = createCache(); // cache должен быть общий для всез вызовов handler, поэтому вызываем его за пределеами createPapiMethod return createPapiMethod({ path: '/my/papi', method: 'post', async handler({ httpClient }) { // используем то, что запросили в deps из createPapiMethod if (cache.has('test')) { return 'test'; } const { payload } = await httpClient.get('fake'); return payload; }, deps: { httpClient: HTTP_CLIENT, // эту же зависимость надо пересоздать для каждого вызова и они должны быть независимы }, }); }, deps: { createCache: CREATE_CACHE_TOKEN, // это зависимость из рутового контейнера, котоарая будет создана только один раз }, }), ],})export class PapiTestModule {} Скопировать "},{"title":"Как добавить новый papi роут в приложении","type":1,"pageTitle":"Papi introduction","url":"docs/features/papi/introduction#как-добавить-новый-papi-роут-в-приложении","content":"Существует два способа задания роутов. 1 - основываясь на файловой структуре, 2 - задание через провайдеров Используя file api подход# Самый простой способ создать PAPI роут, это создать в корне проекта директорию papi в которую положить TS файлы с обработчиками. Название файлов будет являться урлом до роута. Например: мы хотим создать новый papi обработчик, который читает body запросов и суммирует пришедшие значения. Для этого создаем файл /papi/getSum.ts с содержимым:  содержимое getSum.ts import { Request, Response } from '@tramvai/papi';import { CREATE_CACHE_TOKEN } from '@tramvai/module-common'; // в tramvai.json мы добавили указание на директорию с файловым апи// \"commands\": {// \"build\": {// \"options\": {// \"server\": \"server-add-file-api/index.ts\",// \"serverApiDir\": \"server-add-file-api/papi\"// }// }// }// и теперь каждый файл в этой директории будет обработчиком какого-то урла в зависимости от имени самого файла// /${appName}/papi/${fileName} т.е. для текушего файла урл будет /server/papi/getSum // экспортируя переменную rootDeps мы можем запросить зависимости из рутового DI на сервере// эти записимости будут переданы в handler третьим параметромexport const rootDeps = { createCache: CREATE_CACHE_TOKEN,}; // если зависимости при этом надо как-то изначально проиницилизировать, то можно использовать// mapDeps который будет вызван один раз, получит в качестве аргумента зависимости из deps, и// результат этой функции будет использован вместо третьего аргумента в handlerexport const mapRootDeps = ({ createCache }: typeof rootDeps) => { return { cache: createCache('memory'), };}; // handler это наш обработчик который будет вызываться на каждый запрос// тоже самое будет если сделать export defaultexport const handler = (req: Request, res: Response, { cache }: ReturnType<typeof mapRootDeps>) => { const { body: { a, b }, method, } = req; if (method !== 'POST') { throw new Error('only post methods'); } if (!a || !b) { return { error: true, message: 'body parameters a and b should be set', }; } const key = `${a},${b}`; if (cache.has(key)) { return { error: false, fromCache: true, result: cache.get(key) }; } const result = +a + +b; cache.set(key, result); return { error: false, fromCache: false, result };}; Скопировать  Этот файл можно будет запросить с помощью papi клиента, либо вызвав урл /${appName}/papi/getSum Используя провайдеры# Необходимо добавить multi провайдер SERVER_MODULE_PAPI_PUBLIC_ROUTE в котором добавить новые papi роуты import { createPapiMethod } from '@tramvai/papi';import { SERVER_MODULE_PAPI_PUBLIC_ROUTE } from '@tramvai/tokens-server';import { provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: SERVER_MODULE_PAPI_PUBLIC_ROUTE, multi: true, useValue: createPapiMethod({ method: 'get', // метод, может быть post, all и так далее path: '/test', // путь по которому будет доступен роут async handler(req, res): Promise<any> { // функция которая будет вызываться, если придут запросы на урл return new Promise({ test: true }); }, }), }), ],})export class PapiTestModule {} Скопировать И после этого будет доступен роут test "},{"title":"File-System Pages","type":0,"sectionRef":"#","url":"docs/features/file-system-pages","content":"","keywords":""},{"title":"Explanation","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#explanation","content":""},{"title":"Motivation","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#motivation","content":"By default, you need to provide page components with bundles, then register this components for the corresponding routes, for example: Create bundle with component (used lazy for granular code splitting): const commentsBundle = createBundle({ name: 'comments', components: { 'comments-list': lazy(() => import('./pages/CommentsList')), },}); Скопировать Create static route with this bundle and component: const routes = [ { name: 'comments', path: '/comments/', config: { bundle: 'comments', pageComponent: 'comments-list', }, },]; Скопировать File-System Pages is designed to remove the first step, or even both steps, and make it easier to add new pages to the application. "},{"title":"File-System Pages","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#file-system-pages","content":"The first option is to automatically read page components from the file system and register them inside an application, without need to specify bundle. You can use this components by unique name in route.config.pageComponent property, and the component to be rendered for that route will be automatically wrapped in lazy. Thus, all routes with file-system pages will load only neccesary JS and CSS chunks. For example, you create page components with this file structure: src└── pages ├── index.tsx └── comments.tsx Скопировать This components will be available in the application with these names: @/pages/index@/pages/comments Скопировать and you can create few static pages from them: const routes = [ { name: 'main', path: '/', config: { pageComponent: '@/pages/index', }, }, { name: 'comments', path: '/comments/', config: { pageComponent: '@/pages/comments', }, },]; Скопировать Example application "},{"title":"File-System Routing","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#file-system-routing","content":"Second option is less flexible, but fully automates the creation of routes in the application. Static routes will be generated from file-system pages, and paths for this routes will be created based on paths to components, strictly conforming to naming conventions. For example, you want to handle this urls by your application: //login//comments//comments/:id/ Скопировать In that case you need to create components with this file structure: src└── pages ├── index.tsx ├── login └── index.tsx └── comments ├── index.tsx └── [id] └── index.tsx Скопировать Where path with square brackets relates to dynamic parts of url. File for /login/ page must be named login/index.tsx instead of login.tsx, because we must have strictly one way to convert url back to page component name. Example application "},{"title":"Usage","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#usage","content":"Experimental feature File-System Pages hidden behind the flag commands.build.configurations.experiments.fileSystemPages.enable in tramvai.json configuration file: { \"projects\": { \"your-app-name\" : { \"commands\": { \"build\": { \"configurations\": { \"experiments\": { \"fileSystemPages\": { \"enable\": true, \"pagesDir\": \"pages\", \"routesDir\": \"routes\" } } } } } } }} Скопировать \"enable\": true - activates the feature \"pagesDir\": \"pages\" - default directory for File-System Pages \"routesDir\": \"routes\" - default directory for File-System Routing "},{"title":"Pages","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#pages","content":"You need to use default export in page components, e.g.: const CommentsPage = () => <h1>Comments</h1>; export default CommentsPage; Скопировать "},{"title":"Actions","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#actions","content":"Page components support global actions in actions static property, these actions will work as bundles actions: const CommentsPage = () => <h1>Comments</h1>; CommentsPage.actions = [fetchCommentsListAction]; export default CommentsPage; Скопировать This actions will be code-splitted with page component code. "},{"title":"Reducers","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#reducers","content":"Page components support reducers in reducers static property, these reducers will be registered in application store: const CommentsPage = () => <h1>Comments</h1>; CommentsPage.reducers = [CommentsStore]; export default CommentsPage; Скопировать This reducers will be code-splitted with page component code. "},{"title":"Components","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#components","content":"Page components support additional React components in components static property, this components will be registered in the application: const CommentsPage = () => <h1>Comments</h1>; CommentsPage.components = { 'modal-box': () => <dialog>Modal Box</dialog>,}; export default CommentsPage; Скопировать This components will be code-splitted with page component code. You can directly access these components with PAGE_SERVICE: import { useDi } from '@tramvai/react';import { PAGE_SERVICE } from '@tramvai/tokens-router'; const CommentsPage = () => { const pageService = useDi(PAGE_SERVICE); const ModalBox = pageService.getComponent('modal-box'); return ( <> <h1>Comments</h1> <ModalBox /> </> )} Скопировать "},{"title":"How to","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#how-to","content":""},{"title":"How to change layout component","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#how-to-change-layout-component","content":"When use File-System Pages, at first, add layout component to page components: const CommentsPage = () => <h1>Comments</h1>; CommentsPage.components = { 'comments-layout': CommentsLayout,}; export default CommentsPage; Скопировать then, add this layout to layoutComponent property of appropriate route: const routes = [ { name: 'comments', path: '/comments/', config: { pageComponent: '@/pages/comments', layoutComponent: 'comments-layout', }, },]; Скопировать When use File-System Routing, at this moment you can't change the page layout. "},{"title":"How to create static route with dynamic parameters","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#how-to-create-static-route-with-dynamic-parameters","content":"File-System Routing example Wrap dynamic part of url in square brackets in file path. For /comments/:id/ create page component with this path pages/comments/[id]/index.tsx: src└── pages └── comments └── [id] └── index.tsx Скопировать Dynamic parameter available in current route params. In react components, use useRoute hook: import { useRoute } from '@tramvai/module-router'; const Comment = () => { const route = useRoute(); return ( <li> Current comment id: {route.params.id} </li> );} Скопировать In actions, use PAGE_SERVICE_TOKEN: import { createAction } from '@tramvai/core'; const someAction = createAction({ name: 'someAction', fn: (_, __, { pageService }) => { const route = pageService.getCurrentRoute(); console.log(`Current comment id: ${route.params.id}`); }, deps: { pageService: PAGE_SERVICE_TOKEN, },}); Скопировать "},{"title":"Migration","type":1,"pageTitle":"File-System Pages","url":"docs/features/file-system-pages#migration","content":"If you want to migrate from bundles to file-system pages, there is few steps: Enable experiments.fileSystemPages.enable option in tramvai.json, and change default folders for safety: { \"fileSystemPages\": { \"enable\": true, \"pagesDir\": \"new-fs-pages\", // file-system pages directory \"routesDir\": false // force disable file-system routing }} Скопировать Split your bundles to components from this bundle src/bundles/someBundle.ts: import { createBundle } from '@tramvai/core';import { lazy } from '@tramvai/react';import { actionFoo, actionBar } from '../actions';import { StoreFoo, StoreBar } from '../reducers';import { CommonComponent } from '../components'; const someBundle = createBundle({ name: 'someBundle', components: { 'pages/foo-page': lazy(() => import('../pages/Foo')), 'pages/bar-page': lazy(() => import('../pages/Bar')), 'components/common': CommonComponent, }, actions: [actionFoo, actionBar], reducers: [StoreFoo, StoreBar],}); export default someBundle; Скопировать you need to create two page components, src/new-fs-pages/foo.tsx and src/new-fs-pages/bar.tsx, with this content: import { lazy } from '@tramvai/react';import { actionFoo, actionBar } from '../actions';import { StoreFoo, StoreBar } from '../reducers';import { CommonComponent } from '../components'; // the same for src/new-fs-pages/bar.tsxconst FooPage = () => { return <h1>Foo Page</h1>;} FooPage.components = { 'components/common': CommonComponent,};FooPage.actions = [actionFoo, actionBar];FooPage.reducers = [StoreFoo, StoreBar]; export default FooPage; Скопировать then update your routes config from: const routes = [ { name: 'foo', path: '/foo/', config: { bundle: 'sameBundle', pageComponent: 'pages/foo-page', }, }, { name: 'bar', path: '/bar/', config: { bundle: 'sameBundle', pageComponent: 'pages/bar-page', }, },] Скопировать to this: const routes = [ { name: 'foo', path: '/foo/', config: { pageComponent: '@/new-fs-pages/foo', }, }, { name: 'bar', path: '/bar/', config: { pageComponent: '@/new-fs-pages/bar', }, },] Скопировать and remove bundle property from createApp "},{"title":"Working with React","type":0,"sectionRef":"#","url":"docs/features/react","content":"","keywords":""},{"title":"Подключение в проекте","type":1,"pageTitle":"Working with React","url":"docs/features/react#подключение-в-проекте","content":"npm i --save @tramvai/react Скопировать "},{"title":"DI","type":1,"pageTitle":"Working with React","url":"docs/features/react#di","content":"При создание компонентов вам может понадобиться получение данных с di для этого есть hook useDi и HoC withDi "},{"title":"useDi","type":1,"pageTitle":"Working with React","url":"docs/features/react#usedi","content":"type useDi = (deps: Record<string, string | Token>) => Record<string, any>; Скопировать type useDi = (dep: string | Token) => any; Скопировать Хук в который мы можем передать как объект с требуемыми зависимостями и нам вернется объект с данными, так и единичный token, где нам вернется результат. При вызове useDi мы получаем данные из di и если мы не нашли данных в di, произойдет ошибка. import React from 'react';import { useDi } from '@tramvai/react'; const MyComponent = () => { const { logger } = useDi({ logger: 'logger' }); // передаем объект const Region = useDi(regionToken); // передаем единичный токен logger.info('text'); return ( <div> Component <Region /> </div> );}; Скопировать "},{"title":"withDi","type":1,"pageTitle":"Working with React","url":"docs/features/react#withdi","content":"type withDi = ( deps: Record<string, string | Token>) => (wrapper: React.ReactElement<any>) => React.ReactElement<any>; Скопировать Хок, который позволяет обернуть любые компоненты, получить данные из DI и передать результат с зависимостями в props компонента import React from 'react';import { withDi } from '@tramvai/react'; @withDi({ logger: LOGGER_TOKEN })class BoxyPage extends Component { render() { this.props.logger.info('text'); return <div>Component</div>; }} Скопировать "},{"title":"useDiContainer","type":1,"pageTitle":"Working with React","url":"docs/features/react#usedicontainer","content":"type useDiContainer = () => DI.Container; Скопировать Получение инстанса DI контейнера который был добавлен в контекст приложения. Лучше не пользоваться этим hook, так как он сильно низкоуровневый и предназначен для разработки новых hook "},{"title":"Error","type":1,"pageTitle":"Working with React","url":"docs/features/react#error","content":"Для обработки ошибок при рендере в React используются Error Boundary. Этот пакет предоставляет свою версию Error Boundary которая залогирует ошибку через общий логгер и отобразит заглушку для обернутого компонента если произошла ошибка. "},{"title":"ErrorBoundary","type":1,"pageTitle":"Working with React","url":"docs/features/react#errorboundary","content":"Error Boundary компонент, который следит за ошибками ниже по дереву и в случае возникшей ошибки рендера залогирует ошибку и отобразит компонент fallbackComponent (передается как пропс, по дефолту это FallbackError из этого пакета) вместо упавшего поддерева рендера. Можно переопределить fallbackComponent через провайдер ERROR_BOUNDARY_FALLBACK_COMPONENT_TOKEN. "},{"title":"FallbackError","type":1,"pageTitle":"Working with React","url":"docs/features/react#fallbackerror","content":"Компонент используемый по умолчанию как заглушка для поддерева в котором призошла ошибка рендера "},{"title":"withError","type":1,"pageTitle":"Working with React","url":"docs/features/react#witherror","content":"Хок оборачивающий компонент в ErrorBoundary. "},{"title":"lazy","type":1,"pageTitle":"Working with React","url":"docs/features/react#lazy","content":"Для динамического импорта компонентов с поддержкой SSR, существует high order компонент lazy: import { lazy } from '@tramvai/react'; const LazyComponent = lazy(() => import('./components/foo'), { loading: <div>Загрузка...</div>,}); <LazyComponent />; Скопировать "},{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/features/routing","content":"","keywords":""},{"title":"Base modules","type":1,"pageTitle":"Introduction","url":"docs/features/routing#base-modules","content":"NoSpaRouterModule - creates a router instance, initializes a router for routing and synchronizes it with a router, registers actions, bundles, validators, redirects and other features to the corresponding router hooks.SpaRouterModule - same as previous plus switches the router to use the History API on the client. "},{"title":"Create event","type":0,"sectionRef":"#","url":"docs/features/state/create-event","content":"","keywords":""},{"title":"Описание метода","type":1,"pageTitle":"Create event","url":"docs/features/state/create-event#описание-метода","content":"createEvent(eventName: string, payloadCreator?: PayloadTransformer): EventCreator eventName - Уникальные индетификатор событияpayloadCreator - не обязательная функция, которая позволяет объединять множество аргументов в один, В случаях, когда эвент был вызван с множеством аргументов. "},{"title":"Примеры","type":1,"pageTitle":"Create event","url":"docs/features/state/create-event#примеры","content":"Создание эвента без параметров# import { createEvent } from '@tramvai/state'; const userLoadingInformation = createEvent('user loading information'); userLoadingInformation(); Скопировать Создание эвента с параметрами# import { createEvent } from '@tramvai/state'; const userInformation = createEvent<{ age: number; name: string }>('user information'); userInformation({ age: 42, name: 'Tom' }); Скопировать Создание эвента с преобразование payload# import { createEvent } from '@tramvai/state'; const itemPrice = createEvent('user information', (info: string, price: number) => ({ [info]: price,})); itemPrice('car', 3000); Скопировать Использование эвентов в экшенах# Мы создаем экшен, в котором после загрузки информации, создаем эвент и кидаем его в context.dispatch import { createAction } from '@tramvai/core';import { createEvent } from '@tramvai/state'; const userInformation = createEvent < { age: number, name: string } > 'user information'; const action = createAction({ name: 'userLoadInformation', fn: async (context) => { const result = await tinkoffRequest({ method: 'information' }); context.dispatch(userInformation(result)); },}); Скопировать "},{"title":"Create reducer","type":0,"sectionRef":"#","url":"docs/features/state/create-reducer","content":"","keywords":""},{"title":"Описание метода","type":1,"pageTitle":"Create reducer","url":"docs/features/state/create-reducer#описание-метода","content":"createReducer(name, initialState) name - уникальное название редьюсера. Не должно пересекаться с другими редьюсерамиinitialState - состояние редьюсера по умолчанию "},{"title":"Типизация","type":1,"pageTitle":"Create reducer","url":"docs/features/state/create-reducer#типизация","content":"По умолчанию, тип стейта редьюсера, и его название, выводятся автоматически: import { createReducer } from '@tramvai/state'; const userReducer = createReducer('user', { name: 'anonymus' }); Скопировать Зачем вообще нужна типизация для названия редьюсера? Тогда этот редьюсер будет удобнее использовать вместе с useSelector. Если передавать тип стейта вручную, желательно указать и название вторым аргументом дженерика: import { createReducer } from '@tramvai/state'; type UserState = { name: string }; const userReducer = createReducer<UserState, 'user'>('user', { name: 'anonymus' }); Скопировать Но, можно просто задать нужный тип для initialState: import { createReducer } from '@tramvai/state'; type UserState = { name?: string }; const userReducer = createReducer('user', {} as UserState); Скопировать "},{"title":"Подписка на эвенты","type":1,"pageTitle":"Create reducer","url":"docs/features/state/create-reducer#подписка-на-эвенты","content":".on(evnet, reducer) При создании редьюсера становится доступным метод .on который позволяет подписаться на события и вернуть новый стейт event - эвент или строка, на которые будет подписан редьюсерreducer(state, payload) - чистая функция которая принимает текущий state, payload из события и должен вернуть новое состояние редьюсера Пример использования .on метода import { createReducer, createEvent } from '@tramvai/state'; export const userLoadInformation = createEvent < { status: string } > 'user load information';export const userAddInformation = createEvent < { name: string, info: {} } > 'user add information'; const userReducer = createReducer('user', { info: {},}) .on(userLoadInformation, (state, info) => ({ info })) .on(userAddInformation, (state, { name, info }) => ({ ...state, state: { ...state.info, [name]: info, }, })); Скопировать "},{"title":"Автоматическое создание эвентов","type":1,"pageTitle":"Create reducer","url":"docs/features/state/create-reducer#автоматическое-создание-эвентов","content":".createEvents(model) метод который позволяет убрать необходимость в создании и явном привязывании эвентов model - объект, в котором ключ это идентификатор эвента, который потом будет передан в createEvent, а значение это функция редьюсера, которая попадет в метод .on() и будет вызываться при срабатывании эвентов Пример использования .createEvents метода import { createReducer } from '@tramvai/state'; const userReducer = createReducer('user', { info: {},});export const { userLoadInformation, userAddInformation } = userReducer.createEvents({ userLoadInformation: (state, info: { status: string }) => ({ info }), userAddInformation: (state, { name, info }: { name: string; info: {} }) => ({ ...state, state: { ...state.info, [name]: info, }, }),}); Скопировать Обязательно необходимо описать типы payload аргумента в редьюсерах, иначе не будет работать вывод типов для эвентов. "},{"title":"DevTools","type":0,"sectionRef":"#","url":"docs/features/state/dev-tools","content":"","keywords":""},{"title":"Возможные проблемы","type":1,"pageTitle":"DevTools","url":"docs/features/state/dev-tools#возможные-проблемы","content":"Для лучшего пользовательского опыта необходимо использовать отдельное окно расширения redux dev tools, а не вкладку в chrome developer tools, т.к. иначе не сохраняется история экшнов issue. "},{"title":"Производительность","type":1,"pageTitle":"DevTools","url":"docs/features/state/dev-tools#производительность","content":"Так как весь стейт приложения со всеми экшенами довольно большой, то наблюдаются ощутимые тормоза при работе с девтулз при использовании прыжков по состояниям\\событиям и при одновременном срабатывании большого количества экшнов. Поэтому: Используйте техники кастомизации для задания pickState для уменьшения размера данных в девтулзах.Увеличьте значение параметра latency (передается в connectViaExtension.connect), который по сути делает debounce на посылку actions в расширение docs "},{"title":"Дополнительный материал","type":1,"pageTitle":"DevTools","url":"docs/features/state/dev-tools#дополнительный-материал","content":"Репозиторий с devtoolsGetting Started with Redux DevTools Extension  "},{"title":"API","type":0,"sectionRef":"#","url":"docs/features/react-query/api","content":"","keywords":""},{"title":"Explanation","type":1,"pageTitle":"API","url":"docs/features/react-query/api#explanation","content":"For the library to work, the module @tramvai/module-react-query must be added to the tramvai application "},{"title":"Api","type":1,"pageTitle":"API","url":"docs/features/react-query/api#api","content":""},{"title":"Query","type":1,"pageTitle":"API","url":"docs/features/react-query/api#query","content":"A wrapper around react-query options with tramvai integration. fork# Create new Query from an existing query with option to override settings. import { createQuery } from '@tramvai/react-query'; const query = createQuery();const newQuery = query.fork({ refetchInterval: 2000, refetchIntervalInBackground: false,}); Скопировать prefetchAction# Return a tramvai action that can be used to prefetch current query export default function PageComponent() { const { data, isLoading } = useQuery(query); return <div>{isLoading ? 'loading...' : data}</div>;} Component.actions = [query.prefetchAction()]; Скопировать fetchAction# Return a tramvai action that can be used to fetch current query const action = createAction({ name: 'action', fn: async (context) => { const result = await context.executeAction(query.fetchAction()); console.log('__action__', result); },}); Скопировать raw# Might be used when the raw query options is needed. The result can be passed to the underlying methods of react-query lib in cases when @tramvai/react-query doesn't provide appropriate wrapper. This method is used internally in the lib to redirect calls to react-query. "},{"title":"createQuery","type":1,"pageTitle":"API","url":"docs/features/react-query/api#createquery","content":"Allows you to create a Query object that can later be used in components using useQuery. Used to execute single data retrieval requests. import { createQuery } from '@tramvai/react-query'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get('api/base'); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); Скопировать Unique query parameters# To create a generic query that takes parameters for a query, you must return a unique key, you can read more about this in the official documentation section Query Keys As a parameter key you can use: a string, such as key: 'query-name'an array where any serializable data can be used as elements, for example key: ['query-name', false, { bar: 'baz }]a function that takes the parameters with which query is called and returns a string - key: (options) => 'query-name'a function that accepts parameters, with which query is called, and returns an array, where any serializable data can be used as elements - key: (options) => ['query-name', options, { bar: 'baz' }] import { createQuery, useQuery } from '@tramvai/react-query'; const query = createQuery({ key: (id: number) => ['user', id], fn: async (id, { apiClient }) => { const { payload } = await apiClient.get(`api/user/${id}`); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); export function Component({ id }) { const { data, isLoading } = useQuery(query, id); return <div>{isLoading ? 'loading...' : data}</div>;} Скопировать "},{"title":"useQuery","type":1,"pageTitle":"API","url":"docs/features/react-query/api#usequery","content":"React hook for working with Query object react-query docs import { useQuery } from '@tramvai/react-query'; export function Component() { const { data, isLoading } = useQuery(query); return <div>{isLoading ? 'loading...' : data}</div>;} Скопировать "},{"title":"useQueries","type":1,"pageTitle":"API","url":"docs/features/react-query/api#usequeries","content":"React Hook for working with the list of Query objects react-query docs import { useQueries } from '@tramvai/react-query'; export function Component() { const [ { data: data1, isLoading: isLoading1 }, { data: data2, isLoading: isLoading2 }, ] = useQueries([query1, query2]); return ( <div> <div>{isLoading1 ? 'loading1...' : data1}</div> <div>{isLoading2 ? 'loading2...' : data2}</div> </div> );} Скопировать "},{"title":"createInfiniteQuery","type":1,"pageTitle":"API","url":"docs/features/react-query/api#createinfinitequery","content":"Creates an InfiniteQuery object that can later be used in components using useInfiniteQuery. It is used to execute queries to obtain a sequence of data that can be loaded as the component runs. import { createInfiniteQuery } from '@tramvai/react-query'; const query = createInfiniteQuery({ key: 'list', fn: async (_, start = 0, { apiClient }) => { const { payload } = await apiClient.get<Response>('api/list', { query: { count: 30, start, }, }); return payload; }, getNextPageParam: (page: Response) => { return page.nextPage; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); Скопировать "},{"title":"useInfiniteQuery","type":1,"pageTitle":"API","url":"docs/features/react-query/api#useinfinitequery","content":"React hook for working with the InfiniteQuery object react-query docs import { useInfiniteQuery } from '@tramvai/react-query'; export function Component() { const { data, isLoading, fetchNextPage, hasNextPage } = useInfiniteQuery(query); if (isLoading) { return 'loading...'; } return ( <div> <div> {data.pages.map((page) => { return page.list.map((entry) => { return <div key={entry}>{entry}</div>; }); })} </div> {hasNextPage && ( <button type=\"button\" onClick={() => fetchNextPage()}> Load more </button> )} </div> );} Скопировать "},{"title":"createMutation","type":1,"pageTitle":"API","url":"docs/features/react-query/api#createmutation","content":"Creates a Mutation object that can later be used in components using useMutation. Used to send and modify data in the api. import { createMutation } from '@tramvai/react-query'; const mutation = createMutation({ key: 'post', fn: async (_, data: string, { apiClient }) => { const { payload } = await apiClient.post('api/post', { body: { data, }, }); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); Скопировать "},{"title":"useMutation","type":1,"pageTitle":"API","url":"docs/features/react-query/api#usemutation","content":"React hook for working with the Mutation object react-query docs import { useMutation } from '@tramvai/react-query'; export function Component() { const { isLoading, mutate } = useMutation(mutation); if (isLoading) { return 'loading...'; } return ( <button type=\"button\" onClick={() => mutate('test')}> Send data </button> );} Скопировать "},{"title":"How-to","type":1,"pageTitle":"API","url":"docs/features/react-query/api#how-to","content":"Examples of using @tramvai/react-query "},{"title":"Use react-query directly","type":1,"pageTitle":"API","url":"docs/features/react-query/api#use-react-query-directly","content":"Prefer to use methods from the @tramvai/react-query as it is can work both with the Query wrapper and the query options to react-query itself ::: You can get QueryClient from di by token QUERY_CLIENT_TOKEN or using method useQueryClient in React-components. To convert wrapped Query object to object acceptable by react-query use method raw of the Query instance. "},{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/features/state/overview","content":"","keywords":""},{"title":"Особенности","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#особенности","content":"Redux-like стейт-менеджерВстроенная библиотека, похожая на redux-act, для уменьшения boilerplate кодаСодержит привязки к react компонентам, такие как connect и useSelectorДинамическая инициализация редьюсеров. Можно в любое время зарегистрировать редьюсер или сгенерировать новый.Точечные подписки на изменения состояний редьюсеров. При изменении данных повторно пересчитываются только затронутые connect и useSelector, а не все.Поддержка SSR режима. "},{"title":"Основные концепции","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#основные-концепции","content":"Стор - Класс, который содержит состояние всех редьюсеров, подписки на изменения и создается для каждого клиентаРедьюсеры - сущности в которых мы описываем то, как будут храниться и преобразовываться данныеЭвенты - события, с помощью которых можно изменить состояния редьюсеровЭкшены - функции, которые позволяют выполнять сайд-эффекты и обновлять данные в сторе. Похожи на redux-thunk "},{"title":"Рекомендации","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#рекомендации","content":"Нельзя мутировать данные в редьюсерах. Иначе из-за различных оптимизаций не произойдёт оповещение подписчиков о измененияхИнициализировать редьюсеры как можно раньше и до его использования. Иначе при вызове dispatch(userLoadInformation()) редьюсер еще не будет отслеживать события и не получит данные.Не хранить статичные данные в сторах. Так как эти данные будут передаваться с сервера на клиент, то данные задублируются. Лучше вынести в константы.Разбивать на небольшие редьюсеры. Иначе у нас появляется огромный редьюсер, который содержит большое количество информации и любые изменения будут вызывать перерасчеты для большого количества компонентов. "},{"title":"Установка","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#установка","content":"npm i --save @tramvai/state Скопировать "},{"title":"Базовый пример","type":1,"pageTitle":"Introduction","url":"docs/features/state/overview#базовый-пример","content":"import { createReducer, createEvent } from '@tramvai/state'; export const userLoadInformation = createEvent('user load information');export const userAddInformation = createEvent('user add information'); const userReducer = createReducer('user', { info: {},}) .on(userLoadInformation, (state, info) => ({ info })) .on(userAddInformation, (state, { name, info }) => ({ ...state, state: { ...state.info, [name]: info, }, })); Скопировать "},{"title":"React hooks","type":0,"sectionRef":"#","url":"docs/features/state/hooks","content":"","keywords":""},{"title":"useActions","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#useactions","content":"Позволяет исполнять трамвайные экшены в React компонентах "},{"title":"Интерфейс","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#интерфейс","content":"actions - один или массив трамвайных экшенов Если передавать в useActions массив, для типизации требуется указать as const - useActions([] as const) "},{"title":"Использование","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#использование","content":"import { useActions } from '@tramvai/state';import { loadUserAction, getInformationAction, setInformationAction } from './actions'; export const Component = () => { // если передавать один экшен, тип payload для loadUser выводится автоматически const loadUser = useActions(loadUserAction); // если передавать список экшенов, `as const` необходим для корректного вывода типов const [getInformation, setInformation] = useActions([ getInformationAction, setInformationAction, ] as const); return ( <div> <div onClick={loadUser}>load user</div> <div onClick={getInformation}>get information</div> <div onClick={() => setInformation({ user: 1 })}>set information</div> </div> );}; Скопировать "},{"title":"useSelector()","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#useselector","content":"Получение данных со стора в компонентах "},{"title":"Интерфейс","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#интерфейс-1","content":"stores: [] - список токенов на которые будет подписан селектор. Будет влиять на то, какие изменения в сторах вызовут обновление в компонентеselector: (state) => any - сам селектор, это функция, которая будет вызвана при инициализации и любых изменениях сторов переданных в stores. Функция должна вернуть данные которые можно будет использовать в компонентеequalityFn?: (cur, prev) => boolean - не обязательная функция для изменения способа сравнения прошлых и новых значений селектора "},{"title":"Использование","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#использование-1","content":"Для получения данных из стора, можно использовать имя стора, ссылку на стор, или объект с опциональным стором: 'storeName'storeObject{ store: storeObject, optional: true }{ store: 'storeName', optional: true } Можно передавать массив ключей, тогда для корректного вывода типов лучше использовать as const: useSelector(['fooStoreName', barStoreObject] as const, ({ foo, bar }) => null); import { useSelector } from '@tramvai/state'; export const Component = () => { const isBrowser = useSelector('media', (state) => state.media.isBrowser); return <div>{isBrowser ? <span>Browser</span> : <span>Desktop</span>}</div>;}; Скопировать "},{"title":"Оптимизации","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#оптимизации","content":"Для того, чтобы уменьшить количество перерисовок компонентов после каждого вызова selector проверяются возвращаемые значения с теми, которые были раньше. Если возвращаемые данные селектора не изменились, то компонент не будет перерисован. По этой причине, в селекторах лучше получать небольшие куски информации. Тогда меньше шанс, что компонент обновится. К примеру: нам нужны roles пользователя, мы пишем селектор, который запрашивает все данные пользователя (state) => state.user и теперь любые изменения редьюсера user будут обновлять компонент. Лучше, если мы будем получать только необходимые данные (state) => state.user.roles в таком случае перерисовываться компонент будет только тогда, когда изменятся roles пользователя "},{"title":"useStoreSelector","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#usestoreselector","content":"Упрощенная версия хука useSelector, в который можно передать только один стор, созданный через createReducer. Сделан был для улучшения вывода типов селекторов, так как сам useSelector не может этого делать из-за использования внутри строковых имен сторов, токенов и наследников BaseStore "},{"title":"Интерфейс","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#интерфейс-2","content":"store: Reducer - Стор, созданный через createReducerselector: (state) => any - сам селектор, это функция, которая будет вызвана при инициализации и любых изменениях стора, переданного в stores. Функция должна вернуть данные которые можно будет использовать в компоненте "},{"title":"Использование","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#использование-2","content":"import { useStoreSelector } from '@tramvai/state';import { createReducer } from '@tramvai/state'; const myStore = createReducer('myStore', { id: '123' }); export const Component = () => { const id = useStoreSelector((myStore, (state) => state.id)); // Корректно выведется тип id как \"string\" return <div>{id}</div>;}; Скопировать "},{"title":"Оптимизации","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#оптимизации-1","content":"Хук является оберткой над useSelector, поэтому оптимизации аналогичны. Сама функция селектора внутри мемоизируется "},{"title":"useStore","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#usestore","content":"Хук для получения состояния конкретного редьюсера. Особенности: автоматически выводит тип состоянияперерендеривает компонент только при обновлении редьюсерапозволяет создавать редьюсеры \"на лету\" "},{"title":"Интерфейс","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#интерфейс-3","content":"store: Reducer - Стор, созданный через createReducer "},{"title":"Использование","type":1,"pageTitle":"React hooks","url":"docs/features/state/hooks#использование-3","content":"Базовый пример: import { useStore } from '@tramvai/state';import { createReducer } from '@tramvai/state'; const userReducer = createReducer('user', { id: '123' }); export const Component = () => { const { id } = useStore(userReducer); return <div>{id}</div>;}; Скопировать "},{"title":"Static HTML Export","type":0,"sectionRef":"#","url":"docs/features/static-html-export","content":"","keywords":""},{"title":"Explanation","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#explanation","content":"tramvai static <appName> command run production build of the application, then starts application server, and make requests to all application routes. All responses are saved to .html files inside dist/static directory. This feature is suitable for applications where all pages are independent of dynamic server-side data. You can serve exported HTML files without tramvai server by CDN or any static server. "},{"title":"Usage","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#usage","content":""},{"title":"Development","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#development","content":"Run command to export HTML pages with --serve flag: tramvai static <appName> --serve Скопировать Open server with exported pages at http://localhost:3000/ "},{"title":"Production","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#production","content":"Run command to export HTML pages: tramvai static <appName> Скопировать Deploy HTML pages to your server and static assets to your CDN "},{"title":"Static Assets","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#static-assets","content":"All static resources (js, css files) will be loaded according to the url specified in ASSETS_PREFIX env variable. "},{"title":"Limitations","type":1,"pageTitle":"Static HTML Export","url":"docs/features/static-html-export#limitations","content":"Dynamic pages (routes like /foo/bar/:id) is not supported, tramvai static command only show warnings for this pages. "},{"title":"Project structure","type":0,"sectionRef":"#","url":"docs/get-started/app-structure","content":"","keywords":""},{"title":"Repository type","type":1,"pageTitle":"Project structure","url":"docs/get-started/app-structure#repository-type","content":"Multirepo# The repository structure is designed for one application root-directory├── tramvai.json - project configuration for `@tramvai/cli`├── env.development.js - environment variables used for local builds of the project└── src - application code directory └── App block Скопировать Monorepo# The repository structure is designed for the presence of several applications, and separate shared libraries root-directory├── tramvai.json - project configuration for `@tramvai/cli`├── env.development.js - environment variables used for local builds of the project├── apps - directory with applications│ ├── App block│ ├── App block└── packages - a directory with various libraries / modules that will be shared between applications ├── Lib block └── Lib block Скопировать "},{"title":"Blocks","type":1,"pageTitle":"Project structure","url":"docs/get-started/app-structure#blocks","content":"Application# app-directory├── index.ts - application entry point, where all tramvai modules are connected├── vendor.ts - file with vendor dependencies, will be extracted into a separate js chunk├── polyfill.ts - polyfills used by the application (absent by default)├── postcss.js - postcss configuration object ├── shared - reused modules of the application└── routes - application pages Скопировать "},{"title":"Additional links","type":1,"pageTitle":"Project structure","url":"docs/get-started/app-structure#additional-links","content":"The following links provide detailed definitions of terms bundle, module and a description of the settings tramvai.json ModuleBundleTramvai CLI settings "},{"title":"Список обязательных модулей","type":0,"sectionRef":"#","url":"docs/get-started/core-modules","content":"","keywords":""},{"title":"Подключение нового модуля","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#подключение-нового-модуля","content":"Подключение модуля в приложение состоит из двух шагов: Установка модуля# npm install @tramvai/module-common Скопировать Добавление в приложение# import { CommonModule } from '@tramvai/module-common'; createApp({ name: 'new-app', modules: [ CommonModule, // ... ], // ...}); Скопировать "},{"title":"CommonModule","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#commonmodule","content":"Самый основной модуль, который должен подключаться всегда и при этом должен быть выставлен самым первым в списке модулей (позиция модуля определяет приоритет провайдеров попадающих в DI - чем модуль ниже тем выше приоритет его провайдеров, поэтому наличие CommonModule в качестве первого модуля позволит другим модулям переопределить какую-либо базовую функциональность tramvai). Содержит в себе: реализацию экшеновменеджер бандловменеджер кешей в приложениираннер коммандрегистр компонентов приложенияконтекстбазовый логгерменеджер модулейpubsubменеджер запроса и ответа на сервереstate-manager "},{"title":"RenderModule","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#rendermodule","content":"Модуль отвечающий за рендер приложения. Рендерит приложение React на сервере и полностью собирает html-страницу. На клиенте гидрирует верстку при первом рендере и обновляет рендер при изменениях роута приложения. "},{"title":"RouterModule","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#routermodule","content":"Роутинг приложения: позволяет получить информацию о текущем роуте, делать спа-переходы и т.п. Используется другими модулями для своей работы (например, RenderModule использует его для определения какие компоненты надо сейчас рендерить). Позволяет задавать фиксированные роуты в приложении через метод RouterModule.forRoot. Если фиксированные роуты не заданы, то для работы потребуется модуль ApiClientModule для загрузки данных из админки. "},{"title":"ServerModule","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#servermodule","content":"Модуль стартующий сервер на основе express. Также добавляет работу с papi методами "},{"title":"HttpClientModule","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#httpclientmodule","content":"Модуль для работы с HTTP запросами. "},{"title":"ErrorIntercepterModule (optional)","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#errorinterceptermodule-optional","content":"Добавляет перехват глобальных ошибок и логгирование таких ошибок. "},{"title":"LogModule (optional)","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#logmodule-optional","content":"Не является обязательным т.к. заменяет реализацию из CommonModule. Однако с этим модулем логи будут лучше форматироваться, фильтроваться и будет возможность отправлять логи с клиента на апи логов. "},{"title":"SeoModule (optional)","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#seomodule-optional","content":"Добавляет мета теги на страницу, на основании роута или явно заданных данных в приложении. "},{"title":"CacheWarmupModule (optional)","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#cachewarmupmodule-optional","content":"Модуль для прогрева кешей на сервере при запуске приложения в проде. "},{"title":"Дополнительные ссылки","type":1,"pageTitle":"Список обязательных модулей","url":"docs/get-started/core-modules#дополнительные-ссылки","content":"Следующие ссылки содержат описания терминов экшен, внедрение зависимостей и управление состоянием ЭкшенDependency InjectionState management "},{"title":"Tramvai integration","type":0,"sectionRef":"#","url":"docs/features/state/tramvai-integration","content":"","keywords":""},{"title":"Провайдеры","type":1,"pageTitle":"Tramvai integration","url":"docs/features/state/tramvai-integration#провайдеры","content":"Модуль @tramvai/module-common подключает StateModule, который делает доступным в приложении провайдер STORE_TOKEN, реализующий все возможности управления стейтом: type Store = { dispatch(event); subscribe(listener); subscribe(reducer, listener); getState(); getState(reducer);} Скопировать "},{"title":"Изменение состояния","type":1,"pageTitle":"Tramvai integration","url":"docs/features/state/tramvai-integration#изменение-состояния","content":"Метод store.dispatch() используется для изменения состояния, например: import { commandLineListTokens } from '@tramvai/core';import { createEvent, createReducer } from '@tramvai/state';import { STORE_TOKEN } from '@tramvai/tokens-common'; const incEvent = createEvent('inc');const countReducer = createReducer('count', 0).on(inc, (state) => state + 1); const provider = { provide: commandLineListTokens.resolveUserDeps, multi: true, useFactory: ({ store }) => { return function updateCountReducer() { store.dispatch(incEvent()); }; }, deps: { store: STORE_TOKEN, },} Скопировать "},{"title":"Чтение состояния","type":1,"pageTitle":"Tramvai integration","url":"docs/features/state/tramvai-integration#чтение-состояния","content":"Метод store.getState() используется для получения общего состояния, или состояния конкретного редьюсера. Использование store.getState(reducer) не подходит для опциональных сторов - если вы не уверены, что стор подключается в приложении напрямую или через модули, используйте const { storeName = defaultValue } = store.getState() Пример: import { commandLineListTokens } from '@tramvai/core';import { createEvent, createReducer } from '@tramvai/state';import { STORE_TOKEN } from '@tramvai/tokens-common'; const userReducer = createReducer('user', {}); const provider = { provide: commandLineListTokens.resolveUserDeps, multi: true, useFactory: ({ store }) => { return function readUserState() { // { user: {} } - получаем все состояние const state = store.getState(); // user: {} - получаем состояние конкретного редьюсера const user = store.getState(userReducer); }; }, deps: { store: STORE_TOKEN, },} Скопировать "},{"title":"Подписка","type":1,"pageTitle":"Tramvai integration","url":"docs/features/state/tramvai-integration#подписка","content":"Метод store.subscribe() используется для подписки на изменение глобального состояния, например: import { commandLineListTokens } from '@tramvai/core';import { createEvent, createReducer } from '@tramvai/state';import { STORE_TOKEN } from '@tramvai/tokens-common'; const incEvent = createEvent('inc');const countReducer = createReducer('count', 0).on(inc, (state) => state + 1); const provider = { provide: commandLineListTokens.resolveUserDeps, multi: true, useFactory: ({ store }) => { return function listenCountState() { let currentState = store.getState(countReducer); const unsubscribe = store.subscribe((nextGlobalState) => { const nextState = store.getState(countReducer); if (currentState !== nextState) { console.log('count reducer state is:', currentState); currentState = nextState; } }); setInterval(() => { store.dispatch(incEvent()); }, 1000); }; }, deps: { store: STORE_TOKEN, },} Скопировать Или для подписки на изменение состояния конкретного редьюсера: import { commandLineListTokens } from '@tramvai/core';import { createEvent, createReducer } from '@tramvai/state';import { STORE_TOKEN } from '@tramvai/tokens-common'; const incEvent = createEvent('inc');const countReducer = createReducer('count', 0).on(inc, (state) => state + 1); const provider = { provide: commandLineListTokens.resolveUserDeps, multi: true, useFactory: ({ store }) => { return function listenCountState() { const unsubscribe = store.subscribe(countReducer, (nextState) => { console.log('count reducer state is:', nextState); }); setInterval(() => { store.dispatch(incEvent()); }, 1000); }; }, deps: { store: STORE_TOKEN, },} Скопировать "},{"title":"Экшены","type":1,"pageTitle":"Tramvai integration","url":"docs/features/state/tramvai-integration#экшены","content":"Модуль @tramvai/module-common подключает в приложении провайдер CONTEXT_TOKEN, которые помимо работы с состоянием (под капотом используется STORE_TOKEN), позволяет запускать экшены: type ConsumerContext = { executeAction(action, payload); dispatch(event); subscribe(listener); getState(); getState(reducer);} Скопировать Пример использования контекста: import { createAction } from '@tramvai/core';import { createEvent, createReducer } from '@tramvai/state'; const loadUser = createEvent('load user');const userReducer = createReducer('user', { name: 'anonymus' }); userReducer.on(loadUser, (state, payload) => payload); const fetchUserAction = createAction({ name: 'fetchUser', fn: async (context, payload, { httpClient }) => { const { name } = context.getState(userReducer); if (name !== 'anonymus') { return; } const response = await httpClient.get('/user'); context.dispatch(loadUser(response.payload)); }, deps: { httpClient: HTTP_CLIENT, },}); Скопировать "},{"title":"Создаем приложение на tramvai","type":0,"sectionRef":"#","url":"docs/get-started/create-app","content":"","keywords":""},{"title":"Настройка системы","type":1,"pageTitle":"Создаем приложение на tramvai","url":"docs/get-started/create-app#настройка-системы","content":"Для работы tramvai и @tramvai/cli необходим NodeJS версии 10+ "},{"title":"Установка tramvai CLI","type":1,"pageTitle":"Создаем приложение на tramvai","url":"docs/get-started/create-app#установка-tramvai-cli","content":"Мы будем использовать tramvai CLI для генерации нового проекта и запуска в режиме разработки npm i @tramvai/cli -g Скопировать После этого в терминале будет доступна команда tramvai "},{"title":"Генерация приложения","type":1,"pageTitle":"Создаем приложение на tramvai","url":"docs/get-started/create-app#генерация-приложения","content":"Теперь нам нужно сгенерировать приложение с помощью tramvai tramvai new new-app Скопировать После запуска, необходимо выбрать настройки - шаблон проекта, настройки CI и пакетный менеджер. Для быстрого старта подойдут настройки по умолчанию. Затем команда сгенерирует в директории new-app стартовый проект с базовыми модулями "},{"title":"Запуск приложения","type":1,"pageTitle":"Создаем приложение на tramvai","url":"docs/get-started/create-app#запуск-приложения","content":"Теперь нам нужно запустить наш проект в режиме разработки, для удобной разработки и проверки, что наш проект работает. Для этого выполняем команду cd new-app && npm start Скопировать Эта команда запустит в dev режиме сервер который будет следить за серверным и клиентским кодом. После выполнения команды можно зайти по адресу http://localhost:3000/ и увидеть поднятое чистое приложение "},{"title":"Разбора структуры проекта и процесса инициализации приложения","type":1,"pageTitle":"Создаем приложение на tramvai","url":"docs/get-started/create-app#разбора-структуры-проекта-и-процесса-инициализации-приложения","content":"Стартовой точкой проекта является src/index.ts, который создает экземпляр tramvai приложения и подключает необходимые для работы модули. В проекте уже подключены базовые модули, которые реализуют следующий функционал: Получение роутов (из админки или статичных роутов)Рендеринг приложения на сервере и клиентеЗапуск сервера для приложенияПредоставление сервисов для работы с внешними\\внутренним API При этом не обязательно использовать модули из базового набора tramvai, можно написать свои реализации которые реализуют интерфейсы базовых модулей При старте приложения происходит инициализация зависимостей модули и начинают выполнятся команды из цепочки действий, во время которых происходят запросы данных из API, рендеринг, etc. "},{"title":"Дополнительные ссылки","type":1,"pageTitle":"Создаем приложение на tramvai","url":"docs/get-started/create-app#дополнительные-ссылки","content":"По ссылкам можно ознакомиться со структурой проекта и базовыми модулями, необходимыми для полноценной работы приложения. Структура проектаОбязательные модули "},{"title":"Введение в документацию","type":0,"sectionRef":"#","url":"docs/get-started/overview","content":"","keywords":""},{"title":"Первые шаги","type":1,"pageTitle":"Введение в документацию","url":"docs/get-started/overview#первые-шаги","content":"Для первого знакомства с фреймворком рекомендуется пройти урок Создаем приложение на Tramvai "},{"title":"Погружение в tramvai","type":1,"pageTitle":"Введение в документацию","url":"docs/get-started/overview#погружение-в-tramvai","content":"Познакомиться с концепциями, которые лежат в основе фреймворка, можно в разделе Основные концепции "},{"title":"Основные возможности","type":1,"pageTitle":"Введение в документацию","url":"docs/get-started/overview#основные-возможности","content":"Узнать больше о возможностях фреймворка можно в разделе Возможности "},{"title":"Джедайские техники","type":1,"pageTitle":"Введение в документацию","url":"docs/get-started/overview#джедайские-техники","content":"Гайды и рецепты для решения самых популярных задач расположены в разделе Рецепты "},{"title":"Справочник API","type":1,"pageTitle":"Введение в документацию","url":"docs/get-started/overview#справочник-api","content":"Справочник API фреймворка, документация к встроенным модулям и библиотекам расположены в разделе API "},{"title":"Tramvai CLI","type":1,"pageTitle":"Введение в документацию","url":"docs/get-started/overview#tramvai-cli","content":"Документация к Tramvai CLI находится на странице CLI "},{"title":"Оптимизация бандла","type":0,"sectionRef":"#","url":"docs/guides/bundle-optimization","content":"","keywords":""},{"title":"Code Splitting","type":1,"pageTitle":"Оптимизация бандла","url":"docs/guides/bundle-optimization#code-splitting","content":"Предоставление клиенту минимально необходимого JavaScript кода является одной из самый важных вещей в оптимизации web-приложений. Разделение точек входа при сборке бандлов и динамический import модулей, и использование этих банлов на основе роутинга / пользовательских действий - основные механизмы разделения кода. При сборке множества бандлов и динамических чанков возникает проблема дублирования кода между ними, которую позволяет решить SplitChunksPlugin Tramvai приложения имеют ряд особенностей - единая точнка входа (platform.js на выходе), динамический импорт на уровне каждого bundle, отдельная сборка vendor чанка. Для приложения, имеющего несколько tramvai бандлов под разные страницы, каждая страница будет загружать как минимум чанк platform.js с общим кодом фреймворка и модулей, и чанк {bundleName}.js с уникальным кодом для страницы. Дубликаты могут быть в чанках, созданных под tramvai бандлы (например компоненты ui-kit), и этот код желательно вынести в общие чанки. CLI предлагает три стратегии для разделения кода - один общий common чанк, множество granular чанков, и отключение SplitChunksPlugin. "},{"title":"Отключение SplitChunksPlugin","type":1,"pageTitle":"Оптимизация бандла","url":"docs/guides/bundle-optimization#отключение-splitchunksplugin","content":"Для приложений, которые имеют только один tramvai бандл на все страницы, либо разделяют бандл для десктопной и мобильной версии, в большинстве случаев не требуется разделение кода, и стоит выставить опцию \"commonChunk\": false: { \"projects\": { \"{appName}\": { \"commands\": { \"build\": { \"configurations\": { \"commonChunk\": false } } } } }} Скопировать Почему не оставить common чанк, если он не мешает? Проблема в сторонных библиотеках, которые могут использовать динамический import под капотом, при этом приложение может не использовать этот код, но он может попасть в common чанк, который будет загружаться на каждой странице. Также, если приложение обслуживает множество страниц, и разделяет код на уровне page компонентов через @tramvai/react lazy, имеет смысл рассмотреть другие стратегии, т.к. появятся дубликаты в динамических чанках страниц. "},{"title":"Common Chunk","type":1,"pageTitle":"Оптимизация бандла","url":"docs/guides/bundle-optimization#common-chunk","content":"Стратегия включена в CLI по умолчанию, весь общий код из бандлов и динамических чанков выносится в common-chunk.js. Параметр commonChunkSplitNumber позволяет указать, какое минимальное количество чанков должно использовать этот код, что бы вынести его в common. Для приложений с большим количеством бандлов, common-chunk.js может включать огромное количество кода, которое не нужно на каждой отдельной странице, и стоит либо увеличить commonChunkSplitNumber, либо использовать стратегию Granular Chunks. Пример конфигурации для увеличения минимального количества чанков, использующих общий код: { \"projects\": { \"{appName}\": { \"commands\": { \"build\": { \"configurations\": { \"commonChunkSplitNumber\": 5 } } } } }} Скопировать Как выбрать подходящее число commonChunkSplitNumber? Как вариант, число можно вычислить по формулам commonChunkSplitNumber = bundles / 3 или commonChunkSplitNumber = bundles / 2, где bundles - это количество tramvai бандлов, которые подключаются в конкретное приложение, но скорее всего каждое приложение будет лучше рассматривать отдельно. "},{"title":"Granular Chunks","type":1,"pageTitle":"Оптимизация бандла","url":"docs/guides/bundle-optimization#granular-chunks","content":"Подробное описание использования стратегии в Next.js и Gatsby.js Стратегия включается через параметр granularChunks, позволяет вынести общий код во множество мелких чанков, для эффективного кэширования общего кода, и загрузки на каждую страницу только нужного кода. Баланс достигается за счет того, что общий код как минимум между двумя (настройки по умолчанию) чанками выносится в отдельный чанк с уникальным именем, и таких чанков будет от одного на все остальные, до одного на каждые два чанка. Недостатки этой стратегии: на одну страницу может загружаться значительно больше js скриптов, до нескольких десятков, что не значительно влияет на производительность при использовании HTTP/2; и менее эффективная gzip/brotli архивация, что не так заметно по сравнению с уменьшением количества исходного кода. Параметр granularChunksSplitNumber позволяет переопределить число общих чанков по умолчанию (2), если по каким-то причинам необходимо уменьшить количество итоговых чанков: { \"projects\": { \"{appName}\": { \"commands\": { \"build\": { \"configurations\": { \"granularChunks\": true, \"granularChunksSplitNumber\": 3 } } } } }} Скопировать "},{"title":"Deploy приложения","type":0,"sectionRef":"#","url":"docs/guides/deploy","content":"","keywords":""},{"title":"Общее","type":1,"pageTitle":"Deploy приложения","url":"docs/guides/deploy#общее","content":"Tramvai это обычное node.js приложение которое можно запустить стандартными инструментами доступными в node.js комьюнити. Ограничения только накладываются на файловую структуру и необходимости передать ENV переменные приложению "},{"title":"Список действий необходимых для деплоя приложения","type":1,"pageTitle":"Deploy приложения","url":"docs/guides/deploy#список-действий-необходимых-для-деплоя-приложения","content":"собрать приложение в продакшен режимезалить ассетысбилдить докер контейнер с файлами приложениязапустить, передав ENV переменные "},{"title":"Сборка проекта","type":1,"pageTitle":"Deploy приложения","url":"docs/guides/deploy#сборка-проекта","content":"Для сборки проекта необходимо использовать команду (перед этим установив зависимости в проекте) tramvai build APP_ID Скопировать в APP_ID необходимо передать идентификатор приложения. После выполнения команды появится директория dist с файлами сборки сервера и клиентского кода "},{"title":"Создание докер контейнера","type":1,"pageTitle":"Deploy приложения","url":"docs/guides/deploy#создание-докер-контейнера","content":"Рекомендуемый Dockerfile FROM node:14-buster-slimWORKDIR /appCOPY dist/server /app/COPY package.json /app/ENV NODE_ENV='production' EXPOSE 3000CMD [ \"node\", \"--max-http-header-size=80000\", \"/app/server.js\" ] Скопировать FROM - можете поставить 14+ версию ноды, желательно alpine версию для снижения размера "},{"title":"Заливки клиенской статики","type":1,"pageTitle":"Deploy приложения","url":"docs/guides/deploy#заливки-клиенской-статики","content":"Рекомендуемый способ это заливка файлов на CDN, так как node.js не очень хорошо справляется с раздачей статики, так и будет большой трафик для нашей инфрастуктуры. По этому для продакшен приложений, которые будут использовать клиенты, стоит всегда испольвать CDN. Для этого, содержимое папки dist/client заливаете на CDN по выбранному вами способу, получается URL по которому будут доступны файлы и подставляете этот урл в ENV переменную ASSETS_PREFIX например ASSETS_PREFIX=https://cdn-domain.com/my-awesome-app/ Если вам не нужен CDN, то можете посмотреть ниже в пункте \"Запуск приложения без клиентского CDN\", стоит использовать для тестовых стендов или не нагруженных приложений "},{"title":"Деплой приложения","type":1,"pageTitle":"Deploy приложения","url":"docs/guides/deploy#деплой-приложения","content":"Приложение запускается как обычный node.js процес командой node, при запуске необходимо передать все необходимые ENV переменные (список ENV зависит от используемых модулей приложением). Если не добавить ENV переменные - то приложение не запустится. Не забудьте про переменную ASSETS_PREFIX "},{"title":"Explanation","type":1,"pageTitle":"Deploy приложения","url":"docs/guides/deploy#explanation","content":""},{"title":"Пробы","type":1,"pageTitle":"Deploy приложения","url":"docs/guides/deploy#пробы","content":"Если вы деплоетесь в kubernetes, то для этих кейсов есть специальные урлы для проб которые необходимо использовать /healthz - после старта приложения всегда отдает ответ OK/readyz - после старта приложения всегда отдает OK "},{"title":"Запуск приложения без клиентского CDN","type":1,"pageTitle":"Deploy приложения","url":"docs/guides/deploy#запуск-приложения-без-клиентского-cdn","content":"В трамвай встроен сервер отдачи статики. Так лучше не делать, по той причине что nodeJS не лучший инструмент для этого и статика будет влиять на приложение. В общем виде все то же самое как и при обычном деплое, но необходимо добавить копирование ассетов пользователя, в docker образ, для этого: добавить копирование файлов COPY dist/client /app/public/staticsизменить ENV переменную ASSETS_PREFIX Пример готового Dockerfile FROM node:14-buster-slimWORKDIR /appCOPY dist/server /app/COPY package.json /app/COPY dist/client /app/public/staticsENV NODE_ENV='production' EXPOSE 3000CMD [ \"node\", \"--max-http-header-size=80000\", \"/app/server.js\" ] Скопировать При запуске приложения необходимо передать ASSETS_PREFIX=/statics/. При старте приложения поднимется сервер отдачи статитики и будет доступны все файлы внутри директории /public/. Тем самым клиент сможет получить данные по урлу /statics/payment.js "},{"title":"Локальный запуск в docker контейнере","type":1,"pageTitle":"Deploy приложения","url":"docs/guides/deploy#локальный-запуск-в-docker-контейнере","content":"На устройстве должен быть установлен https://www.docker.com/products/docker-desktop и выполняться команда docker run hello-world Собираем проект в продакшен режиме, у нас появится артифакт в директории dist# yarn build Скопировать Собираем докер образ приложения# docker build -t test/myapp . Скопировать Запускаем собранный образ# docker run --rm -e DANGEROUS_UNSAFE_ENV_FILES='true' -e ASSETS_PREFIX='http://localhost:4000/static/' -v ${PWD}/env.development.js:/app/env.development.js -v ${PWD}/dist/client:/app/static -e DEV_STATIC=true -p 3000:3000 -p 4000:4000 -d test/myapp Скопировать Для остановки контейнера нужно получить CONTAINER ID, выполним команду docker ps и далее выполнить команду docker stop <CONTAINER ID> Для остановки всех контейнеров# docker kill $(docker ps --quiet) Скопировать "},{"title":"Создание tramvai библиотеки","type":0,"sectionRef":"#","url":"docs/guides/tramvai-library","content":"","keywords":""},{"title":"Предпосылки","type":1,"pageTitle":"Создание tramvai библиотеки","url":"docs/guides/tramvai-library#предпосылки","content":"Рассмотрим все важные кейсы на примере создания нового tramvai модуля. Допустим, модуль будет предоставлять новый HTTP клиент для работы с API Github. "},{"title":"Название пакета","type":1,"pageTitle":"Создание tramvai библиотеки","url":"docs/guides/tramvai-library#название-пакета","content":"Крайне не рекомендуется использовать скоупы @tramvai и @tramvai-tinkoff вне репозитория tramvai. Если наше приложение называется tincoin, можно например выбрать один из таких скоупов: @tincoin@tramvai-tincoin@tincoin-core Для модулей, как правило используется префикс module-, например: @tramvai-tincoin/module-github-api-client "},{"title":"Версионирование","type":1,"pageTitle":"Создание tramvai библиотеки","url":"docs/guides/tramvai-library#версионирование","content":"Выбор стратегии версионирования исключительно за вами. Мы определенно рекомендуем следовать semver, и можем рекомендовать использовать сквозное версионирование, если: вы поддерживаете монорепу с core библиотекамиэти библиотеки могут быть связаны между собойи эти пакеты используются в приложениях все вместе (или большинство из них) "},{"title":"Dependencies","type":1,"pageTitle":"Создание tramvai библиотеки","url":"docs/guides/tramvai-library#dependencies","content":"Работа с зависимостями у библиотек - не простая задача, и не имеет идеального решения, но есть ряд советов, упрощающих управление зависимостями. Лучше всего начать с разделения зависимостей на различные типы: Framework# Пример таких зависимостей - react и react-dom, @tramvai/* и @tramvai-tinkoff/*. Если мы пишем babel или eslint плагин, то это могут быть @babel/core и eslint. Как правило, конечный пользователь, например tramvai приложение, обязано устанавливать фреймворк зависимости, без них оно просто не будет работать. Поэтому наша библиотека должна устанавливать их в peerDependencies, с максимально свободными версиями, например если пакет завязан на базовый функционал tramvai, и использует React хуки: { \"peerDependencies\": { \"@tramvai/core\": \"*\", \"react\": \">=16.8\", \"react-dom\": \">=16.8\" }} Скопировать Singleton# Ряд зависимостей должен быть строго один в приложении. Любые дубликаты это минус, т.к. увеличивают вес бандла приложения, но такие библиотеки как react или @tinkoff/logger требуют быть в единственном экземпляре в нашем приложении. Для них действует правило как с framework, надо устанавливать их в peerDependencies, с максимально свободными версиями: { \"peerDependencies\": { \"@tinkoff/logger\": \"*\" }} Скопировать Popular# Многие пакеты достаточно популярны, и большая вероятность, что они уже используются в конечном приложении. Пример таких зависимостей - date-fns, lru-cache, @tinkoff/dippy Для них действует правило как с framework, надо устанавливать их в peerDependencies, с максимально свободными версиями: { \"peerDependencies\": { \"@tinkoff/dippy\": \"*\", \"date-fns\": \">=2\", \"lru-cache\": \"*\" }} Скопировать Specific# Допустим, наш новый tramvai модуль поставляет в приложение уникальный функционал, для которого требуется сторонняя библиотека (или даже другой пакет в вашей монорепе) Если мы разрабатываем сервис для работы с API Github, это может быть пакет @octokit/rest. В таком случае, нужно ставить библиотеку в dependencies, и можно оставить стандартный range с помощью ^: { \"dependencies\": { \"@octokit/rest\": \"^18.0.0\" }} Скопировать Development# Завимость может участвовать в сборке вашего пакета - например rollup или @tramvai/build. Зависимость требуется для запуска тестов библиотеки. Зависимость содержит необходимые для сборки тайпинги. Во всех этих случаях, даже если либа уже есть в peerDependencies, стоит добавить более конкретную версию в devDependencies, например: { \"devDependencies\": { \"@tramvai/build\": \"^2.5.0\", \"@types/react\": \"^17.0.0\", \"react\": \"^17.0.0\" }} Скопировать Исключения# Конечно, есть исключительные кейсы. Например, tramvai предоставляет множество тестовых утилит, где все основные @tramvai зависимости были в peerDependencies. Как только эти утилиты начали использовать не в репозиториях с приложениями, а в монорепах с core пакетами, появилась проблема отсутствующих зависимостей, и мы перенесли почти все из peerDependencies в dependencies Действуйте по ситуации, и всегда думайте об удобстве использования вашего продукта :) "},{"title":"Сборка","type":1,"pageTitle":"Создание tramvai библиотеки","url":"docs/guides/tramvai-library#сборка","content":"Предполагается, что итоговую сборку пакетов в контексте приложения будет осуществлять @tramvai/cli. Поэтому, для публикации пакетов, написанных на TypeScript, достаточно использовать tsc, и публиковать множество собранных .js и .d.ts файлов. Но сборка пакетов в бандлы перед публикацией, например через rollup или @tramvai/build, дает ряд возможностей: предварительный tree-shaking отсечет все лишнее, это положительно скажется на сборке приложенияможно сделать несколько бандлов для разного окружения, в CJS или ES modules форматахможно сделать отдельный бандл для браузерной сборки, отдельный для серверной - топ для библиотек с поддержкой SSR  Подробная документация про использование @tramvai/build доступна в документации "},{"title":"Разделение кода для сервера и клиента","type":0,"sectionRef":"#","url":"docs/guides/universal","content":"","keywords":""},{"title":"Код приложения","type":1,"pageTitle":"Разделение кода для сервера и клиента","url":"docs/guides/universal#код-приложения","content":"Для выполнения веток кода или в определенных окружения, можно использовать несколько проверок: process.env# При сборке проекта tramvai cli проставляет две переменные, указывающие на окружение - process.env.SERVER и process.env.BROWSER. Webpack автоматически удалит код с условием, не соответствующим текущему окружению, например следующий код не попадет в серверный бандл: if (process.env.BROWSER) { console.log(window.innerWidth, window.innerHeight);} Скопировать Для исключения кода из production сборки, независимо от окружения, можно использовать переменную process.env.NODE_ENV: if (process.env.NODE_ENV === 'development') { console.log('отладочная информация');} Скопировать Для исключения импортируемых библиотек из сборки требуется замена верхнеуровневых import на require внутри условия: if (process.env.BROWSER) { const logger = require('@tinkoff/logger'); const log = logger('debug'); log.info(window.location.href);} Скопировать typeof window# Для дополнительных оптимизаций, используется babel плагин, который превращает typeof window из серверной сборке в 'undefined', а из клиентской - в 'object', что позволяет webpack'у вырезать лишний код, например следующее условие работает аналогично проверке process.env.BROWSER: if (typeof window !== 'undefined') { console.log(window.innerWidth, window.innerHeight);} Скопировать package.json# Если нам потребовалось заменять целый файл, а не определенные строки кода, можно вынести его в отдельную папку, описать реализацию для всех окружений, и добавить package.json: // module.server.jsexport const CONSTANT = 'SERVER_SIDE'; Скопировать // module.client.jsexport const CONSTANT = 'CLIENT_SIDE'; Скопировать Далее, в package.json надо указать бандлеру, какой код использовать для разных окружений. Поле main используется для серверного бандла, а browser для клиентского: { \"main\": \"./module.server.js\", \"browser\": \"./module.client.js\"} Скопировать "},{"title":"npm библиотеки","type":1,"pageTitle":"Разделение кода для сервера и клиента","url":"docs/guides/universal#npm-библиотеки","content":"Для создания библиотеки, реализации которой должны отличаться на сервере и клиенте, необходимо поддерживать общий интерфейс экспорта, и настроить package.json аналогично предыдущему примеру. Например, библиотека экспортирует класс Library, и константу LIBRARY_CONSTANT. Создадим две точки входа в нашу библиотеку - server.js и client.js: // server.jsexport class Library { constructor() { // ... }} export const LIBRARY_CONSTANT = 'SERVER_SIDE_LIBRARY'; Скопировать // client.jsexport class Library { constructor() { // ... }} export const LIBRARY_CONSTANT = 'CLIENT_SIDE_LIBRARY'; Скопировать Далее, в package.json надо указать бандлеру, какой код использовать для разных окружений. Поле main используется для серверного бандла, а browser для клиентского: { \"name\": \"library\", \"version\": \"0.1.0\", \"main\": \"server.js\", \"browser\": \"client.js\", \"dependencies\": { ... }} Скопировать После публикации библиотеки, можно импортировать ее в tramvai приложение, и не заботиться о том, какую именно реализацию мы получим: import { LIBRARY_CONSTANT } from 'library'; // при запуске приложения через tramvai start, увидим 'SERVER_SIDE_LIBRARY' в терминале, и 'CLIENT_SIDE_LIBRARY' в консоли браузераconsole.log(LIBRARY_CONSTANT); Скопировать "},{"title":"tramvai модули","type":1,"pageTitle":"Разделение кода для сервера и клиента","url":"docs/guides/universal#tramvai-модули","content":"Новый функционал в tramvai приложение добавляется с помощью модулей, и как правило, поведение этих модулей кардинально отличается в разных окружениях, например: Рендеринг приложения в строку на сервере и гидрация реального DOM на клиентеЗапуск https сервераИнициализация service worker'а По этой причине, в репозитории tramvai, стандартный шаблон tramvai модуля, генерируемый через команду npm run generate:module, сразу разделяет точки входа в модуль на server.js и client.js , с помощью package.json. Разберем это на примере создания модуля, который добавляет в приложение сервис для работы с cookie: Этот сервис должен иметь общий интерфейс: export interface ICookie { get(key); set(key, value);} Скопировать И разные реализации для серверного и клиентского окружения: // src/cookie.server.ts// серверная реализация требует объекты Request и Response для работы с кукамиexport class Cookie implements ICookie { constructor({ req, res }) { // ... } get(key) { // ... } set(key, value) { // ... }} Скопировать // src/cookie.client.ts// клиентская реализация обращается напрямую к объекту Windowexport class Cookie implements ICookie { get(key) { // ... } set(key, value) { // ... }} Скопировать Добавляем сервис в DI с помощью модулей: // src/server.tsimport { Module, Scope, provide } from '@tramvai/core';import { REQUEST, RESPONSE } from '@tramvai/tokens-common';import { Cookie } from './cookie.server'; @Module({ providers: [ provide({ provide: 'cookie', useClass: Cookie, scope: Scope.REQUEST, deps: { req: REQUEST, res: RESPONSE, }, }), ],})export class CookieModule {} Скопировать // src/client.tsimport { Module, Scope, provide } from '@tramvai/core';import { Cookie } from './cookie.client'; @Module({ providers: [ provide({ provide: 'cookie', useClass: Cookie, scope: Scope.SINGLETON, }), ],})export class CookieModule {} Скопировать Настраиваем package.json: { \"name\": \"@tramvai/module-cookie\", \"version\": \"0.1.0\", \"main\": \"lib/server.js\", \"browser\": \"lib/client.js\", \"dependencies\": { ... }} Скопировать После импорта модуля в приложение, мы получаем универсальный доступ к cookies, и не думаем про окружение, при использовании: import { createApp, commandLineListTokens, provide } from '@tramvai/core';import { CookieModule } from '@tramvai/module-cookie'; createApp({ name: 'app', modules: [ // ... CookieModule, ], providers: [ // ... provide({ provide: commandLineListTokens.init, useFactory: ({ cookie }) => { console.log('wuid', cookie.get('wuid')); }, deps: { cookie: 'cookie', }, }), ], // ...}); Скопировать "},{"title":"Execution of actions depending on conditions","type":0,"sectionRef":"#","url":"docs/how-to/actions-conditions","content":"","keywords":""},{"title":"Использование предустановленных ограничений","type":1,"pageTitle":"Execution of actions depending on conditions","url":"docs/how-to/actions-conditions#использование-предустановленных-ограничений","content":"Допустим, мы хотим выполнять один экшен только на сервере, и один только на клиенте, для этого есть ограничители onlyServer и onlyBrowser:  Создаем экшены import { createAction } from '@tramvai/core';import { set } from '../store'; export const innerAction = createAction({ name: 'innerAction', fn: (context) => { console.log('execute innerAction'); return context.dispatch(set('innerAction')); }, // conditions not set - the action will be executed by default: // if the action is defined as global (in an application, bundle or page), // then the action will first try to execute on the server - if it succeeds, then it will not be executed again on the client // if the action did not manage to be executed within the limit, then it will be launched on the client, // repeated launches when switching to the page with this action will not be executed, because the last successful execution is remembered // if the action is called explicitly through the context, then such an action will always be executed (the execution limit still affects, // and the data may not always be available with ssr, but the action will always try to execute)}); export const innerServerAction = createAction({ name: 'innerServerAction', fn: (context) => { console.log('execute innerServerAction'); return context.dispatch(set('innerServerAction')); }, // this action can only be executed on the server conditions: { onlyServer: true, },}); export const innerBrowserAction = createAction({ name: 'innerBrowserAction', fn: (context) => { console.log('execute innerBrowserAction'); return context.dispatch(set('innerBrowserAction')); }, // this action can only be executed on the browser conditions: { onlyBrowser: true, },}); Скопировать   Используем экшены import { createAction } from '@tramvai/core';import { set } from '../store';import { innerAction, innerBrowserAction, innerServerAction } from './inner'; export const pageServerAction = createAction({ name: 'pageServerAction', fn: async (context) => { console.log('execute pageServerAction'); await context.executeAction(innerAction); await context.executeAction(innerServerAction); await context.executeAction(innerBrowserAction); return context.dispatch(set('pageServerAction')); }, conditions: { pageServer: true, },}); export const pageBrowserAction = createAction({ name: 'pageBrowserAction', fn: async (context) => { console.log('execute pageBrowserAction'); await context.executeAction(innerAction); await context.executeAction(innerServerAction); await context.executeAction(innerBrowserAction); return context.dispatch(set('pageBrowserAction')); }, // this action can only be executed on the browser conditions: { onlyBrowser: true, },}); export const pageAlwaysAction = createAction({ name: 'pageAlwaysAction', fn: async (context) => { console.log('execute pageAlwaysAction'); return context.dispatch(set('pageAlwaysAction')); }, conditions: { always: true, },}); // this action is only executed in the browser, on page load and on every SPA transitionexport const pageBrowserAlwaysAction = createAction({ name: 'pageBrowserAlwaysAction', fn: async (context) => { console.log('execute pageBrowserAlwaysAction'); return context.dispatch(set('pageBrowserAlwaysAction')); }, conditions: { always: true, onlyBrowser: true, },}); Скопировать  "},{"title":"Создание своих ограничений","type":1,"pageTitle":"Execution of actions depending on conditions","url":"docs/how-to/actions-conditions#создание-своих-ограничений","content":"Для этого нужно реализовать интерфейс ActionCondition, и добавить новый ограничитель в DI, через токен ACTION_CONDITIONALS:  Создаем ограничитель import { ActionCondition } from '@tramvai/module-common';import { PAGE_SERVICE_TOKEN } from '@tramvai/tokens-router'; export const condition = ({ pageService,}: { pageService: typeof PAGE_SERVICE_TOKEN;}): ActionCondition => { return { key: 'custom', fn: (checker) => { if (checker.conditions.custom) { const { pathname } = pageService.getCurrentUrl(); console.log(pathname); if (pathname !== '/custom/') { checker.forbid(); } } }, };}; Скопировать   Создаем экшен с этим ограничителем import { createAction } from '@tramvai/core';import { set } from '../store'; export const customAction = createAction({ name: 'customAction', fn: (context) => { console.log('execute customAction'); return context.dispatch(set('customAction')); }, // you can set your own options, which are then used in their conditions checks conditions: { custom: true, },}); Скопировать  "},{"title":"Выполнение экшенов только на определенных страницах","type":1,"pageTitle":"Execution of actions depending on conditions","url":"docs/how-to/actions-conditions#выполнение-экшенов-только-на-определенных-страницах","content":"Для этого используем статическое свойство actions для компонента, который используется на этих страницах:  Компонент Page import reduceObj from '@tinkoff/utils/object/reduce';import React from 'react';import { PAGE_SERVICE_TOKEN } from '@tramvai/tokens-router';import { useSelector } from '@tramvai/state';import { useDi } from '@tramvai/react';import { store } from '../store';import { pageBrowserAction, pageServerAction, pageAlwaysAction, pageBrowserAlwaysAction,} from '../actions/page';import { customAction } from '../actions/custom'; export function Page() { const state = useSelector(store, (x) => x.actionTest); const pageService = useDi(PAGE_SERVICE_TOKEN); return ( <div> <button type=\"button\" onClick={() => pageService.navigate({ url: '/custom/' })}> Navigate To custom </button> {reduceObj( (acc, v, k) => { return acc.concat( <div> {k} loaded from {v} </div> ); }, [], state )} </div> );} Page.actions = [ pageServerAction, pageBrowserAction, pageAlwaysAction, pageBrowserAlwaysAction, customAction,]; Скопировать  "},{"title":"Подключение экшенов и ограничителей в приложении","type":1,"pageTitle":"Execution of actions depending on conditions","url":"docs/how-to/actions-conditions#подключение-экшенов-и-ограничителей-в-приложении","content":"Создаем приложение, подключающее экшены, ограничители и компоненты из предыдущих примеров:  Точка входа в приложение import { createApp, createBundle, provide } from '@tramvai/core';import { ACTION_CONDITIONALS } from '@tramvai/module-common';import { PAGE_SERVICE_TOKEN, ROUTES_TOKEN } from '@tramvai/tokens-router'; import { store } from './store';import { modules } from '../common';import { condition } from './conditions/custom';import { Page } from './components/Page'; const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, }, reducers: [store],}); createApp({ name: 'actions-conditions', modules: [...modules], providers: [ provide({ provide: ACTION_CONDITIONALS, multi: true, useFactory: condition, deps: { pageService: PAGE_SERVICE_TOKEN, }, }), provide({ provide: ROUTES_TOKEN, multi: true, useValue: { name: 'custom', path: '/custom/', }, }), ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Скопировать  "},{"title":"Как создать экшен?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-action","content":"","keywords":""},{"title":"Создание экшена","type":1,"pageTitle":"Как создать экшен?","url":"docs/how-to/how-create-action#создание-экшена","content":"Подключаем createAction и добавляем функцию по загрузки данных из api и отправки данных в store. import { createAction } from '@tramvai/core';import { loadDepositConfig } from './deposit/reducer'; export const loadDepositAction = createAction({ name: 'load-deposit-config', fn: async (context, payload, deps) => { const data = await deps.apiClient.request({ method: 'deposit_config ' }); return context.dispatch(loadDepositConfig(data)); }, deps: { apiClient: 'tinkoffApiClient', },}); Скопировать Мы создали экшен, которому требуется для работы провайдер tinkoffApiClient, этот экшен делает запрос за данными и сохраняет полученные данные в стор. "},{"title":"Выполнение для конкретной страницы","type":1,"pageTitle":"Как создать экшен?","url":"docs/how-to/how-create-action#выполнение-для-конкретной-страницы","content":"Мы создали экшен и хотим подключить его в приложение. Нам важно, что бы экшен выполнялся на сервере, и сервер дожидался выполнения. При этом данные нужны только на конкретной странице, поэтому мы добавляем его в статическое поле actions нужной страницы. import react, { Component } from 'react';import { loadDepositAction } from './loadDepositAction';import { DepositInfo } from './DepositInfo'; class DepositPage extends Component { static actions = [loadDepositAction]; render() { return ( <div> <DepositInfo /> </div> ); }} Скопировать После этого, при открытии роута пользователем, сервер автоматически запустит экшен привязанный к DepositPage и загрузится данные "},{"title":"Что еще стоит прочитать","type":1,"pageTitle":"Как создать экшен?","url":"docs/how-to/how-create-action#что-еще-стоит-прочитать","content":"О createActionКак работают экшены "},{"title":"How to split a component into an asynchronous chunk?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-async-component","content":"","keywords":""},{"title":"Component example","type":1,"pageTitle":"How to split a component into an asynchronous chunk?","url":"docs/how-to/how-create-async-component#component-example","content":"Let's say we have a heavy React component that we use occasionally and we want to load it only when needed. Right now we have the following code: // file heavy.tsxexport const Heavy = () => <div>123</div>; Скопировать // file page.tsximport Heavy from './heavy.tsx'; const Page = () => ( <> <Heavy /> <Footer /> </>); Скопировать "},{"title":"Connecting the lazy","type":1,"pageTitle":"How to split a component into an asynchronous chunk?","url":"docs/how-to/how-create-async-component#connecting-the-lazy","content":"There are several ways to split the component into asynchronous chunks Add new wrapper for heavy into page.tsx.Put heavy code into a separate file and leave only async wrapper in heavy.tsx. We'll create a new file, as this allows us not to change imports in files that have already used the Heavy component. And it will be harder to forget to reuse the async component in the future: // file heavy-component.tsxexport const Heavy = () => <div>123</div>; Скопировать // file heavy.tsximport { lazy } from '@tramvai/react'; export const Heavy = lazy(() => import('./heavy-component')); Скопировать // file page.tsximport Heavy from './heavy.tsx'; const Page = () => ( <> <Heavy /> <Footer /> </>); Скопировать We created a new file, put all the code of the Heavy component there, and left only the component itself in the old file, which we wrapped in lazy and imported the original component with import. Now instead of the original Heavy component we will have an asynchronous version which we will load only when rendering the Page component. "},{"title":"Result","type":1,"pageTitle":"How to split a component into an asynchronous chunk?","url":"docs/how-to/how-create-async-component#result","content":"The Heavy component will be loaded by demand Next, the component will be: Automatically put in a separate webpack chunkWhen rendering, SSR will automatically download the file and immediately render it on the serverJS and CSS of the chunk will be inserted into the HTML with maximum priorityIt will work seamlessly in the browser Example of work in a test application "},{"title":"How to create a bundle?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-bundle","content":"","keywords":""},{"title":"Creating a bundle","type":1,"pageTitle":"How to create a bundle?","url":"docs/how-to/how-create-bundle#creating-a-bundle","content":"We use the createBundle method and create an empty bundle, in which we write the name field, which is the unique identifier of the bundle: import { createBundle } from '@tramvai/core'; export default createBundle({ name: 'coin', components: {},}); Скопировать "},{"title":"Adding components","type":1,"pageTitle":"How to create a bundle?","url":"docs/how-to/how-create-bundle#adding-components","content":"The next step is to add the components that will be available in this bundle. We recommended to use lazy and dynamic import page components for effective code splitting. The key is the identifier of the component, this identifier can be bound to the router: import { createBundle } from '@tramvai/core';import { lazy } from '@tramvai/react'; const MainPage = lazy(() => import('../pages/main'));import Layout from '../layouts'; export default createBundle({ name: 'coin', components: { 'page/coin-main': MainPage, 'layout/coin-layout': Layout, },}); Скопировать You can register any components for different purposes. For example, we can register components of modal windows, popups and so on in the bundle. All these components will be available in the componentRegistry. "},{"title":"Connecting in the application","type":1,"pageTitle":"How to create a bundle?","url":"docs/how-to/how-create-bundle#connecting-in-the-application","content":"Now we have to register the bundle in the application. To do this we add to the bundles object of createApp: key: the identifier of the bundle. The last part must be the same as the bundle ID passed to name, a function of the form last('platform/coin'.split('/')) is used there, otherwise, there will be no loading of the bundle on the server side.value: the function that should return the promise wrapped bundle object. Usually, asynchronous webpack chunks are used, but you can also write a custom loader of regular js files. The important thing is that the name of the chunk, must be synchronized with the name identifier import { createApp } from '@tramvai/core'; createApp({ bundles: { 'platform/coin': () => import(/* webpackChunkName: \"coin\" */ './bundles/coin'), },}); Скопировать After that, we will have a bundle available in the application and after downloading it, the linked components will be available. Then we can use these components in routing Complete documentation about createBundleComplete documentation about createApp "},{"title":"Defaul bundle","type":1,"pageTitle":"How to create a bundle?","url":"docs/how-to/how-create-bundle#defaul-bundle","content":"The default bundle allows you to handle all (created via RouterModule.forRoot) urls for which no bundle is specifically set. It is done like this: Inside index.ts import { createApp } from '@tramvai/core'; createApp({ name: 'myApp', modules: [ // ... ], providers: [ // ... ], bundles: { mainDefault: () => import(/* webpackChunkName: \"mainDefault\" */ './bundles/mainDefault'), },}); Скопировать In file bundles/mainDefault.ts import { createBundle } from '@tramvai/core' import { MainPage } from '../layers/pages/MainPage'import { Layout } from '../layers/layout/Layout' export default createBundle({ name: 'mainDefault', components: { pageDefault: MainPage, layoutDefault: Layout, },}) Скопировать "},{"title":"Executing actions on different pages","type":0,"sectionRef":"#","url":"docs/how-to/actions-execution","content":"","keywords":""},{"title":"Binding actions to a specific page","type":1,"pageTitle":"Executing actions on different pages","url":"docs/how-to/actions-execution#binding-actions-to-a-specific-page","content":"To do this, you can use the static property actions of page components:  Creating actions import { createAction } from '@tramvai/core';import { ACTION_EXECUTION_LIMIT } from '../constants';import { set } from '../store'; export const pageInLimit = createAction({ name: 'pageInLimit', fn: async (context) => { console.log('execute pageInLimit'); await context.dispatch(set({ name: 'pageInLimit', value: false })); await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT / 2)); await context.dispatch(set({ name: 'pageInLimit', value: true })); },}); export const pageOutLimit = createAction({ name: 'pageOutLimit', fn: async (context) => { console.log('execute pageOutLimit'); await context.dispatch(set({ name: 'pageOutLimit', value: false })); await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT * 2)); await context.dispatch(set({ name: 'pageOutLimit', value: true })); },}); Скопировать   Connecting actions to the page import reduceObj from '@tinkoff/utils/object/reduce';import React from 'react';import { useSelector } from '@tramvai/state';import { store } from '../store';import { pageInLimit, pageOutLimit } from '../actions/page'; export function Page() { const state = useSelector(store, (x) => x.actionTest); return ( <div> {reduceObj( (acc, v, k) => { return acc.concat( <div> {k} = {v.toString()} </div> ); }, [], state )} </div> );} // actions can be specified as a static property of a page component// in this case actions will be executed only on pages with this particular pageComponentPage.actions = [pageInLimit, pageOutLimit]; Скопировать  "},{"title":"Binding actions to a bundle","type":1,"pageTitle":"Executing actions on different pages","url":"docs/how-to/actions-execution#binding-actions-to-a-bundle","content":"Bundles allow you to group pages, you can bind actions to them, which will be executed for each page of the bundle:  Creating actions import { createAction } from '@tramvai/core';import { ACTION_EXECUTION_LIMIT } from '../constants';import { set } from '../store'; export const bundleInLimit = createAction({ name: 'bundleInLimit', fn: async (context) => { console.log('execute bundleInLimit'); await context.dispatch(set({ name: 'bundleInLimit', value: false })); await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT / 2)); await context.dispatch(set({ name: 'bundleInLimit', value: true })); },}); export const bundleOutLimit = createAction({ name: 'bundleOutLimit', fn: async (context) => { console.log('execute bundleOutLimit'); await context.dispatch(set({ name: 'bundleOutLimit', value: false })); await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT * 2)); await context.dispatch(set({ name: 'bundleOutLimit', value: true })); },}); Скопировать   Connecting actions to the bundle import { createBundle } from '@tramvai/core';import { store } from '../store';import { bundleInLimit, bundleOutLimit } from '../actions/bundle';import { Page } from '../components/Page'; export const mainDefault = createBundle({ name: 'mainDefault', components: { pageDefault: Page, }, // let's specify our store, so that it will immediately initialize and subscribe to its dispatch events reducers: [store], // the actions can be specified as part of the bundle - then these actions will be executed for all pages of the bundle actions: [bundleInLimit, bundleOutLimit],}); Скопировать  "},{"title":"Common actions for the application","type":1,"pageTitle":"Executing actions on different pages","url":"docs/how-to/actions-execution#common-actions-for-the-application","content":"Actions connected to application are executed on all pages:  Creating actions import { createAction } from '@tramvai/core';import { ACTION_EXECUTION_LIMIT } from '../constants';import { set } from '../store'; export const globalInLimit = createAction({ name: 'globalInLimit', fn: async (context) => { console.log('execute globalInLimit'); await context.dispatch(set({ name: 'globalInLimit', value: false })); // set the execution delay less than the server's execution limit, so that this action will be executed in time to ssr await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT / 2)); await context.dispatch(set({ name: 'globalInLimit', value: true })); },}); export const globalOutLimit = createAction({ name: 'globalOutLimit', fn: async (context) => { console.log('execute globalOutLimit'); await context.dispatch(set({ name: 'globalOutLimit', value: false })); // set an execution delay higher than the server's execution limit, so that this action will not be executed in time with ssr await new Promise((res) => setTimeout(res, ACTION_EXECUTION_LIMIT * 2)); await context.dispatch(set({ name: 'globalOutLimit', value: true })); },}); Скопировать   Connecting actions into the application import { createApp, provide } from '@tramvai/core';import { ACTION_EXECUTION_LIMIT } from './constants';import { modules } from '../common';import { globalInLimit, globalOutLimit } from './actions/global';import { mainDefault } from './bundles/mainDefault'; createApp({ name: 'actions-execution', modules: [...modules], providers: [ provide({ // in the application you can specify a limit on the execution of actions on the server (by default 500ms) provide: 'limitActionGlobalTimeRun', useValue: ACTION_EXECUTION_LIMIT, }), ], // these actions will be executed for all pages of the application actions: [globalInLimit, globalOutLimit], bundles: { mainDefault: () => Promise.resolve({ default: mainDefault }), },}); Скопировать  "},{"title":"Как создать модуль?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-module","content":"","keywords":""},{"title":"Создаем пустой модуль","type":1,"pageTitle":"Как создать модуль?","url":"docs/how-to/how-create-module#создаем-пустой-модуль","content":"Создаем базовый модуль, для этого создаем пустой класс SecurityModule и подключаем декоратор module который необходим для модулей и в который мы будем добавлять интеграции с приложением. import { Module } from '@tramvai/core'; @Module({ providers: [],})export class SecurityModule {} Скопировать Модуль уже можно подключить в приложение, но он не будет ничего делать. "},{"title":"Добавляем провайдеры","type":1,"pageTitle":"Как создать модуль?","url":"docs/how-to/how-create-module#добавляем-провайдеры","content":"Для этого нам необходимо добавить провайдеры в поле providers. У нас была задача добавить хэдеры, для этого мы будем использовать commandLineListTokens, что бы выполнять действия для каждого клиента и будем использовать responseManager в который сможем записать информацию о хэдерах. import { Module, commandLineListTokens, RESPONSE_MANAGER_TOKEN, provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: commandLineListTokens.resolvePageDeps, multi: true, useFactory: ({ responseManager }: { responseManager: typeof RESPONSE_MANAGER_TOKEN }) => function securityHeader() { responseManager.setHeader('X-Frame-Options', 'sameorigin'); }, deps: { responseManager: RESPONSE_MANAGER_TOKEN, }, }), ],})export class SecurityModule {} Скопировать Мы реализовали новый мульти-провайдер, который имеет зависимости и создается через useFactory После подключения модуля в приложение, для каждого клиента сначала выполнится функция useFactory с переданными deps, и после этого вызовется функция securityHeader, в которой мы в полученную зависимость запишем данные, и тем самым выполним нашу цель. "},{"title":"Подключаем в приложение наш новый модуль","type":1,"pageTitle":"Как создать модуль?","url":"docs/how-to/how-create-module#подключаем-в-приложение-наш-новый-модуль","content":"Теперь осталось подключить модуль в приложение, что бы он смог добавить свою реализацию. import { createApp } from '@tramvai/core';import { SecurityModule } from '@tramvai/module-security'; createApp({ modules: [SecurityModule],}); Скопировать После этого модуль добавит свою реализацию и начнет выполняться. Мы можем добавить модуль не только в приложение, но и в другой модуль. Для этого нужно передать в блок imports и тогда при подключении модуля MyCommonModule автоматически подключится и SecurityModule import { Module } from '@tramvai/core';import { SecurityModule } from '@tramvai/module-security'; @Module({ imports: [SecurityModule], providers: [],})export class MyCommonModule {} Скопировать "},{"title":"Итог","type":1,"pageTitle":"Как создать модуль?","url":"docs/how-to/how-create-module#итог","content":"Был создан SecurityModule который будет вызываться для каждого клиента и будет добавлять необходимые хэдеры Подробная дока по модулямПодробная дока по createAppПодробная дока по DI "},{"title":"Как создать обработчик papi?","type":0,"sectionRef":"#","url":"docs/how-to/how-create-papi","content":"","keywords":""},{"title":"Автоматическое создание обработчика","type":1,"pageTitle":"Как создать обработчик papi?","url":"docs/how-to/how-create-papi#автоматическое-создание-обработчика","content":"На основе параметра конфигурации application.commands.build.options.serverApiDir в platform.json (по умолчанию папка ./src/api) определяется директория, в которой хранятся papi-обработчики. Создаем в этой папке новый файл с именем нашего нового обработчика, т.е. getSum.ts для нашего примера. В качестве обработчика будет использован дефолтный экспорт из файла, создаем его: export default () => { return 'hello';}; Скопировать Перезапускаем сервер, чтобы новый обработчик добавился в список papi. Результат вызова функции будет использован как тело ответа, поэтому теперь если обратить по адресу http://localhost:3000/tincoin/papi/getSum то в ответе мы получим объект со свойством payload: 'hello'. Далее добавим логику в наш обработчик: import { Req } from '@tramvai/papi'; // импорт нужен только для типизации, можно обойтись без него или использовать типы из express export default (req: Req) => { const { body: { a, b }, method, } = req; // получаем из объекта запроса всю необходимую ифнормацию if (method !== 'POST') { throw new Error('only post methods'); // выбрасываем ошибку, если хотим обрабатывать только определенные http-методы } if (!a || !b) { // проверяем что были переданы необходимые параметры запроса return { error: true, message: 'body parameters a and b should be set', }; } return { error: false, result: +a + +b }; // возвращаем результат, не забыв сделать все преобразования над строками}; Скопировать Сборку уже перезапускать не нужно и @tramvai/cli сам все пересоберет после сохранения изменений на диск. Теперь можно сделать POST-запрос на http://localhost:3000/tincoin/papi/getSum, передать параметры a и b и получить результат. "},{"title":"Создание обработчика через провайдер","type":1,"pageTitle":"Как создать обработчик papi?","url":"docs/how-to/how-create-papi#создание-обработчика-через-провайдер","content":"При необходимости использовать в обработчике другие зависимости приложения из di, можно добавить провайдер с токеном SERVER_MODULE_PAPI_PUBLIC_ROUTE: // ...import { createPapiMethod } from '@tramvai/papi';import { SERVER_MODULE_PAPI_PUBLIC_ROUTE } from '@tramvai/tokens-server';import { LOGGER_TOKEN } from '@tramvai/tokens-common';import { provide } from '@tramvai/core'; createApp({ // ... providers: [ // ... provide({ provide: SERVER_MODULE_PAPI_PUBLIC_ROUTE, multi: true, useFactory: ({ logger }: { logger: typeof LOGGER_TOKEN }) => { const log = logger('ping-pong'); return createPapiMethod({ method: 'get', path: '/ping', async handler() { log.error('/ping requested'); // логируем с уровнем error, чтобы наверняка увидеть лог return 'pong'; }, }); }, deps: { logger: LOGGER_TOKEN, }, }), ],}); Скопировать Теперь можно сделать запрос по адресу http://localhost:3000/tincoin/papi/ping, в ответе мы получим объект со свойством payload: 'pong', а в терминале с запущенным процессом tramvai start ${APP_ID} увидим лог ошибки /ping requested. "},{"title":"Дополнительные ссылки","type":1,"pageTitle":"Как создать обработчик papi?","url":"docs/how-to/how-create-papi#дополнительные-ссылки","content":"Документация к ServerModule "},{"title":"How to debug modules?","type":0,"sectionRef":"#","url":"docs/how-to/how-debug-modules","content":"","keywords":""},{"title":"Displaying logs on the server","type":1,"pageTitle":"How to debug modules?","url":"docs/how-to/how-debug-modules#displaying-logs-on-the-server","content":"The server log settings are set in the LOG_LEVEL and LOG_ENABLE environment variables, if needed, you can change these settings in runtime, through the papi method /{appName}/private/papi/logger with additional query parameters. You can read more about the available parameters in the documentation @tramvai/module-log LOG_ENABLE='router' // displays all logs for the logger with the ID `router` Скопировать "},{"title":"Displaying logs on the browser","type":1,"pageTitle":"How to debug modules?","url":"docs/how-to/how-debug-modules#displaying-logs-on-the-browser","content":"Client logs settings are controlled by methods of the @tinkoff/logger library. These settings are stored in the localStorage, so to display all client logs with new settings, you must additionally reload the page, or clear the localStorage. import logger from '@tinkoff/logger'; logger.enable('router'); // displays all logs for the logger with the ID `router` Скопировать "},{"title":"How to enable polyfills?","type":0,"sectionRef":"#","url":"docs/how-to/how-to-enable-polyfills","content":"","keywords":""},{"title":"Setup","type":1,"pageTitle":"How to enable polyfills?","url":"docs/how-to/how-to-enable-polyfills#setup","content":"Install polyfills pack# npm i --save @tinkoff/pack-polyfills Скопировать Create a file polyfill.ts# You need to create a file polyfill.ts inside your project, for example src/polyfill.ts and connect the polyfills inside: import '@tinkoff/pack-polyfills'; Скопировать Set up @tramvai/cli# After that, we need to tell @tramvai/cli that our project has polyfills. To do this, in tramvai.json we add for our project the line \"polyfill: \"src/polyfill.ts\" in projects[APP_ID].commands.build.options.polyfill example: { \"projects\": { \"pfphome\": { \"name\": \"pfphome\", \"root\": \"src\", \"type\": \"application\", \"commands\": { \"build\": { \"options\": { \"server\": \"src/index.ts\", \"vendor\": \"src/vendor.ts\", \"polyfill\": \"src/polyfill.ts\" } } } } }} Скопировать "},{"title":"How polyfills loading works","type":1,"pageTitle":"How to enable polyfills?","url":"docs/how-to/how-to-enable-polyfills#how-polyfills-loading-works","content":"On the @tramvai/cli side, we have configured to build the polyfills into a separate file, so it doesn't mix with the main code. On every build we will have a file with polyfills. module-render if it finds polyfills in the build, then for each client embeds inline code that checks the availability of features in the browser and if the browser does not support any of the features, then we consider the browser is legacy and load polyfills. An example of a check: !window.Promise.prototype.finally || !window.URL || !window.URLSearchParams || !window.AbortController || !window.IntersectionObserver || !Object.fromEntries' "},{"title":"Replacing the polyfills loading check","type":1,"pageTitle":"How to enable polyfills?","url":"docs/how-to/how-to-enable-polyfills#replacing-the-polyfills-loading-check","content":""},{"title":"Why would it be necessary?","type":1,"pageTitle":"How to enable polyfills?","url":"docs/how-to/how-to-enable-polyfills#why-would-it-be-necessary","content":"If you do not fit the standard check for supported features in the browser and polyfills do not load in browsers where they should. In this case, it is better to create issue and we will update the check, or you can replace the check with another. "},{"title":"Important tips","type":1,"pageTitle":"How to enable polyfills?","url":"docs/how-to/how-to-enable-polyfills#important-tips","content":"POLYFILL_CONDITION should return true if the browser does not support some featuresYou should not load polyfiles into all browsersIt is better to extend DEFAULT_POLYFILL_CONDITION with additional checks, rather than replacing it "},{"title":"Replacing the check","type":1,"pageTitle":"How to enable polyfills?","url":"docs/how-to/how-to-enable-polyfills#replacing-the-check","content":"To do this, we need to set provider POLYFILL_CONDITION, which is in import { POLYFILL_CONDITION } from '@tramvai/module-render' and pass a new line. Example: This is a synthetic example, but suppose we want to additionally check for the presence of window.Promise in the browser, to do this we extend DEFAULT_POLYFILL_CONDITION string. The resulting expression should return true if the browsers do not support the feature. import { POLYFILL_CONDITION, DEFAULT_POLYFILL_CONDITION } from '@tramvai/module-render';import { provide } from '@tramvai/core'; const provider = provide({ provide: POLYFILL_CONDITION, useValue: `${DEFAULT_POLYFILL_CONDITION} || !window.Promise`,}); Скопировать "},{"title":"How to enable modern mode for an application?","type":0,"sectionRef":"#","url":"docs/how-to/how-enable-modern","content":"","keywords":""},{"title":"Configuring tramvai.json","type":1,"pageTitle":"How to enable modern mode for an application?","url":"docs/how-to/how-enable-modern#configuring-tramvaijson","content":"We need to enable building code for modern versions of browsers. To do this, add the modern: true parameter to tramvai.json: { \"projects\": { \"tincoin\": { \"name\": \"tincoin\", \"root\": \"src\", \"type\": \"application\", \"commands\": { \"build\": { \"options\": { \"vendor\": \"src/vendor.js\", \"polyfill\": \"src/polyfill.ts\", \"server\": \"src/index.ts\" }, \"configurations\": { \"modern\": true } } } } }} Скопировать After that, @tramvai/cli will build two versions of each js file: ES5 and ES2017 After these steps, we will build statics for 2 packs of browsers and RenderModule will give the ES2017-compatible code for modern browsers. "},{"title":"Adding endpoint handler for an application","type":0,"sectionRef":"#","url":"docs/how-to/server-add-path-handler","content":"Adding endpoint handler for an application Tramvai gives you the ability to process any application url yourself, via tokens WEB_APP_BEFORE_INIT_TOKEN и WEB_APP_INIT_TOKEN Example of adding handlers import { createApp, provide } from '@tramvai/core';import { WEB_APP_BEFORE_INIT_TOKEN, WEB_APP_INIT_TOKEN } from '@tramvai/module-server';import { LOGGER_TOKEN } from '@tramvai/module-common';import { modules } from '../common'; createApp({ name: 'server', modules: [...modules], bundles: {}, providers: [ provide({ // Subscribe to WEB_APP_BEFORE_INIT_TOKEN event to subscribe to all default handlers provide: WEB_APP_BEFORE_INIT_TOKEN, multi: true, useFactory: ({ logger }) => { const log = logger('my-path'); // di should get the function from the web application return (app) => { app.use('/my-path', (req, res, next) => { // there will be no cookies in the req because you signed up before setting the cookieParser in @tramvai/module-server log.error('request start!', !!req.cookies); next(); }); }; }, deps: { logger: LOGGER_TOKEN, }, }), provide({ // Subscribe to WEB_APP_INIT_TOKEN event to subscribe to the default root handler provide: WEB_APP_INIT_TOKEN, multi: true, useFactory: ({ logger }) => { const log = logger('my-path'); return (app) => { app.use('/my-path', (req, res) => { // The cookies in the req here will already be there since they signed up after setting the cookieParser in @tramvai/module-server log.error('request start!', !!req.cookies); res.send({ hello: 'world', cookies: req.cookies }); }); }; }, deps: { logger: LOGGER_TOKEN, }, }), ],}); Скопировать","keywords":""},{"title":"SSR with async components","type":0,"sectionRef":"#","url":"docs/how-to/ssr-async-components","content":"SSR with async components When using dynamic import to load React components, we lose the ability to render them on the server. This problem is solved by the library @tramvai/react lazy Example of connecting a lazy component in a bundle import { createApp, createBundle } from '@tramvai/core';import { lazy } from '@tramvai/react';import { modules } from '../common'; const bundle = createBundle({ name: 'mainDefault', components: { // wrap the import in a lazy call so that the component is successfully rendered on the server // and the scripts/styles for the component are preloaded on the client pageDefault: lazy(() => import('./pages/page')), },}); createApp({ name: 'ssr-async-components', modules: [...modules], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Скопировать","keywords":""},{"title":"How to update tramvai version?","type":0,"sectionRef":"#","url":"docs/how-to/tramvai-update","content":"","keywords":""},{"title":"Upgrading to a latest version","type":1,"pageTitle":"How to update tramvai version?","url":"docs/how-to/tramvai-update#upgrading-to-a-latest-version","content":"tramvai update by default use latest: tramvai update Скопировать "},{"title":"Upgrading to a specific version","type":1,"pageTitle":"How to update tramvai version?","url":"docs/how-to/tramvai-update#upgrading-to-a-specific-version","content":"Third argument allows you to specify the version range or exact version: tramvai update ^1 Скопировать or tramvai update 1.0.0 Скопировать "},{"title":"Installing the new tramvai package in the app","type":1,"pageTitle":"How to update tramvai version?","url":"docs/how-to/tramvai-update#installing-the-new-tramvai-package-in-the-app","content":"tramvai add <packageName> by default installs the package to dependencies: tramvai add @tramvai/module-router Скопировать The --dev flag will install the package to devDependencies: tramvai add @tramvai/test-unit --dev Скопировать "},{"title":"Checking tramvai versions in the app","type":1,"pageTitle":"How to update tramvai version?","url":"docs/how-to/tramvai-update#checking-tramvai-versions-in-the-app","content":"The utility @tramvai/tools-check-versions has been created to automatically check the synchronization of tramvai versions. To check, you need to run the command: yarn tramvai-check-versions Скопировать "},{"title":"analyze command","type":0,"sectionRef":"#","url":"docs/references/cli/analyze","content":"","keywords":""},{"title":"See what is got bundled","type":1,"pageTitle":"analyze command","url":"docs/references/cli/analyze#see-what-is-got-bundled","content":"The special webpack plugin webpack-bundle-analyzer able to show every modules get bundled For running analyze npx tramvai analyze APP_ID Скопировать After that app will be built in prod mode and a new tab in browser will be opened "},{"title":"Figure out why dependency got bundled","type":1,"pageTitle":"analyze command","url":"docs/references/cli/analyze#figure-out-why-dependency-got-bundled","content":"With that can help utility whybundled that parses the webpack stats.json file and can show the reason why dependency has been added to bundle Run next command npx tramvai analyze APP_ID --plugin whybundled Скопировать After that a special version of stats.json can be found inside outputClient directory. The exact path will be showed in your terminal Next, you can run whybundled to resolve reasons: # why `debug` got bundlednpx whybundled ./dist/client/stats.json debug # what dependencies were bundled because of the `debug` packagenpx whybundled ./dist/client/stats.json --by debug Скопировать See more options in the whybundled docs "},{"title":"Using @tramvai/react-query library","type":0,"sectionRef":"#","url":"docs/how-to/react-query-usage","content":"","keywords":""},{"title":"Basic example with createQuery and useQuery","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#basic-example-with-createquery-and-usequery","content":" Expand import React from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get<string>('api/base'); await new Promise((resolve) => setTimeout(resolve, 50)); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); // eslint-disable-next-line import/no-default-exportexport default function Component() { const { data, isLoading } = useQuery(query); return <div>{isLoading ? 'loading...' : data}</div>;} Скопировать  "},{"title":"Preloading data on the server for useQuery","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#preloading-data-on-the-server-for-usequery","content":" Expand import React from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get<string>('api/base'); await new Promise((resolve) => setTimeout(resolve, 50)); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); // eslint-disable-next-line import/no-default-exportexport default function Component() { const { data, isLoading } = useQuery(query); return <div>{isLoading ? 'loading...' : data}</div>;} Component.actions = [query.prefetchAction()]; Скопировать  "},{"title":"Sharing useQuery data between components","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#sharing-usequery-data-between-components","content":" Expand import React, { useState, useEffect } from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get<string>('api/base'); await new Promise((resolve) => setTimeout(resolve, 5000)); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); const Child1 = () => { const { isLoading, data } = useQuery(query); return <div>Child1: {isLoading ? 'loading...' : data}</div>;}; const Child2 = () => { const { isLoading, data } = useQuery(query); return <div>Child2: {isLoading ? 'loading...' : data}</div>;}; const Child3 = () => { const { isLoading, data } = useQuery(query); return <div>Child3: {isLoading ? 'loading...' : data}</div>;}; // eslint-disable-next-line import/no-default-exportexport default function Component() { const [child2, setChild2Visible] = useState(false); const [child3, setChild3Visible] = useState(false); useEffect(() => { setTimeout(() => { setChild2Visible(true); }, 3000); setTimeout(() => { setChild3Visible(true); }, 7000); }, []); return ( <> <Child1 /> {child2 && <Child2 />} {child3 && <Child3 />} </> );} Скопировать  "},{"title":"Passing parameters for the request","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#passing-parameters-for-the-request","content":" Expand import React, { useState, useEffect } from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const query = createQuery({ key: (parameter: string) => ['api-group', parameter], fn: async (parameter, { apiClient }) => { console.log(`request to ${parameter}`); const { payload } = await apiClient.get<string>(`api/group/${parameter}`); await new Promise((resolve) => setTimeout(resolve, 5000)); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },}); const Child1 = () => { const { isLoading, data } = useQuery(query, 'test-1'); return <div>Child1: {isLoading ? 'loading...' : data}</div>;}; const Child2 = () => { const { isLoading, data } = useQuery(query, 'test-1'); return <div>Child2: {isLoading ? 'loading...' : data}</div>;}; const Child3 = () => { const { isLoading, data } = useQuery(query, 'test-2'); return <div>Child3: {isLoading ? 'loading...' : data}</div>;};// eslint-disable-next-line import/no-default-exportexport default function Component() { const [child2, setChild2Visible] = useState(false); const [child3, setChild3Visible] = useState(false); useEffect(() => { setTimeout(() => { setChild2Visible(true); }, 3000); setTimeout(() => { setChild3Visible(true); }, 7000); }, []); return ( <> <Child1 /> {child2 && <Child2 />} {child3 && <Child3 />} </> );} Скопировать  "},{"title":"Setting react-query parameters","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#setting-react-query-parameters","content":" Expand import React from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const query = createQuery({ key: 'time', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get<string>('api/time'); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, }, queryOptions: { refetchOnWindowFocus: true, refetchOnMount: true, },});// eslint-disable-next-line import/no-default-exportexport default function Component() { const { data } = useQuery( query.fork({ refetchInterval: 2000, refetchIntervalInBackground: false, }) ); return <div>{data}</div>;} Скопировать  "},{"title":"Failed requests","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#failed-requests","content":" Expand import React from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get('api/fail'); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, }, queryOptions: { retryDelay: 500, },});// eslint-disable-next-line import/no-default-exportexport default function Component() { const { data, isLoading, isError, error } = useQuery(query); if (isLoading) { return <div>loading...</div>; } if (isError) { return <div>error: {error.message}</div>; } return <div>{data}</div>;} Скопировать  "},{"title":"Using conditions for query","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#using-conditions-for-query","content":" Expand import React from 'react';import { createQuery, useQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients';import { TAPI_ROLES } from '@tinkoff/roles'; const query = createQuery({ key: 'base', fn: async (_, { apiClient }) => { const { payload } = await apiClient.get('api/auth'); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, }, conditions: { requiredCoreRoles: [TAPI_ROLES.REGISTERED], },});// eslint-disable-next-line import/no-default-exportexport default function Component() { const { data = 'no-data', isLoading } = useQuery(query); return <div>{isLoading ? 'loading...' : data}</div>;} Скопировать  "},{"title":"Basic example for createInfiniteQuery and useInfiniteQuery","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#basic-example-for-createinfinitequery-and-useinfinitequery","content":" Expand import React from 'react';import { createInfiniteQuery, useInfiniteQuery } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; interface Response { nextPage?: number; list: string[];} const query = createInfiniteQuery({ key: 'list', fn: async (_, start = 0, { apiClient }) => { const { payload } = await apiClient.get<Response>('api/list', { query: { count: 30, start, }, }); return payload; }, getNextPageParam: (page: Response) => { return page.nextPage; }, deps: { apiClient: TINKOFF_API_SERVICE, }, infiniteQueryOptions: {},}); // eslint-disable-next-line import/no-default-exportexport default function Component() { const { data, isLoading, fetchNextPage, hasNextPage } = useInfiniteQuery(query); if (isLoading) { return <>loading...</>; } return ( <div> <div> {data!.pages.map((page) => { return page.list.map((entry) => { return <div key={entry}>{entry}</div>; }); })} </div> {hasNextPage && ( <button type=\"button\" onClick={() => fetchNextPage()}> Load more </button> )} </div> );} Скопировать  "},{"title":"Basic example for createMutation and useMutation","type":1,"pageTitle":"Using @tramvai/react-query library","url":"docs/how-to/react-query-usage#basic-example-for-createmutation-and-usemutation","content":" Подробнее import React from 'react';import { createMutation, useMutation } from '@tramvai/react-query';import { TINKOFF_API_SERVICE } from '@tramvai/module-api-clients'; const mutation = createMutation({ key: 'post', fn: async (_, data: string, { apiClient }) => { const { payload } = await apiClient.post('api/post', { body: { data, }, }); return payload; }, deps: { apiClient: TINKOFF_API_SERVICE, },});// eslint-disable-next-line import/no-default-exportexport default function Component() { const { isLoading, mutate } = useMutation(mutation); if (isLoading) { return <>loading...</>; } return ( <button type=\"button\" onClick={() => mutate('test')}> Send data </button> );} Скопировать  "},{"title":"Base","type":0,"sectionRef":"#","url":"docs/references/cli/base","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"Base","url":"docs/references/cli/base#installation","content":"Global installation on the developer machine. After that the new command tramvai will be available in terminal. npm i -g @tramvai/cli Скопировать Local installation to the project npm i --save-dev @tramvai/cli Скопировать "},{"title":"API","type":1,"pageTitle":"Base","url":"docs/references/cli/base#api","content":""},{"title":"Commands","type":1,"pageTitle":"Base","url":"docs/references/cli/base#commands","content":"After any command you can pass --help string, e.g. tramvai --help or tramvai start --help. After that you will see description of the command and its options. tramvai new - generate new tramvai app with @tramvai/clitramvai start - run app in the development modetramvai start-prod - run app in development mode, but code will be build in the production modetramvai build - build an app for server and clienttramvai analyze - analyze bundle sizetramvai generate - code generation for different components. E.g. new projects, react components, actions and etc.tramvai update - update @tramvai/cli and all of the @tramvai and @tramvai-tinkoff dependencies in the project. This command additionally executes dependency deduplication and code migrationstramvai add - add @tramvai or @tramvai-tinkoff dependency to the app. This command additionally executes dependency deduplication and code migrations "},{"title":"Explanation","type":1,"pageTitle":"Base","url":"docs/references/cli/base#explanation","content":""},{"title":"Notifications settings","type":1,"pageTitle":"Base","url":"docs/references/cli/base#notifications-settings","content":"Inside tramvai.json the settings for the notification can be specified at path commands.serve.notifications. Parameters are passed to webpack-build-notifier. You can specify global configuration or a specific configuration either for client or server build. \"commands\": { \"serve\": { \"notifications\": { \"suppressSuccess\": \"always\", \"server\": { \"suppressWarning\": true }, \"client\": { \"activateTerminalOnError\": true } } }} Скопировать "},{"title":"CSS class names generation settings","type":1,"pageTitle":"Base","url":"docs/references/cli/base#css-class-names-generation-settings","content":"Name generation is configured via the options cssLocalIdentNameDev and cssLocalIdentNameProd (common option cssLocalIdentName might be used to specify settings for both prod and dev). \"commands\": { \"build\": { \"configurations\": { \"postcss\": { \"cssLocalIdentName\": \"[hash:base64:5]\", // default value (deprecated) \"cssLocalIdentNameDev\": \"[name]__[local]_[minicss]\", // available values see in the docs to [css-loader](https://github.com/webpack-contrib/css-loader) \"cssLocalIdentNameProd\": \"[minicss]\", // additionally new tag `minicss` can be used for the generating minimal css names. Based on [article](https://dev.to/denisx/reduce-bundle-size-via-one-letter-css-classname-hash-strategy-10g6) }; }; };}; Скопировать "},{"title":"Polyfills for the standard NodeJS modules","type":1,"pageTitle":"Base","url":"docs/references/cli/base#polyfills-for-the-standard-nodejs-modules","content":"By default, webpack starting with 5th version, do not add polyfills to browser bundle when using nodejs standard modules in the browser code, e.g. when using crypto, path, process, buffer, etc. @tramvai/cli explicitly adds polyfills for path and process modules as these modules are often used and lightweighted. "},{"title":"Checking TypeScript types","type":1,"pageTitle":"Base","url":"docs/references/cli/base#checking-typescript-types","content":"Checking types is enabled by flag checkAsyncTs. When running tramvai start ts compilation and type checks will be executed. Inside tramvai.json \"checkAsyncTs\": { \"failOnBuild\": true, // optional \"pluginOptions\": {} // optional}, Скопировать failOnBuild adds type checks when running tramvai build. This way build will fail in case of wrong types. pluginOptions – list of the additional options for the plugin fork-ts-checker-webpack-plugin If you want to override path to tsconfig through pluginOptions.tsconfig the option should be specified relative to the @tramvai/cli folder itself e.g. node_modules/@tramvai/cli. By default tsconfig is expected to be in the project root directory: \\<rootDir>/tsconfig.json "},{"title":"Deduplication of modules","type":1,"pageTitle":"Base","url":"docs/references/cli/base#deduplication-of-modules","content":"Option commands.build.configurations.dedupe controls the settings of plugin for the deduplication process. Available options are: \"equality\" - uses strict version comparison. Dedupes modules in node_modules with equal package version that are imported from different sources. E.g. imports for node_modules/package/index.js and node_modules/nested-package/node_modules/package/index.js are deduped into a single node_modules/package/index.js import whilst without dedupe it will bundle two files as separate modules.\"semver\" - compares version of packages based on semver. It can dedupe all of the imports with the same major version and any of the minor and patch versions. E.g. next versions will be deduped: from 1.14.0 and 1.16.2 to 1.16.2, from 0.14.1 and 0.16.5 to 0.16.5, whilst versions 0.0.2 and 0.0.5 will be left without deduplication.false - disable deduplication, by default "},{"title":"Debug an app","type":1,"pageTitle":"Base","url":"docs/references/cli/base#debug-an-app","content":"While developing sometimes it is needed to debug nodejs app directly so see CPU, memory consumptions etc. To do it the options --debug might be passed to commands start and start-prod which do next: enables source maps for build on client and serverstarts the server process with the flag --inspect. After that you can open debugger in the chrome devtools - chrome://inspect Source Maps# webpack offers several kind of sourcemap qualities. Some of the examples are: Source code - the code before transpilation and bundling. Snapshot of the source code, splitted by modulesTransformed code - the code after transpilation by loaders (etc. babel-loader), splitted by modulesGenerated code - the code after transpilation and bundling, splitted by modules. Every import and exported are replaced by webpack wrapper code For development source maps for transformed or generated code is used as it is more performant and shows the exact code that is executed in the target environment. The main differences from the debugging without sourcemaps is that code has links to modules to original source files. tramvai generates big single bundle with server code and that's why it is preferred to not include sourcemaps in the code itself and put it to the separate .js.map file. Development# By default, for browser is used the fastest sourcemaps, while for server no sourcemaps is used. Flag --debug enables sourcemap generation for the server bundle. Option commands.serve.configurations.sourceMap enables sourcemap generation both for browser and server code. Production# By default, sourcemaps are disabled both for the client and server code. Flag --debug enables sourcemaps generation for the client and server bundles. Option commands.build.configurations.sourceMap enables sourcemap generation for the client bundle. Option commands.build.configurations.sourceMapServer enables sourcemap generation for the server bundle. "},{"title":"How to","type":1,"pageTitle":"Base","url":"docs/references/cli/base#how-to","content":""},{"title":"Code generation","type":1,"pageTitle":"Base","url":"docs/references/cli/base#code-generation","content":"For make life easier for developers @tramvai/cli has ability to automatically generate code with template. For running code generator use command tramvai generate and pick up one of the options available to generate that entity: actionbundlereducerpagecomponentmodule After that template files will be generated "},{"title":"Generate new project","type":1,"pageTitle":"Base","url":"docs/references/cli/base#generate-new-project","content":"For the quick start of new project you can use command tramvai new that will generate new base project with the tramvai and tramvai-cli install tramvai-cli globallyenter command tramvai new NAME_YOUR_APP in the shellchoose options based on your preferences: monorepo or multirepo, CI integration and testing framework After command execution and dependency installation new project will be ready to use "},{"title":"How to run nodejs app in debug mode?","type":1,"pageTitle":"Base","url":"docs/references/cli/base#how-to-run-nodejs-app-in-debug-mode","content":"Add flag --debug when running app tramvai start my-app --debug Скопировать Then open chrome devTools, click on NodeJs logo in the upper left corner. New window with the nodejs devtools will be opened that allows to debug memory and cpu usage, debug code and take the performance profiles. "},{"title":"Get details for deprecated and warning logs","type":1,"pageTitle":"Base","url":"docs/references/cli/base#get-details-for-deprecated-and-warning-logs","content":"It might be useful to get the stacktraces of some of the warnings. E.g., while running app if you see logs like this (node:2898) DeprecationWarning: ...(Use `node --trace-deprecation ...` to show where the warning was created) Скопировать You may add flag --trace in order to run nodejs server with the additional options. tramvai start my-app --trace Скопировать After that these logs will be printed with their stacktraces "},{"title":"How to use browserstack for testing","type":1,"pageTitle":"Base","url":"docs/references/cli/base#how-to-use-browserstack-for-testing","content":"To get access to browserstack just type command /bs in slack Run app as usual with tramvai start command and follow the browsertack instruction for the local development. If everything were done right you will be able to get access to localhost inside browserstack and test your app through it. "},{"title":"How to test app on mobile or other device in local network","type":1,"pageTitle":"Base","url":"docs/references/cli/base#how-to-test-app-on-mobile-or-other-device-in-local-network","content":"Both devices one that running the app and one for testing must reside in the same network. For setting access through local network follow next steps: figure out the ip of the machine that runs apprun command tramvai start with flag --staticHost with value of the ip address that was resolved on previous step (e.g. tramvai start tincoin --staticHost 192.168.1.3)from the testing device open the new page in the browser and use the ip address from the previous step as domain name When calling @tramvai/cli using npm you need to pass -- before any additional arguments, e.g. command should look similar to this npm start -- --staticHost 192.168.1.3 "},{"title":"Integration with browserslist","type":0,"sectionRef":"#","url":"docs/references/cli/browserslist","content":"","keywords":""},{"title":"Supported envs for browserslist","type":1,"pageTitle":"Integration with browserslist","url":"docs/references/cli/browserslist#supported-envs-for-browserslist","content":"In cli only specific list of supported env targets is used for browserslist: modern - used for builds supposed to be provided for modern browsersnode - used for builds running on serverdefaults - used otherwise, usually for outdated browsers "},{"title":"cli setup","type":1,"pageTitle":"Integration with browserslist","url":"docs/references/cli/browserslist#cli-setup","content":"By default, cli uses browserslist config from a library @tinkoff/browserslist-config. To extend or override default settings, you can use any of the methods for browserslist config following next rules: It is allowed to change config only for envs from the list used in cli. How to do it see browserslist docs. If some of env is not defined, the default config for the env will be used.If you want to extend default settings then use the ability to extend config \"browserslist\": { \"modern\": [ \"extends @tinkoff/browserslist-config\", \"chrome > 25\" ], \"node\": [ \"extends @tinkoff/browserslist-config\" ], \"defaults\": [ \"extends @tinkoff/browserslist-config\", \"chrome > 27\" ]} Скопировать If you want to narrow down the supported list of the browsers, then do not use extends @tinkoff/browserslist-config and specify list of the supported browsers yourself. Take the default list from the @tinkoff/browserslist-config as a basis. Do it for every env if you need it. Not overrided env will use default settings. "},{"title":"Debug","type":1,"pageTitle":"Integration with browserslist","url":"docs/references/cli/browserslist#debug","content":"You can test how browserslist works using next commands: npx browserslist --env=modern # list of the modern browsersnpx browserslist --env=node # list of the supported nodejs versionsnpx browserslist # list of the browsers including legacy one Скопировать "},{"title":"Caveats","type":1,"pageTitle":"Integration with browserslist","url":"docs/references/cli/browserslist#caveats","content":""},{"title":"autoprefixer","type":1,"pageTitle":"Integration with browserslist","url":"docs/references/cli/browserslist#autoprefixer","content":"Because of the some internal restrictions of the autoprefixer build will be executed only using defaults config. If you really interested in this feature, please, create an issue on the github. "},{"title":"build command","type":0,"sectionRef":"#","url":"docs/references/cli/build","content":"build command Command tramvai build can build libraries to separate bundles for various environments: CommonJS modules + ES2015 code (for nodejs without ESM support) - it uses field main in package.jsonES modules + ES2015 code (for nodejs with ESM support) - it uses filed module in package.jsonES modules + ES5 code (for legacy browser) - it uses field browser in package.jsonES modules + ES2017+ code (for modern browsers) - it uses field es2017 in package.json To specify new library in tramvai.json add new project with the type package: { \"projects\": { \"{{packageName}}\": { \"name\": \"{{packageName}}\", \"type\": \"package\", \"root\": \"libs/{{packageName}}\" } }} Скопировать Any additional settings should be specified in the package.json of the library itself: { \"name\": \"{{packageName}}\", \"version\": \"1.0.0\", \"source\": \"src/index.ts\", // entry point to library \"browserSource\": \"src/browser.ts\", // optional field, entry point for the browser environment. Can be used to split implementations for server and browser \"main\": \"dist/index.js\", // name of the built CommonJS + ES2015 bundle \"module\": \"dist/index.es.js\", // name of the built ESM + ES2015 bundle \"browser\": \"dist/browser.js\", // optional field, name of the built + ES2015 bundle, should be used with the field `browserSource` \"es2017\": \"dist/browser.es2017.js\", // optional field, name of the built ESM + ES2017 bundle. It it is omitted calculates from the `source` field \"sideEffects\": false, \"scripts\": { \"start\": \"tramvai build {{packageName}} --watch\", // watch mode to develop package \"build\": \"tramvai build {{packageName}}\" // single time build for the production }} Скопировать","keywords":""},{"title":"Experimental settings","type":0,"sectionRef":"#","url":"docs/references/cli/experiments","content":"","keywords":""},{"title":"Webpack settings","type":1,"pageTitle":"Experimental settings","url":"docs/references/cli/experiments#webpack-settings","content":"Webpack by itself has a list of experimental flags which might be passed directly to webpack through experiments.webpack. "},{"title":"Defaults","type":1,"pageTitle":"Experimental settings","url":"docs/references/cli/experiments#defaults","content":"cacheUnaffected=true - should improve build performance in serve mode "},{"title":"minicss","type":1,"pageTitle":"Experimental settings","url":"docs/references/cli/experiments#minicss","content":"Flags are specified through experiments.minicss and allows to enable experimental settings for mini-css-extract-plugin useImportModule - enables a special way to compile css modules that should improve build time and decrease memory usage. More details in the official docs "},{"title":"Defaults","type":1,"pageTitle":"Experimental settings","url":"docs/references/cli/experiments#defaults-1","content":"useImportModule=true - enabled by default as this improves build time and provides better css related error descriptions "},{"title":"Configuration","type":0,"sectionRef":"#","url":"docs/references/cli/config","content":"","keywords":""},{"title":"config file format","type":1,"pageTitle":"Configuration","url":"docs/references/cli/config#config-file-format","content":"{ \"projects\": { \"react-app\": { \"name\": \"new-app\", \"root\": \"src\", \"type\": \"application\", \"commands\": { \"build\": { \"options\": { ... }, \"configurations\": { ... } }, \"serve\": { \"configurations\": { ... } } } } }} Скопировать projects - map of the projects that resides in the current repository. @tramvai/cli supports many apps and packages inside single repository (so called monorepo concept). "},{"title":"Поддержка JSON схемы файла конфигурации в IDE","type":1,"pageTitle":"Configuration","url":"docs/references/cli/config#поддержка-json-схемы-файла-конфигурации-в-ide","content":""},{"title":"JSON schema validation and autocomplete in IDEs","type":1,"pageTitle":"Configuration","url":"docs/references/cli/config#json-schema-validation-and-autocomplete-in-ides","content":"Link to the actual json schema for the tramvai.json is ./node_modules/@tramvai/cli/schema.json The most simple way to add config validation and autocomplete is to add schema through field $schema inside tramvai.json: { \"$schema\": \"./node_modules/@tramvai/cli/schema.json\", \"projects\": {}} Скопировать Another way is to add schema to the IDE settings: How to add schema to the JetBrains IDE you can find in the official docs. You also need to set tramvai.json as file path pattern in settings. How to add schema to the VSCode you can find in the official docs New projects generated by tramvai new command already has field $schema in their tramvai.json config. "},{"title":"Настройки для build этапа","type":1,"pageTitle":"Configuration","url":"docs/references/cli/config#настройки-для-build-этапа","content":"\"commands\": { \"build\": { \"options\": { \"vendor\": \"\", // path to the vendor file. If not provided vendor bundle will not be generated \"polyfill\": \"\", // path to the polyfill file with all of the required polyfills. If not provided vendor bundle will not be generated \"server\": \"src/server\", // path to the server entry point \"outputServer\": \"dist/server\", // folder to output server bundle \"outputClient\": \"dist/client\" // folder to output client bundle }, \"configurations\": { \"commonChunk\": true, // enables generation common chunk that includes shared code between chunks \"commonChunkSplitNumber\": 3, // number of different chunks that should link to code in order to put that code in commonChunk \"sourceMap\": false, // is client sourcemaps are enabled \"sourceMapServer\": false, // is server sourcemaps are enabled \"modern\": true, // enable separate client bundle for the modern browsers only \"checkAsyncTs\": false, // enables background type checks \"terserParallel\": true, // enables parallel terser compression \"granularChunks\": false, // enables splitting commonChunk to many independent pieces. It may significantly reduce js size on some pages \"granularChunksSplitNumber\": 2, // number of duplicates before move code to the granular chunk \"generateDataQaTag\": false, // @deprecated automatically generate unique id for react components \"definePlugin\": { // replaces passed strings with passed values in the build time \"prod\": {}, \"dev\": {} }, \"threadLoader\": { // config for the multithread build process (https://webpack.js.org/loaders/thread-loader/). }, \"postcss\": { // config for the postcss-loader \"cssLocalIdentName\": \"[hash:base64:5]\", // specifies identifier for the css class names \"config\": \"postcss.config\" // path to the postcss.config file }, \"alias\": {}, // alias config. More details in the [docs](https://www.npmjs.com/package/babel-plugin-module-resolver) \"removeTypeofWindow\": true, // enables babel plugin transform-define that will replace code `typeof window` to 'undefined' or 'object' depending on the environment \"dedupe\": \"equality\" | \"semver\" | false, // controls the deduplication plugin \"svgo\": { \"plugins\": [{ \"cleanupIDs\": false }, { \"collapseGroups\": false }], // svgo plugins (https://github.com/svg/svgo#what-it-can-do) }, \"imageOptimization\": { // config for the process of the image optimizations enabled: true, // enable image optimization options: {} // options for the detailed settings (https://github.com/tcoopman/image-webpack-loader#options) } } }} Скопировать "},{"title":"Add new config parameters","type":1,"pageTitle":"Configuration","url":"docs/references/cli/config#add-new-config-parameters","content":"Config parameters for the @tramvai/cli are stored as TypeScript interface from which JSON Schema is generating. This schema is used for the config validation and applying config defaults, thanks to the library ajv. "},{"title":"Putting inline code for the client on server","type":0,"sectionRef":"#","url":"docs/references/cli/serverInline","content":"","keywords":""},{"title":"Solution","type":1,"pageTitle":"Putting inline code for the client on server","url":"docs/references/cli/serverInline#solution","content":"For clients transpilation is already happens using wepback and babel that targets specific browsers. That way we can reuse that transpilation for client code in order to build specific code on the server which is intended to use on client-side. Rules for transpiling specific code for clients on the server: code for insertion must be placed in separate fileinside that file no imports should be used as it requires webpack runtime which won't know about server modules on the clientcode itself should be defined as exported function and these functions can use only passed arguments. Using external variables is not possiblethe name of the file should end on .inline(.es)?.[tj]s. It works as a marker to transpile this file with a client configinstead on inline code put to the insertion place the string with call of the exported function with passing arguments to it. Thanks to the fact that conversion function to string returns the body of the function itself it should work on the client "},{"title":"Example","type":1,"pageTitle":"Putting inline code for the client on server","url":"docs/references/cli/serverInline#example","content":"Create new file test.inline.ts with the inline code export const test = (arg: string) => { class Test { log() { console.log({ arg, a: 1, }); } } const t = new Test(); t.log();}; Скопировать Import the exported function and put it to the initial html import { Module } from '@tramvai/core';import { RENDER_SLOTS, ResourceType, ResourceSlot } from '@tramvai/module-render';import { test } from './test.inline'; @Module({ providers: [ { provide: RENDER_SLOTS, multi: true, useFactory: () => { const arg = 'Hello'; return { slot: ResourceSlot.HEAD_SCRIPTS, type: ResourceType.inlineScript, // Please, note that we are using function like we are adding new iife function, but instead of adding the body of function manually we are using import from the module // And when passing string as arguments we should additionally wrap it with quotes payload: `(${test})('${arg}')`, }; }, }, ],})export class CustomModule {} Скопировать After building the project and requesting the page, the browser should get the code looking like that instead of source code <script> (function test(arg) { var Test = /*#__PURE__*/ (function () { function Test() {} var _proto = Test.prototype; _proto.log = function log() { console.log({ arg: arg, a: 1, }); }; return Test; })(); var t = new Test(); t.log(); })('Hello');</script> Скопировать "},{"title":"start command","type":0,"sectionRef":"#","url":"docs/references/cli/start","content":"","keywords":""},{"title":"Enable sourcemaps in dev mode","type":1,"pageTitle":"start command","url":"docs/references/cli/start#enable-sourcemaps-in-dev-mode","content":"In tramvai.json \"commands\": { \"serve\": { \"configurations\": { \"sourceMap\": true } }} Скопировать "},{"title":"modern build and dev-mode","type":1,"pageTitle":"start command","url":"docs/references/cli/start#modern-build-and-dev-mode","content":"In dev-mode may work only single build mode: either modern or legacy. By default legacy is used. If you want to use modern build in dev mode, add next lines to the tramvai.json: \"commands\": { \"serve\": { \"configurations\": { \"modern\": true } }} Скопировать "},{"title":"How to","type":1,"pageTitle":"start command","url":"docs/references/cli/start#how-to","content":""},{"title":"Speed up development build","type":1,"pageTitle":"start command","url":"docs/references/cli/start#speed-up-development-build","content":"Build only specific bundles# App may contain of many bundles and the more there bundle, the more code get bundled to the app, the more long in building and rebuilding the app during development. In order to speed up that process when running @tramvai/cli it is possible to specify bundles required for the development and cli will build only that bundles. Bundles should be placed in directory bundles and should be imported from the index app file. When trying to request bundle that was disabled, server will fail with status 500, as it is unexpected condition for the server that bundle is missing # if you need only single bundle during developmenttramvai start myapp --onlyBundles=account# if you need several bundlestramvai start myapp --onlyBundle=account,trading Скопировать "},{"title":"browser-timings","type":0,"sectionRef":"#","url":"docs/references/libs/browser-timings","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"browser-timings","url":"docs/references/libs/browser-timings#installation","content":"Install npm package npm i --save @tinkoff/browser-timings Скопировать "},{"title":"How to","type":1,"pageTitle":"browser-timings","url":"docs/references/libs/browser-timings#how-to","content":"import { browserTimings } from '@tinkoff/browser-timings'; window.addEventListener('load', () => { setTimeout(() => { // setTimeout is necessary in order to get metrics about loadEventEnd const perfData = browserTimings(); }, 0);}); Скопировать After executing perfData will contain client performance metrics which may be send to any external system for further analysis. Call of the library should be executed only after page load in order to get actual data. Otherwise, it may return empty object without data. "},{"title":"Lib interface","type":1,"pageTitle":"browser-timings","url":"docs/references/libs/browser-timings#lib-interface","content":"export interface Timings { /* Connection timing from client to server */ connection: number; /* How much time backend was preparing response */ backend: number; /* Page download to client */ pageDownload: number; /* Timing of first paint for a page */ 'first-paint': number; /* Timing when DOM becomes interactive */ domInteractive: number; /* DOM building is complete */ domComplete: number; /* Page and every resource were loaded */ pageLoadTime: number; /* Common information about resources and its loading time grouped by type */ download: { html: TimingResource; js: TimingResource; css: TimingResource; img: TimingResource; font: TimingResource; other: TimingResource; };} interface TimingResource { /* Timing of resource loading */ duration: number; /* Byte-size measure of data used by resource */ encodedDecodeSize: number; /* Byte-size measure of data transferred by network. Calculating difference between encodedDecodeSize - transferSize may reveal how much data where stored in browser cache */ transferSize: number;} Скопировать "},{"title":"browserslist-config","type":0,"sectionRef":"#","url":"docs/references/libs/browserslist-config","content":"","keywords":""},{"title":"Api","type":1,"pageTitle":"browserslist-config","url":"docs/references/libs/browserslist-config#api","content":""},{"title":"defaults","type":1,"pageTitle":"browserslist-config","url":"docs/references/libs/browserslist-config#defaults","content":"Contains config for every supported browser "},{"title":"modern","type":1,"pageTitle":"browserslist-config","url":"docs/references/libs/browserslist-config#modern","content":"Contains config for, so called \"modern\" browser. Browser's versions in this list are higher than for defaults and these browsers support more functionality "},{"title":"node","type":1,"pageTitle":"browserslist-config","url":"docs/references/libs/browserslist-config#node","content":"Contains config for nodejs "},{"title":"legacy","type":1,"pageTitle":"browserslist-config","url":"docs/references/libs/browserslist-config#legacy","content":"Config for legacy but still supported browsers. Currently this is equal to defaults "},{"title":"error-handlers","type":0,"sectionRef":"#","url":"docs/references/libs/error-handlers","content":"","keywords":""},{"title":"Api","type":1,"pageTitle":"error-handlers","url":"docs/references/libs/error-handlers#api","content":"globalErrorHandler = (logger: Logger = console) - init logging of global errorsunhandledRejectionHandler = (logger: Logger = console) - init logging of unhandled rejection promise "},{"title":"Parameters","type":1,"pageTitle":"error-handlers","url":"docs/references/libs/error-handlers#parameters","content":"Logger - used for logging errors export interface Logger { warn: Function; error: Function;} Скопировать "},{"title":"express-terminus","type":0,"sectionRef":"#","url":"docs/references/libs/express-terminus","content":"","keywords":""},{"title":"Features","type":1,"pageTitle":"express-terminus","url":"docs/references/libs/express-terminus#features","content":"healthChecks handlers are creater for an express app, in contrast to original library which redefines request event handler of server object. Original behaviour is more complicated in case of a need to add common logic for every request in the app, including healthChecks itself. E.g. it was not possible to add http-header in single place to make it work for every request. "},{"title":"eslint-plugin-tramvai","type":0,"sectionRef":"#","url":"docs/references/libs/eslint-plugin-tramvai","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"eslint-plugin-tramvai","url":"docs/references/libs/eslint-plugin-tramvai#installation","content":"Install necessary packages first npm i --save-dev @tinkoff/eslint-config @tinkoff/eslint-config-react @tinkoff/eslint-plugin-tramvai Скопировать Add recommended settings to .eslintrc: { \"extends\": [ \"@tinkoff/eslint-config/app\", \"@tinkoff/eslint-config-react\", \"plugin:@tinkoff/tramvai/recommended\" ]} Скопировать Or add plugin manually: { \"extends\": [ \"@tinkoff/eslint-config/app\", \"@tinkoff/eslint-config-react\" ], \"plugins\": [ \"@tinkoff/tramvai\" ], \"rules\": { \"@tinkoff/tramvai/bundle-chunk-name\": \"warn\" }} Скопировать "},{"title":"Rules","type":1,"pageTitle":"eslint-plugin-tramvai","url":"docs/references/libs/eslint-plugin-tramvai#rules","content":""},{"title":"bundle-chunk-name","type":1,"pageTitle":"eslint-plugin-tramvai","url":"docs/references/libs/eslint-plugin-tramvai#bundle-chunk-name","content":"In a tramvai app, in order to work properly with the bundle system it is necessary to put a special comment for dynamic imports. This rule checks that dynamic imports of bundles are marked with a proper control comment webpackChunkName: [name]. The rule also provides autofix in order to add add/fix control comment automatically. Example of the wrong code: createApp({ bundles: { 'tramvai/bundle-1': () => import('./bundles/bundle1'), 'tramvai/bundle-2': () => import(/* webpackChunkName: \"randomValue\" */ './bundles/bundle2'), },}); Скопировать Example of the right code after autofix for the code above: createApp({ bundles: { 'tramvai/bundle-1': () => import(/* webpackChunkName: \"bundle-1\" */ './bundles/bundle1'), 'tramvai/bundle-2': () => import(/* webpackChunkName: \"bundle-2\" */ './bundles/bundle2'), },}); Скопировать Options: propertyNames: defines array of object properties which will be analyzed. By default it equals to [\"bundles\"]. "},{"title":"hooks","type":0,"sectionRef":"#","url":"docs/references/libs/hooks","content":"","keywords":""},{"title":"Explanation","type":1,"pageTitle":"hooks","url":"docs/references/libs/hooks#explanation","content":"Working with lib consist of two phases: Adding in the target code hook runner call, e.g. runAsyncHooks, with unique event key and additional parameters. It creates a slot for this event that allow to subscribe on the event.Registering hook handler with registerHooks that will be executed when run... function will be called "},{"title":"Caveats","type":1,"pageTitle":"hooks","url":"docs/references/libs/hooks#caveats","content":"There is different types hooks that are not interoperable. So carefully add new registrations with checking expected hook type. Also you should preserve data chain, e.g. return data with same interface from hook, as it otherwise may break other hooks. "},{"title":"API","type":1,"pageTitle":"hooks","url":"docs/references/libs/hooks#api","content":"Hooks# Create new instance of @tinkoff/hook-runner import { Hooks } from '@tinkoff/hook-runner'; const hookRunner = new Hooks(); Скопировать registerHooks(key, hooks)# Register new hook for a specific key. runHooks(key, context, payload, options)# Execute sync hooks. payload is passed through every hook and will be returned as a result (it may be changed by hooks). runAsyncHooks(key, context, payload, options)# Executes async hooks using setTimeout. payload is passed to every hook with its initial value. runPromiseHooks(key, context, options) => (payload) => Promise# Execute promise-based hooks. payload is passed through every hook and will be returned as a result (it may be changed by hooks) "},{"title":"Hooks","type":1,"pageTitle":"hooks","url":"docs/references/libs/hooks#hooks-1","content":""},{"title":"Types","type":1,"pageTitle":"hooks","url":"docs/references/libs/hooks#types","content":"sync# Accepts (context, payload, options). Hooks are running in order passing previous hook result as input for next hook. async# Accepts (context, payload, options). Hooks are running independently from each other. promise# Accepts (context, payload, options). Hooks are running in order passing previous hook result as input for next hook with wrapping call in promise. "},{"title":"is-modern-lib","type":0,"sectionRef":"#","url":"docs/references/libs/is-modern-lib","content":"","keywords":""},{"title":"Usage","type":1,"pageTitle":"is-modern-lib","url":"docs/references/libs/is-modern-lib#usage","content":"Based on example from the article Publish, ship, and install modern JavaScript // webpack.config.jsconst { modernLibsFilter } = require('@tinkoff/is-modern-lib'); module.exports = { module: { rules: [ // Transpile for your own first-party code: { test: /\\.[cm]?js$/i, loader: 'babel-loader', exclude: /node_modules/, }, // Transpile modern dependencies: { test: /\\.[cm]?js$/i, include: modernLibsFilter, use: { loader: 'babel-loader', options: { babelrc: false, configFile: false, presets: ['@babel/preset-env'], }, }, }, ], },}; Скопировать "},{"title":"Layout factory","type":0,"sectionRef":"#","url":"docs/references/libs/layout-factory","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"Layout factory","url":"docs/references/libs/layout-factory#installation","content":"Install @tinkoff/layout-factory using your package manager, e.g. for npm: npm i @tinkoff/layout-factory Скопировать Create new layout object import React from 'react';import { createLayout } from '@tinkoff/layout-factory';import { Content, Page, Feedback } from './components';import { layoutWrapper, feedbackWrapper } from './wrappers'; const MyLayout = createLayout({ components: { page: Page, content: Content, feedback: Feedback, }, wrappers: { layout: layoutWrapper, feedback: feedbackWrapper, },}); Скопировать "},{"title":"Layout structure","type":1,"pageTitle":"Layout factory","url":"docs/references/libs/layout-factory#layout-structure","content":"Layout has the following structure: <LayoutWrapper> {globalComponents} <ContentWrapper> <HeaderWrapper> <Header /> </HeaderWrapper> <PageWrapper>{page}</PageWrapper> <FooterWrapper> <Footer /> </FooterWrapper> </ContentWrapper></LayoutWrapper> Скопировать Any of the wrappers could be customized. By default, every wrapper just renders passed children prop, but HeaderWrapper and FooterWrapper render only if components Header and Footer were passed as props to result layout. "},{"title":"Customization ways","type":1,"pageTitle":"Layout factory","url":"docs/references/libs/layout-factory#customization-ways","content":"Customization is made through options components and wrappers "},{"title":"Components","type":1,"pageTitle":"Layout factory","url":"docs/references/libs/layout-factory#components","content":"React components header, footer, layout, content, page are base components for wrappers. They should render passed prop children. By default, layout, content, page are \"render children\" while header and footer are \"render prop\"any of the other components are, so called, globalComponents. They are just rendered as components inside LayoutWrapper "},{"title":"Wrappers","type":1,"pageTitle":"Layout factory","url":"docs/references/libs/layout-factory#wrappers","content":"HOC for components header, footer, layout, content, page - HOC for the base componentsall of the other components are HOCs for все остальные wrappers - HOC for corresponding globalComponents It is possible to pass a list of HOCs. This way order of render wrapping for passed component will be from end to start of the list. Such wrappers and used for: hide/show elements by conditionset additional css style for componentsinject additional code/handlerpass additional props Example of such wrapper: function layoutWrapper(WrappedComponent) { return (props) => ( <div className=\"ui-layout\"> <WrappedComponent {...props} /> </div> );} Скопировать "},{"title":"http-client","type":0,"sectionRef":"#","url":"docs/references/libs/http-client","content":"","keywords":""},{"title":"API","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#api","content":""},{"title":"HttpClient","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#httpclient","content":"type HttpClient = { // common method for sending HTTP requests request<P = any>(request: HttpClientRequest): Promise<HttpClientResponse<P>>; // method for sending GET requests get<R = any>( path: string, payload?: Pick<HttpClientRequest, 'query' | 'headers'>, config?: Omit<HttpClientRequest, 'url' | 'query' | 'body' | 'headers'> ): Promise<HttpClientResponse<R>>; // method for sending POST requests, uses `requestType: 'json'` by default post<R = any>( path: string, payload?: Pick<HttpClientRequest, 'query' | 'body' | 'headers'>, config?: Omit<HttpClientRequest, 'url' | 'query' | 'body' | 'headers'> ): Promise<HttpClientResponse<R>>; // method for sending PUT requests, uses `requestType: 'json'` by default put<R = any>( path: string, payload?: Pick<HttpClientRequest, 'query' | 'body' | 'headers'>, config?: Omit<HttpClientRequest, 'url' | 'query' | 'body' | 'headers'> ): Promise<HttpClientResponse<R>>; // method for sending DELETE requests delete<R = any>( path: string, payload?: Pick<HttpClientRequest, 'query' | 'headers'>, config?: Omit<HttpClientRequest, 'url' | 'query' | 'body' | 'headers'> ): Promise<HttpClientResponse<R>>; // method for creating a new instance of the HTTP client, based on the settings of the current fork(options?: HttpClientRequest, mergeOptionsConfig?: { replace?: boolean }): HttpClient;} Скопировать "},{"title":"HttpClientRequest","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#httpclientrequest","content":"type HttpClientRequest = { // absolute url of the request, do not use simultaneously with `path` url?: string; // url of the request, not to be used simultaneously with `url` path?: string; // base url, which is added to all queries before the `path` value baseUrl?: string; // basic HTTP methods are supported - GET, POST, PUT, DELETE method?: HttpMethod; // request data type, `form` by default requestType?: HttpContentType; // response data type, is calculated from the `content-type` header by default responseType?: HttpContentType; // HTTP request headers headers?: Record<string, any>; // request query parameters query?: Record<string, any>; // request body body?: Record<string, any>; // request execution time limit, in ms timeout?: number; // disabling logging inside the HTTP client. It is recommended to use if a request error is logged manually silent?: boolean; // disabling the request cache cache?: boolean; // if `abortPromise` is resolved, the request will be canceled abortPromise?: Promise<void>; // method to modify request data modifyRequest?: (req: HttpClientRequest) => HttpClientRequest; // method to modify response data modifyResponse?: <P = any>(res: HttpClientResponse<P>) => HttpClientResponse<P>; // method to modify the error object modifyError?: (error: HttpClientError, req: HttpClientRequest) => HttpClientError; [key: string]: any;} Скопировать "},{"title":"HttpClientResponse","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#httpclientresponse","content":"type HttpClientResponse<P = any> = { // response body payload: P; // HTTP response code status: number; // HTTP response headers headers: Record<string, any>;} Скопировать "},{"title":"HttpClientError","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#httpclienterror","content":"type HttpClientError = Error & { [key: string]: any;} Скопировать "},{"title":"ApiService","type":1,"pageTitle":"http-client","url":"docs/references/libs/http-client#apiservice","content":"ApiService - abstract class for easy creation of services for working with API, allows you to override custom logic in the request method, on top of which the rest of the basic methods work. For example, a service that automatically displays a pop-up window when a request error occurs: class CustomApiService extends ApiService { constructor({ httpClient }: { httpClient: HttpClient }) { super(httpClient); } request<R = any>(request: HttpClientRequest): Promise<HttpClientResponse<R>> { return this.httpClient.request(request).catch((error) => { alert(error); }); }} const service = new CustomApiService({ httpClient }); service.request({ path: 'fake' }) // show alertservice.get('fake') // also show alert Скопировать "},{"title":"meta-tags-generate","type":0,"sectionRef":"#","url":"docs/references/libs/meta-tags-generate","content":"","keywords":""},{"title":"Api","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#api","content":"Meta({ list: [] }): Meta - object used for constructing an instance of meta-tags based on passed sourcesRender(meta: Meta): { render(): string } - render of specific Meta instance as a string. Used in SSRUpdate(meta: Meta): { update(): void } - updates meta-tags layout in browser. Used in browser while SPA-navigations "},{"title":"Format","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#format","content":"Library accepts special parameters which are used to generate result html tags. These parameters have next format: { customTag: { tag: 'meta', attributes: { name: 'k', content: 'i' }, innerHtml: '1' }} Скопировать thar renders in the next tag: <meta name=\"k\" content=\"i\">1</meta> Скопировать "},{"title":"Converters","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#converters","content":"Converters are used to convert meta-tags with specific keys in format view new Meta({ list, converters: { title: (value) => ({ tag: 'meta', innerHtml: value }) } }); Скопировать After that you now can pass meta as { title: 'Тинькофф' } in order to render it through converter above. "},{"title":"Sources","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#sources","content":"Through options list can be passed sources for meta-tags generating. These sources have the form of function that are called in runtime for generating result render. E.g.: const list = [ (walker) => walker.updateMeta(10, { title: 'test', tag: { tag: 'meta', attributes: { link: 'link' } }, }), (walker) => walker.updateMeta(20, { title: 'tinkoff', ogTitle: 'tinkoff', }),];const meta = new Meta({ list, converters }); Скопировать When generating meta tags all functions passed in list will be called with argument of class Walker. Inside such function it is possible to modify data using method updateMeta, which accepts the priority of the change and value. Elements with higher priority overrides values with lower priorities. "},{"title":"How to","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#how-to","content":""},{"title":"Set Meta","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#set-meta","content":"import { Meta, Render, Update } from '@tinkoff/meta-tags-generate'; const list = [ (walker) => walker.updateMeta(10, { title: 'test', tag: { tag: 'meta', attributes: { link: 'link' } }, }),];const meta = new Meta({ list, converters }); const metaContent = new Render(meta).render();console.log(metaContent); // > <title>test</title><meta link=link/> new Update(meta).update(); // Removes all previous meta and adds new one Скопировать "},{"title":"Remove meta parameters","type":1,"pageTitle":"meta-tags-generate","url":"docs/references/libs/meta-tags-generate#remove-meta-parameters","content":"In order to remove data just pass null as a value. E.g. if you want to remove keywords meta: (walker) => walker.updateMeta(30, { keywords: null, }); Скопировать After that specified meta tag will be remove "},{"title":"minicss","type":0,"sectionRef":"#","url":"docs/references/libs/minicss","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"minicss","url":"docs/references/libs/minicss#installation","content":"Install using yarn yarn add --dev @tinkoff/minicss-class-generator Скопировать or npm npm i --save-dev @tinkoff/minicss-class-generator Скопировать "},{"title":"Setup","type":1,"pageTitle":"minicss","url":"docs/references/libs/minicss#setup","content":"Define options localIdentName и getLocalIdent for css-loader config inside your webpack config: ({ loader: 'css-loader', options: { modules: { getLocalIdent: createGenerator(), localIdentName: '[minicss]', }, },}); Скопировать For localIdentName it is possible to pass any template which is accepted by css-loader. E.g. if you want to add the origin filename and the className pass [name]__[local]_[minicss] as localIdentName "},{"title":"How does it work","type":1,"pageTitle":"minicss","url":"docs/references/libs/minicss#how-does-it-work","content":"Plugin generate unique key for a className using formula ${order}${contentHash} where contentHash is a hash of the source file content and order - ordered key of class definition inside source file. Using contentHash from source allows to generate less unique string and allows to reuse the same contentHash for every className that leads for better data compression with gzip/brotli. Using order helps sustain uniqueness for every className in single source file. Examples: [hash:base64:5]file: Button.css .2hlLi .32BZU Скопировать [minicss]file: Button.css .abhUzy .bbhUzy Скопировать "},{"title":"logger","type":0,"sectionRef":"#","url":"docs/references/libs/logger","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#installation","content":"Install using package manager, e.g. for npm: npm i --save @tinkoff/logger Скопировать for yarn: yarn add @tinkoff/logger Скопировать "},{"title":"Api","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#api","content":""},{"title":"Child loggers","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#child-loggers","content":"You can create child loggers using method .child of the current logger instance. Child logger will inherit parent logger settings and can override these settings. const log = logger({ name: 'test' }); const childLog = log.child('child'); // as this logger is child logger the result name will be 'test.child' const childLogWithDefaults = log.child({ name: 'withDefaults', defaults: { // defaults might be used to specify properties which will be merged to log objects logged with this logger child: true, },}); const childLogWithOverrides = log.child({ name: 'override', reporters: [], // may override settings of the parent logger filters: [], extensions: [],}); Скопировать "},{"title":"Display logs","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#display-logs","content":"Library allows to specify used logging level, show/hide logs for specific instances of the logger, reset display settings. By default, error level is used for every logger. Settings display level higher than error for single logger, e.g. logger.enable('info', 'my-logger'), overrides logging level only for my-logger. It is impossible to set logging level lower than common level, e.g. when using common logging level equal to error calls to logger.enable('fatal', 'my-logger') changes nothing. All subsequent setup for log displaying are preserved, e.g. subsequent calls logger.enable('info', 'my-logger') and logger.enable('trace', 'yet-another-logger') will enable logs to both logger according to their settings. Display logs on server# For control of displaying logs on server environment variables LOG_LEVEL and LOG_ENABLE are used: LOG_LEVEL = trace | debug | info | warn | error | fatal - enables displaying logs for specified level and higher. E.g.: if LOG_LEVEL=info then all logs of levels info, warn, error, fatal will be showed. LOG_ENABLE = ${name} | ${level}:${name} - let to enable displaying logs for a specific name and level. It can accept several entries that are passed as comma-separated. E.g.: if LOG_ENABLE=server then all logs for name server will be displayedif LOG_ENABLE=trace:server* then for logs with name server only trace level will be showedif LOG_ENABLE=info:server,client,trace:shared then displaying logs will be enabled for specified loggers using rules above Display logs in browser# In browser display settings are stored in localStorage, so it will work even after page reloads. In order to reset settings you may clear localStorage. For convenient usage a special object logger is added to window object in the browser. logger === window.logger; logger.setLevel('warn'); // enable displaying log for level `warn` and higher logger.enable('info', 'test'); // enable displaying logs for logger `test` with level `info` также отображать вывод логгера test уровня info logger.enable('my-logger'); // show all logs for logger `my-logger` logger.enable('perf*'); // enable all logs with name starting with `perf` logger.disable('my-logger'); // disable displaying logs for `my-logger` logger.clear(); // reset all settings Скопировать "},{"title":"Configuration","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#configuration","content":"Local logger configuration# import { logger } from '@tinkoff/logger'; const log = logger({ name: 'my-logger' }); // name is required field in order to identify logsconst log = logger('my-logger'); // same as above const log = logger({ name: 'remote-logger', defaults: { remote: true, },}); Скопировать Options: name[='log'] - name of the new logger "},{"title":"Extend logger functionality","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#extend-logger-functionality","content":"@tinkoff/logger might be extended using next entities: Filter# Filters can disable logging for specific logs base on inner conditions import { logger } from '@tinkoff/logger'; interface Filter { filter(logObj: LogObj): boolean;} logger.addFilter(filter as Filter); // add new filter to list of previously added filterslogger.setFilters([filter1, filter2]); // replace current filters with passed list. that allows to override default settings Скопировать Extension# Extensions can extend or override log object before making actual logging import { logger } from '@tinkoff/logger'; interface Extension { extend(logObj: LogObj): LogObj;} logger.addExtension(extension as Extension); // add new extension to list of previously added extensionslogger.setExtensions([extension1, extension2]); // replace current extensions with passed list. that allows to override default settings Скопировать Reporter# Reporters can change the way logs are showed (json, fancy logs in browser, send logs to remote api). Be default, enabled only reporters for displaying logs in console based on display logs settings Reporters are depends of logger level settings as reporters will not be called if level of the current log are lower than display logs setting import { logger } from '@tinkoff/logger'; interface Reporter { log(logObj: LogObj): void;} logger.addReporter(reporter as Reporter); // add new reporter to list of previously added reporterslogger.setReporters([reporter1, reporter2]); // replace current reporters with passed list. that allows to override default settings Скопировать BeforeReporter# Same as usual Reporter but BeforeReporter are called unconditionally for every log and get called before any other extension. import { logger } from '@tinkoff/logger'; interface Reporter { log(logObj: LogObj): void;} logger.addBeforeReporter(reporter as Reporter); // add new beforeReporter to list of previously added beforeReporterlogger.setBeforeReporters([reporter1, reporter2]); // replace current beforeReporters with passed list. that allows to override default settings Скопировать "},{"title":"Bundled Reporters","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#bundled-reporters","content":"BrowserReporter# Standard reporter to show logs in browser NodeDevReporter# Standard reporter to showing logs in the server console with handy formatting Used by default in dev-mode or if environment variable process.env.DEBUG_PLAIN is specified. NodeBasicReporter# Minimal reporter to showing logs in the server console. JSONReporter# Show logs in json format. RemoteReporter# Sends logs on remote api. import { logger, RemoteReporter } from '@tinkoff/logger'; const remote = new RemoteReporter({ requestCount: 1, // number of parallel request emitLevels: { error: true, fatal: true }, // log levels which will be send to api async makeRequest(logObj) { // function that accepts log object and sends data to api return await request(); },}); logger.addReporter(remote); const log = logger({ name: 'test-remote' }); // settings for remote will be inherited from RemoteReporter itself log.error('error'); // will be sent to apilog.info('test'); // will not be sent to api const remoteLog = logger({ name: 'remote-for-all', remote: true }); // `remote` allows to override settings from RemoteReporter and send logs unconditionally remoteLog.info('test'); // will be sent to apiremoteLog.debug('test'); // will be sent to api const traceLog = logger({ name: 'log-trace', emitLevels: { trace: true } }); // override RemoteReporter settings traceLog.trace('test'); // will be sent to apitraceLog.error('test'); // will not be sent to api Скопировать "},{"title":"How to","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#how-to","content":""},{"title":"Base usage","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#base-usage","content":"import logger from '@tinkoff/logger'; // import logger const log = logger('my-component'); // create new logger with an id `my-component`. This id will be added for every log at field `name`. Using unique ids will help to find source of the logs // logs can be created with different levelslog.trace('trace');log.debug('debug');log.info({ event: 'client-visited', message: 'client visited tinkoff.ru' });log.warn('warn');log.error({ event: 'form-send-error', error: new Error('form') });log.fatal('fatal error'); Скопировать More about logging level and what do they mean in the article. "},{"title":"How to log properly","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#how-to-log-properly","content":"To log properly it is suitable to use next format: interface Log { event?: string; // unique id of event which is might be easily found in log management tool message?: string; // log description error?: Error; // error if appropriate [key]: any; // any other data} Скопировать In case of logging simple text just use string template to pass result string to logger. For json format this string will be available in the message props. logger.info('hello logger'); // identical to logger.info({ message: 'hello logger' }); Скопировать In order to log some object or many arguments, compile they together to single object: logger.warn({ message: 'be warn', event: 'my-warning', ...obj1, ...obj2, a: 1, b: 2,}); Скопировать In order to log error object either pass the error with the props error or pass it to logger as only argument logger.error({ error: new Error('message'),}); logger.error(new Error('message'));logger.error(new Error('typeError'), 'custom error message'); // a special format to redefine error message Скопировать In case of several arguments were passed to logger then only the first argument will be proceeded with the rules from above while all of the other arguments will be passed as an args props logger.debug( { event: 'watch', data: 'some data', }, 'arg2', 'arg3'); Скопировать These formatting rules are handful to connect logging to external tools like kibana, splunk. So it is desirable to follow these rules, otherwise it may lead to troubles with searching and analyzing your logs. "},{"title":"Troubleshooting","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#troubleshooting","content":""},{"title":"I use logger in my Nest.js application, and it does not work","type":1,"pageTitle":"logger","url":"docs/references/libs/logger#i-use-logger-in-my-nestjs-application-and-it-does-not-work","content":"Be sure that you set all required environment variable (LOG_LEVEL and LOG_ENABLE) before app initialization. If you set all variable in .env and parse them via Nest.js's ConfigModule, they will not be available in the logger initialization phase. ConfigModule parses .env-file later. Also, check here that DEBUG_PLAIN or NODE_ENV variables are available. "},{"title":"mocker","type":0,"sectionRef":"#","url":"docs/references/libs/mocker","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#installation","content":"Install @tinkoff/mocker: yarn add @tinkoff/mocker Скопировать Add your first mock to file mocks/first-api.js: module.exports = { api: 'first-api', mocks: { 'GET /endpoint': { status: 200, headers: {}, payload: 'mocked response', }, },}; Скопировать Set up mocker in your project: import { Mocker, FileSystemMockRepository } from '@tinkoff/mocker'; // Repository will read mocks from directory `mocks` relative from current dirconst repository = new FileSystemMockRepository({ cwd: process.cwd(), root: 'mocks' });// Mocker to all of the request on `/first-api/...` will response with mock found in fs or with proxying request to the source APIconst options = { apis: { 'first-api': { target: 'https://real-first-api.com/', }, }, passUnhandledRequests: true,}; const mocker = new Mocker({ options, repository, logger: console }); (async () => { // with this call mocker reads mocks from repository and creates according routes await mocker.init(); mocker.start(4000, () => { console.log('Mocker is running at 4000 port'); });})(); Скопировать Now we can make a GET request to mocker (async () => { const response = await fetch('http://localhost:4000/first-api/endpoint'); const data = await response.json(); console.log(data); // \"mocked response\"})(); Скопировать "},{"title":"Explanation","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#explanation","content":"Library is based on express. mocker can be used as standalone server or as a middleware for existing server through call mocker.use(req, res). FileSystemMockRepository supports mock in js и json formats. js mocks are able to define custom express handler as a mock handler. For choosing right mock for request next parameters of the request are considered: method, url and query. Mocker supports proxying requests to API that allows to mock only part of the API and not a whole backend "},{"title":"Routing","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#routing","content":"If mocker is running as a standalone server, for example on 4000 port, then it will be accessible at url http://localhost:4000/. For every api from settings options.apis will be created a nester router, e.g. for first-api it will be http://localhost:4000/first-api/. Routes for api are getting created based on mocks, in which key is a method + url of the request, e.g. mock GET /endpoint will be accessible at http://localhost:4000/first-api/endpoint for GET requests. "},{"title":"FileSystem mocks","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#filesystem-mocks","content":"Mocker reads mocks using Repository, that allows to store mocks in FileSystem or on the another server. FileSystemMockRepository works with FileSystem and supports next kinds of mocks: mock.json { \"api\": \"first-api\", \"mocks\": { \"GET /foo\": { \"status\": 200, \"headers\": {}, \"payload\": { \"fake\": \"true\" } } }} Скопировать mock.js module.exports = { api: 'first-api', mocks: { 'GET /bar': { status: 200, headers: {}, payload: { fake: 'true', }, }, 'POST /bar': (req, res) => { res.status(200); res.set('X-Mock-Server', 'true'); res.json({ fake: 'true' }); }, },}; Скопировать "},{"title":"API","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#api","content":""},{"title":"Mocker","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#mocker","content":"interface Mocker { new (params: { options: MockerOptions; repository: MockRepository; logger: Logger }): Mocker; init(): Promise<void>; update(): Promise<void>; use(req: IncomingMessage, res: ServerResponse): express.Express; start(port: number, callback?: (...args: any[]) => void): Server;} Скопировать Mocker.init - resolve mocks using MockRepository, routing initialization. Must be called before using server with mocks. Mocker.update - updating mocks using MockRepository, routing update. Might be called in runtime. Mocker.use - express middleware. Might be used for adding mocker on the existing server. Mocker.start - run mocker as a standalone http-server. "},{"title":"MockerOptions","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#mockeroptions","content":"interface MockerOptions { apis: Record<string, { target: string }>; passUnhandledRequests?: boolean; apiRoutePrefix?: string;} Скопировать MockerOptions.apis - list of APIs for mocking, key target points to the source API. MockerOptions.passUnhandledRequests - when enabled, all of the request without according mock will be proxied to the target, otherwise fail the request. MockerOptions.apiRoutePrefix - if mocker is used in existing server on nested route, e.g. /mocker, this option might be used to pass this route as apiRoutePrefix for proper routing. "},{"title":"MockRepository","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#mockrepository","content":"interface MockRepository { get(api: string, endpoint: string): Promise<Mock>; getAll(api: string): Promise<Record<string, Mock>>; add(api: string, endpoint: string, mock: Mock): Promise<void>; delete(api: string, endpoint: string): Promise<void>;} Скопировать MockRepository.getAll - get all mocks for specified API. MockRepository.get - get specific mock for specific API. MockRepository.add - add new mock for specific API. MockRepository.delete - remove specific mock for specific API. "},{"title":"How to","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#how-to","content":""},{"title":"How to mock request with specific query parameters?","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#how-to-mock-request-with-specific-query-parameters","content":"Mocker allows to specify query parameters for mocks. In the example below request to /endpoint?foo=bar will be mocked with first mock, and request to /endpoint?foo=baz will be mocked with second. All of the other requests with\\without query will be proxied to source API (if passUnhandledRequests is enabled). module.exports = { api: 'api', mocks: { 'GET /endpoint?foo=bar': { status: 200, headers: {}, payload: 'mocked bar response', }, 'GET /endpoint?foo=baz': { status: 200, headers: {}, payload: 'mocked baz response', }, },}; Скопировать "},{"title":"How to proxy specific request to source API?","type":1,"pageTitle":"mocker","url":"docs/references/libs/mocker#how-to-proxy-specific-request-to-source-api","content":"It might be useful if option passUnhandledRequests is disabled. In that case you may pass option pass: true to mock: module.exports = { api: 'api', mocks: { 'ALL /endpoint': { pass: true, }, },}; Скопировать "},{"title":"module-loader-client","type":0,"sectionRef":"#","url":"docs/references/libs/module-loader-client","content":"","keywords":""},{"title":"Установка","type":1,"pageTitle":"module-loader-client","url":"docs/references/libs/module-loader-client#установка","content":"Для yarn: yarn add @tinkoff/module-loader-client Скопировать Для npm: npm install @tinkoff/module-loader-client Скопировать "},{"title":"Подключение и использование","type":1,"pageTitle":"module-loader-client","url":"docs/references/libs/module-loader-client#подключение-и-использование","content":""},{"title":"loadModule","type":1,"pageTitle":"module-loader-client","url":"docs/references/libs/module-loader-client#loadmodule","content":"В loadModule встроена дедубликация загрузки через поиск уже вставленного скрипта с тем же урлом, что позволяет инициировать загрузку скриптов на этапе разбора html, в этом случае вы должны самостоятельно навесить атрибут loaded скрипту, чтобы метод loadModule понимал загружен скрипт или еще нет: <script src=\"https://cdn.example.com/bundle.js\" onload=\"this.setAttribute('loaded', true)\" onerror=\"this.setAttribute('loaded', 'error')\"/> Скопировать Пример использования: import { loadModule } from '@tinkoff/module-loader-client'; loadModule('https://cdn.example.com/js/module.js', { cssUrl: 'https://cdn.example.com/js/module.css', // опционально}).then(() => { // ...}); Скопировать "},{"title":"addScript","type":1,"pageTitle":"module-loader-client","url":"docs/references/libs/module-loader-client#addscript","content":"Вставляет тег script без какой-либо допольнительной логике по дедубликации: import { addScript } from '@tinkoff/module-loader-client'; addScript(src, maybeAttrs, maybeScriptHandler).then(() => something()); Скопировать Коллбэк вызывается сихронно, в который передается непосредственно script элемент. "},{"title":"addLink","type":1,"pageTitle":"module-loader-client","url":"docs/references/libs/module-loader-client#addlink","content":"Вставляет тег link без какой-либо допольнительной логике по дедубликации: import { addLink } from '@tinkoff/module-loader-client'; addLink(type, href, maybeAttrs).then(() => something()); Скопировать "},{"title":"Интерфейс и типы","type":1,"pageTitle":"module-loader-client","url":"docs/references/libs/module-loader-client#интерфейс-и-типы","content":" type LogFunction = (...args: unknown[]) => void; export interface Logger { trace: LogFunction; debug: LogFunction; info: LogFunction; warn: LogFunction; error: LogFunction;} export interface LoadModuleOptions { cssUrl?: string;} Скопировать  "},{"title":"papi","type":0,"sectionRef":"#","url":"docs/references/libs/papi","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"papi","url":"docs/references/libs/papi#подключение","content":"Необходимо установить @tramvai/papi yarn add @tramvai/module-papi Скопировать "},{"title":"Использование","type":1,"pageTitle":"papi","url":"docs/references/libs/papi#использование","content":"import { createPapiMethod } from '@tramvai/papi'; export const papi = createPapiMethod({ path: '/my/papi', method: 'post', async handler(deps) { return 'test'; }, deps: { tinkoffApiService: TINKOFF_API_SERVICE, },}); Скопировать "},{"title":"module-loader-server","type":0,"sectionRef":"#","url":"docs/references/libs/module-loader-server","content":"","keywords":""},{"title":"Установка","type":1,"pageTitle":"module-loader-server","url":"docs/references/libs/module-loader-server#установка","content":"Для yarn: yarn add @tinkoff/module-loader-server Скопировать Для npm: npm install @tinkoff/module-loader-server Скопировать "},{"title":"Подключение и использование","type":1,"pageTitle":"module-loader-server","url":"docs/references/libs/module-loader-server#подключение-и-использование","content":"import { ServerLoader } from '@tinkoff/module-loader-server'; const loader = new ServerLoader(); loader.resolveByUrl('https://cdn.example.com/js/module.js').then((moduleExports) => { // ...}); Скопировать В конструктор можно передать опции (см. интерфейс LoaderDeps), из важных это параметр request который по умлочанию определяется библиотекой request, и содержит только deduplicate плагин. Если вам нужны другие плагины или поведение при запросе на сервер, переопределите параметр request в конструкторе лоадера. "},{"title":"Взаимодействие с кешем","type":1,"pageTitle":"module-loader-server","url":"docs/references/libs/module-loader-server#взаимодействие-с-кешем","content":"Допустим вам нужно сихронное апи для получения объекта, при условии что он есть в кэше. Тогда есть два способа. Первый, используем метод loadByUrl<R>(url: string, options: LoadOptions), который возвращает Promise<R> если объекта нет в кеше, и R если он там есть: const result = loader.loadByUrl(url);if (!isPromise(result)) { syncOperation(result);} else { asyncOperation(result);} Скопировать Второй, можно использовать метод getByUrl<R = any>(url: string, options: LoadOptions = {}): R | void, который возвращает объект, только если он присутствует в кеше: const result = loader.getByUrl(url);if (result !== void 0) { syncOperation(result);} else { asyncOperation(loader.resolveByUrl(url));} Скопировать "},{"title":"Интерфейс и типы","type":1,"pageTitle":"module-loader-server","url":"docs/references/libs/module-loader-server#интерфейс-и-типы","content":" type LogFunction = (...args: unknown[]) => void; export interface Logger { trace: LogFunction; debug: LogFunction; info: LogFunction; warn: LogFunction; error: LogFunction;} export type RequestFunc = (options: { url: string; responseType?: string }) => Promise<any>; export interface Cache { get: (key: string) => any; set: (key: string, module: any) => void;} export interface LoaderDeps { log?: Logger; request?: RequestFunc; cache?: Cache; externals?: Record<string, any>; debug?: string[];} export interface LoadOptions { [key: string]: any; // тип ресурса, по умолчанию 'module', используется при логировании kind?: string; // если задан, будет использоваться после kind при логировании displayName?: string; // если задан, ресурс будет проверен на соответствие заданному хешу integrity?: string; codePrefix?: string;} Скопировать  "},{"title":"prettier","type":0,"sectionRef":"#","url":"docs/references/libs/prettier","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"prettier","url":"docs/references/libs/prettier#installation","content":"Install with package manager, e.g. for npm: npm i --save-dev prettier-config-tinkoff Скопировать Create new file .prettierrc.js in project root: module.exports = require('prettier-config-tinkoff'); Скопировать It will set default settings from config, in order to change some settings follow official guide for prettier "},{"title":"React Hooks","type":0,"sectionRef":"#","url":"docs/references/libs/react-hooks","content":"","keywords":""},{"title":"Api","type":1,"pageTitle":"React Hooks","url":"docs/references/libs/react-hooks#api","content":""},{"title":"useShallowEqual","type":1,"pageTitle":"React Hooks","url":"docs/references/libs/react-hooks#useshallowequal","content":"Makes shallow equal check for passed argument. If current argument is equal to previous then result of the hook will not be changed. Otherwise it will be equal to a current argument. import { useEffect } from 'react';import { useShallowEqual } from '@tinkoff/react-hooks'; export function Cmp({ obj }) { // obj - some object // objRef - reference to object. For example, if reference obj were changed after sequential render, // but it still shallow equals to initial obj then objRef will reference to the initial obj ссылка на объект obj const objRef = useShallowEqual(obj); useEffect(() => { // React checks deps with reference equality that may lead to unnecessary hook call when reference were changed // but we care only about actual changes to object itself not reference // in that case objRef will not lead to effect call in case new reference is shallowly equal to previous }, [objRef]);} Скопировать "},{"title":"pubsub","type":0,"sectionRef":"#","url":"docs/references/libs/pubsub","content":"","keywords":""},{"title":"subscribe - event subscription","type":1,"pageTitle":"pubsub","url":"docs/references/libs/pubsub#subscribe---event-subscription","content":"pubsub.subscribe('type', callback) - subscribe to event with name type. callback accepts as arguments payload from pubsub.publish. callback can return promise which will can be awaited from call pubsub.publish. "},{"title":"publish - event publish","type":1,"pageTitle":"pubsub","url":"docs/references/libs/pubsub#publish---event-publish","content":"pubsub.publish('type', ...args) - publish event with name type. args will be passed as arguments to the subscribers. Return promise which will be resolved after resolve of all subscriptions. "},{"title":"Typed PubSub","type":1,"pageTitle":"pubsub","url":"docs/references/libs/pubsub#typed-pubsub","content":"PubSub can use typed events. For example: a common PubSub with many events and subscriptions. In order to enable type checking for event subscriptions: Create a new type with all event definitions: type MyAwesomeFeatureEvents = { event1: (payload: number) => any; event2: (payload: { prop: boolean }) => any;}; Скопировать Do a typecast in code when using PubSub instance. It will enable type checks for every usage for a new typed instance const featurePubSub = (pubSub as any) as PubSub<MyAwesomeFeatureEvents>; // OK! 👍featurePubSub.subscribe('event1', (payload) => console.log(1 + payload));featurePubSub.publish('event1', 2); // Error 👎featurePubSub.subscribe('event3', (payload) => console.log(1 + payload)); // No such eventfeaturePubSub.publish('event3', 2); // НNo such event featurePubSub.subscribe('event1', (payload) => payload.toLowerCase()); // Wrong payload typefeaturePubSub.publish('event1', 'string'); // number expected Скопировать "},{"title":"safe-strings","type":0,"sectionRef":"#","url":"docs/references/libs/safe-strings","content":"","keywords":""},{"title":"safeParseJSON","type":1,"pageTitle":"safe-strings","url":"docs/references/libs/safe-strings#safeparsejson","content":"Tries to parse json and if it successful returns it, otherwise returns second argument as default value. "},{"title":"safeStringify","type":1,"pageTitle":"safe-strings","url":"docs/references/libs/safe-strings#safestringify","content":"Converts object to json with a replacement of insecure symbols that allows to insert result string in the response html "},{"title":"safeStringiyfJSON","type":1,"pageTitle":"safe-strings","url":"docs/references/libs/safe-strings#safestringiyfjson","content":"Converts object to json with a circular reference handling "},{"title":"removeXss","type":1,"pageTitle":"safe-strings","url":"docs/references/libs/safe-strings#removexss","content":"Removes possible xss strings "},{"title":"tinkoff-request-http-client-adapter","type":0,"sectionRef":"#","url":"docs/references/libs/tinkoff-request-http-client-adapter","content":"","keywords":""},{"title":"API","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#api","content":""},{"title":"createAdapter","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#createadapter","content":"createAdapter - factory to create an HTTP client. It configures an instance of @tinkoff/request via createTinkoffRequest, and based on it creates an instance of HttpClientAdapter type createAdapter = (options: TinkoffRequestOptions) => HttpClient; Скопировать "},{"title":"TinkoffRequestOptions","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#tinkoffrequestoptions","content":"interface TinkoffRequestOptions extends HttpClientRequest { // tramvai logger logger?: typeof LOGGER_TOKEN; // namespace for the logger, the prefix `request.` will be added to it name?: string; // will disable the default caching via `@tinkoff/request-plugin-cache-memory` disableCache?: boolean; // cache factory for `@tinkoff/request-plugin-cache-memory` createCache?: (options: any) => any; // cache ttl for `@tinkoff/request-plugin-cache-memory` cacheTime?: number; // the default request execution time limit, in ms defaultTimeout?: number; // response validator for `@tinkoff/request-plugin-validate` validator?: RequestValidator; // error validator for `@tinkoff/request-plugin-validate` errorValidator?: RequestValidator; // method allows you to modify the error object before sending logs from `@tinkoff/request-plugin-log` errorModificator?: RequestValidator;} Скопировать "},{"title":"createTinkoffRequest","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#createtinkoffrequest","content":"createTinkoffRequest - creates an instance of @tinkoff/request with all the necessary plugins type createTinkoffRequest = (options: TinkoffRequestOptions) => MakeRequest; Скопировать "},{"title":"HttpClientAdapter","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#httpclientadapter","content":"HttpClientAdapter - adapts @tinkoff/request to the interface HttpClient. The request method wraps the request parameters in the modifyRequest option, and passes them to @tinkoff/request. Then, the received response is modified in the HttpClientRequest, and wrapped in the modifyResponse option. If there is an error, it will wrapped into the modifyError option. The fork method creates a new instance of HttpClientAdapter, but with the same @tinkoff/request instance. type HttpClientAdapter = HttpClient; Скопировать "},{"title":"mergeOptions","type":1,"pageTitle":"tinkoff-request-http-client-adapter","url":"docs/references/libs/tinkoff-request-http-client-adapter#mergeoptions","content":"By default, mergeOptions compose modifyRequest, modifyResponse and modifyError options, with the corresponding options from options being executed first, then from nextOptions. If you pass a third parameter { replace: true }, all parameters of the same name from options will simply be overwritten by parameters from nextOptions type mergeOptions = ( options: HttpClientRequest, nextOptions: HttpClientRequest, config?: { replace?: boolean }) => HttpClientRequest; Скопировать "},{"title":"router","type":0,"sectionRef":"#","url":"docs/references/libs/router","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"router","url":"docs/references/libs/router#installation","content":"You need to install @tinkoff/router: yarn add @tinkoff/router Скопировать And connect it to the project: import { Router } from '@tinkoff/router'; const router = new Router(); Скопировать "},{"title":"Explanation","type":1,"pageTitle":"router","url":"docs/references/libs/router#explanation","content":"Features: The library supports options for working both on the server and on the client.It is possible to use different client transition options: with or without SPA transitions.There are Guards to check the availability of a route under specific conditions.You can subscribe to different stages of the transition through hooksComponents and hooks for easy routing from react "},{"title":"Server and client version","type":1,"pageTitle":"router","url":"docs/references/libs/router#server-and-client-version","content":"It is enough just to import routing from the library itself and, based on the settings in package.json, the required version for the server or client will be returned import { Router } from '@tinkoff/router'; Скопировать "},{"title":"Client routing with/without SPA transitions","type":1,"pageTitle":"router","url":"docs/references/libs/router#client-routing-withwithout-spa-transitions","content":"By default, routing with SPA transitions is enabled on the client. If you need to disable SPA transitions, you need to import a special version of the routing import { Router, SpaHistory } from '@tinkoff/router';import { NoSpaRouter } from '@tinkoff/router'; const spaRouter = new Router({ history: new SpaHistory() });const noSpaRouter = new NoSpaRouter(); Скопировать "},{"title":"Router Guards","type":1,"pageTitle":"router","url":"docs/references/libs/router#router-guards","content":"Guards allow you to control the availability of a particular route for a specific transition. From the guard, you can block the transition or initiate a redirect. import { NavigationGuard } from '@tinkoff/router'; export const myGuard: NavigationGuard = async ({ to }) => { if (to.config.blocked) { return false; // block this transition } if (to.config.redirect) { return '/login/'; // call a redirect to the specified page } // if nothing is returned, the transition will be performed as usual}; router.registerGuard(myGuard); Скопировать Rules# guards are asynchronous and it execution will be awaited inside routingall guards are running in parallel and they are all awaitedif several guars return something then the result from a guard that was registered early will be used Possible result# The behaviour of routing depends on the result of executing guards functions and there result might be next: if all of the guards returns undefined than navigation will continue executingif any of the guards returns false than navigation is getting blocked and next action differs on server and clientif any of the guards returns string it is considered as url to which redirect should be happen "},{"title":"Transitions hooks","type":1,"pageTitle":"router","url":"docs/references/libs/router#transitions-hooks","content":"Transition hooks allow you to perform your asynchronous actions at different stages of the transition. import { NavigationHook } from '@tinkoff/router'; export const myHook: NavigationHook = async ({ from, to, url, fromUrl }) => { console.log(`navigating from ${from} to route ${to}`);}; router.registerHook('beforeNavigate', myHook); Скопировать Rules# all hooks from the same event are running in parallelmost of the hooks are asynchronous and are awaited inside routerif some error happens when running hook it will be logged to console but wont affect navigation (except for the beforeResolve hook - error for it will be rethrown) List of available hooks# Async hooks: navigate hooks - asynchronous hooks only for navigate callsupdateCurrentRoute hooks - asynchronous hooks only for updateCurrentRoute calls Sync hooks: change - runs when any of changes to current route\\url happens "},{"title":"API","type":1,"pageTitle":"router","url":"docs/references/libs/router#api","content":""},{"title":"Getting data about the current route or url","type":1,"pageTitle":"router","url":"docs/references/libs/router#getting-data-about-the-current-route-or-url","content":"router.getCurrentRoute(); // will return the current routerouter.getCurrentUrl(); // will return the parsed version of the url of the current page Скопировать "},{"title":"Transition initiation","type":1,"pageTitle":"router","url":"docs/references/libs/router#transition-initiation","content":"There are two methods for initializing the navigation and updating the address bar in the browser. The main difference between these two methods is that one of them will launch a full-fledged transition with data updating and starting heavy data loading actions. The second method is mainly used to update the state for the current route: to update the query parameters on the page or change the dynamic parameters of the route itself. navigate# Initiates a full transition, defining the next route and updating the state in the browser. router.navigate('/test');router.navigate({ url: './test', query: { a: '1' } }); Скопировать navigate hooks# beforeResolvebeforeNavigateafterNavigate navigate workflow# beforeResolve hookguardsbeforeNavigatechangeafterNavigate updateCurrentRoute# The transition is based on the current route (therefore this method cannot be called on the server) and allows you to simply update some data for the current page router.updateCurrentRoute({ params: { id: 'abc' } });router.updateCurrentRoute({ query: { a: '1' } }); Скопировать updateCurrentRoute hooks# beforeUpdateCurrentafterUpdateCurrent updateCurrentRoute workflow# beforeUpdateCurrentchangeafterUpdateCurrent "},{"title":"Working with query","type":1,"pageTitle":"router","url":"docs/references/libs/router#working-with-query","content":"query option# Allows you to set a search string for an url as an object via the query option when navigating. The previous query value will be cleared router.getCurrentUrl().query; // { с: 'c' } router.navigate({ query: { a: 'a', b: 'b' } });router.updateCurrentRoute({ query: { a: 'a', b: 'b' } }); router.getCurrentUrl().query; // { a: 'a', b: 'b' } Скопировать preserveQuery# Allows you to keep the query value from the current navigation and use them in a new transition router.getCurrentUrl().query; // { с: 'c' } router.navigate({ query: { a: 'a' }, preserveQuery: true });router.updateCurrentRoute({ query: { a: 'a' }, preserveQuery: true }); router.getCurrentUrl().query; // { a: 'a', c: 'c' } Скопировать If you pass undefined as the value for a specific query key, then this value will be cleared in a new query: router.getCurrentUrl().query; // { a: 'a', b: 'b' } router.navigate({ query: { a: undefined, c: 'c' }, preserveQuery: true });router.updateCurrentRoute({ query: { a: undefined, c: 'c' }, preserveQuery: true }); router.getCurrentUrl().query; // { b: 'b', c: 'c' } Скопировать "},{"title":"Constructor options","type":1,"pageTitle":"router","url":"docs/references/libs/router#constructor-options","content":"trailingSlash - do router should force all urls to end with slash. If true - force trailing slash for every path, false - force no trailing slash, undefined - trailing slash is specified by request and both trailing and not trailing slashes are used. By default value if undefinedmergeSlashes - replace several consecutive slashes by single slashes (slashes after protocol are still be with // after protocol name). By default is false - no merge for slashes. "},{"title":"Integration with React","type":1,"pageTitle":"router","url":"docs/references/libs/router#integration-with-react","content":"Library has some useful React hooks and components for working with routing useRoute# Returns current active route of the application import React from 'react';import { useRoute } from '@tinkoff/router'; export const Component = () => { const route = useRoute(); return <div>Route path: {route.actualPath}</div>;}; Скопировать useUrl# Returns current active URL of the application import React from 'react';import { useUrl } from '@tinkoff/router'; export const Component = () => { const url = useUrl(); return <div>Url query: {JSON.stringify(url.query)}</div>;}; Скопировать useNavigate# Creates a callback with a navigation call that can be passed to child components or used as an event handler export const Cmp = () => { const navigate = useNavigate('/test/'); return <div onClick={navigate}>Test</div>;}; Скопировать Link# A wrapper for a react component that makes it clickable If the react component is passed to the Link as children, then this passed component will be rendered and the href, onClick props will be passed as props to that component and they should be used to make the navigation. Otherwise, the <a> tag will be rendered with children as a child. import { Link } from '@tinkoff/router';import CustomLink from '@custom-scope/link'; export const Component = () => { return ( <Link url=\"/test/\"> <CustomLink /> </Link> );}; export const WrapLink = () => { return <Link url=\"/test/\">Click me</Link>;}; Скопировать "},{"title":"How to","type":1,"pageTitle":"router","url":"docs/references/libs/router#how-to","content":""},{"title":"Load route config from external api","type":1,"pageTitle":"router","url":"docs/references/libs/router#load-route-config-from-external-api","content":"Use transition hookbeforeResolve and load routes config based on url. router.registerHook('beforeResolve', async (navigation) => { const route = await routeResolve(navigation); if (route) { router.addRoute(routeTransform(route)); }}); Скопировать "},{"title":"App behind proxy","type":1,"pageTitle":"router","url":"docs/references/libs/router#app-behind-proxy","content":"Router doesn't support proxy setup directly. But proxy still can be used with some limitations: setup proxy server to pass requests to app with rewriting request and response paths. (E.g. for nginx)it wont work as expected on spa navigation on client, so only option in this case is use the NoSpaRouter "},{"title":"url","type":0,"sectionRef":"#","url":"docs/references/libs/url","content":"","keywords":""},{"title":"Api","type":1,"pageTitle":"url","url":"docs/references/libs/url#api","content":""},{"title":"parse","type":1,"pageTitle":"url","url":"docs/references/libs/url#parse","content":"Parses url and returns object of class URL with additional property query which represents searchParams as a simple object. import { parse } from '@tinkoff/url'; const url = parse('https://tinkoff.ru/test/?a=1&b=2#abc'); url.protocol; // => :httpsurl.href; // => https://tinkoff.ru/test/?a=1&b=2#abcurl.origin; // => https://tinkoff.ruurl.pathname; // => /test/url.hash; // => #abcurl.query; // => { a: '1', b: '2' } Скопировать "},{"title":"rawParse","type":1,"pageTitle":"url","url":"docs/references/libs/url#rawparse","content":"Same as parse but instead of returning wrapper for URL returns raw URL object "},{"title":"resolve","type":1,"pageTitle":"url","url":"docs/references/libs/url#resolve","content":"Computes absolute url for relative url of base value import { resolve } from '@tinkoff/url'; resolve('//tinkoff.ru', './test123'); // => http://tinkoff.ru/test123resolve('//tinkoff.ru/a/b/c/', '../../test'); // => http://tinkoff.ru/a/testresolve('https://tinkoff.ru/a/b/c/?test=123#abc', '.././test/?me=123#123'); // => https://tinkoff.ru/a/b/test/?me=123#123 Скопировать "},{"title":"resolveUrl","type":1,"pageTitle":"url","url":"docs/references/libs/url#resolveurl","content":"Computes absolute url for relative url of base value. Unlike resolve can accept string or URL and return URL wrapper "},{"title":"rawResolveUrl","type":1,"pageTitle":"url","url":"docs/references/libs/url#rawresolveurl","content":"Same as resolveUrl but instead of returning wrapper for URL returns raw URL object "},{"title":"isAbsoluteUrl","type":1,"pageTitle":"url","url":"docs/references/libs/url#isabsoluteurl","content":"Checks that passed string is absolute url "},{"title":"isInvalidUrl","type":1,"pageTitle":"url","url":"docs/references/libs/url#isinvalidurl","content":"Checks that passed string represents invalid url import { isAbsoluteUrl } from '@tinkoff/url'; isAbsoluteUrl('https://www.exmaple.com'); // true - secure http absolute URLisAbsoluteUrl('//cdn.example.com/lib.js'); // true - protocol-relative absolute URLisAbsoluteUrl('/myfolder/test.txt'); // false - relative URL Скопировать "},{"title":"convertRawUrl","type":1,"pageTitle":"url","url":"docs/references/libs/url#convertrawurl","content":"Returns handy wrapper for URL in form of plain object with some additional fields "},{"title":"rawAssignUrl","type":1,"pageTitle":"url","url":"docs/references/libs/url#rawassignurl","content":"Allows to set parameters to passed raw URL object (passed URL-object will be changed) "},{"title":"user-agent","type":0,"sectionRef":"#","url":"docs/references/libs/user-agent","content":"user-agent Library for parsing and executing check to userAgent string. Based on ua-parser-js","keywords":""},{"title":"autoscroll","type":0,"sectionRef":"#","url":"docs/references/modules/autoscroll","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"autoscroll","url":"docs/references/modules/autoscroll#подключение","content":"Необходимо установить @tramvai/module-autoscroll yarn add @tramvai/module-autoscroll Скопировать Подключить в проекте AutoscrollModule import { createApp } from '@tramvai/core';import { AutoscrollModule } from '@tramvai/module-autoscroll'; createApp({ name: 'tincoin', modules: [AutoscrollModule],}); Скопировать Если нужно отключить подскрол для отдельных страниц - при переходе navigate нужно указать navigateState.disableAutoscroll = true import { useNavigate } from '@tramvai/module-router'; function Component() { const navigateToWithoutScroll = useNavigate({ url: '/url/', navigateState: { disableAutoscroll: true }, }); return <Button onClick={navigateToWithoutScroll} />;} Скопировать behavior: smooth поддерживается не во всех браузерах (например, плавный подскролл не работает в Safari). При необходимости подключите полифил smoothscroll-polyfill в свое приложение. "},{"title":"cache-warmup","type":0,"sectionRef":"#","url":"docs/references/modules/cache-warmup","content":"","keywords":""},{"title":"Как подключить?","type":1,"pageTitle":"cache-warmup","url":"docs/references/modules/cache-warmup#как-подключить","content":"По умолчанию модуль уже подключается в @tramvai/module-server и при его использовании дополнительных действий не требуется. import { createApp } from '@tramvai/core';import { CacheWarmupModule } from '@tramvai/module-cache-warmup'; createApp({ modules: [CacheWarmupModule],}); Скопировать "},{"title":"Что делает?","type":1,"pageTitle":"cache-warmup","url":"docs/references/modules/cache-warmup#что-делает","content":"При старте приложения с запрашивает у bundleInfo список урлов приложения. Затем шлет по 2 запроса на каждый из урлов, но не более 2 запросов одновременно. 2 запроса нужны для того, чтобы симулировать запрос с десктопа и мобильного устройства. User-Agentы, которые использует модуль: [ /** Chrome on Mac OS */ 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.87 Safari/537.36', /** Chrome on Mobile */ 'Mozilla/5.0 (Linux; Android 7.0; SM-G930V Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.125 Mobile Safari/537.36',]; Скопировать Модуль выполняется только при NODE_ENV === production. "},{"title":"Отладка","type":1,"pageTitle":"cache-warmup","url":"docs/references/modules/cache-warmup#отладка","content":"Модуль использует логгер с идентификатором cache-warmup "},{"title":"client-hints","type":0,"sectionRef":"#","url":"docs/references/modules/client-hints","content":"","keywords":""},{"title":"Подключение в проект","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#подключение-в-проект","content":""},{"title":"1. Зависимости","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#1-зависимости","content":"Необходимо установить @tramvai/module-client-hints с помощью npm npm i --save @tramvai/module-client-hints Скопировать или yarn add @tramvai/module-client-hints Скопировать "},{"title":"2. Подключение модуля","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#2-подключение-модуля","content":"Нужно передать в список модулей приложения ClientHintsModule import { createApp } from '@tramvai/core';import { ClientHintsModule } from '@tramvai/module-client-hints'; createApp({ modules: [ClientHintsModule],}); Скопировать "},{"title":"Экспортируемые токены","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#экспортируемые-токены","content":""},{"title":"USER_AGENT_TOKEN","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#user_agent_token","content":"Объект - результат парсинга строки юзер-агента с помощью @tinkoff/user-agent. Парсинг происходит только на сервере, на клиенте - используется инфомация с сервера. "},{"title":"Сторы","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#сторы","content":""},{"title":"userAgent","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#useragent","content":"Стор который хранит результат парсинга юзер-агента. "},{"title":"media","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#media","content":"Стор который хранит медиа-информацию о типе и размере экрана клиента. API для проверки media# Данные в сторе media: type Media = { width: number; height: number; isTouch: boolean; retina: boolean; supposed?: boolean; synchronized?: boolean;}; Скопировать fromClientHints(media: Media): boolean - возвращает true, когда media синхронизированны на сервере и на клиенте isSupposed(media: Media): boolean - возвращает true, когда media определены на сервере по User-Agent, и могут измениться на клиенте isRetina(media: Media): boolean - вовзращает true, когда плотность пикселей на экране 2 или выше useMedia(): Media - возвращает текущее состояние стора media useFromClientHints(): boolean - вычисляет fromClientHints из стора media useIsSupposed(): boolean - вычисляет isSupposed из стора media useIsRetina(): boolean - вычисляет isRetina из стора media "},{"title":"Особенности работы с media на сервере и клиенте","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#особенности-работы-с-media-на-сервере-и-клиенте","content":"Одна из проблем SSR - рендеринг компонентов, которые зависят от текущего размера экрана, например карусель изображений, которая должна рендерить определенное количество картинок, в зависимости от ширины экрана. По умолчанию, узнать точные размеры мы можем только на стороне клиента, и не имеем возможности отрисовать на сервере контент, идентичный клиенту. Если этот контент не требуется для SEO, можно использовать скелетоны или спиннеры, но это подходит не для всех случаев. Модуль Client Hints позволяет частично решить эту проблему, сохраняя данные об устройстве пользователя в cookies при первом заходе, и используя эти данные на сервере при следующих заходах на страницы приложения. "},{"title":"Механизм работы Client Hints","type":1,"pageTitle":"client-hints","url":"docs/references/modules/client-hints#механизм-работы-client-hints","content":"Первый заход на страницу# При первом заходе на страницу, на стороне сервере, модуль определяет тип устройство по User-Agent, и сохраняет предположительные данные об устройстве в стор media. Например, при первом заходе с компьютера, значение стора media будет таким: const state = { width: 1024, height: 768, isTouch: false, retina: false, supposed: true, synchronized: false,}; Скопировать На клиенте, ориентируясь на значение supposed: true, модуль получает реальные данные об устройстве, и обновляет стор media, вызывая перерендер зависимых компонентов. После этого, для широкоэкранного монитора, значение стора media может быть таким: const state = { width: 1920, height: 1080, isTouch: false, retina: true, supposed: false, synchronized: false,}; Скопировать Пока мы имеем значение synchronized: false, нельзя полагаться на данные из media для серверного рендеринга компонентов, т.к. это вызовет \"скачок\" при сохранении реальных данных об устройстве. Повторный заход на страницу# При повторном заходе на страницу, данные об устройстве считываются из cookies, значение synchronized выставляется в true. Таким образом, и на сервере, и на клиенте, мы получим одно значение стора media, и отсутствие перерендера на клиенте: const state = { width: 1920, height: 1080, isTouch: false, retina: true, supposed: false, synchronized: true,}; Скопировать Итоги# Общая информация для компонентов, которые зависят от текущего размера экрана: При первом заходе на страницу, нельзя гарантировать одинаковый результат рендеринга на сервере и на клиенте При первом заходе на страницу, можно показать юзеру скелетон компонента, отображая скелетон при свойстве supposed: true Гарантировать одинаковый результат рендеринга на сервере и на клиенте можно при свойстве synchronized: true Рецепт, который позволит показать скелетон только один раз, при первой загрузке приложения: const App = () => { const isSupposed = useIsSupposed(); if (isSupposed) { return <AdaptiveSliderSkeleton />; } return <AdaptiveSlider />;}; Скопировать Рецепт, который позволит рендерить общий адаптивный компонент при первой загрузке приложения, и выбирать отдельные под desktop и mobile при повторных загрузках: const App = () => { const media = useMedia(); const fromClientHints = useFromClientHints(); let Block = AdaptiveBlock; if (fromClientHints) { Block = media.width >= 1024 ? DesktopBlock : MobileBlock; } return <Block />;}; Скопировать "},{"title":"child-app","type":0,"sectionRef":"#","url":"docs/references/modules/child-app","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"child-app","url":"docs/references/modules/child-app#installation","content":"First, install @tramvai/module-child-app yarn add @tramvai/module-child-app Скопировать And then add module to your app import { createApp } from '@tramvai/core';import { ChildAppModule } from '@tramvai/module-child-app'; createApp({ name: 'tincoin', modules: [ChildAppModule],}); Скопировать "},{"title":"Explanation","type":1,"pageTitle":"child-app","url":"docs/references/modules/child-app#explanation","content":""},{"title":"Terms","type":1,"pageTitle":"child-app","url":"docs/references/modules/child-app#terms","content":"root-app - basic tramvai-app constructed with createApp from @tramvai/core. It can connect with many child-appchild-app - external microfrontend constructed with createChildApp from @tramvai/child-app-core. It is loaded by root-app and provides some external functionalitySingletonDI - DI-container which is exist in single instance for app and exists as long as app itselfRequestDI - DI-Container which is created for every request and represents specific data for single client. RequestDI inherits providers from SingletonDI and it is independent from other RequestDIsCommandLineRunner - instance of CommandModule "},{"title":"DI","type":1,"pageTitle":"child-app","url":"docs/references/modules/child-app#di","content":"Every child-app has its own DI-hierarchy which is isolated from other child app and partially from root-app. The only way communicate fpr DIs it's getting providers from root-app di inside child-app. Next picture shows connection between DI-containers in root-app and child-apps  How does it work when we trying to get provider from DI in child-app: First check that provider is exist in the current DI-container. If it is then return it.If current DI is RequestDI then go to SingletonDI of child-app and look for provider. If it exists in SingletonDI then return itGo to RequestDI of root-app and if provider exists in it return itGo to SingletonDI of root-app and if provider exists in it return itThrow error otherwise If current DI is SingletonDI then go to SingletonDI of root-app and check for provider there If it exists then return itThrow error otherwise "},{"title":"CommandLineRunner","type":1,"pageTitle":"child-app","url":"docs/references/modules/child-app#commandlinerunner","content":"Each child-app has its own CommandLineRunner instance which allows to child-app make some preparations before the actual page render. This CommandLineRunner has almost identical lines as root-app to simplicity, but it is actually completely other line which are independent from lines in root-app  All of the accepted line tokens: const command = { customer: [ commandLineListTokens.customerStart, commandLineListTokens.resolveUserDeps, commandLineListTokens.resolvePageDeps, ], clear: [commandLineListTokens.clear], spa: [ commandLineListTokens.resolveUserDeps, commandLineListTokens.resolvePageDeps, commandLineListTokens.spaTransition, ],}; Скопировать Child-app must be preloaded first to allow to execute commandline runner. In case of late preloading CommandLineRunner will be executed anyway but it will be out of sync with root-app CommandLineRunner (it will be called as soon as child-app code was loaded). Server# If child-app was preloaded before root-app resolvePageDeps then customer line list is executed on root-app resolvePageDeps lineIf child-app was preloaded on root-app resolvePageDeps then customer line list is executed as soon as child-app was loaded. preload call must be awaited in order to prevent root-app CommandLineRunner to passing to next line. That still counts as executing on resolvePageDeps line.Child-app clear line list is executed on root-app clear line for every child-app that was preloaded on previous lines Client# First Page load# If child-app was preloaded on server customer line list is executed on root-app resolvePageDeps lineIf child-app was not preloaded on server but was preloaded on client then customer line list is executed on root-app clear lineChild-app clear line list is executed on root-app clear line for every child-app that was preloaded on previous lines Spa-transitions# If child-app was not preloaded on any previous pages before but was preloaded on next page then customer line list is executed as soon as child-app is loadedIf child-app was preloaded on next page then child-app spa line list is executed on root-app spaTransition line "},{"title":"Loading Child App","type":1,"pageTitle":"child-app","url":"docs/references/modules/child-app#loading-child-app","content":"Loading of child-app is happens only after preloading child-app with CHILD_APP_PRELOAD_MANAGER. This preloading loads code for a child-app and marks it to execution using CommandLineRunner.  Server# Calling PreloadManager.preload(...) loads a child-app code, executes and marks it as executable to CommandLineRunnerResult of PreloadManager.preload(...) must be awaited as it is important to synchronize child-app commands lines execution with a root-app CommandLinerRunnerPreloads after root-app resolvePageDeps are useless as they wont change page render and wont be used by root-app.If child-app was not preloaded at all but still is used on render then the child-app is still preloaded automatically, but it will lead to additional React render and may significantly increase response latency. Client# Calling PreloadManager.preload(...) loads a child-app code, executes and marks it as executable to CommandLineRunnerResult of PreloadManager.preload(...) must be awaited as it is important to synchronize child-app commands lines execution with a root-app CommandLinerRunnerIf child-app was preloaded on server then child-app customer line list is executed on resolvePageDeps on first page renderIf child-app was not preloaded on server then actual loading and command-line execution are happens on root-app clear line as executing child-app before page render may break React hydration and should be executed only after it.On spa transition when previously child-app is preloaded it will be reusedOn spa transition if preloaded child-app was not loaded before it will be loaded and executed as soon as possible. "},{"title":"State","type":1,"pageTitle":"child-app","url":"docs/references/modules/child-app#state","content":"State Management is almost completely isolated from root-app and other of child-apps. Every child-app can register own stores, actions. State for child-apps will be dehydrated on server as separate variable in the result html and then will be automatically rehydrated on client for every child-app. Usually child-app cannot read data from root-app stores, but the dangerous workaround that allows to subscribe on any root-app store exists. It may be done using CHILD_APP_ROOT_STATE_SUBSCRIPTION_TOKEN token. This token is considered dangerous as it leads to high coupling with stores from root-app and this way stores in root-app might not change their public interface. But, in most cases, changes in stores ignore breaking change tracking and often breaks backward-compatibility. So do not use this token if you can, and if you should - use as little as possible from root-app and provide some fallback in case of wrong data. ::: API# How to# Connect a child app# Place a child-app React component somewhere in your page render import React from 'react';import { ChildApp } from '@tramvai/module-child-app'; export const Page = () => { return ( <div> ... <ChildApp name=\"[name]\" /> ... </div> );}; Скопировать Add configuration for child-app loading providers: [ provide({ provide: CHILD_APP_RESOLVE_BASE_URL_TOKEN, // or use `CHILD_APP_EXTERNAL_URL` env useValue: 'http://localhost:4040/', }), provide({ provide: CHILD_APP_RESOLUTION_CONFIGS_TOKEN, useValue: [ { name: '[name]', // name of the child-app byTag: { latest: { version: '[version]', // current version for the child app for tag `latest` }, }, }, ], }),]; Скопировать Preload child-app execution in order to improve performance and allow child-app execute its data preparations import { commandLineListTokens, Provider, provide } from '@tramvai/core';import { CHILD_APP_PRELOAD_MANAGER_TOKEN } from '@tramvai/module-child-app'; const providers: Provider[] = [ provide({ provide: commandLineListTokens.customerStart, multi: true, useFactory: ({ preloadManager }) => { return function preloadHeaderChildApp() { return preloadManager.preload({ name: '[name]' }); // this call is important }; }, deps: { preloadManager: CHILD_APP_PRELOAD_MANAGER_TOKEN, }, }),]; Скопировать Preload child-app# Preloading is vital for using child-app without extensive overhead on its loading. You may preload using next ways: Preload with CHILD_APP_PRELOAD_MANAGER_TOKEN provide({ provide: commandLineListTokens.customerStart, multi: true, useFactory: ({ preloadManager }) => { return function preloadHeaderChildApp() { return preloadManager.preload({ name: '[name]' }); }; }, deps: { preloadManager: CHILD_APP_PRELOAD_MANAGER_TOKEN, },}); Скопировать Add needed child-apps to the pageComponent or layoutComponent through field childApps const PageComponent = () => { return 'Page';}; PageComponent.childApps = [{ name: '[name]' }]; Скопировать Debug child-app# Single child-app# Run child-app using cli yarn tramvai start child-app Скопировать Run root-app with CHILD_APP_DEBUG environment variable CHILD_APP_DEBUG=child-app yarn tramvai start root-app Скопировать Multiple child-app# Run somehow multiple child-apps. They should be started on different ports. And either pass Base Url showed from cli as url to debug every child-app CHILD_APP_DEBUG=child-app1=baseUrl1;child-app2=baseUrl2 yarn tramvai start root-app Скопировать Or implement proxy on default http:://localhost:4040/ yourself which redirects to concrete server by url CHILD_APP_DEBUG=child-app1;child-app2 yarn tramvai start root-app Скопировать More detailed debug setup# You may specify a full config to debug to a specific child-app: To token CHILD_APP_RESOLUTION_CONFIGS_TOKEN for needed child-apps add special tag debug: ({ name: 'child-app', byTag: { latest: { version: 'latest', }, debug: { baseUrl: '...url', version: '...version', client: {}, server: {}, css: {}, }, },}); Скопировать Run root-app with CHILD_APP_DEBUG environment variable with value of child-app names needed to debug "},{"title":"common","type":0,"sectionRef":"#","url":"docs/references/modules/common","content":"","keywords":""},{"title":"Подключение в проект","type":1,"pageTitle":"common","url":"docs/references/modules/common#подключение-в-проект","content":""},{"title":"1. Зависимости","type":1,"pageTitle":"common","url":"docs/references/modules/common#1-зависимости","content":"Необходимо установить @tramvai/module-common с помощью npm npm i @tramvai/module-common Скопировать "},{"title":"2. Подключение модуля","type":1,"pageTitle":"common","url":"docs/references/modules/common#2-подключение-модуля","content":"Нужно передать в список модулей приложения CommonModule import { createApp } from '@tramvai/core';import { CommonModule } from '@tramvai/module-common'; createApp({ modules: [CommonModule],}); Скопировать "},{"title":"Включенные модули","type":1,"pageTitle":"common","url":"docs/references/modules/common#включенные-модули","content":""},{"title":"CommandModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#commandmodule","content":"Модуль которые добавляет в проект реализацию commandLineRunner и дефолтных команд Модуль использует логгер с идентификатором command:command-line-runner "},{"title":"StateModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#statemodule","content":"Подключает и инициализирует state-manager в проекте "},{"title":"ActionModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#actionmodule","content":"Реализация системы экшенов Модуль использует логгер с идентификатором action:action-page-runner "},{"title":"CookieModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#cookiemodule","content":"Подключен модуль который позволяет работать с куками, документация "},{"title":"EnvironmentModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#environmentmodule","content":"Модуль для работы с env переменные в приложении на стороне сервера и клиента, документация "},{"title":"PubSub","type":1,"pageTitle":"common","url":"docs/references/modules/common#pubsub","content":"Для отправки событий между модулями используется PubSub который позволяет отправлять сообщения и подписываться на изменения, документация Модуль использует логгер с идентификатором pubsub "},{"title":"LogModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#logmodule","content":"Минимальная реализация логгера для токена LOGGER_TOKEN без фильтров и дополнительных фич "},{"title":"CacheModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#cachemodule","content":"Модуль для работы с кешами. Функции: Создать новый инстанс кеша (на данный момент это lru-cache)Очистить все ранее созданные кешиПодписка на событие очистки кеша для реализации собственного тригера очистки своих кешейДобавляет papi-метод '/clear-cache' который генерирует событе очистки кешей Модуль использует логгер с идентификатором cache:papi-clear-cache Пример# import { provide } from '@tramvai/core'; export const providers = [ provide({ provide: MY_MODULE_PROVIDER_FACTORY, scope: Scope.SINGLETON, useFactory: ({ createCache }) => { const cache = createCache('memory', ...args); // тип кеша и дополнительные аргументы которые будут переданы в конструктор кеша return someFactory({ cache }); }, deps: { createCache: CREATE_CACHE_TOKEN, }, }), provide({ provide: REGISTER_CLEAR_CACHE_TOKEN, scope: Scope.SINGLETON, useFactory: ({ cache }) => { return async () => { await cache.reset(); console.log('my module cache cleared'); }; }, deps: { cache: MY_MODULE_CACHE, }, }), provide({ provide: commandLineListTokens.clear, useFactory: ({ clearCache }) => { return function clear() { clearCache(); // очистить кеши явно в своем провайдере }; }, deps: { clearCache: CLEAR_CACHE_TOKEN, }, }),]; Скопировать "},{"title":"RequestManagerModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#requestmanagermodule","content":"Модуль для работы с параметрами запроса "},{"title":"ResponseManagerModule","type":1,"pageTitle":"common","url":"docs/references/modules/common#responsemanagermodule","content":"Модуль для работы с параметрами ответа "},{"title":"Экспортируемые токены","type":1,"pageTitle":"common","url":"docs/references/modules/common#экспортируемые-токены","content":"tokens-commoncookieenv "},{"title":"cookie","type":0,"sectionRef":"#","url":"docs/references/modules/cookie","content":"","keywords":""},{"title":"Features","type":1,"pageTitle":"cookie","url":"docs/references/modules/cookie#features","content":"Изоморфный код, работает на сервере и в браузереНа сервере происходит дедубликация одинаковых кук и при добавлении куки, кука будет доступна в методе getПо дефолту мы проставляем secure параметр "},{"title":"Установка","type":1,"pageTitle":"cookie","url":"docs/references/modules/cookie#установка","content":"Уже поставляется внутри @tramvai/module-common и не нужно устанавливать, если подключен module-common. Иначе, нужно подключить @tramvai/module-cookie "},{"title":"Использование","type":1,"pageTitle":"cookie","url":"docs/references/modules/cookie#использование","content":"import { COOKIE_MANAGER, Module, provide } from '@tramvai/core'; @Module({ providers: [ provide({ // Управление куками в приложении provide: 'my_module', useFactory: ({ cookie }) => { cookie.get('sid'); // > ads.api3 }, deps: { cookie: COOKIE_MANAGER, // добавляем в зависимость }, }), ],})class MyModule {} Скопировать "},{"title":"Интерфейс","type":1,"pageTitle":"cookie","url":"docs/references/modules/cookie#интерфейс","content":"Реализует интерфейс CookieManager и добавляет в di провайдер COOKIE_MANAGER. @tinkoff/core "},{"title":"Экспортируемые токены","type":1,"pageTitle":"cookie","url":"docs/references/modules/cookie#экспортируемые-токены","content":"COOKIE_MANAGER_TOKEN# Сущность для работы с куками interface CookieSetOptions { name: string; value: string; expires?: number | Date | string; domain?: string; path?: string; secure?: boolean; httpOnly?: boolean; sameSite?: boolean | 'lax' | 'strict' | 'none';} interface CookieManager { get(name: any): string; all(): Record<string, string>; set({ name, value, ...options }: CookieSetOptions): void; remove(name: string): void;} Скопировать "},{"title":"deps-graph","type":0,"sectionRef":"#","url":"docs/references/modules/deps-graph","content":"","keywords":""},{"title":"Установка","type":1,"pageTitle":"deps-graph","url":"docs/references/modules/deps-graph#установка","content":""},{"title":"1. Зависимости","type":1,"pageTitle":"deps-graph","url":"docs/references/modules/deps-graph#1-зависимости","content":"Необходимо установить @tramvai/module-deps-graph с помощью npm/yarn npm i @tramvai/module-deps-graph Скопировать "},{"title":"2. Подключение модуля","type":1,"pageTitle":"deps-graph","url":"docs/references/modules/deps-graph#2-подключение-модуля","content":"Нужно передать в список модулей приложения CommonModule import { createApp } from '@tramvai/core';import { DepsGraphModule } from '@tramvai/module-deps-graph'; createApp({ modules: [DepsGraphModule],}); Скопировать "},{"title":"Использование","type":1,"pageTitle":"deps-graph","url":"docs/references/modules/deps-graph#использование","content":"Добавляет папи роут /deps-graph (можно найти по адресу /:appName/papi/deps-graph, где appName - поле name из tramvai.json), по которому выводится граф всех зависимостей с возможностью поиска по токену и имени модуля Описание графа# Синий - обычный провайдерЖелтый - mutli-провайдерКрасный - подпавший под поиск  "},{"title":"error-interceptor","type":0,"sectionRef":"#","url":"docs/references/modules/error-interceptor","content":"","keywords":""},{"title":"Интеграция с tramvai","type":1,"pageTitle":"error-interceptor","url":"docs/references/modules/error-interceptor#интеграция-с-tramvai","content":"Модуль не предоставляет публтичного интерфейса, а только подписывается на события инициализации и подключает @tinkoff/error-handlers который перехватывает ошибки в браузере и клиенте "},{"title":"Принцип работы","type":1,"pageTitle":"error-interceptor","url":"docs/references/modules/error-interceptor#принцип-работы","content":"На сервере подписываемся на события unhandledRejection и внезапные остановки выполнения с помощью библиотеки death, затем ошибку кидает в консоль. "},{"title":"env","type":0,"sectionRef":"#","url":"docs/references/modules/env","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"env","url":"docs/references/modules/env#installation","content":"Already supplied inside @tramvai/module-common and does not need to be installed if module-common is connected. Otherwise, you need to install @tramvai/module-environment "},{"title":"Explanation","type":1,"pageTitle":"env","url":"docs/references/modules/env#explanation","content":""},{"title":"Dynamically generated list of used env variables","type":1,"pageTitle":"env","url":"docs/references/modules/env#dynamically-generated-list-of-used-env-variables","content":"All the parameters used in the application are registered by implementing the ENV_USED_TOKEN token in the DI and it is assumed that each module individually registers only the env parameters it needs. In this case, when a module is connected, there will be automatic validation of all passed parameters that are necessary for the application to work import { provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: ENV_USED_TOKEN, useValue: [ { key: 'DEBUG_MODULE', optional: true }, { key: 'DEBUG_MODULE_URL', optional: true }, ], multi: true, }), ],})export class MyModule {} Скопировать In the above example, the module registers several env tokens, which will be initialized and will be available in environmentManager.get('DEBUG_MODULE'). In doing so, the optional parameter has been passed, which indicates that the variables are not required for the application to work. "},{"title":"Validation of environment variables values","type":1,"pageTitle":"env","url":"docs/references/modules/env#validation-of-environment-variables-values","content":"When the application starts, it checks the tokens that were registered in the DI and passed to env at startup. If all required env variables have not been passed to the application, the application will crash. It is also possible to write validators for env values, which will run when the application is initialized. import { provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: ENV_USED_TOKEN, useValue: [ { key: 'MY_ENV', validator: (env) => { if (!env.includes('https')) { return 'Incorrect link format. The link should contain https'; } }, }, ], multi: true, }), ],})export class MyModule {} Скопировать "},{"title":"Functionality works on the server and in the browser","type":1,"pageTitle":"env","url":"docs/references/modules/env#functionality-works-on-the-server-and-in-the-browser","content":"All env variables will be available both on the server and in the browser without any additional actions or settings. Env variables that have dehydrate: true are automatically passed to the browser "},{"title":"Priority of obtaining values for env variables","type":1,"pageTitle":"env","url":"docs/references/modules/env#priority-of-obtaining-values-for-env-variables","content":"Since it is possible to overwrite the values of the variables, the variables are replaced according to certain rules The replacement rules are arranged in order of priority, from lower to higher: Parameters set in tokens { key: 'ENV_PARAM', value: 'env value' }Parameters written in env.development.js filePassing application launch parameters MY_ENV=j node server.js "},{"title":"API","type":1,"pageTitle":"env","url":"docs/references/modules/env#api","content":" Exported tokens and TS interface import { createToken } from '@tinkoff/dippy'; export interface EnvironmentManager { get(name: string): string; getInt(name: string, def: number): number; getAll(): Record<string, string>; update(result: Record<string, string>): void; clientUsed(): Record<string, string>; updateClientUsed(result: Record<string, string>): void;} /** * @description * Instance that used for managing env data on the server and on the client */export const ENV_MANAGER_TOKEN = createToken<EnvironmentManager>('environmentManager'); /** * @description * List of envs that are used by the module or the app. * All of the envs specified by that token will be accessible in the code through `environmentManager` * ENV_USED_TOKEN format: - `key` - id of the env. At that id the value of the env will be accessible through `environmentManager` and will be loaded from the external sources. - `value` - default low-priority value for env `key` - `optional` - is current env is optional. If `true` the app can work as usual event if the env value were not provided, if `false` - the app will fail to run without env value - `validator` - validation function for passed env value. In case this function returns string it will be used as error message and validation will fail - `dehydrate` - if `false` then env value will not be passed to client and this env can be used only on server * * @example ```tsx interface EnvParameter { key: string; value?: string; optional?: boolean; validator?: (value: string) => boolean | string; dehydrate?: boolean; } ``` */export interface EnvParameter { key: string; value?: string; optional?: boolean; validator?: (value: string) => boolean | string; dehydrate?: boolean;} export const ENV_USED_TOKEN = createToken<EnvParameter[]>('envUsed', { multi: true }); Скопировать  "},{"title":"How to","type":1,"pageTitle":"env","url":"docs/references/modules/env#how-to","content":""},{"title":"How to read data in an application","type":1,"pageTitle":"env","url":"docs/references/modules/env#how-to-read-data-in-an-application","content":"Suppose we registered the parameter CONFIG_API used by env with the ENV_USED_TOKEN token, now we need to connect environmentManager in the application and read the data: import { provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: 'MY_SERVICE', useClass: class MyService { constructor({ environmentManager }) { console.log(environmentManager.get('CONFIG_API')); } }, deps: { environmentManager: ENV_MANAGER_TOKEN, }, }), ],})export class MyModule {} Скопировать This code will work both on the server and in the browser "},{"title":"How you can simply pass parameters in local development","type":1,"pageTitle":"env","url":"docs/references/modules/env#how-you-can-simply-pass-parameters-in-local-development","content":"To do this, create a file env.development.js in the root of the project and write all env variables for the application. When the application is initialized, this file will be read. Peculiarities of using env.developmen.js in production builds# The twelve factors application stores the configuration in environment variables, so by default when process.env.NODE_ENV === 'production' EnvironmentManger will not read the env.development.js file. If you want to test the application locally with NODE_ENV=production, you can pass the flag DANGEROUS_UNSAFE_ENV_FILES='true' so that EnvironmentManger will read the env.development.js file and not have to enter all variables by hand. "},{"title":"How to pass env parameters to the application during the deploys","type":1,"pageTitle":"env","url":"docs/references/modules/env#how-to-pass-env-parameters-to-the-application-during-the-deploys","content":"To do this, pass env parameters when starting the application. For example in Docker you can do this with the parameter -e docker run -e MY_ENV_VAR=/ my-image. "},{"title":"How to view all env variables of an application","type":1,"pageTitle":"env","url":"docs/references/modules/env#how-to-view-all-env-variables-of-an-application","content":"This method allows you to see only client variables To get a list of variables, there is a /papi/apiList method Request example: http://localhost:3000/${appName}/papi/apiList "},{"title":"log","type":0,"sectionRef":"#","url":"docs/references/modules/log","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"log","url":"docs/references/modules/log#подключение","content":"Уже входит в @tramvai/module-common и отдельно не нужно подключать "},{"title":"Пример","type":1,"pageTitle":"log","url":"docs/references/modules/log#пример","content":"import { Module, commandLineListToken, provide } from '@tramvai/core';import { LOGGER_TOKEN } from '@tramvai/module-common'; @Module({ providers: [ provide({ provide: commandLineListToken.customerStart, useFactory: ({ logger }) => { logger.debug('customer start'); // логгирование в глобальном пространстве логов const myLogger = logger({ name: 'test', }); myLogger.warn('warning'); // логгирование в пространстве test myLogger.error('error!'); }, deps: { logger: LOGGER_TOKEN, }, }), ],})export class MyModule {} Скопировать "},{"title":"Отображение логов","type":1,"pageTitle":"log","url":"docs/references/modules/log#отображение-логов","content":"см. @tinkoff/logger. По умолчанию на сервере включены все логи уровня warn и выше. На клиенте в дев-режиме включены логи error и выше, в прод-режиме отображение каких-либо логов отключено. "},{"title":"Отправка логов на апи","type":1,"pageTitle":"log","url":"docs/references/modules/log#отправка-логов-на-апи","content":"Предполагается что логи с сервера собираются через отдельный механизм, который имеет доступ к выводу консоли сервера и поэтому в логгировании на внешнее апи нет смысла. В браузере логи на апи отправляются с помощью RemoteReporter. По умолчанию отправляются все логи уровня error и fatal. Урл апи определяется из переменной окружения FRONT_LOG_API. Для индивидуальной настройки смотри документацию к RemoteReporter. "},{"title":"Просмотр логов с сервера в браузере","type":1,"pageTitle":"log","url":"docs/references/modules/log#просмотр-логов-с-сервера-в-браузере","content":"Данная функция доступна в дев режиме и создана для упрощения работы с логами при разработке. В консоли браузера при заходе на страницу приложения появится специальная группа логов, под тегом Tramvai SSR Logs при раскрытии логов будут отображены логи которые были залогированы для даного конретного запроса на сервера, причем будут отображены именно те логи, которые подпадают под настройки отображения для сервера. Если необходимо отобразить все логи с сервера с настройками отображения для клиента, то нужно запустить сервер с переменной окружения DEBUG_FULL_SSR "},{"title":"Просмотр логов для запросов на основе @tinkoff/request","type":1,"pageTitle":"log","url":"docs/references/modules/log#просмотр-логов-для-запросов-на-основе-tinkoffrequest","content":"Логгер и настройки для него должны явно передаваться в плагин логгирования, что уже делается в http-client. В плагине используется генерация тега для логгера в виде request.${name} поэтому чтобы отобразить такие необходимо настроить фильтры для отображения для конкретной фабрики запросов: const logger = di.get(LOGGER_TOKEN);const makeRequest = request([...otherPlugins, logger({ name: 'my-api-name', logger })]); Скопировать Т.к. имя для логгера равно my-api-name, то для отображения логов необходимо: на сервере дополнить переменную окружения LOG_ENABLE: 'request.my-api-name'на клиенте включить логгирование через вызов logger.enable('request.my-api-name') "},{"title":"Как правильно форматировать логи","type":1,"pageTitle":"log","url":"docs/references/modules/log#как-правильно-форматировать-логи","content":"Смотри Как правильно логгировать "},{"title":"Экспортируемые токены","type":1,"pageTitle":"log","url":"docs/references/modules/log#экспортируемые-токены","content":""},{"title":"LOGGER_TOKEN","type":1,"pageTitle":"log","url":"docs/references/modules/log#logger_token","content":"Сущность логгера. Заменяет стандартную реализацию LOGGER_TOKEN из @tramvai/module-common "},{"title":"Изменение серверных настроек логгера","type":1,"pageTitle":"log","url":"docs/references/modules/log#изменение-серверных-настроек-логгера","content":"По умолчанию, настройки отображения логгера на сервере берутся из переменной окружения LOG_ENABLE, а настройки уровня логирования из переменной окружения LOG_LEVEL Для изменения этих настроек в рантайме существует papi роут {app}/private/papi/logger Отображение логов меняется через query параметр enable, например: https://localhost:3000/{app}/private/papi/logger?enable=request.tinkoff Скопировать Уровень логгирования меняется через query параметр level, например: https://localhost:3000/{app}/private/papi/logger?level=warn Скопировать Вернуть настройки по умолчанию, из переменных окружения, можно с параметром mode=default: https://localhost:3000/{app}/private/papi/logger?mode=default Скопировать "},{"title":"Переменные окружения","type":1,"pageTitle":"log","url":"docs/references/modules/log#переменные-окружения","content":"LOG_LEVEL = trace | debug | info | warn | error | fatal - включает отображение логов для заданного уровня и все уровней выше. Пример: если LOG_LEVEL=info, то будут отображаться все логи уровней info, warn, error, fatal LOG_ENABLE = ${name} | ${level}:${name} - позволяет включить отображение всех логов по определенному имени логгера или по определенному имени и уровню. Несколько вхождений передаются через запятую. Примеры: если LOG_ENABLE=server, то будут отображены логи всех уровней с именем serverесли LOG_ENABLE=trace:server*, то будут отображены только логи для server с уровнем traceесли LOG_ENABLE=info:server,client,trace:shared, то будут включены логи для заданных логгеров по правилам выше "},{"title":"Отладка","type":1,"pageTitle":"log","url":"docs/references/modules/log#отладка","content":"Модуль использует логгер с идентификатором ssr-logger "},{"title":"http-client","type":0,"sectionRef":"#","url":"docs/references/modules/http-client","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#installation","content":"You need to install @tramvai/module-http-client yarn add @tramvai/module-http-client Скопировать And connect in the project import { createApp } from '@tramvai/core';import { HttpClientModule } from '@tramvai/module-http-client'; createApp({ name: 'tincoin', modules: [HttpClientModule],}); Скопировать "},{"title":"Features","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#features","content":"The http-client module adds functionality to the application related to API requests. Available providers allow you to create new services to work with any API and create more specific services with preset settings for specific APIs. The module implements interfaces from the library @tramvai/http-client using a special library - adapter @tramvai/tinkoff-request-http-client-adapter, running on top of @tinkoff/request. "},{"title":"Concepts","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#concepts","content":""},{"title":"HTTP client","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#http-client","content":"HTTP client - implementation of the HttpClient interface, created via the HTTP_CLIENT_FACTORY token. HTTP client accepts general settings, some of which will be used as defult values ​​for all requests. The HTTP client does not provide an opportunity to add additional methods for requests, and to perform side actions when the request is completed or failed. "},{"title":"Services for working with API","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#services-for-working-with-api","content":"The API service inherits from the ApiService class, which is exported from @tramvai/http-client. The API service takes an HTTP client in its constructor and uses it for requests. The API service implements all methods for requests from the HttpClient interface, but allows you to modify them. For example, you can replace the implementation of the request method by adding an error message to the catch request via an HTTP client - this logic will automatically work for all other methods - get, put, post, delete. In the API service, you can add custom methods for requests to certain API endpoints, and specify only the necessary parameters in them, and type responses. Additional reasons to create API services - if you need to use several different HTTP clients to work with a specific API, or you need the ability to add a convenient abstraction on top of the basic methods for sending requests. "},{"title":"Usage","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#usage","content":""},{"title":"Create a new HTTP client","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#create-a-new-http-client","content":"Each new HTTP client must directly or indirectly inherit HTTP_CLIENT_FACTORY. New HTTP clients / API services should not be created with scope: Scope.SINGLETON, because each request is supplemented with default parameters specific to each user, for example - passing the X-Real-Ip header from the request to the application in all requests to the API. Basic HTTP client# The HTTP_CLIENT_FACTORY token - provides a factory for creating new HTTP clients. The options are preinstalled with a logger and a cache factory. Peculiarities# For all requests to the API, headers are added from the list returned by the API_CLIENT_PASS_HEADERS token, and X-Real-Ip from the current request to the application Token interface: type HTTP_CLIENT_FACTORY = (options: HttpClientFactoryOptions) => HttpClient; Скопировать Token use: import { Scope, provide } from '@tramvai/core';import { ENV_MANAGER_TOKEN } from '@tramvai/tokens-common';import { HTTP_CLIENT_FACTORY } from '@tramvai/tokens-http-client'; const provider = provide({ provide: 'WHATEVER_API_HTTP_CLIENT', useFactory: ({ factory, envManager, }: { factory: typeof HTTP_CLIENT_FACTORY; envManager: typeof ENV_MANAGER_TOKEN; }) => { return factory({ name: 'whatever-api', baseUrl: envManager.get('WHATEVER_API'), }); }, deps: { factory: HTTP_CLIENT_FACTORY, envManager: ENV_MANAGER_TOKEN, },}); Скопировать "},{"title":"Using existing HTTP clients","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#using-existing-http-clients","content":"Most HTTP clients implement additional logic for requests, and inherit from ApiService. Thus, each service has methods get, post, put, delete and request, but there may be specific methods. Common HTTP client# The HTTP_CLIENT token provides a basic client for sending requests to any URLs, request caching is disabled. Token use: import { createAction } from '@tramvai/core';import { HTTP_CLIENT } from '@tramvai/tokens-http-client'; export const fetchAction = createAction({ name: 'fetch', fn: async (_, __, { httpClient }) => { const { payload, headers, status } = await httpClient.get( 'https://www.domain.com/api/endpoint' ); return payload; }, deps: { httpClient: HTTP_CLIENT, },}); Скопировать "},{"title":"Adding custom data to requests","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#adding-custom-data-to-requests","content":"Let's consider a case using the abstract service WHATEVER_API_SERVICE as an example. Let's say we want to add an X-Real-Ip header to every request: import { provide } from '@tramvai/core';import { HttpClientRequest, HttpClient } from '@tramvai/http-client';import { REQUEST_MANAGER_TOKEN } from '@tramvai/tokens-common'; const provider = provide({ provide: 'WHATEVER_API_SERVICE', useFactory: ({ factory, requestManager, envManager, }: { factory: typeof HTTP_CLIENT_FACTORY; requestManager: typeof REQUEST_MANAGER_TOKEN; envManager: typeof ENV_MANAGER_TOKEN; }) => { return factory({ name: 'whatever-api', baseUrl: envManager.get('WHATEVER_API'), modifyRequest: (request: HttpClientRequest) => { return { ...request, headers: { ...request.headers, 'X-real-ip': requestManager.getClientIp(), }, }; }, }); }, deps: { factory: HTTP_CLIENT_FACTORY, requestManager: REQUEST_MANAGER_TOKEN, envManager: ENV_MANAGER_TOKEN, },}); Скопировать "},{"title":"How to","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#how-to","content":""},{"title":"How to disable HTTP request caching?","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#how-to-disable-http-request-caching","content":"To disable caching for all HTTP clients, pass the env variable HTTP_CLIENT_CACHE_DISABLED: true to the application "},{"title":"Testing","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#testing","content":"Testing your api clients# If you have a module or providers that define api-clients, then it will be convenient to use special utilities in order to test them separately import { testApi } from '@tramvai/module-http-client/tests';import { CustomModule } from './module'; describe('testApi', () => { it('test', async () => { const { di, fetchMock, mockJsonResponse } = testApi({ modules: [CustomModule], env: { TEST_API: 'testApi', }, }); const httpClient: typeof HTTP_CLIENT = di.get('CUSTOM_HTTP_CLIENT') as any; mockJsonResponse({ a: 'aaa' }); const { payload } = await httpClient.get('test'); expect(payload).toEqual({ a: 'aaa' }); expect(fetchMock).toHaveBeenCalledWith('http://testApi/test', expect.anything()); });}); Скопировать "},{"title":"Logging","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#logging","content":"By default, @tinkoff/request will log every failed requests with level error. You can disable logging by pass { silent: true } parameter to request parameters. Useful meta information about request will be available in error.__meta property. Example: const log = logger('request:test'); httpClient.request({ path: 'test', silent: true }).catch((error) => { log.info(error);}); Скопировать "},{"title":"Debug","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#debug","content":"You can show all the default logs of http clients by providing these env variables: LOG_ENABLE=request*LOG_LEVEL=trace Скопировать If the built-in http clients logs are not enough, you can enable NodeJS debugging of the request module this way: NODE_DEBUG=request tramvai start<appName> Скопировать "},{"title":"Exported tokens","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#exported-tokens","content":"link "},{"title":"Environment Variables","type":1,"pageTitle":"http-client","url":"docs/references/modules/http-client#environment-variables","content":"HTTP_CLIENT_CACHE_DISABLED - disable caching for all HTTP clientsHTTP_CLIENT_CIRCUIT_BREAKER_DISABLED - disable plugin https://tinkoff.github.io/tinkoff-request/docs/plugins/circuit-breaker.html "},{"title":"mocker","type":0,"sectionRef":"#","url":"docs/references/modules/mocker","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#подключение","content":"Необходимо установить @tramvai/module-mocker: yarn add @tramvai/module-mocker Скопировать Создать первый мок, в файле mocks/my-api.js, где свойство api должно содержать env переменную с урлом API, который требуется мокировать, в данном случае MY_API: module.exports = { api: 'MY_API', mocks: { 'GET /endpoint?foo=bar': { status: 200, headers: {}, payload: { result: { type: 'json', value: { a: 'b' }, }, }, }, },}; Скопировать Подключить модуль в проекте: import { createApp } from '@tramvai/core';import { MockerModule } from '@tramvai/module-module'; createApp({ name: 'tincoin', modules: [ MockerModule ],}); Скопировать Запустить приложения с env переменной MOCKER_ENABLED, например: MOCKER_ENABLED=\"true\" tramvai start tincoin Скопировать После этого, все запросы на MY_API и на клиенте и на сервере автоматически будут отправлены в мокер, а если не нашлось подходящих моков, проксируются в оригинальное API. "},{"title":"Explanation","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#explanation","content":"Особенности мокера описаны в документации библиотеки. Модуль подключает middleware мокера на papi роуте /mocker, и заменяет все env переменные мокируемых API ссылками на papi, подходящие для серверного и для клиентского кода. По умолчанию, мокируются все API, которые были найдены в моках, это поведение можно переопределить. Мокер подключается только при наличии env переменной MOCKER_ENABLED=\"true\". "},{"title":"Замена env переменных","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#замена-env-переменных","content":"Допустим, приложение имеет env переменную MY_API: https://www.my-api.com/, и для этого API зарегистрирован мок. Модуль рассчитан на работу локально, на динамических стендах, и в test/stage окружениях, это порождает сложность с определением пути до papi эндпоинта: На сервере мы должны делать запрос по абсолютном пути, и тут приложение всегда доступно на localhost, значит env переменные заменяются на урлы вида http://localhost:3000/tincoin/papi/mocker/MY_API/ На клиенте, на стендах мы не знаем текущий домен приложения, и надо делать запросы по относительным путям, поэтому клиентские env переменные заменяются на урлы вида /tincoin/papi/mocker/MY_API/ Благодаря этой замене, все запросы приложения на мокируемое API, клиентские и серверные, автоматически отправляются в мокер. "},{"title":"How to","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#how-to","content":""},{"title":"У меня есть моки для нескольких API, как мокировать только одно из них?","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#у-меня-есть-моки-для-нескольких-api-как-мокировать-только-одно-из-них","content":"По умолчанию все API считываются из моков при старте приложения. Это поведение можно переопределить, передавая список API для мокирования при инициализации модуля: MockerModule.forRoot({ config: () => ({ apis: ['MY_API'], }),}); Скопировать "},{"title":"Экспортируемые токены","type":1,"pageTitle":"mocker","url":"docs/references/modules/mocker#экспортируемые-токены","content":" import { createToken } from '@tinkoff/dippy';import type { Mocker, MockRepository } from '@tinkoff/mocker'; export interface MockerOptions { apis: string[];} export const MOCKER = createToken<Mocker>('MOCKER'); export const MOCKER_REPOSITORY = createToken<MockRepository[]>('MOCKER_REPOSITORY', { multi: true,}); export const MOCKER_CONFIGURATION = createToken<() => Promise<MockerOptions>>( 'MOCKER_CONFIGURATION'); Скопировать  "},{"title":"metrics","type":0,"sectionRef":"#","url":"docs/references/modules/metrics","content":"","keywords":""},{"title":"Как пользоваться","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#как-пользоваться","content":"import { createToken } from '@tinkoff/dippy';import { Module, provide } from '@tramvai/core';import { Counter, Metrics, METRICS_MODULE_TOKEN } from '@tramvai/tokens-metrics'; interface SomeModuleOptions { metrics: Metrics;} class SomeModule { private metricActionCounter: Counter; constructor(options: SomeModuleOptions) { this.metricActionCounter = options.metrics.counter({ name: 'some_actions_total', help: 'Total count of some actions', }); } public action(): void { this.metricActionCounter.inc(); // Do some meaningful action }} export const SOME_MODULE = createToken<SomeModule>('someModule'); @Module({ providers: [ provide({ provide: SOME_MODULE, useFactory: (deps) => new SomeModule(deps), deps: { metrics: METRICS_MODULE_TOKEN, }, }), ],})export class SomeModuleContainer {} Скопировать "},{"title":"Мониторинг исходящих запросов","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#мониторинг-исходящих-запросов","content":"Для того чтобы мониторить состояние исходящих запросов (количество запросов, количество ошибок, время выполнения) в модуле манкипатчатся методы request и get модулей http и https. Чтобы это заработало необходимо просто подключить модуль метрик в приложение. В метрики попадают лейблы: http методhttp код ответаимя сервиса Метрики определяют имя сервиса сопоставляя урлы со значениями в MetricsServicesRegistry. Изначательно туда загружается инвертированное содержимое env, то есть если урл из env является подстрокой урла запроса, то ключ станет именем сервиса. Если совпадает несколько, то берётся самый длинный урл из env. "},{"title":"Как сделать чтобы для запросов в метриках было имя сервиса вместо адреса хоста","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#как-сделать-чтобы-для-запросов-в-метриках-было-имя-сервиса-вместо-адреса-хоста","content":"Можно подсказать модулю метрик имя сервиса, если урл получается динамически. Для этого нужно: подключить модуль по токену METRICS_SERVICES_REGISTRY_TOKEN;вызвать metricsServicesRegistry.register(\"Часть урла или весь урл\", \"Имя сервиса\") "},{"title":"Использование метрик для профилирования перформанса на стороне браузера","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#использование-метрик-для-профилирования-перформанса-на-стороне-браузера","content":"Для измерения продолжительности события, необходимо использовать метод startTimer у классов Gauge, Histogram и Summary. В dev-режиме эти классы патчатся и методы работы с таймером использует PerformanceApi. "},{"title":"Пример использования","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#пример-использования","content":"Без дополнительных полей const metric = metrics.gauge({ name: 'request_measure', help: 'Request duration measure',}); const endTimer = metric.startTimer(); fetch(url).then(() => { endTimer(); // выводим результат - performance.getEntriesByName('request_measure');}); Скопировать Добавляем динамические поля const metric = metrics.gauge({ name: 'request_measure', help: 'Request duration measure',}); const endTimer = metric.startTimer({ method: 'GET' }); fetch(url).then(() => { endTimer({ status: 200 }); // выводим результат - performance.getEntriesByName('request_measure{method=\"GET\",status=\"200\"}');}); Скопировать "},{"title":"Клиентские метрики","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#клиентские-метрики","content":"Модуль реализует в себе возможность собирать метрики с клиента и раздавать их прометеусам с помощью обычного серверного механизма через отправку метрик в papi-роуты. Механика работы заключается в том что заводится counter и специальный папи-роут, дёрнув который по http мы можем инкрементировать этот counter. В модуле уже реализован весь общий для таких случаев функционал. Чтобы создать метрику необходимо создать провайдер с токеном REGISTER_INSTANT_METRIC_TOKEN, провайдер должен возвращать список из двух сущностей где первая это slug papi-роута, а вторая это инстанс счётчика. Например: import { provide } from '@tramvai/core'; provide({ provide: REGISTER_INSTANT_METRIC_TOKEN, multi: true, deps: { metrics: METRICS_MODULE_TOKEN, }, useFactory({ metrics }) { return [ 'page-load', new Counter({ name: 'client_page_load_total', help: 'Загрузки страниц у клиентов' }), ]; },}); Скопировать Теперь для того чтобы инкрементировать метрику client_page_load_total достаточно дёрнуть papi-роут /metrics/page-load. instantMetricsReporter# На практике выяснилось что часто помимо сбора метрик необходимо отправить логи с подробностями. Эту потребность реализует instantMetricsReporter. При вызове логгера он проверяет наличие метрик со slug аналогичным полю event в логах и если такие метрики существуют, то отправляет запрос на соответствующий papi-роут. Таким образом можно одновременно залогировать событие и инкрементировать серверную метрику. import { provide } from '@tramvai/core';provide({ provide: commandLineListTokens.init, multi: true, deps: { logger: LOGGER_TOKEN, }, useFactory({ logger }) { return () => { window.on('load', () => { logger.info({ event: 'page-load' }); }) }; },}), Скопировать "},{"title":"Отладка","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#отладка","content":"Модуль использует логгеры с идентификаторами: metrics:perf, metrics:papi "},{"title":"Экспортируемые токены","type":1,"pageTitle":"metrics","url":"docs/references/modules/metrics#экспортируемые-токены","content":"ссылка "},{"title":"react-query","type":0,"sectionRef":"#","url":"docs/references/modules/react-query","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#installation","content":"You need to install @tramvai/module-react-query yarn add @tramvai/module-react-query Скопировать And connect in the project import { createApp } from '@tramvai/core';import { ReactQueryModule } from '@tramvai/module-react-query'; createApp({ name: 'tincoin', modules: [...ReactQueryModule],}); Скопировать "},{"title":"Explanation","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#explanation","content":"The module adds an instance react-query QueryClient to the DI и and allows specifying options for creating it. The module also adds React wrappers for react-query to the application renderer, which allow using functions for working with query inside components. "},{"title":"Server","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#server","content":"On the server, the module also additionally performs dehydration of the data preloaded on the server in order to transfer them to the client "},{"title":"Client","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#client","content":"The browser additionally performs rehydration of the data preloaded on the server "},{"title":"API","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#api","content":"The module basically provides the necessary things in DI for the library @tramvai/react-query and itself may be needed only if there is a need to change the settings for QueryClient or use QueryClient directly (but better not to use directly) "},{"title":"How to","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#how-to","content":""},{"title":"Enable devtools","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#enable-devtools","content":"React-query devtools are provided through @tramvai/module-dev-tools and to enable it both modules should be passed to modules list: import { ReactQueryModule, ReactQueryDevtoolsModule } from '@tramvai/module-react-query';import { DevToolsModule } from '@tramvai/module-dev-tools'; createApp({ name: 'app', modules: [ ...modules, ReactQueryModule, ...(process.env.NODE_ENV === 'development' ? [DevToolsModule, ReactQueryDevtoolsModule] : []), ], bundles: {}, providers: [],}); Скопировать "},{"title":"Exported tokens","type":1,"pageTitle":"react-query","url":"docs/references/modules/react-query#exported-tokens","content":" import { createToken } from '@tinkoff/dippy';import type { QueryClient, DefaultOptions } from 'react-query';import type { DehydratedState } from 'react-query/hydration'; /** * @description * [Клиент react-query](https://react-query.tanstack.com/reference/QueryClient) */ export const QUERY_CLIENT_TOKEN = createToken<QueryClient>('reactQuery queryClient'); /** * @description * [Дефолтные опции для клиента react-query](https://react-query.tanstack.com/guides/important-defaults) */export const QUERY_CLIENT_DEFAULT_OPTIONS_TOKEN = createToken<DefaultOptions>( 'reactQuery queryClientDefaultOptions'); /** * @description * [Стейт для клиента react-query](https://react-query.tanstack.com/reference/hydration/dehydrate), иницилизированный на сервере */export const QUERY_CLIENT_DEHYDRATED_STATE_TOKEN = createToken<DehydratedState>( 'reactQuery queryClientDehydratedState'); export const QUERY_DEHYDRATE_STATE_NAME_TOKEN = createToken<string>( 'reactQuery dehydrate state name'); Скопировать  "},{"title":"render","type":0,"sectionRef":"#","url":"docs/references/modules/render","content":"","keywords":""},{"title":"Быстрый обзор","type":1,"pageTitle":"render","url":"docs/references/modules/render#быстрый-обзор","content":" Модуль который внутри себя содержит логику по генерацию html страницы, начиная от получения текущего компонента, так и заканчивая генерации конечного html c помощью библиотеки htmlpagebuilder. Из особенностей, в этом модуле присутствует код создания верхнеуровнего реакт компонента, получения пэйдж компонента и лайаута из роутинга и создание композиции из провайдеров в приложении "},{"title":"Подключение","type":1,"pageTitle":"render","url":"docs/references/modules/render#подключение","content":"Необходимо установить @tramvai/module-render с помощью npm npm i @tramvai/module-render Скопировать И подключить в проекте import { createApp } from '@tramvai/core';import { RenderModule } from '@tramvai/module-render'; createApp({ name: 'tincoin', modules: [RenderModule],}); Скопировать "},{"title":"Explanation","type":1,"pageTitle":"render","url":"docs/references/modules/render#explanation","content":""},{"title":"Разные режимы отрисовки React","type":1,"pageTitle":"render","url":"docs/references/modules/render#разные-режимы-отрисовки-react","content":"Подробнее о режимах рендеринга можете узнать в официальной доке в module-render есть поддержка всех типов и вы можете выбрать для своего приложения актуальный тип Для задания режима, необходимо при инициализации RenderModule передать параметр mode RenderModule.forRoot({ mode: 'concurrent' }); Скопировать Доступны варианты: 'legacy' | 'strict' | 'blocking' | 'concurrent' Постепенная миграция на concurrent режим "},{"title":"Ассеты в приложении","type":1,"pageTitle":"render","url":"docs/references/modules/render#ассеты-в-приложении","content":"Для работы с ресурсами в tramvai был разработан модуль ассетов который позволяет задать в DI список ресурсов и дальше их отрисовать в определенные слоты. Пример: createApp({ providers: [ { multi: true, useValue: [ { type: ResourceType.inlineScript, // inlineScript обернет payload в тег <script> slot: ResourceSlot.HEAD_CORE_SCRIPTS, // определяет позицию где в html будет вставлен ресурс payload: 'alert(\"render\")', }, { type: ResourceType.asIs, // asIs занчит вставить ресурс как есть. без обработки slot: ResourceSlot.BODY_TAIL, payload: '<div>hello from render slots</div>', }, ], }, ],}); Скопировать type - тип ресурса, уже есть готовые пресеты которые упрощает добавление кода на страницу, без прокидывания дополнительных параметров и так далееslot - место в html странице, куда будет добавлен этот ресурсpayload - что будет отрисовано  Доступные слоты export const REACT_RENDER = 'react:render';export const HEAD_PERFORMANCE = 'head:performance';export const HEAD_META = 'head:meta';export const HEAD_POLYFILLS = 'head:polyfills';export const HEAD_CORE_STYLES = 'head:core-styles';export const HEAD_CORE_SCRIPTS = 'head:core-scripts';export const HEAD_DYNAMIC_SCRIPTS = 'head:dynamic-scripts';export const HEAD_ANALYTICS = 'head:analytics';export const HEAD_ICONS = 'head:icons';export const BODY_START = 'body:start';export const BODY_END = 'body:end';export const BODY_TAIL_ANALYTICS = 'body:tail:analytics';export const BODY_TAIL = 'body:tail'; Скопировать   Схема разметки слотов в HTML странице import type { StaticDescriptor, DynamicDescriptor } from '@tinkoff/htmlpagebuilder';import { dynamicRender, staticRender } from '@tinkoff/htmlpagebuilder';import { ResourceSlot } from '@tramvai/tokens-render';import { formatAttributes } from './utils'; const { REACT_RENDER, HEAD_CORE_SCRIPTS, HEAD_DYNAMIC_SCRIPTS, HEAD_META, HEAD_POLYFILLS, HEAD_CORE_STYLES, HEAD_PERFORMANCE, HEAD_ANALYTICS, BODY_START, BODY_END, HEAD_ICONS, BODY_TAIL_ANALYTICS, BODY_TAIL,} = ResourceSlot; export const htmlPageSchemaFactory = ({ htmlAttrs,}): Array<StaticDescriptor | DynamicDescriptor> => { return [ staticRender('<!DOCTYPE html>'), staticRender(`<html ${formatAttributes(htmlAttrs, 'html')}>`), staticRender('<head>'), staticRender('<meta charset=\"UTF-8\">'), dynamicRender(HEAD_META), dynamicRender(HEAD_PERFORMANCE), dynamicRender(HEAD_CORE_STYLES), dynamicRender(HEAD_POLYFILLS), dynamicRender(HEAD_DYNAMIC_SCRIPTS), dynamicRender(HEAD_CORE_SCRIPTS), dynamicRender(HEAD_ANALYTICS), dynamicRender(HEAD_ICONS), staticRender('</head>'), staticRender(`<body ${formatAttributes(htmlAttrs, 'body')}>`), dynamicRender(BODY_START), // react app dynamicRender(REACT_RENDER), dynamicRender(BODY_END), dynamicRender(BODY_TAIL_ANALYTICS), dynamicRender(BODY_TAIL), staticRender('</body>'), staticRender('</html>'), ];}; Скопировать  Как добавить загрузку ассетов на странице "},{"title":"Автоматический инлайнинг ресурсов","type":1,"pageTitle":"render","url":"docs/references/modules/render#автоматический-инлайнинг-ресурсов","content":"Контекст# Большое количество файлов ресурсов создаёт проблемы при загрузке страницы, т.к. браузеру приходится создавать много соединений на небольшие файлы Решение# Решили добавить возможность включить часть ресурсов прямо в приходящий с сервера HTML. Чтобы не инлайнить вообще всё, добавлена возможность задать верхнюю границу размера файлов. Подключение и конфигурация# С версии 0.60.7 инлайнинг для стилей включен по умолчанию, инлайнятся CSS-файлы размером меньше 40kb до gzip (+-10kb после gzip). Для переопределения этих настроек нужно добавить провайдер с указанием типов ресурсов, которые будут инлайниться (стили и\\или скрипты), а также верхнюю границу размера файлов (в байтах, до gzip): import { RESOURCE_INLINE_OPTIONS } from '@tramvai/tokens-render';import { ResourceType } from '@tramvai/tokens-render';import { provide } from '@tramvai/core'; provide({ provide: RESOURCE_INLINE_OPTIONS, useValue: { types: [ResourceType.script, ResourceType.style], // Включаем для стилей и скриптов threshold: 1024, // 1kb unzipped },}), Скопировать Особенности# Инлайнятся все скрипты и\\или стили (в зависимости от настроек), зарегистрированные через ResourcesRegistry Загрузка файлов на сервере происходит в lazy-режиме асинхронно. Это означает, что при первой загрузке страницы инлайнинга не будет происходить. Также это означает, что никакого дополнительного ожидания загрузки ресурсов на стороне сервера не происходит. После попадания файла в кэш он будет инлайниться. Кэш имеет TTL 30 минут, сброс кэша не предусмотрен. "},{"title":"Автоматический предзагрузка ассетов приложений","type":1,"pageTitle":"render","url":"docs/references/modules/render#автоматический-предзагрузка-ассетов-приложений","content":"Для ускорения загрузки данных добавлена система подзагрузки данных для ресурсов и асинхронных чанков, которая работает по следующему сценарию: После рендеринга приложения мы получаем информацию о всех используемых в приложении css, js и асинхронных чанкахДальше добавляем все css в прелоад тег и навешиваем onload событие. Нам необходимо максимально быстро загрузить блокирующие ресурсы.При загрузке любого css файла, добавляем в предзагрузку все необходимые js файлы Особенности# Обязательно должен быть синхронизирована последняя часть идентификатора бандла с названием чанка const dashboard = () => require.ensure([], (require) => require('./bundles/dashboard'), 'dashboard');bundles: { 'platform/mvno/dashboard': dashboard,} Скопировать или если используете import const dashboard = () => import(/* webpackChunkName: \"dashboard\" */ './bundles/dashboard');bundles: { 'platform/mvno/dashboard': dashboard,} Скопировать В примере выше, 'dashboard' и last('platform/mvno/dashboard'.split('/')) имеют одинаковое значение. Иначе мы не сможем на стороне сервера узнать, какой из списка чанков подходит в бандлу и подзагрузка произойдет только на стороне клиента. "},{"title":"Базовый layout","type":1,"pageTitle":"render","url":"docs/references/modules/render#базовый-layout","content":"В module-render встроен дефолтный базовый layout, который поддерживает различные способы расширения и добавления функциональности Подробнее про лайаут можете почитать на странице библиотеке Добавление базовых header и footer# Можно добавить компоненты header и footer, которые будут отрисовываться по умолчанию для всех страниц Через провайдер# Зарегистрировать компоненты header и footer через провайдеры import { DEFAULT_HEADER_COMPONENT, DEFAULT_FOOTER_COMPONENT } from '@tramvai/tokens-render';import { provide } from '@tramvai/core'; createApp({ providers: [ provide({ provide: DEFAULT_HEADER_COMPONENT, useValue: DefaultHeader, }), provide({ provide: DEFAULT_FOOTER_COMPONENT, useValue: DefaultFooter, }), ],}); Скопировать Через бандл# Можно зарегистрировать в бандле компонент headerDefault и footerDefault, которые будет отрисовываться для всех роутов, у которых не переопределены headerComponent и footerComponent. createBundle({ name: 'common-bundle', components: { headerDefault: CustomHeader, footerDefault: CustomFooter, },}); Скопировать Добавление компонентов и враперов# Добавить кастомные компоненты и врапперы для layout можно через токен LAYOUT_OPTIONS import { provide } from '@tramvai/core';@Module({ providers: [ provide({ provide: 'LAYOUT_OPTIONS', multi: true, useValue: { // react компоненты components: { // базовые кастомные компоненты врапперы для отрисовки страницы и контента content: Content, page: Page, // глобальные компоненты alerts: Alerts, feedback: Feedback, }, // HOC для компонентов wrappers: { layout: layoutWrapper, alerts: [alertWrapper1, alertWrapper2], }, }, }), ],})export class MyLayoutModule {} Скопировать Подробнее про опции components и wrappers можно узнать в @tinkoff/layout-factory Замена базового layout# Если вам не подходит базовый лайаут, вы можете его подменить на любой другой React компонент. При этом вам нужно самостоятельно реализовывать все врапперы и подключать глобальные компоненты, если они вам нужны. Заменить можно двумя способами: Добавить layoutComponent у роута# Вы можете прописать параметр layoutComponent у роута в properties и зарегистрировать компонент в bundle. При отрисовке страницы отобразится зарегистрированный компонент createBundle({ name: 'common-bundle', components: { myCustomLayout: CustomLayout, },}); Скопировать Переопределить layoutDefault# Вы можете зарегистрировать в бандле компонент layoutDefault который автоматически будет отрисовываться для всех роутов, у которых не переопределен layoutComponent createBundle({ name: 'common-bundle', components: { layoutDefault: CustomLayout, },}); Скопировать "},{"title":"How to","type":1,"pageTitle":"render","url":"docs/references/modules/render#how-to","content":""},{"title":"Как добавить загрузку ассетов на странице","type":1,"pageTitle":"render","url":"docs/references/modules/render#как-добавить-загрузку-ассетов-на-странице","content":"Присутствует 2 способа, как можно добавить ресурсы в приложение токен RENDER_SLOTS, в который можно передать список ресурсов, например HTML разметка, inline скрипты, тег scriptтокен RESOURCES_REGISTRY для получения менеджера ресурсов, и регистрации нужных ресурсов вручную Пример:  Пример приложения import React from 'react';import { createApp, createBundle, commandLineListTokens } from '@tramvai/core';import { RENDER_SLOTS, RESOURCES_REGISTRY, ResourceType, ResourceSlot,} from '@tramvai/module-render';import { modules } from '../common'; function Page() { return <div>Render</div>;} const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, },}); createApp({ name: 'render-add-resources', modules: [...modules], providers: [ { // Если требуется добавить свои ресурсы (скрипты, стили, картинки) для загрузки, то можно использовать // провайдер RENDER_SLOTS для добавления необходимого, все это потом будет использовано в RenderModule // и вставлено в html provide: RENDER_SLOTS, multi: true, useValue: [ { type: ResourceType.inlineScript, // inlineScript обернет payload в тег <script> slot: ResourceSlot.HEAD_CORE_SCRIPTS, // определяет позицию где в html будет вставлен ресурс payload: 'alert(\"render\")', }, { type: ResourceType.asIs, // asIs занчит вставить ресурс как есть. без обработки slot: ResourceSlot.BODY_TAIL, payload: '<div>hello from render slots</div>', }, ], }, { provide: commandLineListTokens.resolveUserDeps, multi: true, // также ресурсы можно добавить отдельно через di и токен RESOURCES_REGISTRY useFactory: ({ resourcesRegistry }) => { return function addMyScripts() { resourcesRegistry.register({ slot: ResourceSlot.HEAD_ANALYTICS, // место вставки type: ResourceType.script, // script создаст новый тег скрипт с src равном payload payload: './some-script.js', }); }; }, deps: { resourcesRegistry: RESOURCES_REGISTRY, }, }, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Скопировать  "},{"title":"Как можно перевести приложения на Concurrent render mode","type":1,"pageTitle":"render","url":"docs/references/modules/render#как-можно-перевести-приложения-на-concurrent-render-mode","content":"React позволяет выполнить постепенную миграцию приложения Этапы миграции: Strict Mode - строгий режим, в котором React предупреждает об использовании легаси API Для подключения необходимо сконфигурировать render-module modules: [ RenderModule.forRoot({ mode: 'strict' })] Скопировать Затем необходимо исправить все новые предупреждения, такие как использование легаси методов жизненного цикла и строковые рефы. Blocking Mode - добавляет часть возможностей Concurrent Mode, например Suspense на сервере. Подходит для постепенной миграции на Concurrent Mode. Для подключения необходимо установить экспериментальную версию React и сконфигурировать render-module npm install react@experimental react-dom@experimental Скопировать modules: [ RenderModule.forRoot({ mode: 'blocking' })] Скопировать На этом этапе надо проверить работоспособность приложения, и можно попробовать новые API, например SuspenseList Concurrent Mode Для подключения необходимо установить экспериментальную версию React и сконфигурировать render-module npm install react@experimental react-dom@experimental Скопировать modules: [ RenderModule.forRoot({ mode: 'concurrent' })] Скопировать На этом этапе надо проверить работоспособность приложения, и можно попробовать новые API, например useTransition "},{"title":"Тестирование","type":1,"pageTitle":"render","url":"docs/references/modules/render#тестирование","content":"Тестирование расширений рендера через токены RENDER_SLOTS или RESOURCES_REGISTRY# Если у вас имеется модуль или провайдеры которые определяют RENDER_SLOTS или используют RESOURCES_REGISTRY, то удобно будет использовать специальные утилиты для того чтобы протестировать их отдельно import { RENDER_SLOTS, ResourceSlot, RESOURCES_REGISTRY, ResourceType,} from '@tramvai/tokens-render';import { testPageResources } from '@tramvai/module-render/tests';import { CustomModule } from './module';import { providers } from './providers'; describe('testPageResources', () => { it('modules', async () => { const { render } = testPageResources({ modules: [CustomModule], }); const { head } = render(); expect(head).toMatchInlineSnapshot(`\"<meta charset=\\\\\"UTF-8\\\\\"><script>console.log(\\\\\"from module!\\\\\")</script>\"`); }); it('providers', async () => { const { render, runLine } = testPageResources({ providers, }); expect(render().body).toMatchInlineSnapshot(`\"\" `); await runLine(commandLineListTokens.resolvePageDeps); expect(render().body).toMatchInlineSnapshot(`\"<script defer=\\\\\"defer\\\\\" charset=\\\\\"utf-8\\\\\" crossorigin=\\\\\"anonymous\\\\\" src=\\\\\"https://scripts.org/script.js\\\\\"></script><span>I\\`m body!!!</span>\" `); });}); Скопировать "},{"title":"Экспортируемые токены","type":1,"pageTitle":"render","url":"docs/references/modules/render#экспортируемые-токены","content":"ссылка "},{"title":"sentry","type":0,"sectionRef":"#","url":"docs/references/modules/sentry","content":"","keywords":""},{"title":"Подключение в проект","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#подключение-в-проект","content":""},{"title":"Переменные окружения","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#переменные-окружения","content":"Обязательные: SENTRY_DSN - DSN приложения Опциональные: SENTRY_RELEASE - информация о текущем релизе приложенияSENTRY_ENVIRONMENT - информация об окруженииSENTRY_SDK_URL - URL для загрузки Sentry SDK в браузере, задан по умолчаниюSENTRY_DSN_CLIENT - DSN приложения для использования только в браузере. "},{"title":"Подключение модуля","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#подключение-модуля","content":"SentryModule следует подключать в приложение одним из первых import { SentryModule } from '@tramvai/module-sentry'; createApp({ modules: [SentryModule],}); Скопировать И обязательно добавьте SENTRY_DSN параметр на стендах. Иначе плагин не будет работать. "},{"title":"Пример отправки кастомных ошибок","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#пример-отправки-кастомных-ошибок","content":"import { createAction } from '@tramvai/core';import { SENTRY_TOKEN } from '@tramvai/module-sentry';import { loadUsers } from './users'; export default createAction({ name: 'loadUsers', fn: async (context, _, { sentry }) => { try { await loadUsers(); } catch (e) { sentry.captureException(e); throw e; } }, deps: { sentry: SENTRY_TOKEN, },}); Скопировать "},{"title":"Локальный дебаг модуля","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#локальный-дебаг-модуля","content":"Локально Sentry отключен и если вы хотите оддебажить модуль, то необходимо явно включить Sentry SentryModule.forRoot({ enabled: true, debug: true }); Скопировать И добавить в env.development.js параметр SENTRY_DSN после этого Sentry включится при локальной разработке "},{"title":"Получение DSN","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#получение-dsn","content":"Для этого: Зайдите в UI интерфейс SentryНажмите на таб SettingsВ табе Projects выберите свой проектВыберите Client Keys (DSN)Скопируйте текст с DefaultDSN поля. "},{"title":"Sensitive Data","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#sensitive-data","content":"Прежде чем начать использовать модуль, следует ознакомиться с документаций и в случае необходимости сконфигурировать под свое приложение Sentry старается максимально обогощать контекст ошибки, формируя breadcrumbs и получая информацию от дополнительных интеграций. Все это можно конфигурировать, но следует внимательно следить за тем, какая информация в итоге попадает в Sentry хранилище. "},{"title":"Поведение","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#поведение","content":"Модуль использует universal подход, что позволяет логировать ошибки на клиенте и сервере. Интеграция c Sentry SDK происходит на шаге commandLineListTokens.init. По умолчанию Sentry включается только для production и если имется DSN. "},{"title":"Browser","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#browser","content":"Концептуально используется lazy loaded подход при котором Sentry SDK подключается динамически (возможно по необходимости), то есть @sentry/browser не попадает в итоговый бандл "},{"title":"Node","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#node","content":"Используется @sentry/node и Sentry express middleware "},{"title":"Загрузка sourcemaps","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#загрузка-sourcemaps","content":"Для загрузки sourcemaps в Sentry систему можно использовать @sentry/cli. Важно правильно указать --url-prefix. --rewrite нужен, чтобы сократить размер загружаемых файлов и выполнить проверку валидности сорсмап Пример такого скрипта для загрузки: ci/sentry-upload-sourcemaps:# set -eu -o pipefail -x PACKAGE_VERSION=$(node -p -e \"require('./package.json').version\")VERSION=${SENTRY_RELEASE:-\"${PACKAGE_VERSION}-${CI_COMMIT_SHA}\"}export SENTRY_PROJECT=\"${APP}\"export SENTRY_URL=\"${SENTRY_URL_TEST}\"export SENTRY_AUTH_TOKEN=\"${SENTRY_AUTH_TOKEN_TEST}\"sentry-cli releases files $VERSION upload-sourcemaps --rewrite --url-prefix \"~/\" ./server/ & \\sentry-cli releases files $VERSION upload-sourcemaps --rewrite --url-prefix \"~/platform/\" ./assets/ Скопировать Чтобы генерировались sourcemaps для сервера, нужно указать \"sourceMapServer\": true в configurations для приложения в platform.json. "},{"title":"Экспортируемые токены","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#экспортируемые-токены","content":"SENTRY_TOKEN# Подготовленный инстанс Sentry на основе Node SDK или Browser SDK "},{"title":"SENTRY_OPTIONS_TOKEN","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#sentry_options_token","content":"Опции для конфигурирования Sentry для Node и Browser окружений "},{"title":"SENTRY_REQUEST_OPTIONS_TOKEN","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#sentry_request_options_token","content":"Опции для конфигурирования парсера данных из запроса для express middleware "},{"title":"SENTRY_FILTER_ERRORS","type":1,"pageTitle":"sentry","url":"docs/references/modules/sentry#sentry_filter_errors","content":"Позволяет передать функцию для фильтрации ошибок перед отправкой в Sentry. Механизм фильтрации описан в документации Sentry, в функцию передаются аргументы event и hint метода beforeSend. "},{"title":"seo","type":0,"sectionRef":"#","url":"docs/references/modules/seo","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#installation","content":"You need to install @tramvai/module-seo npm i @tramvai/module-seo Скопировать And connect to the project import { createApp } from '@tramvai/core';import { SeoModule } from '@tramvai/module-seo'; createApp({ name: 'tincoin', modules: [...SeoModule],}); Скопировать "},{"title":"Tramvai integration","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#tramvai-integration","content":"The module does not add a public api to the DI. The seo renderer uses the @tramvai/module-render capabilities to insert code into the html page. "},{"title":"Basic data sources","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#basic-data-sources","content":"default - list of basic default parametersconfig/meta - a list of meta parameters from the route configuration "},{"title":"Connecting additional data sources","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#connecting-additional-data-sources","content":"The @tinkoff/meta-tags-generate library allows you to connect additional data sources for meta tags with the ability to overwrite basic ones. To do this, you need to define a multi-provider META_UPDATER_TOKEN. import { createApp, provide } from '@tramvai/core';import { SeoModule, META_UPDATER_TOKEN, META_PRIORITY_ROUTE } from '@tramvai/module-seo'; const metaSpecial = (meta) => { meta.updateMeta(META_PRIORITY_ROUTE, { // priority - 10 title: 'title', // key/value in meta, metaCustom: { // more information about the format [in the documentation](references/libs/meta-tags-generate.md) tag: 'meta', attributes: { name: 'metaCustomNameAttribute', content: 'metaCustomContent', }, }, });}; createApp({ providers: [ provide({ // or add via provider provide: META_UPDATER_TOKEN, multi: true, useValue: metaSpecial, }), ], modules: [ SeoModule.forRoot({ list: [metaSpecial], }), ],}); Скопировать Each source is a function that takes a meta and allows you to extend the meta through a updateMeta call. The priority is a positive number, for each specific meta key the value with the highest priority will be used, the value with priority 0 denotes the default value. More about the format in the documentation "},{"title":"Setting seo data dynamically","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#setting-seo-data-dynamically","content":"If you want to install seo in a page action or in one of the commandLineRunner steps, you can explicitly use the MetaWalk entity from the @tinkoff/meta-tags-generate lib. import { createAction } from '@tramvai/core';import { META_WALK_TOKEN, META_PRIORITY_APP } from '@tramvai/module-seo'; createAction({ name: 'action', fn: async (context, payload, { meta }) => { meta.updateMeta(META_PRIORITY_APP, { title: 'WoW, such dynamic!', }); }, deps: { meta: META_WALK_TOKEN, }, conditions: { always: true, },}); Скопировать "},{"title":"Replacing default seo data","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#replacing-default-seo-data","content":"The SEO module comes with a default package of seo tags. If they do not suit you, you can replace the provider's implementation and put your own data: import { createApp } from '@tramvai/core';import { SeoModule, META_DEFAULT_TOKEN } from '@tramvai/module-seo'; createApp({ providers: [ // Change metaDefaultPack token implementation { provide: META_DEFAULT_TOKEN, useValue: { title: 'E Corp' }, }, ], modules: [SeoModule],}); Скопировать After that we will substitute the new default parameters "},{"title":"Meta parameters","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#meta-parameters","content":"The library already predefines some basic parameters for convenient use when configuring routers. And we can use meta parameters like title: 'Tinkoff'. See the list of such converters in the src/converters/converters.ts file "},{"title":"How to","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#how-to","content":""},{"title":"Testing","type":1,"pageTitle":"seo","url":"docs/references/modules/seo#testing","content":"Testing work with META_UPDATER_TOKEN and META_DEFAULT_TOKEN# If you have a module or providers that define META_UPDATER_TOKEN or META_DEFAULT_TOKEN then it is convenient to use special utilities to test them separately import { Module, provide } from '@tramvai/core';import { testMetaUpdater } from '@tramvai/module-seo/tests';import { META_PRIORITY_APP, META_DEFAULT_TOKEN, META_UPDATER_TOKEN } from '@tramvai/module-seo'; describe('testMetaUpdater', () => { it('modules', async () => { const metaUpdater = jest.fn< ReturnType<typeof META_UPDATER_TOKEN>, Parameters<typeof META_UPDATER_TOKEN> >((walker) => { walker.updateMeta(META_PRIORITY_APP, { title: 'test title', }); }); @Module({ providers: [ provide({ provide: META_UPDATER_TOKEN, multi: true, useValue: metaUpdater, }), ], }) class CustomModule {} const { renderMeta } = testMetaUpdater({ modules: [CustomModule], }); const { render, metaWalk } = renderMeta(); expect(metaWalk.get('title').value).toBe('test title'); expect(render).toMatch('<title data-meta-dynamic=\"true\">test title</title>'); }); it('providers', async () => { const { renderMeta } = testMetaUpdater({ providers: [ provide({ provide: META_DEFAULT_TOKEN, useValue: { title: 'default title', }, }), ], }); const { render } = renderMeta(); expect(render).toMatch('<title data-meta-dynamic=\"true\">default title</title>'); });}); Скопировать "},{"title":"server","type":0,"sectionRef":"#","url":"docs/references/modules/server","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"server","url":"docs/references/modules/server#installation","content":"You need to install @tramvai/module-server npm i --save @tramvai/module-server Скопировать And connect to the project import { createApp } from '@tramvai/core';import { ServerModule } from '@tramvai/module-server'; createApp({ name: 'tincoin', modules: [ServerModule],}); Скопировать "},{"title":"Explanation","type":1,"pageTitle":"server","url":"docs/references/modules/server#explanation","content":""},{"title":"Processing the users requests","type":1,"pageTitle":"server","url":"docs/references/modules/server#processing-the-users-requests","content":"ServerModule creates express.js application, handles user requests, runs commandLineRunner, and sends responses to users with data, headers and status from RESPONSE_MANAGER_TOKEN token. "},{"title":"Request proxying","type":1,"pageTitle":"server","url":"docs/references/modules/server#request-proxying","content":"ServerModule allows you to configure the proxying of urls to the application using the library http-proxy-middleware To enable proxying, create a file proxy.conf.js or proxy.conf.json in the root of the project to export the request mapping object, or you can use the PROXY_CONFIG_TOKEN token. Proxy config format# Key-value object# const testStand = 'https://example.org'; module.exports = { // The key is the path pattern for the `express` to be passed to `app.use` // value can be a string, in order to proxy all urls starting with `/login/` '/login/': testStand, // or can be a config object for [http-proxy](https://github.com/chimurai/http-proxy-middleware#http-proxy-options) '/test/': { target: testStand, auth: true, xfwd: true, ... }}; Скопировать Object with context and target properties# module.exports = { // context - is similar to the option for [http-proxy-middleware](https://github.com/chimurai/http-proxy-middleware#context-matching) context: ['/login/', '/registration/', '/auth/papi/'], target: 'https://example.org', // other `http-proxy-middleware` options changeOrigin: true,}; Скопировать Array with context and target properties# [ { \"context\": [\"/a/\", \"/b/*/c/\"], \"target\": \"https://example.org\" }] Скопировать Implementation of the PROXY_CONFIG_TOKEN token# import { Scope, provide } from '@tramvai/core';import { PROXY_CONFIG_TOKEN } from '@tramvai/tokens-server'; [ provide({ provide: PROXY_CONFIG_TOKEN, scope: Scope.SINGLETON, useValue: { context: ['/a/', '/b/*/c/'], target: 'https://example.org', }, multi: true, }),]; Скопировать "},{"title":"Serving static files","type":1,"pageTitle":"server","url":"docs/references/modules/server#serving-static-files","content":"The ServerModule has a built-in static server that allows you to distribute static files to users. To serve files, you need to create a directory public in the root of the project in which to place the necessary files. After that, all files will be available for request by browsers. For example, we want to distribute sw.js file from the project's root: for this we create a folder public in which we put the file sw.js. Now on the client side, we will be able to request data from the url http://localhost:3000/sw.js. Also, we will most likely need some modifications on the CI/CD side to copy the public folder to the stands. This function is also available in production. For this purpose, copy the folder public into the docker container "},{"title":"PAPI","type":1,"pageTitle":"server","url":"docs/references/modules/server#papi","content":"Papi - API routes for the tramvai application. More information is available in Papi "},{"title":"Emulation of network/backends problems in the application","type":1,"pageTitle":"server","url":"docs/references/modules/server#emulation-of-networkbackends-problems-in-the-application","content":"(functionality is only available in dev mode) The server has the ability to increase the response time of all requests. To do this you must: start the applicationsend a POST request to /private/papi/debug-http-request with a delay for the request: curl --location --request POST 'http://localhost:3000/tincoin/private/papi/debug-http-request' \\--header 'Content-Type: application/x-www-form-urlencoded' \\--data-urlencode 'delay=2000' Скопировать check if the application works. Note: after each restart of the server the settings are reset, so after each rebuild it is necessary to access papi again.you can disable the timeout by accessing the same papi using the DELETE method curl --location --request DELETE 'http://localhost:3000/tincoin/private/papi/debug-http-request' Скопировать "},{"title":"Logging requests sent to the server","type":1,"pageTitle":"server","url":"docs/references/modules/server#logging-requests-sent-to-the-server","content":"In dev mode, all requests sent through the standard http and https libraries for nodejs are logged under a special server:node-debug:request key. This allows you to see all requests that have been sent to the server, even if no logging has been defined for the requests explicitly. To enable such logging, simply add the server:node-debug:request key to the LOG_ENABLE environment variable "},{"title":"Health checks","type":1,"pageTitle":"server","url":"docs/references/modules/server#health-checks","content":"/healthz - always replies OK after starting the application/readyz - always replies OK after starting the application Metrics The metrics module is automatically connected into the server module. For more information on metrics, you can read in the metrics documentation "},{"title":"Warming application caches","type":1,"pageTitle":"server","url":"docs/references/modules/server#warming-application-caches","content":"The cache-warmup module is automatically plugged into the server module. Detailed information on cache warmup can be found in cache-warmup documentation "},{"title":"Custom headers","type":1,"pageTitle":"server","url":"docs/references/modules/server#custom-headers","content":"Building and Deployment Information# There are special headers in the module, which help to determine the exact information about the version of the built application, commit, branch, etc: x-app-id - The name of the application specified in createApp. Specified in the application code.x-host - Hostname of the server where the current application is running. Computed in runtime.x-app-version - version of the running application. Transmitted through the environment variable APP_VERSION.x-deploy-branch - branch from which the current application image was built. Passed through environment variable DEPLOY_BRANCH.x-deploy-commit - sha commit from which current application image was built. Passed through environment variable DEPLOY_COMMIT.x-deploy-version - deploy revision number in k8s. Passed through environment variable DEPLOY_VERSION.x-deploy-repository - application repository link. Passed through environment variable DEPLOY_REPOSITORY. For all of the headers above which are passed via environment variables to be available, you need the external infrastructure to pass them when building and deprovisioning the application image (inside tinkoff this is done automatically). "},{"title":"Debugging","type":1,"pageTitle":"server","url":"docs/references/modules/server#debugging","content":"Module uses loggers with identifiers: server, server:static, server:webapp, server:node-debug:request "},{"title":"How to","type":1,"pageTitle":"server","url":"docs/references/modules/server#how-to","content":""},{"title":"Specify server port","type":1,"pageTitle":"server","url":"docs/references/modules/server#specify-server-port","content":"By default server starts at 3000 port. You can change this value by specifying environment variable PORT: in dev environment it can be done by adding env PORT to file env.development.json e.g. PORT: \"8080\"it can be specified explicitly as an environment variable PORT e.g. PORT=8080 "},{"title":"Exportable tokens","type":1,"pageTitle":"server","url":"docs/references/modules/server#exportable-tokens","content":"Link "},{"title":"router","type":0,"sectionRef":"#","url":"docs/references/modules/router","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"router","url":"docs/references/modules/router#installation","content":"You need to install @tramvai/module-router: yarn add @tramvai/module-router Скопировать And connect in the project: import { createApp } from '@tramvai/core';import { NoSpaRouterModule, SpaRouterModule } from '@tramvai/module-router'; createApp({ name: 'tincoin', modules: [SpaRouterModule], // modules: [ NoSpaRouterModule ], if you want to disable client SPA transitions}); Скопировать "},{"title":"Explanation","type":1,"pageTitle":"router","url":"docs/references/modules/router#explanation","content":"The module is based on the library @tinkoff/router "},{"title":"Default Settings","type":1,"pageTitle":"router","url":"docs/references/modules/router#default-settings","content":"Next settings are used trailingSlashes = truemergeSlashes = true "},{"title":"Navigation flow on the server","type":1,"pageTitle":"router","url":"docs/references/modules/router#navigation-flow-on-the-server","content":" "},{"title":"Flow of the first navigation on the client","type":1,"pageTitle":"router","url":"docs/references/modules/router#flow-of-the-first-navigation-on-the-client","content":" "},{"title":"Flow of navigation on the client without SPA transitions","type":1,"pageTitle":"router","url":"docs/references/modules/router#flow-of-navigation-on-the-client-without-spa-transitions","content":" "},{"title":"Flow of navigation on the client with SPA transitions","type":1,"pageTitle":"router","url":"docs/references/modules/router#flow-of-navigation-on-the-client-with-spa-transitions","content":" "},{"title":"API","type":1,"pageTitle":"router","url":"docs/references/modules/router#api","content":""},{"title":"Static routes in the application","type":1,"pageTitle":"router","url":"docs/references/modules/router#static-routes-in-the-application","content":"Route description format: const routes = [ { // the name of the route is required name: 'route1', // the path of the route is required path: '/route/a/', // additional configs for the route config: { // layout component name layoutComponent: 'layout', // page component name pageComponent: 'page', }, },]; Скопировать You can explicitly transfer a list of routes to routing when adding a router module: import { createApp } from '@tramvai/core';import { SpaRouterModule } from '@tramvai/module-router'; const routes = [ // ...]; createApp({ modules: [ // ..., SpaRouterModule.forRoot(routes), ],}); Скопировать Or separately with the ROUTES_TOKEN token (you can set it several times): import { ROUTES_TOKEN } from '@tramvai/module-router';import { provide } from '@tramvai/core'; const routesCommon = [ // ...];const routesSpecific = [ // ...]; const providers = [ // ..., provide({ provide: ROUTES_TOKEN, multi: true, useValue: routesCommon, }), provide({ provide: ROUTES_TOKEN, multi: true, useValue: routesSpecific, }),]; Скопировать "},{"title":"PAGE_SERVICE_TOKEN","type":1,"pageTitle":"router","url":"docs/references/modules/router#page_service_token","content":"Service wrapper for working with routing. Serves to hide routing work and is the preferred way of routing work. Methods: getCurrentRoute() - get the current routegetCurrentUrl() - object-result of parsing the current urlgetConfig() - get the config of the current pagegetContent() - get content for the current pagegetMeta() - get the meta for the current pagenavigate(options) - navigation to a new page moreupdateCurrentRoute(options) - update the current route with new parameters moreback() - go back through historyforward() - go forward through historygo(to) - go to the specified delta by historyaddComponent(name, component) - add new component to current page into ComponentRegistrygetComponent(name) - get component from current page components from ComponentRegistry "},{"title":"RouterStore","type":1,"pageTitle":"router","url":"docs/references/modules/router#routerstore","content":"Store that stores information about the current and previous routes. Properties: currentRoute - current routecurrentUrl - current urlpreviousRoute - previous routepreviousUrl - previous url "},{"title":"ROUTER_GUARD_TOKEN","type":1,"pageTitle":"router","url":"docs/references/modules/router#router_guard_token","content":"Allows you to block or redirect the transition to the page under certain conditions. See @tinkoff/router "},{"title":"Redirects","type":1,"pageTitle":"router","url":"docs/references/modules/router#redirects","content":"Redirects can be done via guards or explicitly via the redirect property in the route. const routes = [ // ..., { name: 'redirect', path: '/from/', redirect: '/to/', },]; Скопировать "},{"title":"Not Found route","type":1,"pageTitle":"router","url":"docs/references/modules/router#not-found-route","content":"The route used if no matches were found for the current page, can be specified in a special way in the list of routes. const route = [ // ...other routes, { name: 'not-found', path: '*', config: { pageComponent: 'notfoundComponentName', }, },]; Скопировать "},{"title":"ROUTE_RESOLVE_TOKEN","type":1,"pageTitle":"router","url":"docs/references/modules/router#route_resolve_token","content":"Allows you to define an asynchronous function that returns a route object that will be called if no suitable static route was found in the application. "},{"title":"ROUTE_TRANSFORM_TOKEN","type":1,"pageTitle":"router","url":"docs/references/modules/router#route_transform_token","content":"Transformer function for application routes (set statically and those that will be loaded via ROUTE_RESOLVE_TOKEN) "},{"title":"Method of setting when actions should be performed during SPA transitions","type":1,"pageTitle":"router","url":"docs/references/modules/router#method-of-setting-when-actions-should-be-performed-during-spa-transitions","content":"By default, SPA transitions execute actions after defining the next route, but before the actual transition, which allows the page to be displayed immediately with new data, but can cause a noticeable visual lag if the actions are taken long enough. It is possible to change the behavior and make the execution of actions after the transition itself. Then, when developing components, you will need to take into account that data will be loaded as it becomes available. Configurable explicitly when using the routing module: import { createApp } from '@tramvai/core';import { SpaRouterModule } from '@tramvai/module-router'; createApp({ modules: [ // ..., SpaRouterModule.forRoot([], { spaActionsMode: 'after', // default is 'before' }), ],}); Скопировать or through token ROUTER_SPA_ACTIONS_RUN_MODE_TOKEN: import { ROUTER_SPA_ACTIONS_RUN_MODE_TOKEN } from '@tramvai/module-router';import { provide } from '@tramvai/core'; const providers = [ // ..., provide({ provide: ROUTER_SPA_ACTIONS_RUN_MODE_TOKEN, useValue: 'after', }),]; Скопировать "},{"title":"How to","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to","content":""},{"title":"Working with navigation in providers and actions","type":1,"pageTitle":"router","url":"docs/references/modules/router#working-with-navigation-in-providers-and-actions","content":"In this case, it is best to use the PAGE_SERVICE_TOKEN import { provide, createAction } from '@tramvai/core';import { PAGE_SERVICE_TOKEN } from '@tramvai/module-router'; const provider = provide({ provide: 'token', useFactory: ({ pageService }) => { if (pageService().getCurrentUrl().pathname === '/test/') { return pageService.navigate({ url: '/redirect/', replace: true }); } }, deps: { pageService: PAGE_SERVICE_TOKEN, },}); const action = createAction({ name: 'action', fn: (_, __, { pageService }) => { if (pageService.getConfig().pageComponent === 'pageComponent') { return page.updateCurrentRoute({ query: { test: 'true' } }); } }, deps: { pageService: PAGE_SERVICE_TOKEN, },}); Скопировать "},{"title":"Working with navigation in React components","type":1,"pageTitle":"router","url":"docs/references/modules/router#working-with-navigation-in-react-components","content":"You can work with routing inside React components using hooks and components - useNavigate, useRoute, Link from the @tinkoff/router  An example of working with navigation in the application import React from 'react';import { createApp, createBundle } from '@tramvai/core';import { SpaRouterModule, useNavigate, useUrl, Link } from '@tramvai/module-router';import { modules } from '../common'; const Navigation = ['/1/', '/2/', '/3/']; function Page() { // useUrl allows you to get the current url const { pathname, path } = useUrl(); // useNavigate allows you to get a function with which you can call the navigation const navigate = useNavigate(); // useNavigate also allows you to set properties immediately so that the result can be passed immediately as a callback const navigateToRoot = useNavigate({ url: '/', query: { a: '1', b: '2' } }); return ( <div> <div>Current Path: {path}</div> <div> <button type=\"button\" onClick={navigateToRoot}> Navigate to Root </button> {/* the Link component allows you to create a link with a transition */} <Link url=\"/link/\" replace> <button type=\"button\">Navigate By Link</button> </Link> </div> {Navigation.map((p) => { if (p !== pathname) { return ( <button type=\"button\" onClick={() => navigate({ url: p })}> Navigate to {p} </button> ); } return null; })} </div> );} const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, },}); createApp({ name: 'router-navigate', modules: [ SpaRouterModule.forRoot([ { name: 'root', path: '/', }, { name: 'link', path: '/link/', }, { name: '1', path: '/1/', }, { name: '2', path: '/2/', }, { name: '3', path: '/3/', }, ]), ...modules, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Скопировать  "},{"title":"How to set static routes","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to-set-static-routes","content":"RouterModule allows you to add new routes when configuring your application. The second way is to pass static routes to DI via the ROUTES_TOKEN token.  An example of adding static routes to an application import React from 'react';import { createApp, createBundle } from '@tramvai/core';import { useSelector } from '@tramvai/state';import { useDi } from '@tramvai/react';import { SpaRouterModule, ROUTES_TOKEN, PAGE_SERVICE_TOKEN } from '@tramvai/module-router'; import { modules } from '../common'; const Navigation = ['/1/', '/2/', '/3/']; function Page() { // useSelector to get the current route // store 'router' is provided by RouterModule const state = useSelector('router', (x) => x.router); // pageService - a wrapper for working with a router, you can get various properties and initiate a transition // but through useDi you cannot subscribe to data changes inside services, so to subscribe to route changes // used by useSelector above const pageService = useDi(PAGE_SERVICE_TOKEN); const { pathname, path } = state.currentUrl; return ( <div> <div>Current Path: {path}</div> {Navigation.map((p) => { if (p !== pathname) { return ( <button type=\"button\" onClick={() => pageService.navigate({ url: p })}> Navigate to {p} </button> ); } return null; })} </div> );} const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, },}); createApp({ name: 'route-static-routes', modules: [ // the static forRoot method allows you to define static routes in the application - // these routes are always available and the config for them is not loaded from the admin panel, but are set right there SpaRouterModule.forRoot([ { name: '1', path: '/1/', }, { name: '2', path: '/2/', }, ]), ...modules, ], providers: [ { // you can also set static routes by a separate provider provide: ROUTES_TOKEN, multi: true, useValue: [ { name: '3', path: '/3/', }, ], }, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Скопировать  "},{"title":"How to set Route Guard","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to-set-route-guard","content":"ROUTER_GUARD_TOKEN is set as an asynchronous function, which allows you to perform various actions and influence the routing behavior.  Example router guards job in application import React from 'react';import { createReducer, createEvent } from '@tramvai/state';import { createApp, createBundle, createAction } from '@tramvai/core';import { SpaRouterModule, ROUTER_GUARD_TOKEN, useNavigate, useUrl } from '@tramvai/module-router';import { STORE_TOKEN, CONTEXT_TOKEN, COMBINE_REDUCERS } from '@tramvai/module-common';import { modules } from '../common'; const Navigation = ['/1/', '/2/', '/3/', '/redirect/', '/block/']; function Page() { const navigate = useNavigate(); const { pathname, path } = useUrl(); return ( <div> <div>Current Path: {path}</div> {Navigation.map((p) => { if (p !== pathname) { return ( <button type=\"button\" onClick={() => navigate({ url: p })}> Navigate to {p} </button> ); } return null; })} </div> );} const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, },}); const event = createEvent<boolean>('event');const store = createReducer<boolean | void>('store', undefined).on(event, (_, val) => val); const action = createAction({ name: 'action', fn: async (context) => { await new Promise<void>((res) => setTimeout(res, 1200)); return context.dispatch(event(true)); },}); createApp({ name: 'router-guards', modules: [ SpaRouterModule.forRoot([ { name: 'root', path: '/', }, { name: '1', path: '/1/', }, { name: '2', path: '/2/', }, { name: '3', path: '/3/', }, { name: 'redirect', path: '/redirect/', }, { name: 'block', path: '/block/', }, ]), ...modules, ], providers: [ { provide: COMBINE_REDUCERS, multi: true, useValue: store, }, { provide: ROUTER_GUARD_TOKEN, multi: true, useValue: async ({ to }) => { if (to.path === '/redirect/') { // we can make a redirect from the guard return '/3/'; } }, }, { provide: ROUTER_GUARD_TOKEN, multi: true, useFactory: ({ store: state, context }) => { return async ({ to }) => { if (to.path === '/block/') { if (state.getState().store === undefined) { await context.executeAction(action); } if (state.getState().store) { // we can block navigation return false; } } }; }, deps: { store: STORE_TOKEN, context: CONTEXT_TOKEN, }, }, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Скопировать  "},{"title":"How to add transition hooks","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to-add-transition-hooks","content":"Transition hooks allows to subscribe on different steps of the transition Get router instance with ROUTER_TOKEN tokenUse methods registerHook, registerSyncHook to add new hooks to the routerRegistration should happen as soon as possible so appropriate line is customerStart as it executes before navigation happens. "},{"title":"How to set the Not found route","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to-set-the-not-found-route","content":"The Not found route is used if the corresponding route is not found for the url. Such a route is specified in the list of routes with the special * character in the path property.  An example of setting a Not Found route in an application import React from 'react';import { createApp, createBundle } from '@tramvai/core';import { SpaRouterModule, useNavigate, useUrl } from '@tramvai/module-router';import { modules } from '../common'; const Navigation = [ '/1/', '/2/', '/3/', '/not-found', '/child/1/', '/child/2/', '/child/3/', '/child/not-found',]; function Page() { const navigate = useNavigate(); const { pathname, path } = useUrl(); return ( <div> <div>Current Path: {path}</div> {Navigation.map((p) => { if (p !== pathname) { return ( <button type=\"button\" onClick={() => navigate({ url: p })}> Navigate to {p} </button> ); } return null; })} </div> );} // Defining a separate pageconst NotFoundRoot = () => { return 'not found root';}; const NotFoundChild = () => { return 'not found child';}; const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, notFoundRoot: NotFoundRoot, notFoundChild: NotFoundChild, },}); createApp({ name: 'router-not-found', modules: [ SpaRouterModule.forRoot([ { name: 'root', path: '/', }, { name: '1', path: '/1/', }, { name: '2', path: '/2/', }, { name: '3', path: '/3/', }, { name: 'child-1', path: '/child/1/', }, { name: 'child-2', path: '/child/2/', }, { name: 'child-1', path: '/child/3/', }, { name: 'not-found-root', path: '*', config: { pageComponent: 'notFoundRoot', }, }, { name: 'not-found-child', path: '/child/*', config: { pageComponent: 'notFoundChild', }, }, ]), ...modules, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Скопировать  "},{"title":"How to change Not found route response status","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to-change-not-found-route-response-status","content":"By default, responses for the Not found route return a status of 200. You can change status in custom Route Guard, by using RESPONSE_MANAGER_TOKEN.  An example of changing a Not Found route response status import React from 'react';import { createApp, createBundle } from '@tramvai/core';import { SpaRouterModule, useNavigate, useUrl, ROUTER_GUARD_TOKEN } from '@tramvai/module-router';import { RESPONSE_MANAGER_TOKEN } from '@tramvai/tokens-common';import { modules } from '../common'; const Navigation = ['/', '/not-found']; function Page() { const navigate = useNavigate(); const { pathname, path } = useUrl(); return ( <div> <div>Current Path: {path}</div> {Navigation.map((p) => { if (p !== pathname) { return ( <button type=\"button\" onClick={() => navigate({ url: p })}> Navigate to {p} </button> ); } return null; })} </div> );} const NotFoundRoot = () => { return 'not found root';}; const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, notFoundRoot: NotFoundRoot, },}); createApp({ name: 'router-not-found-custom-status', modules: [ SpaRouterModule.forRoot([ { name: 'root', path: '/', }, { name: 'not-found', path: '*', config: { pageComponent: 'notFoundRoot', }, }, ]), ...modules, ], providers: [ { provide: ROUTER_GUARD_TOKEN, multi: true, useFactory: ({ responseManager }): typeof ROUTER_GUARD_TOKEN => { return async ({ to }) => { // watch all navigations, and wait for route with name `not-found` if (to && to.name === 'not-found') { // set the response status, it will be applied until the end of the response responseManager.setStatus(404); } }; }, deps: { responseManager: RESPONSE_MANAGER_TOKEN, }, }, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Скопировать  "},{"title":"How to change response status in actions","type":1,"pageTitle":"router","url":"docs/references/modules/router#how-to-change-response-status-in-actions","content":"For example, you make a important request in action, and if this request will fail, application need to return 500 or 404 status. Page actions running after router navigation flow, when route is completely resolved. You can change status by using RESPONSE_MANAGER_TOKEN. If you want to prevent page component rendering, you can throw NotFoundError from @tinkoff/errors library.  An example of changing response status in actions import React from 'react';import { createApp, createBundle, createAction } from '@tramvai/core';import { SpaRouterModule, useNavigate, useUrl } from '@tramvai/module-router';import { RESPONSE_MANAGER_TOKEN } from '@tramvai/tokens-common';import { NotFoundError } from '@tinkoff/errors';import { modules } from '../common'; const Navigation = ['/']; const fetchSomeData = () => new Promise((resolve, reject) => { setTimeout(() => { reject(); }, 100); }); const pageAction = createAction({ name: 'pageAction', fn: async (_, __, { responseManager }) => { try { await fetchSomeData(); } catch (e) { const isCriticalDataError = false; if (isCriticalDataError) { // if you throw NotFoundError, Page component will not be rendered, response body will be empty throw new NotFoundError(); } else { // otherwise, if you only change response status, Page component will be rendered without neccesary data responseManager.setStatus(500); } } }, deps: { responseManager: RESPONSE_MANAGER_TOKEN, },}); function Page() { const navigate = useNavigate(); const { pathname, path } = useUrl(); return ( <div> <div>Current Path: {path}</div> {Navigation.map((p) => { if (p !== pathname) { return ( <button type=\"button\" onClick={() => navigate({ url: p })}> Navigate to {p} </button> ); } return null; })} </div> );} Page.actions = [pageAction]; const NotFoundRoot = () => { return 'not found root';}; const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: Page, notFoundRoot: NotFoundRoot, },}); createApp({ name: 'router-action-error', modules: [ SpaRouterModule.forRoot([ { name: 'root', path: '/', }, { name: 'not-found-root', path: '*', config: { pageComponent: 'notFoundRoot', }, }, ]), ...modules, ], bundles: { mainDefault: () => Promise.resolve({ default: bundle }), },}); Скопировать  "},{"title":"Testing","type":1,"pageTitle":"router","url":"docs/references/modules/router#testing","content":"Testing ROUTER_GUARD_TOKEN extensions# If you have a module or providers that define ROUTER_GUARD_TOKEN, then it will be convenient to use special utilities to test them separately import { ROUTER_GUARD_TOKEN } from '@tramvai/tokens-router';import { testGuard } from '@tramvai/module-router/tests';import { CustomModule } from './module';import { providers } from './providers'; describe('router guards', () => { it('should redirect from guard', async () => { const { router } = testGuard({ providers, }); await router.navigate('/test/'); expect(router.getCurrentUrl()).toMatchObject({ path: '/redirect/', }); }); it('should block navigation', async () => { const { router } = testGuard({ modules: [CustomModule], }); expect(router.getCurrentUrl()).toMatchObject({ path: '/' }); await router.navigate('/test/').catch(() => null); expect(router.getCurrentUrl()).toMatchObject({ path: '/', }); });}); Скопировать "},{"title":"Exported tokens","type":1,"pageTitle":"router","url":"docs/references/modules/router#exported-tokens","content":"link "},{"title":"Integration tests","type":0,"sectionRef":"#","url":"docs/references/test/test-integration","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"Integration tests","url":"docs/references/test/test-integration#installation","content":"npm i --save-dev @tramvai/test-integration Скопировать "},{"title":"How To","type":1,"pageTitle":"Integration tests","url":"docs/references/test/test-integration#how-to","content":""},{"title":"Test request to the tramvai app without using browser (aka curl)","type":1,"pageTitle":"Integration tests","url":"docs/references/test/test-integration#test-request-to-the-tramvai-app-without-using-browser-aka-curl","content":"For testing requests to the tramvai app libraries superagent and node-html-parser are used under hood. Call of app.request sends requests to the app. All of the features of superagent are available. Call of app.render resolves to the HTML render that is returned from server while serving the request. import { startCli } from '@tramvai/test-integration';import { initPuppeteer, wrapPuppeteerPage } from '@tramvai/test-puppeteer'; beforeAll(async () => { app = await startCli('bootstrap', { env: { SOME_ENV: 'test', }, });}, 80000); afterAll(() => { return app.close();}); it('request to main page should return status 200', async () => { return app.request('/').expect(200);}); it('main page HTML snapshot', async () => { const parsed = await app.render('/'); const applicationInnerHtml = parsed.application; expect(parsed.application).toMatchInlineSnapshot();}); Скопировать "},{"title":"Testing app in browser with the puppeteer","type":1,"pageTitle":"Integration tests","url":"docs/references/test/test-integration#testing-app-in-browser-with-the-puppeteer","content":"You may use another library @tramvai/test-puppeteer to implement testing in the browser. "},{"title":"Usage of @tinkoff/mocker in tests","type":1,"pageTitle":"Integration tests","url":"docs/references/test/test-integration#usage-of-tinkoffmocker-in-tests","content":"In order to use mocker there should be added @tramvai/module-mocker to the tramvai app modules list. After thar mocker will read file based mocks as it described in the docs to the mocker itself and it can be used dynamically in the tests: it('should work with mocker', async () => { await app.mocker.addMocks('CONFIG_API', { 'GET /test/': { status: 200, payload: { status: 'OK', response: 'smth', }, }, }); await app.request('/api/').expect(200); await app.papi.clearCache(); await app.mocker.removeMocks('CONFIG_API', ['GET /test/']); await app.request('/api/').expect(500);}); Скопировать "},{"title":"JSDom tests","type":0,"sectionRef":"#","url":"docs/references/test/test-jsdom","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"JSDom tests","url":"docs/references/test/test-jsdom#installation","content":"npm i --save-dev @tramvai/test-jsdom Скопировать "},{"title":"Api","type":1,"pageTitle":"JSDom tests","url":"docs/references/test/test-jsdom#api","content":""},{"title":"waitRaf","type":1,"pageTitle":"JSDom tests","url":"docs/references/test/test-jsdom#waitraf","content":"Wait for execution of requestAnimationFrame callback import { waitRaf } from '@tramvai/test-jsdom'; describe('test', () => { it('test', async () => { // some code with raf usage await waitRaf(); });}); Скопировать "},{"title":"Jest integration","type":0,"sectionRef":"#","url":"docs/references/test/test-integration-jest","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"Jest integration","url":"docs/references/test/test-integration-jest#installation","content":"npm i --save-dev @tramvai/test-integration-jest Скопировать "},{"title":"How To","type":1,"pageTitle":"Jest integration","url":"docs/references/test/test-integration-jest#how-to","content":""},{"title":"Debug and development of integration tests in Jest","type":1,"pageTitle":"Jest integration","url":"docs/references/test/test-integration-jest#debug-and-development-of-integration-tests-in-jest","content":"Using this jest preset you can run integration tests in watch mode. In this case, application itself will be launched only once and will work in background. Add preset @tramvai/test-integration-jest to jest.integration.config.js: module.exports = { preset: '@tramvai/test-integration-jest',}; Скопировать Add new script for running tests in watch mode to package.json: { \"scripts\": { \"test:integration\": \"jest -w=3 --config ./jest.integration.config.js\", \"test:integration:watch\": \"jest --runInBand --watch --config ./jest.integration.config.js\" }} Скопировать Run some test with yarn test:integration:watch <path_to_test>. In this case you are able to go to local url http://localhost:3000 and see application at work. "},{"title":"Environment for Jest","type":1,"pageTitle":"Jest integration","url":"docs/references/test/test-integration-jest#environment-for-jest","content":"Minimal set of dependencies for running jest: npm i --save-dev jest @types/jest jest-circus Скопировать "},{"title":"Puppeteer tests","type":0,"sectionRef":"#","url":"docs/references/test/test-puppeteer","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"Puppeteer tests","url":"docs/references/test/test-puppeteer#installation","content":"npm i --save-dev @tramvai/test-puppeteer Скопировать "},{"title":"How To","type":1,"pageTitle":"Puppeteer tests","url":"docs/references/test/test-puppeteer#how-to","content":""},{"title":"Tests in browser","type":1,"pageTitle":"Puppeteer tests","url":"docs/references/test/test-puppeteer#tests-in-browser","content":"Puppeteer runs tests in headless Chrome browser, documentation can be found on official site import { startCli } from '@tramvai/test-integration';import { initPuppeteer, wrapPuppeteerPage } from '@tramvai/test-puppeteer'; beforeAll(async () => { app = await startCli('bootstrap', { env: { SOME_ENV: 'test', }, });}, 80000); afterAll(() => { return app.close();}); it('puppeteer', async () => { const { browser } = await initPuppeteer(app.serverUrl); const page = await browser.newPage(); const wrapper = wrapPuppeteerPage(page); await page.goto(app.serverUrl); expect( await page.$eval('.application', (node) => (node as HTMLElement).innerText) ).toMatchInlineSnapshot(`\"Main Page click link\"`); await wrapper.router.navigateWithReload('./second'); expect( await page.$eval('.application', (node) => (node as HTMLElement).innerText) ).toMatchInlineSnapshot(`\"Second Page click link\"`); await browser.close();}); Скопировать "},{"title":"Mocks","type":0,"sectionRef":"#","url":"docs/references/test/test-mocks","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#подключение","content":"npm i --save-dev @tramvai/test-mocks Скопировать "},{"title":"Api","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#api","content":""},{"title":"STORE_TOKEN","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#store_token","content":"Creates mock instance for token STORE_TOKEN which used in app as a common storage for store Empty State# import { createMockStore } from '@tramvai/test-mocks'; const store = createMockStore();const state = store.getState(); store.dispatch('event'); Скопировать Initial State# import { createMockStore } from '@tramvai/test-mocks'; const initialState = { a: 1, b: 2 };const reducerC = createReducer('c', 3);const store = createMockStore({ stores: [reducerC], initialState }); const state = store.getState(); Скопировать  More examples import { createReducer, createEvent } from '@tramvai/state';import { createMockStore } from './store'; describe('test/unit/mocks/store', () => { it('should create empty store', () => { const store = createMockStore(); const spyGetState = jest.spyOn(store, 'getState'); expect(store.getState()).toEqual({}); expect(spyGetState).toHaveBeenCalled(); }); it('should update stores with dispatch', () => { const event = createEvent<string>('testEvent'); const reducer = createReducer('test', { a: 'test' }).on(event, (_, data) => { return { a: data, }; }); const store = createMockStore({ stores: [reducer] }); expect(store.getState()).toEqual({ test: { a: 'test' } }); store.dispatch(event('dispatched')); expect(store.getState()).toEqual({ test: { a: 'dispatched' } }); }); it('should create store by initialState', () => { const initialState = { a: 1, b: 2 }; const reducerA = createReducer('a', {}); const reducerB = createReducer('b', {}); const store = createMockStore({ stores: [reducerA, reducerB], initialState }); expect(store.getState()).toEqual(initialState); }); it('should create fake reducer stores for every key in initialState', () => { const initialState = { a: 1, b: 2 }; const reducerC = createReducer('c', 3); const store = createMockStore({ stores: [reducerC], initialState }); expect(store.getState()).toEqual({ a: 1, b: 2, c: 3, }); });}); Скопировать  "},{"title":"DI","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#di","content":"Creates mock instance of DI-container import { createMockDi } from '@tramvai/test-mocks'; const di = createMockDi(); const dep = di.get(SOME_TOKEN); Скопировать "},{"title":"Context","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#context","content":"Creates mock instance for CONTEXT_TOKEN import { createMockContext } from '@tramvai/test-mocks'; it('test', async () => { const context = createMockContext(); await context.dispatch('event'); await context.executeAction(action); const spyExecuteAction = jest.spyOn(context, 'executeAction'); expect(spyExecuteAction).toHaveBeenCalled();}); Скопировать  More examples import { createEvent, createReducer } from '@tramvai/state';import { createMockContext } from './context'; describe('test/unit/mocks/context', () => { it('should create consumer context', () => { const context = createMockContext(); expect(context.executeAction).toBeInstanceOf(Function); expect(context.getState).toBeInstanceOf(Function); expect(context.dispatch).toBeInstanceOf(Function); expect(context.getState()).toEqual({}); }); it('should dispatch data', async () => { const event = createEvent<string>('mockEvent'); const reducer = createReducer('a', 'data').on(event, (_, data) => data); const context = createMockContext({ stores: [reducer], }); const spyDispatch = jest.spyOn(context, 'dispatch'); await context.dispatch(event('mock1')); expect(spyDispatch).toHaveBeenCalledWith(event('mock1')); expect(context.getState()).toEqual({ a: 'mock1' }); });}); Скопировать  "},{"title":"Router","type":1,"pageTitle":"Mocks","url":"docs/references/test/test-mocks#router","content":"Creates mock instance for @tinkoff/router import { createMockRouter } from '@tramvai/test-mocks'; describe('test', () => { it('should create router mock', () => { const router = createMockRouter(); expect(router.getCurrentRoute()).toMatchObject({ path: '/' }); expect(router.getCurrentUrl()).toMatchObject({ path: '/' }); }); it('should allow to specify currentRoute', () => { const router = createMockRouter({ currentRoute: { name: 'page', path: '/page/test/' } }); expect(router.getCurrentRoute()).toMatchObject({ path: '/page/test/' }); expect(router.getCurrentUrl()).toMatchObject({ path: '/page/test/' }); });}); Скопировать "},{"title":"React tests","type":0,"sectionRef":"#","url":"docs/references/test/test-react","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"React tests","url":"docs/references/test/test-react#installation","content":"npm i --save-dev @tramvai/test-react Скопировать "},{"title":"How to","type":1,"pageTitle":"React tests","url":"docs/references/test/test-react#how-to","content":""},{"title":"Test component","type":1,"pageTitle":"React tests","url":"docs/references/test/test-react#test-component","content":"Under the hood the @testing-library/react is used. /** * @jest-environment jsdom */import { testComponent } from '@tramvai/test-react'; describe('test', () => { it('render', async () => { const { render, rerender, context, act, fireEvent, Wrapper } = testComponent(<Cmp id={1} />); // test component render expect(render.getByTestId('test').textContent).toBe('Content 1'); // test render after store update act(() => { context.dispatch(event('data')); }); // interact with the component fireEvent.click(render.getByText('Button')); // component rerender rerender(<Cmp id={2} />); expect(render.getByTestId('test').textContent).toBe('Content 2'); });}); Скопировать  More examples /** * @jest-environment jsdom */ import React, { useEffect, useRef } from 'react';import { createReducer, createEvent, useStore } from '@tramvai/state';import { useDi } from '@tramvai/react';import { useRoute } from '@tinkoff/router';import { testComponent } from './testComponent'; describe('test/unit/react/testComponent', () => { it('should render simple component', async () => { const Cmp = () => { return ( <div> <div>Root</div> <div data-testid=\"test\">Content</div> </div> ); }; const { render } = testComponent(<Cmp />); expect(render.getByTestId('test').textContent).toBe('Content'); }); it('should rerender component on store updates', async () => { const event = createEvent<void>('evnt'); const store = createReducer('store', { a: 1 }).on(event, (state) => ({ a: state.a + 1 })); const Cmp = () => { const { a } = useStore(store); return ( <div> <span data-testid=\"content\">Counter: {a}</span> </div> ); }; const { context, render, act } = testComponent(<Cmp />, { stores: [store] }); expect(render.getByTestId('content').textContent).toBe('Counter: 1'); act(() => { context.dispatch(event()); }); expect(render.getByTestId('content').textContent).toBe('Counter: 2'); }); it('should work with di', async () => { const Cmp = () => { const { provider } = useDi({ provider: 'provider' }); return <span role=\"text\">{provider}</span>; }; const { render } = testComponent(<Cmp />, { providers: [ { provide: 'provider', useValue: 'test', }, ], }); expect(render.getByRole('text')).toMatchInlineSnapshot(` <span role=\"text\" > test </span> `); }); it('should work with routing', async () => { const Cmp = () => { const route = useRoute(); return ( <div> <div data-testid=\"route\"> <div data-testid=\"route-path\">{route.actualPath}</div> <div data-testid=\"route-name\">{route.name}</div> </div> </div> ); }; const { render } = testComponent(<Cmp />, { currentRoute: { name: 'test', path: '/test/' } }); expect(render.getByTestId('route-path').textContent).toBe('/test/'); expect(render.getByTestId('route-name').textContent).toBe('test'); }); it('should rerender simple component', async () => { expect.hasAssertions(); const Cmp = ({ label }: { label: string }) => { const count = useRef(1); useEffect(() => { count.current += 1; }, [label]); return ( <div> <div>Root</div> <div data-testid=\"test\">{`${count.current}. ${label}`}</div> </div> ); }; const { render, rerender } = testComponent(<Cmp label=\"first render\" />); expect(render.getByTestId('test').textContent).toBe('1. first render'); rerender(<Cmp label=\"second render\" />); expect(render.getByTestId('test').textContent).toBe('2. second render'); }); it('should rerender component on props updates', async () => { const event = createEvent<void>('evnt'); const store = createReducer('store', { a: 1 }).on(event, (state) => ({ a: state.a + 1 })); const Cmp = ({ label }: { label: string }) => { const count = useRef(1); const { a } = useStore(store); useEffect(() => { count.current += 1; }, [label]); return ( <div> <span data-testid=\"content\">{`${count.current}. ${label}: ${a}`}</span> </div> ); }; const { context, render, rerender, act } = testComponent(<Cmp label=\"first render\" />, { stores: [store], }); expect(render.getByTestId('content').textContent).toBe('1. first render: 1'); act(() => { context.dispatch(event()); }); expect(render.getByTestId('content').textContent).toBe('2. first render: 2'); rerender(<Cmp label=\"second render\" />); expect(render.getByTestId('content').textContent).toBe('2. second render: 2'); });}); Скопировать  "},{"title":"Test React-hooks","type":1,"pageTitle":"React tests","url":"docs/references/test/test-react#test-react-hooks","content":"Under the hood the @testing-library/react-hooks is used. /** * @jest-environment jsdom */import { testHooks } from '@tramvai/test-react'; describe('test', () => { it('hook', async () => { const { result, context, act } = testHook(() => useHook()); // test the result of hook call expect(result.current).toBe('result'); // test the result after store update act(() => { context.dispatch(event('data')); }); });}); Скопировать  More examples /** * @jest-environment jsdom */ import { createReducer, createEvent, useStore } from '@tramvai/state';import { useDi } from '@tramvai/react';import { useRoute } from '@tinkoff/router';import { waitRaf } from '@tramvai/test-jsdom';import { testHook } from './testHook'; describe('test/unit/react/testHook', () => { it('should render simple hook', async () => { const useHook = jest.fn((p: string) => 'result'); const { result } = testHook(() => useHook('test')); expect(result.current).toBe('result'); expect(useHook).toHaveBeenCalledWith('test'); }); it('should rerender hook', async () => { const event = createEvent<void>('evnt'); const store = createReducer('store', { a: 1 }).on(event, (state) => ({ a: state.a + 1 })); const useHook = () => { return useStore(store).a; }; const { context, result, act } = testHook(() => useHook(), { stores: [store] }); expect(result.current).toBe(1); await act(async () => { await context.dispatch(event()); await waitRaf(); }); expect(result.current).toBe(2); }); it('should work with di', async () => { const useHook = () => { return useDi({ provider: 'provider' }).provider; }; const { result } = testHook(() => useHook(), { providers: [ { provide: 'provider', useValue: 'test', }, ], }); expect(result.current).toEqual('test'); }); it('should work with routing', async () => { const useHook = () => { const route = useRoute(); return [route.actualPath, route.name]; }; const { result } = testHook(() => useHook(), { currentRoute: { name: 'test', path: '/test/' }, }); expect(result.current).toEqual(['/test/', 'test']); });}); Скопировать  "},{"title":"Jest unit","type":0,"sectionRef":"#","url":"docs/references/test/test-unit-jest","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"Jest unit","url":"docs/references/test/test-unit-jest#installation","content":"Install package: npm i --save-dev @tramvai/test-unit-jest Скопировать Add new preset to your jest.config: module.exports = { preset: '@tramvai/test-unit-jest',}; Скопировать "},{"title":"Explanation","type":1,"pageTitle":"Jest unit","url":"docs/references/test/test-unit-jest#explanation","content":"This presets implements next settings: use jest-circus as testRunnerdefault testEnvironment is nodeuses @swc-node/jest for transformationcss files are mapped with identity-obj-proxyimage files are mapped to empty string "},{"title":"How To","type":1,"pageTitle":"Jest unit","url":"docs/references/test/test-unit-jest#how-to","content":""},{"title":"Override testEnvironment for file","type":1,"pageTitle":"Jest unit","url":"docs/references/test/test-unit-jest#override-testenvironment-for-file","content":"Based on jest doc Just add at the start of test file following comment: /** * @jest-environment your-environment */ Скопировать "},{"title":"child-app-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/child-app-tokens","content":"child-app-tokens import { createToken } from '@tinkoff/dippy';import type { Action, Command } from '@tramvai/core';import type { INITIAL_APP_STATE_TOKEN } from '@tramvai/tokens-common';import type { ComponentType } from 'react';import type { ChildAppLoader, ChildAppDiManager, ChildAppPreloadManager, ChildAppCommandLineRunner, ChildAppRequestConfig, WrapperProps, RootStateSubscription, ChildAppStateManager, ChildAppFinalConfig, ChildAppRenderManager, ChildAppResolutionConfig, ResolutionConfig,} from './types'; export * from './types'; const multiOptions = { multi: true }; /** * @public * @description CommandLineRunner steps specific for child app */export const commandLineListTokens = { // section: client processing customerStart: createToken<Command>('child-app customer_start', multiOptions), // Инициализация клиента resolveUserDeps: createToken<Command>('child-app resolve_user_deps', multiOptions), // Получение данных о клиенте resolvePageDeps: createToken<Command>('child-app resolve_page_deps', multiOptions), // Получение данных необходимых для роута // section: clear data clear: createToken<Command>('child-app clear', multiOptions), // Очистка данных // section: spa transitions spaTransition: createToken<Command>('child-app spa_transition', multiOptions),}; /** * @public * @description Contains child app configs that was used to figure out how to load child apps */export const CHILD_APP_RESOLUTION_CONFIGS_TOKEN = createToken<ChildAppResolutionConfig[]>( 'child-app resolve configs'); /** * @public * @description async function to execute any preload action before any child-app starts execute */export const CHILD_APP_PRELOAD_EXTERNAL_CONFIG_TOKEN = createToken<() => Promise<void>>( 'child-app preload external config'); /** * @public * @description Used to resolve resolution config for a specific child-app */export const CHILD_APP_GET_RESOLUTION_CONFIG_TOKEN = createToken< (config: ChildAppRequestConfig) => ResolutionConfig>('child-app get resolution config'); /** * @public * @description Used to resolve external config with urls to external code entries */export const CHILD_APP_RESOLVE_CONFIG_TOKEN = createToken< (config: ChildAppRequestConfig) => ChildAppFinalConfig>('child-app resolve external config'); /** * @public * @description Base url for external urls for child apps on client */export const CHILD_APP_RESOLVE_BASE_URL_TOKEN = createToken<string>( 'child-app resolve external base url'); /** * @public * @description Allows to preload child app for the specific page */export const CHILD_APP_PRELOAD_MANAGER_TOKEN = createToken<ChildAppPreloadManager>( 'child-app preload manager'); /** * @public * @description Contains child app config that was used to load current child app */export const CHILD_APP_INTERNAL_CONFIG_TOKEN = createToken<ChildAppFinalConfig>( 'child-app current config'); /** * @public * @description Actions of child app */export const CHILD_APP_INTERNAL_ACTION_TOKEN = createToken<Action>( 'child-app action', multiOptions); /** * @public * @description Subscription on a root state updates */export const CHILD_APP_INTERNAL_ROOT_STATE_SUBSCRIPTION_TOKEN = createToken<RootStateSubscription>( 'child-app root state subscription', multiOptions); /** * @public * @description Allows to recreate token implementation the same way as in root di, but specific to child-app di */export const CHILD_APP_INTERNAL_ROOT_DI_BORROW_TOKEN = createToken<any>( 'child-app root di borrow', multiOptions); /** * @private * @description boolean flag indicating that current di if for a child-app */export const IS_CHILD_APP_DI_TOKEN = createToken<boolean>('child-app isChildApp Di'); /** * @private * @description Manages Singleton-Scope DIs for every child app */export const CHILD_APP_SINGLETON_DI_MANAGER_TOKEN = createToken<ChildAppDiManager>( 'child-app singleton di manager'); /** * @private * @description Manages Request-Scope DIs for every child app */export const CHILD_APP_DI_MANAGER_TOKEN = createToken<ChildAppDiManager>('child-app di manager'); /** * @private * @description Bridge from React render to di providers for child apps */export const CHILD_APP_RENDER_MANAGER_TOKEN = createToken<ChildAppRenderManager>( 'child-app render manager'); /** * @private * @description Manages state dehydration for child-app */export const CHILD_APP_STATE_MANAGER_TOKEN = createToken<ChildAppStateManager>( 'child-app state manager'); /** * @private * @description Manages loading child-app resources from the external place */export const CHILD_APP_LOADER_TOKEN = createToken<ChildAppLoader>('child-app loader'); /** * @private * @description Implements CommandLineRunner for child apps */export const CHILD_APP_COMMAND_LINE_RUNNER_TOKEN = createToken<ChildAppCommandLineRunner>( 'child-app command runner'); /** * @private * @description Stores the common server-dehydrated state for all of child apps */export const CHILD_APP_COMMON_INITIAL_STATE_TOKEN = createToken< Record<string, typeof INITIAL_APP_STATE_TOKEN>>('child-app initialAppState'); /** * @private * @description Used as render function for a child app. Usually implemented as a wrapper over child app render itself with an additional logic for di and connections to root app */export const CHILD_APP_INTERNAL_RENDER_TOKEN = createToken<ComponentType<WrapperProps<any>>>( 'child-app render'); Скопировать","keywords":""},{"title":"Unit tests","type":0,"sectionRef":"#","url":"docs/references/test/test-unit","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#installation","content":"npm i --save-dev @tramvai/test-unit Скопировать "},{"title":"How to","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#how-to","content":""},{"title":"Testing reducers","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#testing-reducers","content":"import { testReducer } from '@tramvai/test-unit'; it('test', async () => { const { dispatch, getState } = testReducer(reducer); expect(getState()).toEqual([]); dispatch(event(1)); expect(getState()).toEqual([1]);}); Скопировать  More examples import { createEvent, createReducer } from '@tramvai/state';import { testReducer } from './testReducer'; describe('test/unit/testReducer', () => { it('should handle state change', () => { const handle = jest.fn((state: number[], payload: number) => { return [...state, payload]; }); const event = createEvent<number>('push'); const reducer = createReducer('test', [] as number[]).on(event, handle); const { dispatch, getState } = testReducer(reducer); expect(getState()).toEqual([]); expect(handle).not.toHaveBeenCalled(); dispatch(event(1)); expect(getState()).toEqual([1]); expect(handle).toHaveBeenCalledWith([], 1); dispatch(event(3)); expect(getState()).toEqual([1, 3]); expect(handle).toHaveBeenCalledWith([1], 3); }); it('should handle several tests reducers at separate', () => { const event = createEvent<number>('push'); const reducer = createReducer('test', [] as number[]).on(event, (state, payload) => { return [...state, payload]; }); const test1 = testReducer(reducer); const test2 = testReducer(reducer); expect(test1.getState()).toEqual([]); expect(test2.getState()).toEqual([]); test1.dispatch(event(1)); expect(test1.getState()).toEqual([1]); expect(test2.getState()).toEqual([]); test2.dispatch(event(2)); expect(test1.getState()).toEqual([1]); expect(test2.getState()).toEqual([2]); });}); Скопировать  "},{"title":"Testing actions","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#testing-actions","content":"import { testAction } from '@tramvai/test-unit'; it('test', async () => { const { run } = testAction(action); expect(await run(true)).toBe('hello'); expect(await run(false)).toBe('world');}); Скопировать  More examples import { createAction } from '@tramvai/core';import { createEvent } from '@tramvai/state';import { createMockContext } from '@tramvai/test-mocks';import { testAction } from './testAction'; describe('test/unit/state/testAction', () => { it('should call action', async () => { const action = createAction({ name: 'test', fn: (context, payload: boolean) => { if (payload) { return 'hello'; } return 'world'; }, }); const { run } = testAction(action); expect(await run(true)).toBe('hello'); expect(await run(false)).toBe('world'); }); it('should call action with custom context', async () => { const context = createMockContext(); const event = createEvent<string>('test'); const action = createAction({ name: 'dispatch', fn: (ctx, payload: string) => { return ctx.dispatch(event(`action${payload}`)); }, }); const spyDispatch = jest.spyOn(context, 'dispatch'); const { run } = testAction(action, { context }); await run('ping'); expect(spyDispatch).toHaveBeenCalledWith({ payload: 'actionping', type: 'test' }); await run('pong'); expect(spyDispatch).toHaveBeenCalledWith({ payload: 'actionpong', type: 'test' }); }); it('should not require payload', async () => { const action = createAction({ name: 'no-payload', fn: () => { return 'empty'; }, }); const { run } = testAction(action); await expect(run()).resolves.toBe('empty'); });}); Скопировать  "},{"title":"Testing tramvai module","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#testing-tramvai-module","content":"Testing module in isolation# import { testModule } from '@tramvai/test-unit'; it('test', async () => { const { di, module, runLine } = testModule(TestModule); expect(module).toBeInstanceOf(TestModule); expect(di.get('testToken')).toEqual({ a: 1 }); // Run only specific command line in order to execute handlers for this line inside module await runLine(commandLineListTokens.generatePage);}); Скопировать Testing module in conjunction with other modules# import { createTestApp } from '@tramvai/test-unit'; it('test', async () => { const { app } = await createTestApp({ modules: [TestModule, DependentModule] }); // get tokens from di implemented by module expect(app.di.get('testToken')).toEqual({ a: 1 });}); Скопировать  More examples import { commandLineListTokens, DI_TOKEN, Module } from '@tramvai/core';import { Container } from '@tinkoff/dippy';import { testModule } from './testModule'; describe('test/unit/module/testModule`', () => { it('should test module', () => { const mockConstructor = jest.fn(); @Module({ providers: [ { provide: 'testToken', useFactory: () => { return { a: 1 }; }, }, ], deps: { di: DI_TOKEN, optToken: { token: 'optional_token', optional: true }, }, }) class TestModule { constructor(deps: any) { mockConstructor(deps); } } const { di, module } = testModule(TestModule); expect(module).toBeInstanceOf(TestModule); expect(mockConstructor).toHaveBeenCalledWith({ di: expect.any(Container), optToken: null }); expect(di.get('testToken')).toEqual({ a: 1 }); }); it('should test command line', async () => { const mock = jest.fn(); @Module({ providers: [ { provide: commandLineListTokens.generatePage, multi: true, useFactory: () => { return mock; }, }, ], }) class TestModule {} const { runLine } = testModule(TestModule); expect(() => runLine(commandLineListTokens.customerStart)).toThrow(); expect(mock).not.toHaveBeenCalled(); await runLine(commandLineListTokens.generatePage); expect(mock).toHaveBeenCalledWith(); });}); Скопировать  "},{"title":"Testing app","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#testing-app","content":"Testing app works only in node-environment. See jest docs import { testApp } from '@tramvai/test-unit'; it('test', async () => { const { request, render } = await testApp(app); const response = await request('/').expect(200).expect('X-App-Id', 'unit-app'); expect(response.text).toMatch('<html class=\"no-js\" lang=\"ru\">'); expect(response.text).toMatch('<div class=\"application\">rootPage</div>'); expect(response.text).toMatch('<script>var initialState ='); const rootPage = await render('/'); expect(rootPage.application).toEqual('rootPage'); const secondPage = await render('/second/'); expect(secondPage.application).toEqual('secondPage'); expect(secondPage.initialState).toEqual({ stores: expect.objectContaining({ environment: { FRONT_LOG_API: 'test', }, router: expect.objectContaining({ currentUrl: expect.objectContaining({ path: '\\\\u002Fsecond\\\\u002F', }), }), }), });}); Скопировать  More examples import { NoSpaRouterModule } from '@tramvai/module-router';import { commandLineListTokens, createApp, createBundle } from '@tramvai/core';import { CommonModule, ENV_USED_TOKEN } from '@tramvai/module-common';import { LogModule } from '@tramvai/module-log';import { RenderModule } from '@tramvai/module-render';import { ServerModule } from '@tramvai/module-server';import { testApp } from './testApp'; type ThenArg<T> = T extends PromiseLike<infer U> ? U : T; const bundle = createBundle({ name: 'mainDefault', components: { pageDefault: () => 'rootPage', pageSecond: () => 'secondPage', },}); describe('test/unit/app/testApp', () => { let testEnv: ThenArg<ReturnType<typeof testApp>>; describe('normal', () => { beforeAll(async () => { const app = createApp({ name: 'unit-app', bundles: { mainDefault: () => Promise.resolve({ default: bundle }), }, modules: [ CommonModule, LogModule, RenderModule, ServerModule, NoSpaRouterModule.forRoot([ { name: 'root', path: '/', }, { name: 'other', path: '/second/', config: { pageComponent: 'pageSecond', }, }, ]), ], providers: [ { provide: ENV_USED_TOKEN, multi: true, useValue: { key: 'FRONT_LOG_API', value: 'test' }, }, ], }); testEnv = await testApp(app); }); afterAll(() => { return testEnv.close(); }); it('should request to server', async () => { const { request } = testEnv; const response = await request('/').expect(200).expect('X-App-Id', 'unit-app'); expect(response.text).toMatch('<html class=\"no-js\" lang=\"ru\">'); expect(response.text).toMatch('<div class=\"application\">rootPage</div>'); expect(response.text).toMatch('<script>var initialState ='); }); it('should return render of page', async () => { const { render } = testEnv; const rootPage = await render('/'); expect(rootPage.application).toEqual('rootPage'); const secondPage = await render('/second/'); expect(secondPage.application).toEqual('secondPage'); expect(secondPage.initialState).toEqual({ stores: expect.objectContaining({ environment: { FRONT_LOG_API: 'test', }, router: expect.objectContaining({ currentUrl: expect.objectContaining({ path: '/second/', }), }), }), }); }); it('should return mocker instance', async () => { const { mocker } = testEnv; expect(mocker).toBeDefined(); }); }); describe('fail', () => { beforeAll(async () => { const app = createApp({ name: 'unit-app', bundles: { mainDefault: () => Promise.resolve({ default: bundle }), }, modules: [CommonModule, LogModule, RenderModule, ServerModule], providers: [ { provide: commandLineListTokens.resolveUserDeps, multi: true, useFactory: ({ wrong }) => { return wrong.test(); }, deps: { wrong: '_unknown_provider', }, }, ], }); testEnv = await testApp(app); }); afterAll(() => { return testEnv.close(); }); it('render with 500 status should fail', async () => { const { render } = testEnv; await expect(render('/')).rejects.toThrowError( 'Error: Token not found &quot;_unknown_provider&quot; at &quot;resolve_user_deps&quot;' ); }); });}); Скопировать  "},{"title":"Adding providers to DI","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#adding-providers-to-di","content":"Most of the helpers accepts option providers which allows to redefine already existing providers or add new. For example, passing providers to helper testAction allows to access this provider inside action itself: import { createAction } from '@tramvai/core';import { testAction } from '@tramvai/test-unit'; const action = createAction({ name: 'action', fn: (_, __, { test }) => { console.log(test); // token value }, deps: { test: 'token name', },}); it('test', async () => { const { run } = testAction(action, { providers: [ { provide: 'token name', useValue: 'token value', }, ], });}); Скопировать "},{"title":"Create app only for testing","type":1,"pageTitle":"Unit tests","url":"docs/references/test/test-unit#create-app-only-for-testing","content":"import { createTestApp } from '@tramvai/test-unit'; it('test', async () => { const { app } = await createTestApp({ modules: [TestModule, DependentModule] }); // get tokens from di implemented by module expect(app.di.get('testToken')).toEqual({ a: 1 });}); Скопировать  More examples import http from 'http';import { ENV_MANAGER_TOKEN } from '@tramvai/tokens-common';import { SERVER_TOKEN } from '@tramvai/tokens-server';import { CommonModule } from '@tramvai/module-common';import { createTestApp } from './createTestApp'; describe('test/unit/app/createTestApp', () => { it('should return app', async () => { const { app, close } = await createTestApp(); const envManager = app.di.get(ENV_MANAGER_TOKEN); expect(envManager.get('FRONT_LOG_API')).toBe('test'); expect(envManager.get('TEST_ENV')).toBeUndefined(); expect(app.di.get(SERVER_TOKEN)).toBeInstanceOf(http.Server); return close(); }); it('should specify env', async () => { const { app, close } = await createTestApp({ env: { TEST_ENV: '1234', }, }); const envManager = app.di.get(ENV_MANAGER_TOKEN); expect(envManager.get('FRONT_LOG_API')).toBe('test'); expect(envManager.get('TEST_ENV')).toBe('1234'); return close(); }); it('should ignore default modules', async () => { const { app } = await createTestApp({ excludeDefaultModules: true, modules: [CommonModule], }); expect(() => app.di.get(SERVER_TOKEN)).toThrow('Token not found'); }); it('should return mocker instance', async () => { const { mocker, close } = await createTestApp(); expect(mocker).toBeDefined(); return close(); });}); Скопировать  "},{"title":"http-client-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/http-client-tokens","content":"","keywords":""},{"title":"Tokens","type":1,"pageTitle":"http-client-tokens","url":"docs/references/tokens/http-client-tokens#tokens","content":" import { createToken } from '@tinkoff/dippy';import type { ApiService, HttpClient } from '@tramvai/http-client';import type { TinkoffRequestOptions, Agent } from '@tramvai/tinkoff-request-http-client-adapter'; export type HttpClientFactoryOptions = TinkoffRequestOptions & { name: string }; /** * @description * Factory of HTTP clients with minimal base settings */export const HTTP_CLIENT_FACTORY = createToken<(options: HttpClientFactoryOptions) => HttpClient>( 'HTTP_CLIENT_FACTORY'); /** * @description * Universal HTTP client for arbitrary requests */export const HTTP_CLIENT = createToken<HttpClient>('HTTP_CLIENT'); /** * @description * Global HTTP and HTTPS agents for all clients * https://nodejs.org/dist/latest-v16.x/docs/api/http.html#class-httpagent */export const HTTP_CLIENT_AGENT = createToken<{ http: Agent; https: Agent;}>('HTTP_CLIENT_AGENT'); /** * @description * List of HTTP headers that are proxied from app request to all of the backend API */export const API_CLIENT_PASS_HEADERS = createToken<string[]>('apiClientPassHeaders', { multi: true,}); /** * @description * Internal api for app server. * Uses the value of `APP_INFO_TOKEN` from di for constructing the request address */export const PAPI_SERVICE = createToken<ApiService>('papi service'); Скопировать  "},{"title":"metrics-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/metrics-tokens","content":"","keywords":""},{"title":"Tokens list","type":1,"pageTitle":"metrics-tokens","url":"docs/references/tokens/metrics-tokens#tokens-list","content":" import { createToken } from '@tinkoff/dippy';import type { Counter, CounterConfiguration, Gauge, GaugeConfiguration, Histogram, HistogramConfiguration, Summary, SummaryConfiguration,} from 'prom-client'; interface Metrics { counter<T extends string = string>(opt: CounterConfiguration<T>): Counter<T>; gauge<T extends string = string>(opt: GaugeConfiguration<T>): Gauge<T>; histogram<T extends string = string>(opt: HistogramConfiguration<T>): Histogram<T>; summary<T extends string = string>(opt: SummaryConfiguration<T>): Summary<T>;} export { Counter, Gauge, Histogram, Summary, Metrics }; /** * @description * Metric module implementation */export const METRICS_MODULE_TOKEN = createToken<Metrics>('metricsModule'); export interface MetricsServicesRegistryInterface { register(url: string, serviceName: string): void; registerEnv(env: Record<string, unknown>): void; getServiceName(url: string): string | void;} /** * @description * Utility for pointing out to metric module which service name to set for different requests */export const METRICS_SERVICES_REGISTRY_TOKEN = createToken<MetricsServicesRegistryInterface>( 'metricsServicesRegistry'); /** * @description * Token for registering counter metric which can be incremented with POST papi request */export const REGISTER_INSTANT_METRIC_TOKEN = createToken<[string, Counter<string>]>( 'registerInstantMetric'); Скопировать  "},{"title":"common-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/common-tokens","content":"","keywords":""},{"title":"Action tokens","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#action-tokens","content":" import { createToken } from '@tinkoff/dippy';import type { Action } from '@tramvai/core'; /** * @description * Registry for storing actions based on their type */export const ACTION_REGISTRY_TOKEN = createToken<ActionsRegistry>('actionRegistry'); /** * @description * Instance that executes actions */export const ACTION_EXECUTION_TOKEN = createToken<ActionExecution>('actionExecution'); /** * @description * Instance that executes actions on navigations */export const ACTION_PAGE_RUNNER_TOKEN = createToken<ActionPageRunner>('actionPageRunner'); /** * @description * Conditions that specify should action be executing or not */export const ACTION_CONDITIONALS = createToken<ActionCondition[]>('actionConditionals', { multi: true,}); export interface ActionsRegistry { add(type: string, actions: Action | Action[]): void; get(type: string, addingActions?: Action[]): Action[]; getGlobal(): Action[]; remove(type: string, actions?: Action | Action[]): void;} export interface ActionExecution { execution: Map<string, any[]>; run(action: Action, payload: any): Promise<any>;} export interface ActionPageRunner { runActions(actions: Action[], stopRunAtError?: (error: Error) => boolean): Promise<any>;} export interface ActionConditionChecker<State = any> { payload: any; parameters: any; conditions: Record<string, any>; type: 'global' | 'local'; allow(): void; setState(value: State): void; getState(): State; forbid(): void;} export type ActionCondition = { key: string; fn: (checker: ActionConditionChecker) => void;}; Скопировать  "},{"title":"Bundle tokens","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#bundle-tokens","content":" import { createToken } from '@tinkoff/dippy';import type { Bundle } from '@tramvai/core'; /** * @description * Bundle Storage. When getting bundle additionally adds actions and components from bundle to according storages */export const BUNDLE_MANAGER_TOKEN = createToken<BundleManager>('bundleManager'); /** * @description * Provides additional bundles to the app. * Important! This token doesn't overrides already existing bundles. */export const ADDITIONAL_BUNDLE_TOKEN = createToken<{ [key: string]: Bundle }>('additional bundle', { multi: true,}); export interface BundleManager { bundles: Record<string, any>; get(name: string, pageComponent: string): Promise<any>; has(name: string, pageComponent: string): boolean;} Скопировать  "},{"title":"ComponentRegistry tokens","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#componentregistry-tokens","content":" import type { ComponentType } from 'react';import { createToken } from '@tinkoff/dippy';import type { Action } from '@tramvai/core'; export interface RegistryComponentExtend { redirects?: any; actions?: Action[];} export type Component = ComponentType & RegistryComponentExtend; /** * @description * React components storage. * Components in the repository are divided into groups, e.g. you can specify a bundle or a page component as a group key. * The entity also allows you to get static component parameters through the `getComponentParam` method (will not work with `lazy` components) */export const COMPONENT_REGISTRY_TOKEN = createToken<ComponentRegistry>('componentRegistry'); export interface ComponentRegistry { components: Record<string, Component>; add(name: string, component: Component, group?: string): void; get(name: string, group?: string): Component; getComponentParam<T>(param: string, defaultValue: T, component: string, group?: string): T;} Скопировать  "},{"title":"Env tokens","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#env-tokens","content":" import { createToken } from '@tinkoff/dippy'; export interface EnvironmentManager { get(name: string): string; getInt(name: string, def: number): number; getAll(): Record<string, string>; update(result: Record<string, string>): void; clientUsed(): Record<string, string>; updateClientUsed(result: Record<string, string>): void;} /** * @description * Instance that used for managing env data on the server and on the client */export const ENV_MANAGER_TOKEN = createToken<EnvironmentManager>('environmentManager'); /** * @description * List of envs that are used by the module or the app. * All of the envs specified by that token will be accessible in the code through `environmentManager` * ENV_USED_TOKEN format: - `key` - id of the env. At that id the value of the env will be accessible through `environmentManager` and will be loaded from the external sources. - `value` - default low-priority value for env `key` - `optional` - is current env is optional. If `true` the app can work as usual event if the env value were not provided, if `false` - the app will fail to run without env value - `validator` - validation function for passed env value. In case this function returns string it will be used as error message and validation will fail - `dehydrate` - if `false` then env value will not be passed to client and this env can be used only on server * * @example ```tsx interface EnvParameter { key: string; value?: string; optional?: boolean; validator?: (value: string) => boolean | string; dehydrate?: boolean; } ``` */export interface EnvParameter { key: string; value?: string; optional?: boolean; validator?: (value: string) => boolean | string; dehydrate?: boolean;} export const ENV_USED_TOKEN = createToken<EnvParameter[]>('envUsed', { multi: true }); Скопировать  "},{"title":"Context tokens","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#context-tokens","content":" import type { Container } from '@tinkoff/dippy';import { createToken } from '@tinkoff/dippy';import type { ConsumerContext as BaseConsumerContext } from '@tramvai/types-actions-state-context';import type { PUBSUB_TOKEN } from './pubsub'; export { PlatformAction } from '@tramvai/types-actions-state-context'; /** * @description * Context implementation */export const CONTEXT_TOKEN = createToken<ConsumerContext>('context'); export interface ConsumerContext extends BaseConsumerContext { readonly di: Container; readonly pubsub: typeof PUBSUB_TOKEN; dehydrate: () => { dispatcher: { stores: Record<string, any>; }; };} Скопировать  "},{"title":"Hook tokens","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#hook-tokens","content":" import { createToken } from '@tinkoff/dippy'; /** * @description * [Hooks documentation](https://tramvai.dev/docs/references/libs/hooks) */export const HOOK_TOKEN = createToken<Hooks>('hooks'); type Hook<TPayload> = (context: any, payload?: TPayload, options?: any) => TPayload; export interface Hooks { /** * Register hooks */ registerHooks<TPayload>(name: string, list: Hook<TPayload>[] | Hook<TPayload>): void; /** * Run sync hook */ runHooks<TPayload>(name: string, context: any, payload?: TPayload, options?: any): TPayload; /** * Run async hooksЗапуск ассихронных хуков */ runAsyncHooks<TPayload>(name: string, context: any, payload: TPayload, options?: any): TPayload; /** * Run promise hooks */ runPromiseHooks( name: string, context: any, options?: any ): <TPayload>(payload: TPayload) => Promise<TPayload> | Promise<never>;} Скопировать  "},{"title":"Logger tokens","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#logger-tokens","content":" import type { Logger } from '@tinkoff/logger';import { createToken } from '@tinkoff/dippy'; /** * @description * Logger implementation */export const LOGGER_TOKEN = createToken<LoggerFactory>('logger'); /** * @description * Hook to be able to modify logger on initialization */export const LOGGER_INIT_HOOK = createToken<LoggerInitHook>('loggerHook'); type Config = { name: string; [key: string]: any;}; export type LoggerFactory = Logger & ((configOrName: string | Config) => Logger); type LoggerInitHook = (logger: LoggerFactory) => void; export type { Logger, LogFn, LogArg } from '@tinkoff/logger'; Скопировать  "},{"title":"Pubsub tokens","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#pubsub-tokens","content":" import { createToken } from '@tinkoff/dippy'; /** * @description * Factory for creating pubsub instances */export const PUBSUB_FACTORY_TOKEN = createToken<() => PubSub>('pubsubFactory'); /** * @description * Singleton pubsub instance */export const PUBSUB_TOKEN = createToken<PubSub>('pubsub'); /** * @description * Request pubsub instance that is created for every client */export const ROOT_PUBSUB_TOKEN = createToken<PubSub>('rootPubsub'); export interface PubSub { subscribe(event: string, fn: (payload?: any) => void): () => boolean; publish(event: string, ...args: unknown[]): any;} Скопировать  "},{"title":"RequestManager tokens","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#requestmanager-tokens","content":" import { createToken } from '@tinkoff/dippy';import type { Request } from 'express'; // HACK: to prevent inlining of Request and providing internal express dependencies to outsidetype RequestExt = Request;/** * @description * Direct reference to request object */export const REQUEST = createToken<RequestExt>('request'); /** * @description * Instance for managing client requests (request headers, query-parameters, cookies etc). * Mostly used on server, but has partial functional for browser for simplification build isomorphic app */export const REQUEST_MANAGER_TOKEN = createToken<RequestManager>('requestManager'); export interface RequestManager { getBody(): unknown; getUrl(): string; getMethod(): string; getCookie(key: string): string; getCookies(): Record<string, string>; getHeader(key: string): string | string[]; getHeaders(): Record<string, string | string[]>; getClientIp(): string; getHost(): string;} Скопировать  "},{"title":"ResponseManager tokens","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#responsemanager-tokens","content":" import { createToken } from '@tinkoff/dippy';import type { Response } from 'express'; /** * @description * Direct reference to Response instance */export const RESPONSE = createToken<Response>('response'); /** * @description * Instance for managing client response (response headers, cookies, response body). * Mostly used on server, but has partial functional for browser for simplification build isomorphic app */export const RESPONSE_MANAGER_TOKEN = createToken<ResponseManager>('responseManager'); export interface ResponseManager { getBody(): string; setBody(value: string): void; getHeader(key: string): string | string[]; getHeaders(): Record<string, string | string[]>; setHeader(key: string, value: string): void; getCookie(key: string): string; getCookies(): Record<string, string>; setCookie(key: string, value: string): void; getStatus(): number; setStatus(status: number): void;} Скопировать  "},{"title":"State tokens","type":1,"pageTitle":"common-tokens","url":"docs/references/tokens/common-tokens#state-tokens","content":" import { createToken } from '@tinkoff/dippy';import type { DispatcherContext, Event, Middleware, Reducer } from '@tramvai/state'; /** * @description * dispatcher implementation * Реализация dispatcher */export const DISPATCHER_TOKEN = createToken('dispatcher'); /** * @description * dispatcher context implementation */export const DISPATCHER_CONTEXT_TOKEN = createToken<DispatcherContext<any>>('dispatcherContext'); /** * @description * Token for adding stores that were created with createReducer */export const COMBINE_REDUCERS = createToken('combineReducers', { multi: true }); /** * @description * Common app store */export const STORE_TOKEN = createToken<Store>('store'); /** * @description * Custom middlewares for working with store state */export const STORE_MIDDLEWARE = createToken<Middleware>('storeMiddleware', { multi: true }); /** * @description * Начальное состояние для клиента */export const INITIAL_APP_STATE_TOKEN = createToken<{ stores: Record<string, any> }>( 'initialAppState'); export interface Store<State = Record<string, any>> { dispatch: <Payload>(actionOrNameEvent: string | Event<Payload>, payload?: Payload) => Payload; subscribe(callback: (state: Record<string, any>) => void): () => void; subscribe<S>(reducer: Reducer<S>, callback: (state: S) => void): () => void; getState(): State; getState<S>(reducer: Reducer<S>): S;} Скопировать  "},{"title":"render-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/render-tokens","content":"","keywords":""},{"title":"Список токенов","type":1,"pageTitle":"render-tokens","url":"docs/references/tokens/render-tokens#список-токенов","content":" import type { ReactElement, ComponentType } from 'react';import { createToken } from '@tinkoff/dippy';import { StorageRecord } from '@tinkoff/htmlpagebuilder';import * as ResourceSlot from './slots'; /** * @description * Token adding resources to specific render slots. * Used only on server and it is equivalent to usage of RESOURCES_REGISTRY. * * [Usage example](https://tramvai.dev/docs/how-to/render-add-resources) */export const RENDER_SLOTS = createToken<PageResource | PageResource[]>('RENDER_SLOTS', { multi: true,}); /** * @description * Token for defining additional attributes for html, body and app container. Keep in mind that: * - only raw html attributes are allowed (not react or anything else, e.g. do not use className use class) * - new attributes overrides old one * - only text values are supported * * @example ```tsx { provide: HTML_ATTRS, useValue: { target: 'body', attrs: { class: 'custom-class', }, }, multi: true, }, ``` */export const HTML_ATTRS = createToken<HtmlAttrs>('HTML_ATTRS', { multi: true }); /** * @description * Add node-style callback on render event in browser. * Passes error instance as first argument if there was an error */export const RENDERER_CALLBACK = createToken<((e?: Error) => void)[]>('RENDERER_CALLBACK', { multi: true,}); /** * @description * Used as async function which overrides app render. This function may define render parameters or override render result. */export const CUSTOM_RENDER = createToken<(content: JSX.Element) => Promise<string>>( 'CUSTOM_RENDER'); /** * @description * Resources registry is used only on server for registering any additional assets for browser (scripts, styles, html) which should be added to response html page */export const RESOURCES_REGISTRY = createToken<ResourcesRegistry>('resourcesRegistry'); /** * @description * A string used for check of need to loading polyfills in the client browser. * Polyfills are always loading for browsers without module support and if browser do support modules * this check will called in order to find out the need of loading polyfills * (by default checks for Promise.prototype.finally and implementations for URL and URLSearchParams) * * [Polyfill documentation](https://tramvai.dev/docs/how-to/how-to-enable-polyfills) */export const POLYFILL_CONDITION = createToken<string>('POLYFILL_CONDITION'); /** * @description * Allows to specify different modes for React Render - `strict`, `blocking`, `concurrent`, by default value `legacy` is used * * [More details in doc for module-render](https://tramvai.dev/docs/references/modules/render) */export const RENDER_MODE = createToken<RenderMode>('RENDER_MODE'); /** * @description * A wrapper for app render. * Through that token is possible to specify for example React.Context.Provider for the app */export const EXTEND_RENDER = createToken<Array<(current: ReactElement) => ReactElement>>( 'EXTEND_RENDER', { multi: true, }); /** * @description * Token for default layout for page */export const DEFAULT_LAYOUT_COMPONENT = createToken('defaultLayoutComponent'); /** * @description * Token for default header for page */export const DEFAULT_HEADER_COMPONENT = createToken('defaultHeaderComponent'); /** * @description * Token for default footer for page */export const DEFAULT_FOOTER_COMPONENT = createToken('defaultFooterComponent'); /** * @description * Token for passing parameters for page layout */export const LAYOUT_OPTIONS = createToken<LayoutOptions[]>('layoutOptions', { multi: true }); type ReactComponent = ComponentType<any>; type Wrapper = (WrappedComponent: ReactComponent) => ReactComponent; export interface LayoutOptions { components?: Record<string, ReactComponent>; wrappers?: Record<string, Wrapper | Wrapper[]>;} export interface PageResource { type: keyof typeof StorageRecord; slot: typeof ResourceSlot[keyof typeof ResourceSlot]; payload: string | null; attrs?: Record<string, string | null>;} export interface ResourcesRegistry { register(resource: PageResource | PageResource[]): void; getPageResources(): PageResource[];} export type HtmlAttrs = { target: 'html' | 'body' | 'app'; attrs: { [name: string]: string | boolean | Record<string, any> | number };}; export type RenderMode = 'legacy' | 'strict' | 'blocking' | 'concurrent'; type ResourceInlineOptions = { threshold: number; types: (keyof typeof StorageRecord)[];}; /** * @description * Settings for HTML resources inlining * * threshold Maximum value (in bytes) of the file which are getting inlined in HTML page * * types Types of resources which should be inlined */export const RESOURCE_INLINE_OPTIONS = createToken<ResourceInlineOptions>( 'resourceInlineThreshold'); export { ResourceSlot };export { StorageRecord as ResourceType }; Скопировать  "},{"title":"Render slots","type":1,"pageTitle":"render-tokens","url":"docs/references/tokens/render-tokens#render-slots","content":" export const HEAD_META = 'head:meta';export const HEAD_PERFORMANCE = 'head:performance';export const HEAD_CORE_STYLES = 'head:core-styles';export const HEAD_POLYFILLS = 'head:polyfills';export const HEAD_CORE_SCRIPTS = 'head:core-scripts';export const HEAD_DYNAMIC_SCRIPTS = 'head:dynamic-scripts';export const HEAD_ANALYTICS = 'head:analytics';export const HEAD_ICONS = 'head:icons';export const BODY_START = 'body:start';export const REACT_RENDER = 'react:render';export const BODY_END = 'body:end';export const BODY_TAIL_ANALYTICS = 'body:tail:analytics';export const BODY_TAIL = 'body:tail'; Скопировать  "},{"title":"router-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/router-tokens","content":"","keywords":""},{"title":"Tokens","type":1,"pageTitle":"router-tokens","url":"docs/references/tokens/router-tokens#tokens","content":" import { createToken } from '@tinkoff/dippy';import type { AbstractRouter, NavigationGuard, Route, Navigation, NavigationRoute, NavigateOptions, UpdateCurrentRouteOptions, HistoryOptions,} from '@tinkoff/router';import type { Component } from '@tramvai/tokens-common'; /** * @description * Token to access the router instance */export const ROUTER_TOKEN = createToken<AbstractRouter>('router router'); /** * @description * Token for defining static routes */export const ROUTES_TOKEN = createToken<Route>('router routes', { multi: true });/** * @description * Token for providing guard handlers for page transitions */export const ROUTER_GUARD_TOKEN = createToken<NavigationGuard>('router guard', { multi: true }); /** * @description * Encapsulates the logic of working with the router - contains methods for getting the configuration of the route and performing navigation */export const PAGE_SERVICE_TOKEN = createToken<PageService>('router pageService'); /** * @description * Hook to resolve route dynamically */export const ROUTE_RESOLVE_TOKEN = createToken<RouteResolve>('router routeResolve'); /** * @description * Hook to transform route config */export const ROUTE_TRANSFORM_TOKEN = createToken<RouteTransform>('router routeTransform', { multi: true,}); /** * @description * Flag for SPA-transitions, indicating that actions must be executed before or after a route update in the stor */export const ROUTER_SPA_ACTIONS_RUN_MODE_TOKEN = createToken<'before' | 'after'>( 'router spaRunMode'); export interface PageService { getCurrentRoute(): NavigationRoute; getCurrentUrl(): ReturnType<AbstractRouter['getCurrentUrl']>; getConfig(): Route['config']; getContent(): Record<string, any>; getMeta(): { seo: Record<string, string>; analytics: Record<string, string> }; navigate(options: string | NavigateOptions): Promise<void>; updateCurrentRoute(options: UpdateCurrentRouteOptions): Promise<void>; back(options?: HistoryOptions): Promise<void>; forward(): Promise<void>; go(to: number, options?: HistoryOptions): Promise<void>; addComponent(name: string, component: Component): void; getComponent(name: string): Component; resolveComponentFromConfig(property: 'page' | 'layout' | 'header' | 'footer'): Component;} export type RouteResolve = (navigation: Navigation) => Promise<Route | void>; export type RouteTransform = (route: Route) => Route; Скопировать  "},{"title":"server-tokens","type":0,"sectionRef":"#","url":"docs/references/tokens/server-tokens","content":"","keywords":""},{"title":"Tokens","type":1,"pageTitle":"server-tokens","url":"docs/references/tokens/server-tokens#tokens","content":" import type { Server } from 'http';import type { Application } from 'express';import { createToken } from '@tinkoff/dippy';import type { Papi } from '@tramvai/papi'; /** * @description * Specifies base url for public papi handlers. By default equals to `/[appName]/papi` */export const SERVER_MODULE_PAPI_PUBLIC_URL = createToken<string>('serverModulePapiPublicUrl'); /** * @description * Specifies base url for private papi handlers. By default equals `/[appName]/private/papi` */export const SERVER_MODULE_PAPI_PRIVATE_URL = createToken<string>('serverModulePapiPrivateUrl'); /** * @description * Add private papi route */export const SERVER_MODULE_PAPI_PRIVATE_ROUTE = createToken<Papi>('serverModulePapiPrivateRoute', { multi: true,}); /** * @description * Add public papi route */export const SERVER_MODULE_PAPI_PUBLIC_ROUTE = createToken<Papi>('serverModulePapiPublicRoute', { multi: true,}); /** * @description * Settings for the static server */export const SERVER_MODULE_STATICS_OPTIONS = createToken<ServerModuleStaticsOptions>( 'serverModuleStaticsOptions'); /** * @description * Instance of nodejs `http.Server`. * Can be used for adding custom logic on server, like error handling, connection settings * * @example ```tsx { provide: commandLineListTokens.init, multi: true, useFactory: ({ server }) => { return function serverListen() { createTerminus(server, {}); }; }, deps: { SERVER_TOKEN, }, }, ``` */export const SERVER_TOKEN = createToken<Server>('server'); /** * @description * Instance of the current server app. By default it is an `express` app. * Can be used to setup custom request handler and add custom routes * * @example ```tsx { provide: SERVER_TOKEN, useFactory: ({ webApp }) => { const server = https.createServer(); server.on('request', webApp); return server; }, deps: { WEB_APP_TOKEN, } } ``` */export const WEB_APP_TOKEN = createToken<Application>('webApp'); /** * @description * Subscription to before web-app initialization. It is called before any standard handlers. * * @example ```tsx { provide: WEB_APP_BEFORE_INIT_TOKEN, multi: true, useValue: (app) => { app.use(cookieParser()) } } ``` */export const WEB_APP_BEFORE_INIT_TOKEN = createToken<APP_INIT_HANDLER>('webAppBeforeInit', { multi: true,}); /** * @description * Subscription to web-app initialization. * It is called after global request handlers but before handlers for page rendering * * @example ```tsx { provide: WEB_APP_INIT_TOKEN, multi: true, useValue: (app) => { app.use('mm.css', proxyCss()); app.use('mm.js', proxyClientJs()); } } ``` */export const WEB_APP_INIT_TOKEN = createToken<APP_INIT_HANDLER>('webAppInit', { multi: true }); /** * @description * Subscription to after web-app initialization. * It is called after any other handlers * * @example ```tsx { provide: WEB_APP_AFTER_INIT_TOKEN, multi: true, useValue: (app) => { app.use(logMiddleware()) } } ``` */export const WEB_APP_AFTER_INIT_TOKEN = createToken<APP_INIT_HANDLER>('webAppAfterInit', { multi: true,}); /** * @description * Add resources for request proxying to the app through `http-proxy-middleware` */export const PROXY_CONFIG_TOKEN = createToken<ProxyConfig[]>('proxyConfigToken', { multi: true,}); /** * @description * Override filter function when accessing papi route `/dependenciesVersion` */export const DEPENDENCIES_VERSION_FILTER_TOKEN = createToken<DepsFilter>( 'dependenciesVersionFilter'); /** * @description * List of the special URLs on server (e.g. healthz and readyz) * Url matching is happens with a library `path-to-regexp`. */export const SPECIAL_SERVER_PATHS = createToken<string>('specialServerPaths', { multi: true }); export interface ServerModuleStaticsOptions { path: string;} export type APP_INIT_HANDLER = Array<(app?: Application) => Promise<never> | never>; export type ProxyConfig = | { [key: string]: | string | { target: string; [key: string]: any; }; } | { context: string | string[]; target: string; [key: string]: any; }; export type DepsFilter = ( deps: Record<string, string>) => Record<string, string> | Promise<Record<string, string>>; Скопировать  "},{"title":"@tramvai/tools-check-versions","type":0,"sectionRef":"#","url":"docs/references/tools/check-versions","content":"","keywords":""},{"title":"Prerelease версии","type":1,"pageTitle":"@tramvai/tools-check-versions","url":"docs/references/tools/check-versions#prerelease-версии","content":"Инструмент позволяет устанавливать prerelease версии tramvai зависимостей для тестирования нового функционала, пример валидного списка зависимостей: \"dependencies\": { \"@tramvai/core\": \"0.5.0-rc.2\", // release candidate версия, выше по SemVer чем остальные зависимости, ошибок не будет \"@tramvai/module-common\": \"0.4.2\", \"@tramvai/module-router\": \"0.4.2\", \"@tramvai/state\": \"0.4.2\",} Скопировать "},{"title":"Паттерны связанных зависимостей","type":1,"pageTitle":"@tramvai/tools-check-versions","url":"docs/references/tools/check-versions#паттерны-связанных-зависимостей","content":"/^@tramvai\\/core$//^@tramvai\\/module-//^@tramvai-tinkoff\\/module-//^@tramvai\\/tokens-/ "},{"title":"@tramvai/tools-migrate","type":0,"sectionRef":"#","url":"docs/references/tools/migrate","content":"","keywords":""},{"title":"Отключение выполнения миграций","type":1,"pageTitle":"@tramvai/tools-migrate","url":"docs/references/tools/migrate#отключение-выполнения-миграций","content":"Для отключения миграций можно проставить переменную окружения SKIP_TRAMVAI_MIGRATIONS. "},{"title":"Добавление новой миграции","type":1,"pageTitle":"@tramvai/tools-migrate","url":"docs/references/tools/migrate#добавление-новой-миграции","content":"Добавить новую миграцию можно с помощью команды yarn generate:migration после чего потребуется указать имя пакета для которого предназначена миграция и имя новой миграции. Также для этого пакета потребуется добавить в package.json в поле files папку с собранными миграциями, если они не были указаны ранее: \"files\": [ \"lib\", \"__migrations__\"], Скопировать "},{"title":"Реализация миграции","type":1,"pageTitle":"@tramvai/tools-migrate","url":"docs/references/tools/migrate#реализация-миграции","content":"Миграция представляет собой функцию, принимающую специальное апи с помощью которого можно осуществлять изменения кода или конфигов. export interface Api { packageJSON: PackageJSON; // объект-представление корневого package.json tramvaiJSON: TramvaiJSON; // объект-представление файла tramvai.json или platform.json transform: (transformer: Transform, pathTransformer?: PathTransformer) => Promise<void>; // функция принимающая функцию-траснформер для jscodeshift и функцию-трансформер для переименования файлов} Скопировать Трансформация кода осуществляется с помощью jscodeshift "},{"title":"How to","type":1,"pageTitle":"@tramvai/tools-migrate","url":"docs/references/tools/migrate#how-to","content":""},{"title":"Write migration","type":1,"pageTitle":"@tramvai/tools-migrate","url":"docs/references/tools/migrate#write-migration","content":"Transformation# Rules: Prefer to return null | undefined or original source from the transform function in cases when migration doesn't change source code. Otherwise it will lead to unnecessary fs writing.Prefer to use embedded methods of collections returned by call j(source) to make searches and transforms "},{"title":"@tramvai/build","type":0,"sectionRef":"#","url":"docs/references/tools/build","content":"","keywords":""},{"title":"Подключение","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#подключение","content":"Необходимо установить @tramvai/build: yarn add @tramvai/build Скопировать Заполнить необходимые поля в package.json: { \"main\": \"lib/index.js\", \"typings\": \"src/index.ts\"} Скопировать \"main\": \"lib/index.js\" на основе этого поля вычисляется, что точка входа для сборки должна называться \"src/index.ts\" \"typings\": \"src/index.ts\" желательно должен указывать на точку входа, это удобно для монореп, т.к. не требует сборки пакета для его использования в других пакетах. После сборки для публикации это поле заменится на файл с собранными типами, в данном случае - \"typings\": \"lib/index.d.ts\" И в tsconfig.json: { \"compilerOptions\": { \"moduleResolution\": \"node\", \"target\": \"ES5\", \"module\": \"CommonJS\", \"declaration\": true, \"importHelpers\": true, \"skipLibCheck\": true, \"rootDir\": \"./src\", \"outDir\": \"./lib\", \"declarationDir\": \"./lib\" }, \"include\": [ \"./src\" ]} Скопировать Добавить в dependencies библиотеку tslib: yarn add tslib Скопировать Собрать пакет через команду tramvai-build: tramvai-build --forPublish Скопировать с флагом --forPublish tramvai-build заменяет некоторые поля в package.json на необходимые для корректного использования библиотеки в приложениях, например \"typings\": \"src/index.ts\" заменяется на \"typings\": \"lib/index.d.ts\" "},{"title":"Explanation","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#explanation","content":"Основное предназначение библиотеки - эффективная production сборка TypeScript пакетов с помощью rollup, также поддерживается watch режим. Такие сборки, особенно при наличии большого количества пакетов в монорепозитории, могут занимать слишком много времени, и не подойдут для эффективной и удобной разработки. По этой причине, для development окружения рекомендуется использовать tsc, с фичами project references и incremental build. Рекомендуемый и автоматически генерируемый package.json для @tramvai/build позволяет приложениям использовать пакеты собранные и через tsc, и через @tramvai/build, без дополнительных действий. Все собранные бандлы содержат код стандарта ES2019, ожидается то их будет резолвить бандлер (Webpac, etc.), для которого уже настроена транспиляция через babel пакетов в node_modules, написанных на современном JS, в код стандарта ES5. "},{"title":"Бандл под NodeJS в CommonJS формате","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#бандл-под-nodejs-в-commonjs-формате","content":"NodeJS до 12 версии не поддерживает ES модули, либо поддерживает их под специальным флагом.@tramvai/build генерирует бандл с кодом стандарта ES2019, в формате CommonJS, автоматически, название итогового бандла берется из поля main в package.json, например lib/index.js. При сборке нашего пакета в приложении через webpack с опцией target: 'node', этот бандл скорее всего не будет использован, т.к. в приоритете будет бандл из поля module. Ожидается, что этот бандл, из поля \"main\", будет резолвить только NodeJS, а бандлеры (Webpac, etc.) предпочтут бандл из поля \"module\" "},{"title":"Бандл под бандлеры (Webpack, etc.) в формате ES modules","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#бандл-под-бандлеры-webpack-etc-в-формате-es-modules","content":"Современные бандлеры (Webpac, etc.) поддерживают ES модули, и нестандартное поле \"module\" в package.json.@tramvai/build генерирует бандл с кодом стандарта ES2019, в формате ES modules, автоматически, название итогового бандла вычисляется из поля main в package.json, и добавляется суффикс .es например lib/index.es.js. Если сборка произведена через tramvai-build --forPublish, в package.json добавится поле \"module\": \"lib/index.es.js\". При сборке нашего пакета в приложении через webpack с опцией target: 'node', бандл из поля module будет иметь больший приоритет, чем поле main. Генерируется код стандарта ES2019, т.к. ожидается, что этот бандл, из поля \"module\", будут резолвить бандлер (Webpac, etc.), для которого уже настроена транспиляция через babel пакетов в node_modules, написанных на современном JS, в код стандарта ES5. Почему мы не советуем оставлять ES2019 код? Оказалось, что код в ES5 работает заметно быстрее на NodeJS сервере. При этом, размер итогового бандла на сервере не имеет значения. "},{"title":"Бандл для браузеров","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#бандл-для-браузеров","content":"Современные бандлеры (Webpac, etc.) поддерживают ES модули, и нестандартное поле \"browser\" в package.json. При наличии поля browser в package.json, @tramvai/build генерирует бандл с кодом стандарта ES2019, в формате ES modules. Если поле browser в package.json является строкой, то из этого файла вычисляется точка входа для browser бандла, и его новое название. Например, при \"browser\": \"lib/browser.js\", точкой входа будет src/browser.ts, а бандл будет называться lib/browser.js. Иначе, если поле browser является объектом и сборка произведена через tramvai-build --forPublish, название вычисляется из поля main в package.json, и добавляется суффикс .browser, например lib/index.browser.js. Далее в поле browser добавится свойство, указывающее сборщикам приложений, какой бандл резолвить для браузерной сборки, вместо поля module: { \"browser\": { ..., \"./index.es.js\": \"./index.browser.js\" }} Скопировать Спецификация поля browserГенерируется код стандарта ES2019, т.к. ожидается, что этот бандл, из поля \"browser\", будут резолвить бандлер (Webpac, etc.), для которого уже настроена транспиляция через babel пакетов в node_modules, написанных на современном JS, в код согласно актуальному browserslist конфигу. При сборке нашего пакета в приложении через webpack с опцией target: 'web', бандл из поля browser будет иметь больший приоритет, чем поле module. "},{"title":"Копирование статических файлов","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#копирование-статических-файлов","content":"При каждом билде автоматически копируются все файлы, кроме JS/TS скриптов и JSON, например CSS, изображения, шрифты, и сохраняются исходные пути до файлов (src/css/style.css -> lib/css/style.css). Копирование можно отключить, собирая пакет с флагом copyStaticAssets: tramvai-build --copyStaticAssets false Скопировать "},{"title":"Сборка и копирование миграций","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#сборка-и-копирование-миграций","content":"При наличии файлов в папке migrations, они считаются исходниками миграций. Эти файлы компилируются в .js и копируются в папку __migrations__. "},{"title":"CLI","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#cli","content":""},{"title":"Разовая сборка","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#разовая-сборка","content":"tramvai-build Скопировать "},{"title":"Сборка в watch режиме","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#сборка-в-watch-режиме","content":"tramvai-build --watch Скопировать "},{"title":"Копирование статических файлов","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#копирование-статических-файлов-1","content":"tramvai-copy Скопировать "},{"title":"Доступные флаги","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#доступные-флаги","content":"tramvai-build --help Скопировать "},{"title":"JavaScript API","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#javascript-api","content":""},{"title":"TramvaiBuild","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#tramvaibuild","content":"TramvaiBuild позволяет конфигурировать утилиту для дальнейшего использования. import { TramvaiBuild } from '@tramvai/build'; new TramvaiBuild(options); Скопировать Доступные опции:  export type Options = { sourceDir?: string; watchMode?: boolean; copyStaticAssets?: boolean; forPublish?: boolean;}; Скопировать  "},{"title":"Сборка","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#сборка","content":"Метод TramvaiBuild.start позволяет собрать пакет, разово или в watch режиме, в зависимости от конфигурации экземпляра TramvaiBuild: import { TramvaiBuild } from '@tramvai/build'; new TramvaiBuild(options).start(); Скопировать "},{"title":"Копирование статических файлов","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#копирование-статических-файлов-2","content":"Метод TramvaiBuild.copy позволяет разово копировать статические файлы в output директорию: import { TramvaiBuild } from '@tramvai/build'; new TramvaiBuild(options).copy(); Скопировать "},{"title":"How to","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#how-to","content":""},{"title":"Как собрать отдельный бандл для браузерной сборки?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-собрать-отдельный-бандл-для-браузерной-сборки","content":"Допустим, у нас есть две точки входа, серверная - src/server.ts, и клиентская - src/browser.ts. В таком случае, необходимо настроить поле browser в package.json таким образом: { \"main\": \"lib/server.js\", \"browser\": \"lib/browser.js\"} Скопировать После сборки для публикации мы получим такой package.json: { \"main\": \"lib/server.js\", \"browser\": \"lib/browser.js\", \"typings\": \"lib/server.d.ts\", \"module\": \"lib/server.es.js\"} Скопировать "},{"title":"Как заменить отдельный модуль для браузерной сборки?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-заменить-отдельный-модуль-для-браузерной-сборки","content":"Допустим, у нас есть одна точка входа - src/index.ts, а модуль src/external.ts мы хотим заменить на src/external.browser.ts. В таком случае, необходимо настроить поле browser в package.json таким образом: { \"main\": \"lib/index.js\", \"browser\": { \"./lib/external.js\": \"./lib/external.browser.js\" }} Скопировать После сборки для публикации мы получим такой package.json: { \"main\": \"lib/index.js\", \"browser\": { \"./lib/external.js\": \"./lib/external.browser.js\", \"./lib/index.es.js\": \"./lib/index.browser.js\", }, \"typings\": \"lib/index.d.ts\", \"module\": \"lib/index.es.js\"} Скопировать "},{"title":"Как собирать все пакеты в монорепе при разработке, в watch режиме?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-собирать-все-пакеты-в-монорепе-при-разработке-в-watch-режиме","content":"@TODO + ссылка на @tinkoff/fix-ts-references "},{"title":"Как сделать чтобы модуль импортировался только при определенных условиях, а иначе игнорировался при сборке?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-сделать-чтобы-модуль-импортировался-только-при-определенных-условиях-а-иначе-игнорировался-при-сборке","content":"Вместо статичных импортов можно использовать динамический import или require. В этом случае, импортированный модуль будет собран в отдельный чанк и будет добавлен в сборку вебпаком при необходимости, причем при использовании динамического импорта также будет создан отдельный чанк после сборки вебпака, при использовании require отдельного чанка не будет. let func = noop; if (process.env.NODE_ENV !== 'production') { func = require('./realFunc').func;} export { func }; Скопировать "},{"title":"Как использовать json файлы в пакете?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-использовать-json-файлы-в-пакете","content":"По умолчанию в корневом tsconfig.json включена опция resolveJsonModule которая позволяет импортировать json-файлы также как и обычный код используя import, причем всё будет работать с типизацией и tree-shaking при публикации пакета. Для того чтобы ts не ругался на такие импорты необходимо в tsconfig.json пакета добавить новое вхождение в поле includes: { \"includes\": [\"./src\", \"./src/**/*.json\"]} Скопировать "},{"title":"Как использовать файлы других расширений в пакете (например .css)?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-использовать-файлы-других-расширений-в-пакете-например-css","content":"Такие файлы не используются в сборке или явно в коде, и ts такие файлы игнорирует. Для правильной работы пакета потребуется дополнительная настройка, а именно прописать в package.json пакета скрипт tramvai-copy: { \"scripts\": { \"copy-static-assets\": \"tramvai-copy\" }} Скопировать Цель этого скрипта в копировании файлов не относящихся к исходному коду в директорию сборки. Само копирование происходит либо при установке зависимостей в корне репозитория, либо при непосредственной публикации пакетов. Так как в некоторых кейсах по какой-либо причине директория сборки может быть удалена то возможно потребуется перезапуск команды tramvai-copy для данных пакетов. "},{"title":"Как использовать css-модули в пакете?","type":1,"pageTitle":"@tramvai/build","url":"docs/references/tools/build#как-использовать-css-модули-в-пакете","content":"Для того, чтобы typescript не ругался на импорты css-модулей, в папку src внутри пакета нужно добавить файл typings.d.ts с определением: declare module '*.css' { const value: any; export default value;} Скопировать Для копирования css во время dev-сборки нужно изменить команду: \"watch\": \"tramvai-copy && tsc -w\" Скопировать Такие импорты никак не преобразуются, для правильной сборки нужно использовать @tramvai/cli или другие решения для css-модулей. При сборке корректность импортов не проверяется, так что проверяйте пакет перед публикацией. "},{"title":"@tinkoff-monorepo/depscheck","type":0,"sectionRef":"#","url":"docs/references/tools/monorepo-tools/depscheck","content":"","keywords":""},{"title":"Config parameters for .depscheckrc.yml and cli","type":1,"pageTitle":"@tinkoff-monorepo/depscheck","url":"docs/references/tools/monorepo-tools/depscheck#config-parameters-for-depscheckrcyml-and-cli","content":"All of the available parameters for the depscheck can be seen in docs. collector --collector Module for collecting packages for depshcheck. Should implement interface @tinkoff-monorepo/pkgs-collector -> CollectorInterface (currently @tinkoff-monorepo/pkgs-collector-pvm is used) [required] [default: {\"name\":\"@tinkoff-monorepo/pkgs-collector-workspaces\"}] --collector-config-strategy [string] [choices: \"about-to-update\", \"update\", \"changed\", \"changed-since-release\", \"affected\", \"released\", \"updated\", \"all\"] [default: [\"affected\"]] depcheck --depcheck-ignore-matches List of module patterns that should not generate error in case they are missing in package.json [array] [default: []] --depcheck-ignore-dirs List of directory names that depscheck should not check [array] [default: []] --depcheck-skip-missing Disable check for missing dependencies [boolean] [default: false] --depcheck-ignore-bin-package Disable checks in bin files for project [boolean] [default: false] Options: --version Show version number [boolean] --config Path to the config (by default cosmiconfig is used) [string] --fix Enables fix error mode. Currently only fixes unused dependency errors[boolean] [default: false] --ignore-patterns List of file patterns that should be ignored for checks on missing deps [array] [default: []] --ignore-peer-dependencies List of module patterns from peerDependencies that should not generate error when dependency is missing [array] [default: []] --ignore-unused List of module patterns that should not generate error when dependency is not used [array] [default: []] -h Show help [boolean] Скопировать "},{"title":"Config example","type":1,"pageTitle":"@tinkoff-monorepo/depscheck","url":"docs/references/tools/monorepo-tools/depscheck#config-example","content":"ignore-patterns: ['**/*.spec.{ts,tsx}', '**/*.test.{ts,tsx}', '**/dynamic-components/*/shared/externals.{js,ts}']depcheck-ignore-dirs: ['__integration__', 'examples', '__tests__']depcheck-ignore-matches: ['@platform/cli', '@tramvai/tools-migrate'] Скопировать "},{"title":"@tinkoff-monorepo/fix-ts-references","type":0,"sectionRef":"#","url":"docs/references/tools/monorepo-tools/fix-ts-references","content":"","keywords":""},{"title":"Install","type":1,"pageTitle":"@tinkoff-monorepo/fix-ts-references","url":"docs/references/tools/monorepo-tools/fix-ts-references#install","content":"yarn add fix-ts-references Скопировать "},{"title":"Usage","type":1,"pageTitle":"@tinkoff-monorepo/fix-ts-references","url":"docs/references/tools/monorepo-tools/fix-ts-references#usage","content":"npx fix-ts-references --fix Скопировать Script will do next: With flag --fix: Remove references from references list for package if dependency has been removed from package.jsonAdd new references to references list for package if dependency has been added to package.jsonSetting tsconfig.compilerOptions.rootDir=./src if it is not setRemove reference from project reference solution if package has been removed from repositoryAdd reference to project reference solution if package has been added to the repository Without flag --fix will just show list of errors "},{"title":"@tinkoff-monorepo/pkgs-collector-dir","type":0,"sectionRef":"#","url":"docs/references/tools/monorepo-tools/pkgs-collector-dir","content":"","keywords":""},{"title":"Configuration","type":1,"pageTitle":"@tinkoff-monorepo/pkgs-collector-dir","url":"docs/references/tools/monorepo-tools/pkgs-collector-dir#configuration","content":""},{"title":"pkgDirs","type":1,"pageTitle":"@tinkoff-monorepo/pkgs-collector-dir","url":"docs/references/tools/monorepo-tools/pkgs-collector-dir#pkgdirs","content":"List of the path patterns to packages in glob format "},{"title":"@tinkoff-monorepo/pkgs-collector-workspaces","type":0,"sectionRef":"#","url":"docs/references/tools/monorepo-tools/pkgs-collector-workspaces","content":"@tinkoff-monorepo/pkgs-collector-workspaces Get all of the packages defined in package.json -> workspaces","keywords":""},{"title":"createAction","type":0,"sectionRef":"#","url":"docs/references/tramvai/create-action","content":"","keywords":""},{"title":"createAction({ name, fn, deps, conditions })","type":1,"pageTitle":"createAction","url":"docs/references/tramvai/create-action#createaction-name-fn-deps-conditions-","content":"name - The name of the action, a unique identifier is expectedfn(context, payload, deps) - Implementation of the action, this function will be called when the action is used, maybe async context - ConsumerContextpayload - data passed to actiondeps - provider instances from deps deps - List of providers that are needed for the action to workconditions - List of restrictions for the execution of the action "},{"title":"Usage example","type":1,"pageTitle":"createAction","url":"docs/references/tramvai/create-action#usage-example","content":"import { createAction } from '@tramvai/core'; createAction({ name: 'action log error', fn: (context, payload, deps) => { deps.logger.error('ERROR'); }, deps: { logger: 'logger', }, conditions: { requiredCoreRoles: ['god'], },}); Скопировать "},{"title":"createApp","type":0,"sectionRef":"#","url":"docs/references/tramvai/create-app","content":"","keywords":""},{"title":"createApp({ modules, bundles, providers })","type":1,"pageTitle":"createApp","url":"docs/references/tramvai/create-app#createapp-modules-bundles-providers-","content":"modules - array with used modules in the applicationbundles - object with used bundles with data in the application. The key is the bundle identifier, the value is Promise which returns the bundleproviders - an array with application providers, which will be added last in the DI (after module providers) and thus it will be possible to overwrite the implementation of the tokensactions - array with global actions, which will be registered for all bundles and pages "},{"title":"Usage","type":1,"pageTitle":"createApp","url":"docs/references/tramvai/create-app#usage","content":"import { createApp, provide } from '@tramvai/core';import { RouterModule } from '@tramvai/module-router';import { RenderModule } from '@tramvai/module-render';import { ServerModule } from '@tramvai/module-server'; createApp({ name: 'my-awesome-app', modules: [RouterModule, RenderModule, ServerModule], providers: [ provide({ provide: 'options', useValue: {}, }), ], bundles: { mainDefault: () => import(/* webpackChunkName: \"mainDefault\" */ './bundles/mainDefault'), }, actions: [loadDepositConfig],}); Скопировать After calling createApp, СommandLineRunner is started which performs the chain of actions necessary to initialize the application. "},{"title":"createBundle","type":0,"sectionRef":"#","url":"docs/references/tramvai/create-bundle","content":"","keywords":""},{"title":"Properties BundleOptions","type":1,"pageTitle":"createBundle","url":"docs/references/tramvai/create-bundle#properties-bundleoptions","content":"name - Name of the bundle. The value will be used as a bundle identifier.components: {} - An object with registered components for the bundle, which you can use in application routespresets?: [] - A list of additional properties for the current bundle. This list is merged with the current properties. Needed to extract common parts, e.g. a set with actions and components for authorization. Reference - babel and eslint presetsactions?: [] - List of actions that will be registered globally for the bundlereducers?: [] - List of reducers, which must be registered with the loading of the bundle "},{"title":"Usage","type":1,"pageTitle":"createBundle","url":"docs/references/tramvai/create-bundle#usage","content":"import { createBundle } from '@tramvai/core';import { lazy } from '@tramvai/react'; createBundle({ name: 'app/bundle', presets: [commonPreset], components: { 'app/pages/MainPage': lazy(() => import('../pages/MainPage')), 'app/pages/SecondPage': lazy(() => import('../pages/SecondPage')), }, actions: [fooAction, barAction], reducers: [bazReducer],}); Скопировать "},{"title":"module","type":0,"sectionRef":"#","url":"docs/references/tramvai/module","content":"","keywords":""},{"title":"@Module({ providers, deps, imports })(class)","type":1,"pageTitle":"module","url":"docs/references/tramvai/module#module-providers-deps-imports-class","content":"providers - Providers, which will be added to the root DI container and become available in other modulesdeps - List of dependencies from the DI container, necessary to initialize the moduleimports - A list of modules from which providers will be obtained and added to the DI. Allows you to create modules that combine many other modules "},{"title":"Usage","type":1,"pageTitle":"module","url":"docs/references/tramvai/module#usage","content":"import { Module, provide } from '@tramvai/core'; @Module({ providers: [ provide({ provide: 'token', useValue: 'value-in-token', }), ], deps: { logger: 'logger', }, imports: [ModuleLogger],})class ModulePubSub { constructor({ logger }) { logger.info('Module create'); }} Скопировать "}]